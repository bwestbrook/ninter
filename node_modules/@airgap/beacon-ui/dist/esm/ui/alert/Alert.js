// Taken from https://github.com/WalletConnect/walletconnect-monorepo/blob/master/packages/qrcode-modal/src/browser.ts
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { windowRef } from '@airgap/beacon-core';
import { generateGUID } from '@airgap/beacon-utils';
import { alertTemplates } from './alert-templates';
import { preparePairingAlert } from './PairingAlert';
import { getColorMode } from '../../utils/colorMode';
import { createSanitizedElement } from '../../utils/html-elements';
import { constructDefaultAlert, constructPairAlert } from '../../utils/templates';
let lastFocusedElement;
let document;
if (typeof window !== 'undefined' && typeof window.document !== 'undefined') {
    document = window.document;
}
const timeout = {};
const addQR = (dataString) => {
    if (typeof dataString === 'string') {
        return createSanitizedElement('div', [], [['id', 'beacon--qr__container']], [
            createSanitizedElement('div', [], [['id', 'beacon--qr__copy__container']], [
                createSanitizedElement('button', ['beacon-modal__button--outline'], [['id', 'beacon--qr__copy']], 'Copy')
            ])
        ]);
    }
    return createSanitizedElement('span', [], [], '');
};
const formatAlert = (id, body, title, buttons, hasPairingPayload) => {
    const callToAction = title;
    const buttonsHtml = buttons.map((button, index) => createSanitizedElement('button', [`beacon-modal__button${button.style === 'outline' ? '--outline' : ''}`], [['id', `beacon-alert-${id}-${index}`]], button.text));
    let allStyles = alertTemplates.default.css;
    if (hasPairingPayload) {
        allStyles += alertTemplates.pair.css;
    }
    const callToActionEl = createSanitizedElement('span', [], [], callToAction);
    const alertEl = hasPairingPayload
        ? constructPairAlert(id, [callToActionEl], buttonsHtml, [body])
        : constructDefaultAlert(id, [callToActionEl], buttonsHtml, [body]);
    return {
        style: allStyles,
        html: alertEl
    };
};
/**
 * Close an alert by ID
 *
 * @param id ID of alert
 */
const closeAlert = (id) => {
    windowRef.postMessage(`closeAlert-${id}`);
    return new Promise((resolve) => {
        var _a;
        const wrapper = document.getElementById(`beacon-alert-wrapper-${id}`);
        if (!wrapper) {
            return resolve();
        }
        const elm = (_a = wrapper.shadowRoot) === null || _a === void 0 ? void 0 : _a.getElementById(`beacon-alert-modal-${id}`);
        if (elm) {
            const animationDuration = 300;
            const localTimeout = timeout[id];
            if (localTimeout) {
                clearTimeout(localTimeout);
                timeout[id] = undefined;
            }
            elm.className = elm.className.replace('fadeIn', 'fadeOut');
            window.setTimeout(() => {
                const parent = wrapper.parentNode;
                if (parent) {
                    parent.removeChild(wrapper);
                }
                if (lastFocusedElement) {
                    ;
                    lastFocusedElement.focus(); // set focus back to last focussed element
                }
                resolve();
            }, animationDuration);
        }
        else {
            resolve();
        }
    });
};
/**
 * Close all alerts
 */
const closeAlerts = () => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((resolve) => __awaiter(void 0, void 0, void 0, function* () {
        const openAlertElements = document.querySelectorAll('[id^="beacon-alert-wrapper-"]');
        if (openAlertElements.length > 0) {
            const alertIds = [];
            openAlertElements.forEach((element) => __awaiter(void 0, void 0, void 0, function* () {
                alertIds.push(element.id.split('-')[3]);
            }));
            yield Promise.all(alertIds.map(closeAlert));
            resolve();
        }
        else {
            resolve();
        }
    }));
});
/**
 * Show an alert
 *
 * @param alertConfig The configuration of the alert
 */
// eslint-disable-next-line complexity
const openAlert = (alertConfig) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b;
    const body = alertConfig.body;
    const data = alertConfig.data;
    const title = alertConfig.title;
    const timer = alertConfig.timer;
    const pairingPayload = alertConfig.pairingPayload;
    const disclaimer = alertConfig.disclaimerText;
    // eslint-disable-next-line @typescript-eslint/unbound-method
    const closeButtonCallback = alertConfig.closeButtonCallback;
    yield closeAlerts();
    const id = (yield generateGUID()).split('-').join('');
    const shadowRootEl = document.createElement('div');
    shadowRootEl.setAttribute('id', `beacon-alert-wrapper-${id}`);
    const shadowRoot = shadowRootEl.attachShadow({ mode: 'open' });
    const wrapper = document.createElement('div');
    wrapper.setAttribute('tabindex', `0`); // Make modal focussable
    shadowRoot.appendChild(wrapper);
    const buttons = [
        ...((_b = (_a = alertConfig.buttons) === null || _a === void 0 ? void 0 : _a.map((button) => {
            var _a, _b;
            return ({
                text: button.text,
                // eslint-disable-next-line @typescript-eslint/unbound-method
                actionCallback: (_a = button.actionCallback) !== null && _a !== void 0 ? _a : (() => Promise.resolve()),
                style: (_b = button.style) !== null && _b !== void 0 ? _b : 'outline'
            });
        })) !== null && _b !== void 0 ? _b : [])
    ];
    let formattedBody = pairingPayload
        ? addQR(body)
        : createSanitizedElement('span', [], [], body !== null && body !== void 0 ? body : '');
    if (data) {
        formattedBody = createSanitizedElement('span', [], [], [formattedBody, createSanitizedElement('pre', [], [['style', 'text-align: left']], data)]);
    }
    const { style, html } = formatAlert(id, formattedBody, title, buttons, !!(pairingPayload === null || pairingPayload === void 0 ? void 0 : pairingPayload.p2pSyncCode));
    wrapper.appendChild(html);
    const styleEl = document.createElement('style');
    styleEl.textContent = style;
    shadowRoot.appendChild(styleEl);
    if (timer) {
        timeout[id] = window.setTimeout(() => __awaiter(void 0, void 0, void 0, function* () {
            yield closeAlert(id);
        }), timer);
    }
    document.body.prepend(shadowRootEl);
    const closeButton = shadowRoot.getElementById(`beacon-alert-${id}-close`);
    const closeButtonClick = () => __awaiter(void 0, void 0, void 0, function* () {
        if (closeButtonCallback) {
            closeButtonCallback();
        }
        yield closeAlert(id);
    });
    if (disclaimer) {
        const disclaimerContainer = shadowRoot.getElementById(`beacon--disclaimer`);
        if (disclaimerContainer) {
            disclaimerContainer.innerText = disclaimer;
        }
    }
    const colorMode = getColorMode();
    const elm = shadowRoot.getElementById(`beacon-alert-modal-${id}`);
    if (elm) {
        elm.classList.add(`theme__${colorMode}`);
        elm.addEventListener('click', closeButtonClick); // Backdrop click dismisses alert
    }
    const modal = shadowRoot.querySelectorAll('.beacon-modal__wrapper');
    if (modal.length > 0) {
        modal[0].addEventListener('click', (event) => {
            event.stopPropagation();
        });
    }
    lastFocusedElement = document.activeElement; // Store which element has been focussed before the alert is shown
    wrapper.focus(); // Focus alert for accessibility
    buttons.forEach((button, index) => {
        const buttonElement = shadowRoot.getElementById(`beacon-alert-${id}-${index}`);
        if (buttonElement) {
            buttonElement.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {
                yield closeAlert(id);
                if (button.actionCallback) {
                    yield button.actionCallback();
                }
            }));
        }
    });
    if (closeButton) {
        closeButton.addEventListener('click', () => __awaiter(void 0, void 0, void 0, function* () {
            yield closeButtonClick();
        }));
    }
    window.addEventListener('keydown', (event) => __awaiter(void 0, void 0, void 0, function* () {
        if (event.key === 'Escape') {
            yield closeButtonClick();
        }
    }));
    if (pairingPayload) {
        yield preparePairingAlert(id, shadowRoot, pairingPayload);
    }
    return id;
});
export { closeAlert, closeAlerts, openAlert };
//# sourceMappingURL=Alert.js.map