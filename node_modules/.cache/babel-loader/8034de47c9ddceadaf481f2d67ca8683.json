{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.array.at.js\";\nimport \"core-js/modules/es.string.at-alternative.js\";\nimport \"core-js/modules/es.array.includes.js\";\nimport { OpKind, RpcClient } from '@taquito/rpc';\nexport { OpKind } from '@taquito/rpc';\nimport { Observable, ReplaySubject, defer, throwError, of, EMPTY, combineLatest, from, range, concat, Subject, NEVER, BehaviorSubject, timer } from 'rxjs';\nimport { switchMap, timeoutWith, shareReplay, map, filter, first, catchError, tap, distinctUntilChanged, takeWhile, startWith, concatMap, retry, takeUntil, pluck, distinctUntilKeyChanged, publish, refCount } from 'rxjs/operators';\nimport { Schema, ParameterSchema, ViewSchema, MichelsonMap } from '@taquito/michelson-encoder';\nexport { MichelsonMap, UnitValue } from '@taquito/michelson-encoder';\nimport BigNumber from 'bignumber.js';\nimport { validateOperation, ValidationResult, InvalidOperationHashError, InvalidOperationKindError, DeprecationError, validateAddress, InvalidAddressError, validateKeyHash, InvalidKeyHashError, validateContractAddress, InvalidContractAddressError, validateChain, InvalidChainIdError, encodeExpr } from '@taquito/utils';\nimport { HttpResponseError, STATUS_CODE } from '@taquito/http-utils';\nimport { Parser, packDataBytes } from '@taquito/michel-codec';\nimport { LocalForger } from '@taquito/local-forging';\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nclass RpcInjector {\n  constructor(context) {\n    this.context = context;\n  }\n\n  inject(signedOperationBytes) {\n    return this.context.rpc.injectOperation(signedOperationBytes);\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates the signer has been unconfigured in the TezosToolkit instance\r\n */\n\n\nclass UnconfiguredSignerError extends Error {\n  constructor() {\n    super('No signer has been configured. Please configure one by calling setProvider({signer}) on your TezosToolkit instance.');\n    this.name = 'UnconfiguredSignerError';\n  }\n\n}\n/**\r\n * @description Default signer implementation which does nothing and produce invalid signature\r\n */\n\n\nclass NoopSigner {\n  publicKey() {\n    return __awaiter(this, void 0, void 0, function* () {\n      throw new UnconfiguredSignerError();\n    });\n  }\n\n  publicKeyHash() {\n    return __awaiter(this, void 0, void 0, function* () {\n      throw new UnconfiguredSignerError();\n    });\n  }\n\n  secretKey() {\n    return __awaiter(this, void 0, void 0, function* () {\n      throw new UnconfiguredSignerError();\n    });\n  }\n\n  sign(_bytes, _watermark) {\n    return __awaiter(this, void 0, void 0, function* () {\n      throw new UnconfiguredSignerError();\n    });\n  }\n\n}\n\nfunction createObservableFromSubscription(sub) {\n  return new Observable(subscriber => {\n    sub.on('data', data => {\n      subscriber.next(data);\n    });\n    sub.on('error', error => {\n      subscriber.error(error);\n    });\n    sub.on('close', () => {\n      subscriber.complete();\n    });\n    return () => {\n      sub.close();\n    };\n  });\n}\n\nvar DEFAULT_GAS_LIMIT;\n\n(function (DEFAULT_GAS_LIMIT) {\n  DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT[\"DELEGATION\"] = 10600] = \"DELEGATION\";\n  DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT[\"ORIGINATION\"] = 10600] = \"ORIGINATION\";\n  DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT[\"TRANSFER\"] = 10600] = \"TRANSFER\";\n  DEFAULT_GAS_LIMIT[DEFAULT_GAS_LIMIT[\"REVEAL\"] = 1100] = \"REVEAL\";\n})(DEFAULT_GAS_LIMIT || (DEFAULT_GAS_LIMIT = {}));\n\nvar DEFAULT_FEE;\n\n(function (DEFAULT_FEE) {\n  DEFAULT_FEE[DEFAULT_FEE[\"DELEGATION\"] = 1257] = \"DELEGATION\";\n  DEFAULT_FEE[DEFAULT_FEE[\"ORIGINATION\"] = 10000] = \"ORIGINATION\";\n  DEFAULT_FEE[DEFAULT_FEE[\"TRANSFER\"] = 10000] = \"TRANSFER\";\n  DEFAULT_FEE[DEFAULT_FEE[\"REVEAL\"] = 374] = \"REVEAL\";\n})(DEFAULT_FEE || (DEFAULT_FEE = {}));\n\nvar DEFAULT_STORAGE_LIMIT;\n\n(function (DEFAULT_STORAGE_LIMIT) {\n  DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT[\"DELEGATION\"] = 0] = \"DELEGATION\";\n  DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT[\"ORIGINATION\"] = 257] = \"ORIGINATION\";\n  DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT[\"TRANSFER\"] = 257] = \"TRANSFER\";\n  DEFAULT_STORAGE_LIMIT[DEFAULT_STORAGE_LIMIT[\"REVEAL\"] = 0] = \"REVEAL\";\n})(DEFAULT_STORAGE_LIMIT || (DEFAULT_STORAGE_LIMIT = {}));\n\nvar Protocols;\n\n(function (Protocols) {\n  Protocols[\"Pt24m4xi\"] = \"Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd\";\n  Protocols[\"PsBABY5H\"] = \"PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU\";\n  Protocols[\"PsBabyM1\"] = \"PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS\";\n  Protocols[\"PsCARTHA\"] = \"PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb\";\n  Protocols[\"PsDELPH1\"] = \"PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo\";\n  Protocols[\"PtEdo2Zk\"] = \"PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA\";\n  Protocols[\"PsFLorena\"] = \"PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i\";\n  Protocols[\"PtGRANADs\"] = \"PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV\";\n  Protocols[\"PtHangz2\"] = \"PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx\";\n  Protocols[\"PsiThaCa\"] = \"PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP\";\n  Protocols[\"Psithaca2\"] = \"Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A\";\n  Protocols[\"ProtoALpha\"] = \"ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK\";\n})(Protocols || (Protocols = {}));\n\nconst protocols = {\n  '004': [Protocols.Pt24m4xi],\n  '005': [Protocols.PsBABY5H, Protocols.PsBabyM1],\n  '006': [Protocols.PsCARTHA],\n  '007': [Protocols.PsDELPH1],\n  '008': [Protocols.PtEdo2Zk],\n  '009': [Protocols.PsFLorena],\n  '010': [Protocols.PtGRANADs],\n  '011': [Protocols.PtHangz2],\n  '012': [Protocols.PsiThaCa],\n  '013': [Protocols.Psithaca2],\n  '014': [Protocols.ProtoALpha]\n};\nvar ChainIds;\n\n(function (ChainIds) {\n  ChainIds[\"MAINNET\"] = \"NetXdQprcVkpaWU\";\n  ChainIds[\"CARTHAGENET\"] = \"NetXjD3HPJJjmcd\";\n  ChainIds[\"DELPHINET\"] = \"NetXm8tYqnMWky1\";\n  ChainIds[\"EDONET\"] = \"NetXSgo1ZT2DRUG\";\n  ChainIds[\"FLORENCENET\"] = \"NetXxkAx4woPLyu\";\n  ChainIds[\"GRANADANET\"] = \"NetXz969SFaFn8k\";\n  ChainIds[\"HANGZHOUNET\"] = \"NetXZSsxBpMQeAT\";\n  ChainIds[\"ITHACANET\"] = \"NetXbhmtAbMukLc\";\n  ChainIds[\"ITHACANET2\"] = \"NetXnHfVqm9iesp\";\n})(ChainIds || (ChainIds = {}));\n\nconst TZ_DECIMALS = 6;\nconst MTZ_DECIMALS = 3;\n\nfunction getDecimal(format) {\n  switch (format) {\n    case 'tz':\n      return TZ_DECIMALS;\n\n    case 'mtz':\n      return MTZ_DECIMALS;\n\n    case 'mutez':\n    default:\n      return 0;\n  }\n}\n\nfunction format(from = 'mutez', to = 'mutez', amount) {\n  const bigNum = new BigNumber(amount);\n\n  if (bigNum.isNaN()) {\n    return amount;\n  }\n\n  return bigNum.multipliedBy(Math.pow(10, getDecimal(from))).dividedBy(Math.pow(10, getDecimal(to)));\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates invalid smart contract parameters being passed or used\r\n */\n\n\nclass InvalidParameterError extends Error {\n  constructor(smartContractMethodName, sigs, args) {\n    super(`${smartContractMethodName} Received ${args.length} arguments while expecting one of the following signatures (${JSON.stringify(sigs)})`);\n    this.smartContractMethodName = smartContractMethodName;\n    this.sigs = sigs;\n    this.args = args;\n    this.name = 'Invalid parameters error';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid delegation source contract address being passed or used\r\n */\n\n\nclass InvalidDelegationSource extends Error {\n  constructor(source) {\n    super(`Since Babylon delegation source can no longer be a contract address ${source}. Please use the smart contract abstraction to set your delegate.`);\n    this.source = source;\n    this.name = 'Invalid delegation source error';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid smart contract code parameter being passed or used\r\n */\n\n\nclass InvalidCodeParameter extends Error {\n  constructor(message, data) {\n    super(message);\n    this.message = message;\n    this.data = data;\n    this.name = 'InvalidCodeParameter';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates invalid smart contract init parameter being passed or used\r\n */\n\n\nclass InvalidInitParameter extends Error {\n  constructor(message, data) {\n    super(message);\n    this.message = message;\n    this.data = data;\n    this.name = 'InvalidInitParameter';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates invalid view parameter of a smart contract\r\n */\n\n\nclass InvalidViewParameterError extends Error {\n  constructor(smartContractViewName, sigs, args, originalError) {\n    super(`Unable to encode the parameter of the view: ${smartContractViewName}. Received ${args} as parameter while expecting one of the following signatures (${JSON.stringify(sigs)})`);\n    this.smartContractViewName = smartContractViewName;\n    this.sigs = sigs;\n    this.args = args;\n    this.originalError = originalError;\n    this.name = 'Invalid view parameters error';\n    this.cause = originalError;\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates a failure when conducting a view simulation\r\n */\n\n\nclass ViewSimulationError extends Error {\n  constructor(message, viewName, failWith, originalError) {\n    super(message);\n    this.message = message;\n    this.viewName = viewName;\n    this.failWith = failWith;\n    this.originalError = originalError;\n    this.name = 'ViewSimulationError';\n  }\n\n}\n\nconst validateAndExtractFailwith = error => {\n  if (isJsonString(error.body)) {\n    const parsedError = JSON.parse(error.body);\n\n    if (Array.isArray(parsedError) && 'with' in parsedError[parsedError.length - 1]) {\n      return parsedError[parsedError.length - 1].with;\n    }\n  }\n};\n\nconst isJsonString = str => {\n  try {\n    JSON.parse(str);\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n *  @category Error\r\n *  @description Error that indicates invalid or unconfigured context when executing a view\r\n */\n\n\nclass InvalidViewSimulationContext extends Error {\n  constructor(info) {\n    super(`${info} Please configure the context of the view execution in the executeView method.`);\n    this.info = info;\n    this.name = 'InvalidViewSimulationContext';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates a mistake happening during the reveal operation\r\n */\n\n\nclass RevealOperationError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'RevealOperationError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates a mistake in the parameters in the preparation of an Origination operation\r\n */\n\n\nclass OriginationParameterError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'OriginationParameterError';\n  }\n\n}\n\nconst createOriginationOperation = ({\n  code,\n  init,\n  balance = '0',\n  delegate,\n  storage,\n  fee = DEFAULT_FEE.ORIGINATION,\n  gasLimit = DEFAULT_GAS_LIMIT.ORIGINATION,\n  storageLimit = DEFAULT_STORAGE_LIMIT.ORIGINATION,\n  mutez = false\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  if (storage !== undefined && init !== undefined) {\n    throw new OriginationParameterError('Storage and Init cannot be set a the same time. Please either use storage or init but not both.');\n  }\n\n  if (!Array.isArray(code)) {\n    throw new InvalidCodeParameter('Wrong code parameter type, expected an array', code);\n  }\n\n  let contractStorage;\n\n  if (storage !== undefined) {\n    const storageType = code.find(p => 'prim' in p && p.prim === 'storage');\n\n    if ((storageType === null || storageType === void 0 ? void 0 : storageType.args) === undefined) {\n      throw new InvalidCodeParameter('The storage section is missing from the script', code);\n    }\n\n    const schema = new Schema(storageType.args[0]); // TODO\n\n    contractStorage = schema.Encode(storage);\n  } else if (init !== undefined && typeof init === 'object') {\n    contractStorage = init;\n  } else {\n    throw new InvalidInitParameter('Wrong init parameter type, expected JSON Michelson', init);\n  }\n\n  const script = {\n    code,\n    storage: contractStorage\n  };\n  const operation = {\n    kind: OpKind.ORIGINATION,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    balance: mutez ? balance.toString() : format('tz', 'mutez', balance).toString(),\n    script\n  };\n\n  if (delegate) {\n    operation.delegate = delegate;\n  }\n\n  return operation;\n});\n\nconst createTransferOperation = ({\n  to,\n  amount,\n  parameter,\n  fee = DEFAULT_FEE.TRANSFER,\n  gasLimit = DEFAULT_GAS_LIMIT.TRANSFER,\n  storageLimit = DEFAULT_STORAGE_LIMIT.TRANSFER,\n  mutez = false\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  const operation = {\n    kind: OpKind.TRANSACTION,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    amount: mutez ? amount.toString() : format('tz', 'mutez', amount).toString(),\n    destination: to,\n    parameters: parameter\n  };\n  return operation;\n});\n\nconst createSetDelegateOperation = ({\n  delegate,\n  source,\n  fee = DEFAULT_FEE.DELEGATION,\n  gasLimit = DEFAULT_GAS_LIMIT.DELEGATION,\n  storageLimit = DEFAULT_STORAGE_LIMIT.DELEGATION\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  const operation = {\n    kind: OpKind.DELEGATION,\n    source,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    delegate\n  };\n  return operation;\n});\n\nconst createRegisterDelegateOperation = ({\n  fee = DEFAULT_FEE.DELEGATION,\n  gasLimit = DEFAULT_GAS_LIMIT.DELEGATION,\n  storageLimit = DEFAULT_STORAGE_LIMIT.DELEGATION\n}, source) => __awaiter(void 0, void 0, void 0, function* () {\n  return {\n    kind: OpKind.DELEGATION,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    delegate: source\n  };\n});\n\nconst createRevealOperation = ({\n  fee = DEFAULT_FEE.REVEAL,\n  gasLimit = DEFAULT_GAS_LIMIT.REVEAL,\n  storageLimit = DEFAULT_STORAGE_LIMIT.REVEAL\n}, source, publicKey) => __awaiter(void 0, void 0, void 0, function* () {\n  return {\n    kind: OpKind.REVEAL,\n    fee,\n    public_key: publicKey,\n    source,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit\n  };\n});\n\nconst createRegisterGlobalConstantOperation = ({\n  value,\n  source,\n  fee,\n  gasLimit,\n  storageLimit\n}) => __awaiter(void 0, void 0, void 0, function* () {\n  return {\n    kind: OpKind.REGISTER_GLOBAL_CONSTANT,\n    value,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    source\n  };\n});\n\nconst attachKind = (op, kind) => {\n  return Object.assign(Object.assign({}, op), {\n    kind\n  });\n};\n\nconst findWithKind = (arr, kind) => {\n  if (Array.isArray(arr)) {\n    const found = arr.find(op => op.kind === kind);\n\n    if (found && isKind(found, kind)) {\n      return found;\n    }\n  }\n};\n\nconst isKind = (op, kind) => {\n  return op.kind === kind;\n};\n\nconst isOpWithFee = op => {\n  return ['transaction', 'delegation', 'origination', 'reveal', 'register_global_constant'].indexOf(op.kind) !== -1;\n};\n\nconst isOpRequireReveal = op => {\n  return ['transaction', 'delegation', 'origination', 'register_global_constant'].indexOf(op.kind) !== -1;\n};\n\nconst hasMetadata = op => {\n  return 'metadata' in op;\n};\n\nconst hasMetadataWithResult = op => {\n  return hasMetadata(op) && 'operation_result' in op.metadata;\n};\n\nconst hasMetadataWithInternalOperationResult = op => {\n  return hasMetadata(op) && 'internal_operation_results' in op.metadata;\n};\n\nconst isErrorWithMessage = error => {\n  return 'with' in error;\n};\n/**\r\n *  @category Error\r\n *  @description Generic tezos error that will be thrown when a mistake occurs when doing an operation; more details here https://tezos.gitlab.io/api/errors.html\r\n */\n\n\nclass TezosOperationError extends Error {\n  constructor(errors, errorDetails) {\n    super();\n    this.errors = errors;\n    this.errorDetails = errorDetails;\n    this.name = 'TezosOperationError'; // Last error is 'often' the one with more detail\n\n    const lastError = errors[errors.length - 1];\n    this.id = lastError.id;\n    this.kind = lastError.kind;\n    this.message = `(${this.kind}) ${this.id}`;\n\n    if (isErrorWithMessage(lastError)) {\n      if (lastError.with.string) {\n        this.message = lastError.with.string;\n      } else if (lastError.with.int) {\n        this.message = lastError.with.int;\n      } else {\n        this.message = JSON.stringify(lastError.with);\n      }\n    }\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Tezos error that will be thrown when a mistake happens during the preapply stage\r\n */\n\n\nclass TezosPreapplyFailureError extends Error {\n  constructor(result) {\n    super('Preapply returned an unexpected result');\n    this.result = result;\n    this.name = 'TezosPreapplyFailureError';\n  }\n\n} // Flatten all operation content results and internal operation results into a single array\n// Some cases where we can have multiple operation results or internal operation results are:\n// - When an operation includes a reveal operation\n// - When an operation is made using the batch API\n// - Smart contract call can contains internal operation results when they call other smart contract internally or originate contracts\n\n\nconst flattenOperationResult = response => {\n  const results = Array.isArray(response) ? response : [response];\n  const returnedResults = [];\n\n  for (let i = 0; i < results.length; i++) {\n    for (let j = 0; j < results[i].contents.length; j++) {\n      const content = results[i].contents[j];\n\n      if (hasMetadataWithResult(content)) {\n        returnedResults.push(Object.assign({\n          fee: content.fee\n        }, content.metadata.operation_result));\n\n        if (Array.isArray(content.metadata.internal_operation_results)) {\n          content.metadata.internal_operation_results.forEach(x => returnedResults.push(x.result));\n        }\n      }\n    }\n  }\n\n  return returnedResults;\n};\n/***\r\n * @description Flatten all error from preapply response (including internal error)\r\n */\n\n\nconst flattenErrors = (response, status = 'failed') => {\n  const results = Array.isArray(response) ? response : [response];\n  let errors = []; // Transaction that do not fail will be backtracked in case one failure occur\n\n  for (let i = 0; i < results.length; i++) {\n    for (let j = 0; j < results[i].contents.length; j++) {\n      const content = results[i].contents[j];\n\n      if (hasMetadata(content)) {\n        if (hasMetadataWithResult(content) && content.metadata.operation_result.status === status) {\n          errors = errors.concat(content.metadata.operation_result.errors || []);\n        }\n\n        if (hasMetadataWithInternalOperationResult(content) && Array.isArray(content.metadata.internal_operation_results)) {\n          for (const internalResult of content.metadata.internal_operation_results) {\n            if ('result' in internalResult && internalResult.result.status === status) {\n              errors = errors.concat(internalResult.result.errors || []);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return errors;\n};\n/**\r\n *  @category Error\r\n *  @description Error that indicates a general failure happening during an origination operation\r\n */\n\n\nclass OriginationOperationError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'OriginationOperationError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates invalid confirmation count has been passed or configured\r\n */\n\n\nclass InvalidConfirmationCountError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'InvalidConfirmationCountError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates undefined confirmation has not been specified or configured\r\n */\n\n\nclass ConfirmationUndefinedError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'ConfirmationUndefinedError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid filter expression being passed or used\r\n */\n\n\nclass InvalidFilterExpressionError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'InvalidFilterExpressionError';\n  }\n\n}\n/**\r\n * @description Utility class to interact with Tezos operations\r\n */\n\n\nclass Operation {\n  /**\r\n   *\r\n   * @param hash Operation hash\r\n   * @param raw Raw operation that was injected\r\n   * @param context Taquito context allowing access to rpc and signer\r\n   */\n  constructor(hash, raw, results, context) {\n    this.hash = hash;\n    this.raw = raw;\n    this.results = results;\n    this.context = context;\n    this._pollingConfig$ = new ReplaySubject(1);\n    this.currentHead$ = this._pollingConfig$.pipe(switchMap(config => {\n      return defer(() => createObservableFromSubscription(this.context.stream.subscribeBlock('head'))).pipe(timeoutWith(config.timeout * 1000, throwError(new Error('Confirmation polling timed out'))));\n    }), shareReplay({\n      refCount: true\n    })); // Observable that emit once operation is seen in a block\n\n    this.confirmed$ = this.currentHead$.pipe(map(head => {\n      for (let i = 3; i >= 0; i--) {\n        head.operations[i].forEach(op => {\n          if (op.hash === this.hash) {\n            this._foundAt = head.header.level;\n          }\n        });\n      }\n\n      if (head.header.level - this._foundAt >= 0) {\n        return this._foundAt;\n      }\n    }), filter(x => x !== undefined), first(), shareReplay());\n    this._foundAt = Number.POSITIVE_INFINITY;\n\n    if (validateOperation(this.hash) !== ValidationResult.VALID) {\n      throw new InvalidOperationHashError(this.hash);\n    }\n\n    this.confirmed$.pipe(first(), catchError(() => {\n      return of(EMPTY);\n    })).subscribe();\n  }\n\n  get includedInBlock() {\n    return this._foundAt;\n  }\n\n  get revealOperation() {\n    return Array.isArray(this.results) && this.results.find(op => op.kind === 'reveal');\n  }\n\n  get revealStatus() {\n    if (this.revealOperation) {\n      return this.revealOperation.metadata.operation_result.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  get status() {\n    return this.results.map(result => {\n      if (hasMetadataWithResult(result)) {\n        return result.metadata.operation_result.status;\n      } else {\n        return 'unknown';\n      }\n    })[0] || 'unknown';\n  }\n  /**\r\n   *\r\n   * @param confirmations [0] Number of confirmation to wait for\r\n   * @param timeout [180] Timeout\r\n   */\n\n\n  confirmation(confirmations, timeout) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (typeof confirmations !== 'undefined' && confirmations < 1) {\n        throw new InvalidConfirmationCountError('Confirmation count must be at least 1');\n      }\n\n      const {\n        defaultConfirmationCount,\n        confirmationPollingTimeoutSecond\n      } = this.context.config;\n\n      this._pollingConfig$.next({\n        timeout: timeout || confirmationPollingTimeoutSecond\n      });\n\n      const conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;\n      return new Promise((resolve, reject) => {\n        this.confirmed$.pipe(switchMap(() => this.currentHead$), filter(head => head.header.level - this._foundAt >= conf - 1), first()).subscribe(_ => {\n          resolve(this._foundAt + (conf - 1));\n        }, reject);\n      });\n    });\n  }\n\n}\n\nclass BatchOperation extends Operation {\n  constructor(hash, params, source, raw, results, context) {\n    super(hash, raw, results, context);\n    this.params = params;\n    this.source = source;\n  }\n\n  sumProp(arr, prop) {\n    return arr.reduce((prev, current) => {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  }\n\n  get status() {\n    return this.results.filter(result => BATCH_KINDS.indexOf(result.kind) !== -1).map(result => {\n      if (hasMetadataWithResult(result)) {\n        return result.metadata.operation_result.status;\n      } else {\n        return 'unknown';\n      }\n    })[0] || 'unknown';\n  }\n\n  get fee() {\n    return this.sumProp(this.params, 'fee');\n  }\n\n  get gasLimit() {\n    return this.sumProp(this.params, 'gas_limit');\n  }\n\n  get storageLimit() {\n    return this.sumProp(this.params, 'storage_limit');\n  }\n\n  get consumedGas() {\n    return String(this.sumProp(flattenOperationResult({\n      contents: this.results\n    }), 'consumed_gas'));\n  }\n\n  get storageDiff() {\n    return String(this.sumProp(flattenOperationResult({\n      contents: this.results\n    }), 'paid_storage_size_diff'));\n  }\n\n  get errors() {\n    return flattenErrors({\n      contents: this.results\n    });\n  }\n\n}\n\nclass OperationEmitter {\n  constructor(context) {\n    this.context = context;\n  }\n\n  get rpc() {\n    return this.context.rpc;\n  }\n\n  get signer() {\n    return this.context.signer;\n  }\n\n  isRevealOpNeeded(op, pkh) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return !(yield this.isAccountRevealRequired(pkh)) || !this.isRevealRequiredForOpType(op) ? false : true;\n    });\n  }\n\n  isAccountRevealRequired(publicKeyHash) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return !(yield this.context.readProvider.isAccountRevealed(publicKeyHash, 'head'));\n    });\n  }\n\n  isRevealRequiredForOpType(op) {\n    let opRequireReveal = false;\n\n    for (const operation of op) {\n      if (isOpRequireReveal(operation)) {\n        opRequireReveal = true;\n      }\n    }\n\n    return opRequireReveal;\n  } // Originally from sotez (Copyright (c) 2018 Andrew Kishino)\n\n\n  prepareOperation({\n    operation,\n    source\n  }, pkh) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const counters = {};\n      let ops = [];\n      const blockHashPromise = this.context.readProvider.getBlockHash('head~2');\n      const blockProtoPromise = this.context.readProvider.getNextProtocol('head');\n\n      if (Array.isArray(operation)) {\n        ops = [...operation];\n      } else {\n        ops = [operation];\n      } // Implicit account who emit the operation\n\n\n      const publicKeyHash = pkh ? pkh : yield this.signer.publicKeyHash();\n      let counterPromise = Promise.resolve(undefined);\n\n      for (let i = 0; i < ops.length; i++) {\n        if (isOpRequireReveal(ops[i]) || ops[i].kind === 'reveal') {\n          counterPromise = this.context.readProvider.getCounter(publicKeyHash, 'head');\n          break;\n        }\n      }\n\n      const [hash, protocol, headCounter] = yield Promise.all([blockHashPromise, blockProtoPromise, counterPromise]);\n      const counter = parseInt(headCounter || '0', 10);\n\n      if (!counters[publicKeyHash] || counters[publicKeyHash] < counter) {\n        counters[publicKeyHash] = counter;\n      }\n\n      const getFee = op => {\n        const opCounter = ++counters[publicKeyHash];\n        return {\n          counter: `${opCounter}`,\n          fee: typeof op.fee === 'undefined' ? '0' : `${op.fee}`,\n          gas_limit: typeof op.gas_limit === 'undefined' ? '0' : `${op.gas_limit}`,\n          storage_limit: typeof op.storage_limit === 'undefined' ? '0' : `${op.storage_limit}`\n        };\n      };\n\n      const getSource = op => {\n        return {\n          source: typeof op.source === 'undefined' ? source || publicKeyHash : op.source\n        };\n      };\n\n      const constructOps = cOps => cOps.map(op => {\n        switch (op.kind) {\n          case OpKind.ACTIVATION:\n            return Object.assign({}, op);\n\n          case OpKind.REVEAL:\n            return Object.assign(Object.assign(Object.assign({}, op), getSource(op)), getFee(op));\n\n          case OpKind.ORIGINATION:\n            return Object.assign(Object.assign(Object.assign(Object.assign({}, op), {\n              balance: typeof op.balance !== 'undefined' ? `${op.balance}` : '0'\n            }), getSource(op)), getFee(op));\n\n          case OpKind.TRANSACTION:\n            {\n              const cops = Object.assign(Object.assign(Object.assign(Object.assign({}, op), {\n                amount: typeof op.amount !== 'undefined' ? `${op.amount}` : '0'\n              }), getSource(op)), getFee(op));\n\n              if (cops.source.toLowerCase().startsWith('kt1')) {\n                throw new DeprecationError(`KT1 addresses are not supported as source since ${Protocols.PsBabyM1}`);\n              }\n\n              return cops;\n            }\n\n          case OpKind.DELEGATION:\n            return Object.assign(Object.assign(Object.assign({}, op), getSource(op)), getFee(op));\n\n          case OpKind.REGISTER_GLOBAL_CONSTANT:\n            return Object.assign(Object.assign(Object.assign({}, op), getSource(op)), getFee(op));\n\n          default:\n            throw new InvalidOperationKindError(op.kind);\n        }\n      });\n\n      const contents = constructOps(ops);\n      return {\n        opOb: {\n          branch: hash,\n          contents,\n          protocol\n        },\n        counter\n      };\n    });\n  }\n\n  forge({\n    opOb: {\n      branch,\n      contents,\n      protocol\n    },\n    counter\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const forgedBytes = yield this.context.forger.forge({\n        branch,\n        contents\n      });\n      return {\n        opbytes: forgedBytes,\n        opOb: {\n          branch,\n          contents,\n          protocol\n        },\n        counter\n      };\n    });\n  }\n\n  simulate(op) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        opResponse: yield this.rpc.runOperation(op),\n        op,\n        context: this.context.clone()\n      };\n    });\n  }\n\n  estimate(_a, estimator) {\n    var {\n      fee,\n      gasLimit,\n      storageLimit\n    } = _a,\n        rest = __rest(_a, [\"fee\", \"gasLimit\", \"storageLimit\"]);\n\n    return __awaiter(this, void 0, void 0, function* () {\n      let calculatedFee = fee;\n      let calculatedGas = gasLimit;\n      let calculatedStorage = storageLimit;\n\n      if (fee === undefined || gasLimit === undefined || storageLimit === undefined) {\n        const estimation = yield estimator(Object.assign({\n          fee,\n          gasLimit,\n          storageLimit\n        }, rest));\n\n        if (calculatedFee === undefined) {\n          calculatedFee = estimation.suggestedFeeMutez;\n        }\n\n        if (calculatedGas === undefined) {\n          calculatedGas = estimation.gasLimit;\n        }\n\n        if (calculatedStorage === undefined) {\n          calculatedStorage = estimation.storageLimit;\n        }\n      }\n\n      return {\n        fee: calculatedFee,\n        gasLimit: calculatedGas,\n        storageLimit: calculatedStorage\n      };\n    });\n  }\n\n  signAndInject(forgedBytes) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const signed = yield this.signer.sign(forgedBytes.opbytes, new Uint8Array([3]));\n      forgedBytes.opbytes = signed.sbytes;\n      forgedBytes.opOb.signature = signed.prefixSig;\n      const opResponse = [];\n      const results = yield this.rpc.preapplyOperations([forgedBytes.opOb]);\n\n      if (!Array.isArray(results)) {\n        throw new TezosPreapplyFailureError(results);\n      }\n\n      for (let i = 0; i < results.length; i++) {\n        for (let j = 0; j < results[i].contents.length; j++) {\n          opResponse.push(results[i].contents[j]);\n        }\n      }\n\n      const errors = flattenErrors(results);\n\n      if (errors.length) {\n        throw new TezosOperationError(errors, 'Error occurred during validation simulation of operation');\n      }\n\n      return {\n        hash: yield this.context.injector.inject(forgedBytes.opbytes),\n        forgedBytes,\n        opResponse,\n        context: this.context.clone()\n      };\n    });\n  }\n\n}\n\nconst BATCH_KINDS = [OpKind.ACTIVATION, OpKind.ORIGINATION, OpKind.TRANSACTION, OpKind.DELEGATION];\n\nclass OperationBatch extends OperationEmitter {\n  constructor(context, estimator) {\n    super(context);\n    this.estimator = estimator;\n    this.operations = [];\n  }\n  /**\r\n   *\r\n   * @description Add a transaction operation to the batch\r\n   *\r\n   * @param params Transfer operation parameter\r\n   */\n\n\n  withTransfer(params) {\n    if (validateAddress(params.to) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(params.to);\n    }\n\n    this.operations.push(Object.assign({\n      kind: OpKind.TRANSACTION\n    }, params));\n    return this;\n  }\n  /**\r\n   *\r\n   * @description Add a transaction operation to the batch\r\n   *\r\n   * @param params Transfer operation parameter\r\n   */\n\n\n  withContractCall(params) {\n    return this.withTransfer(params.toTransferParams());\n  }\n  /**\r\n   *\r\n   * @description Add a delegation operation to the batch\r\n   *\r\n   * @param params Delegation operation parameter\r\n   */\n\n\n  withDelegation(params) {\n    if (params.source && validateAddress(params.source) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(params.source);\n    }\n\n    if (params.delegate && validateAddress(params.delegate) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(params.delegate);\n    }\n\n    this.operations.push(Object.assign({\n      kind: OpKind.DELEGATION\n    }, params));\n    return this;\n  }\n  /**\r\n   *\r\n   * @description Add an activation operation to the batch\r\n   *\r\n   * @param params Activation operation parameter\r\n   */\n\n\n  withActivation({\n    pkh,\n    secret\n  }) {\n    if (validateKeyHash(pkh) !== ValidationResult.VALID) {\n      throw new InvalidKeyHashError(pkh);\n    }\n\n    this.operations.push({\n      kind: OpKind.ACTIVATION,\n      pkh,\n      secret\n    });\n    return this;\n  }\n  /**\r\n   *\r\n   * @description Add an origination operation to the batch\r\n   *\r\n   * @param params Origination operation parameter\r\n   */\n\n\n  withOrigination(params) {\n    this.operations.push(Object.assign({\n      kind: OpKind.ORIGINATION\n    }, params));\n    return this;\n  }\n  /**\r\n   *\r\n   * @description Add an operation to register a global constant to the batch\r\n   *\r\n   * @param params RegisterGlobalConstant operation parameter\r\n   */\n\n\n  withRegisterGlobalConstant(params) {\n    this.operations.push(Object.assign({\n      kind: OpKind.REGISTER_GLOBAL_CONSTANT\n    }, params));\n    return this;\n  }\n\n  getRPCOp(param) {\n    return __awaiter(this, void 0, void 0, function* () {\n      switch (param.kind) {\n        case OpKind.TRANSACTION:\n          return createTransferOperation(Object.assign({}, param));\n\n        case OpKind.ORIGINATION:\n          return createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign({}, param)));\n\n        case OpKind.DELEGATION:\n          return createSetDelegateOperation(Object.assign({}, param));\n\n        case OpKind.ACTIVATION:\n          return Object.assign({}, param);\n\n        case OpKind.REGISTER_GLOBAL_CONSTANT:\n          return createRegisterGlobalConstantOperation(Object.assign({}, param));\n\n        default:\n          throw new InvalidOperationKindError(param.kind);\n      }\n    });\n  }\n  /**\r\n   *\r\n   * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\r\n   *\r\n   * @param params Operations parameter\r\n   */\n\n\n  with(params) {\n    for (const param of params) {\n      switch (param.kind) {\n        case OpKind.TRANSACTION:\n          this.withTransfer(param);\n          break;\n\n        case OpKind.ORIGINATION:\n          this.withOrigination(param);\n          break;\n\n        case OpKind.DELEGATION:\n          this.withDelegation(param);\n          break;\n\n        case OpKind.ACTIVATION:\n          this.withActivation(param);\n          break;\n\n        case OpKind.REGISTER_GLOBAL_CONSTANT:\n          this.withRegisterGlobalConstant(param);\n          break;\n\n        default:\n          throw new InvalidOperationKindError(param.kind);\n      }\n    }\n\n    return this;\n  }\n  /**\r\n   *\r\n   * @description Forge and Inject the operation batch\r\n   *\r\n   * @param params Optionally specify the source of the operation\r\n   */\n\n\n  send(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const publicKeyHash = yield this.signer.publicKeyHash();\n      const publicKey = yield this.signer.publicKey();\n      const estimates = yield this.estimator.batch(this.operations);\n      const revealNeeded = yield this.isRevealOpNeeded(this.operations, publicKeyHash);\n      let i = revealNeeded ? 1 : 0;\n      const ops = [];\n\n      for (const op of this.operations) {\n        if (isOpWithFee(op)) {\n          const estimated = yield this.estimate(op, () => __awaiter(this, void 0, void 0, function* () {\n            return estimates[i];\n          }));\n          ops.push(yield this.getRPCOp(Object.assign(Object.assign({}, op), estimated)));\n        } else {\n          ops.push(Object.assign({}, op));\n        }\n\n        i++;\n      }\n\n      if (revealNeeded) {\n        const reveal = {\n          kind: OpKind.REVEAL\n        };\n        const estimatedReveal = yield this.estimate(reveal, () => __awaiter(this, void 0, void 0, function* () {\n          return estimates[0];\n        }));\n        ops.unshift(yield createRevealOperation(Object.assign({}, estimatedReveal), publicKeyHash, publicKey));\n      }\n\n      const source = params && params.source || publicKeyHash;\n      const prepared = yield this.prepareOperation({\n        operation: ops,\n        source\n      });\n      const opBytes = yield this.forge(prepared);\n      const {\n        hash,\n        context,\n        forgedBytes,\n        opResponse\n      } = yield this.signAndInject(opBytes);\n      return new BatchOperation(hash, ops, source, forgedBytes, opResponse, context);\n    });\n  }\n\n}\n\nclass RPCBatchProvider {\n  constructor(context, estimator) {\n    this.context = context;\n    this.estimator = estimator;\n  }\n  /***\r\n   *\r\n   * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\r\n   *\r\n   * @param params List of operation to batch together\r\n   */\n\n\n  batch(params) {\n    const batch = new OperationBatch(this.context, this.estimator);\n\n    if (Array.isArray(params)) {\n      batch.with(params);\n    }\n\n    return batch;\n  }\n\n}\n\nconst receiptFromOperation = (op, {\n  ALLOCATION_BURN,\n  ORIGINATION_BURN\n} = {\n  ALLOCATION_BURN: 257,\n  ORIGINATION_BURN: 257\n}) => {\n  const operationResults = flattenOperationResult({\n    contents: op\n  });\n  let totalGas = new BigNumber(0);\n  let totalStorage = new BigNumber(0);\n  let totalFee = new BigNumber(0);\n  let totalOriginationBurn = new BigNumber(0);\n  let totalAllocationBurn = new BigNumber(0);\n  let totalPaidStorageDiff = new BigNumber(0);\n  operationResults.forEach(result => {\n    totalFee = totalFee.plus(result.fee || 0);\n    totalOriginationBurn = totalOriginationBurn.plus(Array.isArray(result.originated_contracts) ? result.originated_contracts.length * ORIGINATION_BURN : 0);\n    totalAllocationBurn = totalAllocationBurn.plus('allocated_destination_contract' in result ? ALLOCATION_BURN : 0);\n    totalGas = totalGas.plus(result.consumed_gas || 0);\n    totalPaidStorageDiff = totalPaidStorageDiff.plus('paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0);\n  });\n  totalStorage = totalStorage.plus(totalAllocationBurn).plus(totalOriginationBurn).plus(totalPaidStorageDiff);\n  return {\n    totalFee,\n    totalGas,\n    totalStorage,\n    totalAllocationBurn,\n    totalOriginationBurn,\n    totalPaidStorageDiff,\n    totalStorageBurn: new BigNumber(totalStorage.multipliedBy(1000))\n  };\n};\n/**\r\n *  @category Error\r\n *  @description Error that indicates a missed block when polling to retrieve new head block. This may happen when the polling interval is greater than the time between blocks.\r\n */\n\n\nclass MissedBlockDuringConfirmationError extends Error {\n  constructor() {\n    super('Taquito missed a block while waiting for operation confirmation and was not able to find the operation');\n    this.name = 'MissedBlockDuringConfirmationError';\n  }\n\n}\n\nconst MAX_BRANCH_ANCESTORS = 60;\n/**\r\n * @description WalletOperation allows to monitor operation inclusion on chains and surface information related to the operation\r\n */\n\nclass WalletOperation {\n  /**\r\n   *\r\n   * @param opHash Operation hash\r\n   * @param raw Raw operation that was injected\r\n   * @param context Taquito context allowing access to rpc and signer\r\n   */\n  constructor(opHash, context, _newHead$) {\n    this.opHash = opHash;\n    this.context = context;\n    this._newHead$ = _newHead$;\n    this._operationResult = new ReplaySubject(1);\n    this._includedInBlock = new ReplaySubject(1);\n    this._included = false;\n    this.newHead$ = this._newHead$.pipe(tap(newHead => {\n      if (!this._included && this.lastHead && newHead.header.level - this.lastHead.header.level > 1) {\n        throw new MissedBlockDuringConfirmationError();\n      }\n\n      this.lastHead = newHead;\n    }), shareReplay({\n      bufferSize: 1,\n      refCount: true\n    })); // Observable that emit once operation is seen in a block\n\n    this.confirmed$ = this.newHead$.pipe(map(head => {\n      for (const opGroup of head.operations) {\n        for (const op of opGroup) {\n          if (op.hash === this.opHash) {\n            this._included = true;\n\n            this._includedInBlock.next(head);\n\n            this._operationResult.next(op.contents); // Return the block where the operation was found\n\n\n            return head;\n          }\n        }\n      }\n    }), filter(x => {\n      return typeof x !== 'undefined';\n    }), first(), shareReplay({\n      bufferSize: 1,\n      refCount: true\n    }));\n\n    if (validateOperation(this.opHash) !== ValidationResult.VALID) {\n      throw new InvalidOperationHashError(this.opHash);\n    }\n\n    this.confirmed$.pipe(first(), catchError(() => of(undefined))).subscribe();\n  }\n\n  operationResults() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this._operationResult.pipe(first()).toPromise();\n    });\n  }\n  /**\r\n   * @description Receipt expose the total amount of tezos token burn and spent on fees\r\n   * The promise returned by receipt will resolve only once the transaction is included\r\n   */\n\n\n  receipt() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return receiptFromOperation(yield this.operationResults());\n    });\n  }\n\n  getCurrentConfirmation() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._included) {\n        return 0;\n      }\n\n      return combineLatest([this._includedInBlock, from(this.context.readProvider.getBlock('head'))]).pipe(map(([foundAtBlock, head]) => {\n        return head.header.level - foundAtBlock.header.level + 1;\n      }), first()).toPromise();\n    });\n  }\n\n  isInCurrentBranch(tipBlockIdentifier = 'head') {\n    return __awaiter(this, void 0, void 0, function* () {\n      // By default it is assumed that the operation is in the current branch\n      if (!this._included) {\n        return true;\n      }\n\n      const tipBlockHeaderLevel = yield this.context.readProvider.getBlockLevel(tipBlockIdentifier);\n      const inclusionBlock = yield this._includedInBlock.pipe(first()).toPromise();\n      const levelDiff = tipBlockHeaderLevel - inclusionBlock.header.level; // Block produced before the operation is included are assumed to be part of the current branch\n\n      if (levelDiff <= 0) {\n        return true;\n      }\n\n      const tipBlockLevel = Math.min(inclusionBlock.header.level + levelDiff, inclusionBlock.header.level + MAX_BRANCH_ANCESTORS);\n      const blocks = new Set(yield this.context.readProvider.getLiveBlocks(tipBlockLevel));\n      return blocks.has(inclusionBlock.hash);\n    });\n  }\n\n  confirmationObservable(confirmations) {\n    if (typeof confirmations !== 'undefined' && confirmations < 1) {\n      throw new InvalidConfirmationCountError('Confirmation count must be at least 1');\n    }\n\n    const {\n      defaultConfirmationCount\n    } = this.context.config;\n    const conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;\n\n    if (conf === undefined) {\n      throw new ConfirmationUndefinedError('Default confirmation count can not be undefined!');\n    }\n\n    return combineLatest([this._includedInBlock, this.newHead$]).pipe(distinctUntilChanged(([, previousHead], [, newHead]) => {\n      return previousHead.hash === newHead.hash;\n    }), map(([foundAtBlock, head]) => {\n      return {\n        block: head,\n        expectedConfirmation: conf,\n        currentConfirmation: head.header.level - foundAtBlock.header.level + 1,\n        completed: head.header.level - foundAtBlock.header.level >= conf - 1,\n        isInCurrentBranch: () => this.isInCurrentBranch(head.hash)\n      };\n    }), takeWhile(({\n      completed\n    }) => !completed, true));\n  }\n  /**\r\n   *\r\n   * @param confirmations [0] Number of confirmation to wait for\r\n   */\n\n\n  confirmation(confirmations) {\n    return this.confirmationObservable(confirmations).toPromise();\n  }\n\n}\n\nclass BatchWalletOperation extends WalletOperation {\n  constructor(opHash, context, newHead$) {\n    super(opHash, context, newHead$);\n    this.opHash = opHash;\n    this.context = context;\n  }\n\n  revealOperation() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const operationResult = yield this.operationResults();\n      return operationResult.find(x => x.kind === OpKind.REVEAL);\n    });\n  }\n\n  status() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._included) {\n        return 'pending';\n      }\n\n      const op = yield this.operationResults();\n      return op.filter(result => BATCH_KINDS.indexOf(result.kind) !== -1).map(result => {\n        if (hasMetadataWithResult(result)) {\n          return result.metadata.operation_result.status;\n        } else {\n          return 'unknown';\n        }\n      })[0] || 'unknown';\n    });\n  }\n\n}\n\nclass DelegationWalletOperation extends WalletOperation {\n  constructor(opHash, context, newHead$) {\n    super(opHash, context, newHead$);\n    this.opHash = opHash;\n    this.context = context;\n  }\n\n  revealOperation() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const operationResult = yield this.operationResults();\n      return operationResult.find(x => x.kind === OpKind.REVEAL);\n    });\n  }\n\n  delegationOperation() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const operationResult = yield this.operationResults();\n      return operationResult.find(x => x.kind === OpKind.DELEGATION);\n    });\n  }\n\n  status() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._included) {\n        return 'pending';\n      }\n\n      const op = yield this.delegationOperation();\n\n      if (!op) {\n        return 'unknown';\n      }\n\n      return op.metadata.operation_result.status;\n    });\n  }\n\n}\n\nclass OriginationWalletOperation extends WalletOperation {\n  constructor(opHash, context, newHead$) {\n    super(opHash, context, newHead$);\n    this.opHash = opHash;\n    this.context = context;\n  }\n\n  originationOperation() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const operationResult = yield this.operationResults();\n      return findWithKind(operationResult, OpKind.ORIGINATION);\n    });\n  }\n\n  revealOperation() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const operationResult = yield this.operationResults();\n      return findWithKind(operationResult, OpKind.REVEAL);\n    });\n  }\n\n  status() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._included) {\n        return 'pending';\n      }\n\n      const op = yield this.originationOperation();\n\n      if (!op) {\n        return 'unknown';\n      }\n\n      return op.metadata.operation_result.status;\n    });\n  }\n\n  contract() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const op = yield this.originationOperation();\n      const address = ((op === null || op === void 0 ? void 0 : op.metadata.operation_result.originated_contracts) || [])[0];\n      return this.context.wallet.at(address);\n    });\n  }\n\n}\n\nclass TransactionWalletOperation extends WalletOperation {\n  constructor(opHash, context, newHead$) {\n    super(opHash, context, newHead$);\n    this.opHash = opHash;\n    this.context = context;\n  }\n\n  revealOperation() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const operationResult = yield this.operationResults();\n      return operationResult.find(x => x.kind === OpKind.REVEAL);\n    });\n  }\n\n  transactionOperation() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const operationResult = yield this.operationResults();\n      return operationResult.find(x => x.kind === OpKind.TRANSACTION);\n    });\n  }\n\n  status() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._included) {\n        return 'pending';\n      }\n\n      const op = yield this.transactionOperation();\n\n      if (!op) {\n        return 'unknown';\n      }\n\n      return op.metadata.operation_result.status;\n    });\n  }\n\n}\n\nconst createNewPollingBasedHeadObservable = (sharedHeadOb, context, scheduler) => {\n  return sharedHeadOb.pipe(timeoutWith(context.config.confirmationPollingTimeoutSecond * 1000, throwError(new Error('Confirmation polling timed out')), scheduler), shareReplay({\n    refCount: true,\n    scheduler\n  }));\n};\n\nclass OperationFactory {\n  constructor(context) {\n    this.context = context; // Cache the last block for one second across all operations\n\n    this.sharedHeadObs = defer(() => {\n      return createObservableFromSubscription(this.context.stream.subscribeBlock('head'));\n    });\n  }\n\n  createNewHeadObservable() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return createNewPollingBasedHeadObservable(this.sharedHeadObs, this.context);\n    });\n  }\n\n  createPastBlockWalker(startBlock, count = 1) {\n    return from(this.context.readProvider.getBlock(startBlock)).pipe(switchMap(block => {\n      if (count === 1) {\n        return of(block);\n      }\n\n      return range(block.header.level, count - 1).pipe(startWith(block), concatMap(level => __awaiter(this, void 0, void 0, function* () {\n        return this.context.readProvider.getBlock(typeof level === 'number' ? level : level.header.level);\n      })));\n    }));\n  }\n\n  createHeadObservableFromConfig({\n    blockIdentifier\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const observableSequence = [];\n\n      if (blockIdentifier) {\n        observableSequence.push(this.createPastBlockWalker(blockIdentifier));\n      }\n\n      observableSequence.push(yield this.createNewHeadObservable());\n      return concat(...observableSequence);\n    });\n  }\n\n  createOperation(hash, config = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new WalletOperation(hash, this.context.clone(), yield this.createHeadObservableFromConfig(config));\n    });\n  }\n\n  createBatchOperation(hash, config = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new BatchWalletOperation(hash, this.context.clone(), yield this.createHeadObservableFromConfig(config));\n    });\n  }\n\n  createTransactionOperation(hash, config = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new TransactionWalletOperation(hash, this.context.clone(), yield this.createHeadObservableFromConfig(config));\n    });\n  }\n\n  createDelegationOperation(hash, config = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new DelegationWalletOperation(hash, this.context.clone(), yield this.createHeadObservableFromConfig(config));\n    });\n  }\n\n  createOriginationOperation(hash, config = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new OriginationWalletOperation(hash, this.context.clone(), yield this.createHeadObservableFromConfig(config));\n    });\n  }\n\n}\n\nclass RpcTzProvider extends OperationEmitter {\n  constructor(context) {\n    super(context);\n  }\n\n  getBalance(address) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (validateAddress(address) !== ValidationResult.VALID) {\n        throw new InvalidAddressError(address);\n      }\n\n      return this.context.readProvider.getBalance(address, 'head');\n    });\n  }\n\n  getDelegate(address) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (validateAddress(address) !== ValidationResult.VALID) {\n        throw new InvalidAddressError(address);\n      }\n\n      return this.context.readProvider.getDelegate(address, 'head');\n    });\n  }\n\n  activate(pkh, secret) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (validateKeyHash(pkh) !== ValidationResult.VALID) {\n        throw new InvalidKeyHashError(pkh);\n      }\n\n      const operation = {\n        kind: OpKind.ACTIVATION,\n        pkh,\n        secret\n      };\n      const prepared = yield this.prepareOperation({\n        operation: [operation],\n        source: pkh\n      });\n      const forgedBytes = yield this.forge(prepared);\n      const bytes = `${forgedBytes.opbytes}00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`;\n      return new Operation(yield this.rpc.injectOperation(bytes), Object.assign(Object.assign({}, forgedBytes), {\n        opbytes: bytes\n      }), [], this.context.clone());\n    });\n  }\n\n}\n\nconst MINIMAL_FEE_MUTEZ = 100;\nconst MINIMAL_FEE_PER_BYTE_MUTEZ = 1;\nconst MINIMAL_FEE_PER_GAS_MUTEZ = 0.1;\nconst GAS_BUFFER = 100;\n/**\r\n * Examples of use :\r\n *\r\n *  Estimate a transfer operation :\r\n * ```\r\n * // Assuming that provider and signer are already configured...\r\n *\r\n * const amount = 2;\r\n * const address = 'tz1h3rQ8wBxFd8L9B3d7Jhaawu6Z568XU3xY';\r\n *\r\n * // Estimate gasLimit, storageLimit and fees for a transfer operation\r\n * const est = await Tezos.estimate.transfer({ to: address, amount: amount })\r\n * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,\r\n *  est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)\r\n *\r\n * ```\r\n *\r\n * Estimate a contract origination :\r\n * ```\r\n * // generic.json is referring to a Michelson Smart Contract\r\n *\r\n * const genericMultisigJSON = require('./generic.json')\r\n * const est = await Tezos.estimate.originate({\r\n *   code: genericMultisigJSON,\r\n *   storage: {\r\n *     stored_counter: 0,\r\n *     threshold: 1,\r\n *     keys: ['edpkuLxx9PQD8fZ45eUzrK3BhfDZJHhBuK4Zi49DcEGANwd2rpX82t']\r\n *   }\r\n * })\r\n * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,\r\n *   est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)\r\n *\r\n * ```\r\n */\n\nclass Estimate {\n  constructor(_milligasLimit, _storageLimit, opSize, minimalFeePerStorageByteMutez,\n  /**\r\n   * @description Base fee in mutez (1 mutez = 1e106 tez)\r\n   */\n  baseFeeMutez = MINIMAL_FEE_MUTEZ) {\n    this._milligasLimit = _milligasLimit;\n    this._storageLimit = _storageLimit;\n    this.opSize = opSize;\n    this.minimalFeePerStorageByteMutez = minimalFeePerStorageByteMutez;\n    this.baseFeeMutez = baseFeeMutez;\n  }\n  /**\r\n   * @description The number of Mutez that will be burned for the storage of the [operation](https://tezos.gitlab.io/user/glossary.html#operations). (Storage + Allocation fees)\r\n   */\n\n\n  get burnFeeMutez() {\n    return this.roundUp(Number(this.storageLimit) * Number(this.minimalFeePerStorageByteMutez));\n  }\n  /**\r\n   * @description  The limit on the amount of storage an [operation](https://tezos.gitlab.io/user/glossary.html#operations) can use.\r\n   */\n\n\n  get storageLimit() {\n    const limit = Math.max(Number(this._storageLimit), 0);\n    return limit > 0 ? limit : 0;\n  }\n  /**\r\n   * @description The limit on the amount of [gas](https://tezos.gitlab.io/user/glossary.html#gas) a given operation can consume.\r\n   */\n\n\n  get gasLimit() {\n    return this.roundUp(Number(this._milligasLimit) / 1000 + GAS_BUFFER);\n  }\n\n  get operationFeeMutez() {\n    return (Number(this._milligasLimit) / 1000 + GAS_BUFFER) * MINIMAL_FEE_PER_GAS_MUTEZ + Number(this.opSize) * MINIMAL_FEE_PER_BYTE_MUTEZ;\n  }\n\n  roundUp(nanotez) {\n    return Math.ceil(Number(nanotez));\n  }\n  /**\r\n   * @description Minimum fees for the [operation](https://tezos.gitlab.io/user/glossary.html#operations) according to [baker](https://tezos.gitlab.io/user/glossary.html#baker) defaults.\r\n   */\n\n\n  get minimalFeeMutez() {\n    return this.roundUp(MINIMAL_FEE_MUTEZ + this.operationFeeMutez);\n  }\n  /**\r\n   * @description The suggested fee for the operation which includes minimal fees and a small buffer.\r\n   */\n\n\n  get suggestedFeeMutez() {\n    return this.roundUp(this.operationFeeMutez + MINIMAL_FEE_MUTEZ * 2);\n  }\n  /**\r\n   * @description Fees according to your specified base fee will ensure that at least minimum fees are used.\r\n   */\n\n\n  get usingBaseFeeMutez() {\n    return Math.max(Number(this.baseFeeMutez), MINIMAL_FEE_MUTEZ) + this.roundUp(this.operationFeeMutez);\n  }\n  /**\r\n   * @description The sum of `minimalFeeMutez` + `burnFeeMutez`.\r\n   */\n\n\n  get totalCost() {\n    return this.minimalFeeMutez + this.burnFeeMutez;\n  }\n  /**\r\n   * @description Since Delphinet, consumed gas is provided in milligas for more precision.\r\n   * This function returns an estimation of the gas that operation will consume in milligas.\r\n   */\n\n\n  get consumedMilligas() {\n    return Number(this._milligasLimit);\n  }\n\n  static createEstimateInstanceFromProperties(estimateProperties) {\n    let milligasLimit = 0;\n    let storageLimit = 0;\n    let opSize = 0;\n    let minimalFeePerStorageByteMutez = 0;\n    let baseFeeMutez;\n    estimateProperties.forEach(estimate => {\n      milligasLimit += estimate.milligasLimit;\n      storageLimit += estimate.storageLimit;\n      opSize += estimate.opSize;\n      minimalFeePerStorageByteMutez = Math.max(estimate.minimalFeePerStorageByteMutez, minimalFeePerStorageByteMutez);\n\n      if (estimate.baseFeeMutez) {\n        baseFeeMutez = baseFeeMutez ? baseFeeMutez + estimate.baseFeeMutez : estimate.baseFeeMutez;\n      }\n    });\n    return new Estimate(milligasLimit, storageLimit, opSize, minimalFeePerStorageByteMutez, baseFeeMutez);\n  }\n\n  static createArrayEstimateInstancesFromProperties(estimateProperties) {\n    return estimateProperties.map(x => new Estimate(x.milligasLimit, x.storageLimit, x.opSize, x.minimalFeePerStorageByteMutez, x.baseFeeMutez));\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates invalid public key being passed when doing a reveal operation estimate\r\n */\n\n\nclass RevealEstimateError extends Error {\n  constructor() {\n    super('Unable to estimate the reveal operation, the public key is unknown');\n    this.name = 'Reveal Estimate Error';\n  }\n\n}\n\nconst mergeLimits = (userDefinedLimit, defaultLimits) => {\n  return {\n    fee: typeof userDefinedLimit.fee === 'undefined' ? defaultLimits.fee : userDefinedLimit.fee,\n    gasLimit: typeof userDefinedLimit.gasLimit === 'undefined' ? defaultLimits.gasLimit : userDefinedLimit.gasLimit,\n    storageLimit: typeof userDefinedLimit.storageLimit === 'undefined' ? defaultLimits.storageLimit : userDefinedLimit.storageLimit\n  };\n}; // RPC requires a signature but does not verify it\n\n\nconst SIGNATURE_STUB = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg';\n\nclass RPCEstimateProvider extends OperationEmitter {\n  constructor() {\n    super(...arguments);\n    this.ALLOCATION_STORAGE = 257;\n    this.ORIGINATION_STORAGE = 257;\n    this.OP_SIZE_REVEAL = 128;\n  }\n\n  getKeys() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const isSignerConfigured = this.context.isAnySignerConfigured();\n      return {\n        publicKeyHash: isSignerConfigured ? yield this.signer.publicKeyHash() : yield this.context.walletProvider.getPKH(),\n        publicKey: isSignerConfigured ? yield this.signer.publicKey() : undefined\n      };\n    });\n  } // Maximum values defined by the protocol\n\n\n  getAccountLimits(pkh, constants, numberOfOps) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const balance = yield this.context.readProvider.getBalance(pkh, 'head');\n      const {\n        hard_gas_limit_per_operation,\n        hard_gas_limit_per_block,\n        hard_storage_limit_per_operation,\n        cost_per_byte\n      } = constants;\n      return {\n        fee: 0,\n        gasLimit: numberOfOps ? Math.floor(this.ajustGasForBatchOperation(hard_gas_limit_per_block, hard_gas_limit_per_operation, numberOfOps).toNumber()) : hard_gas_limit_per_operation.toNumber(),\n        storageLimit: Math.floor(BigNumber.min(balance.dividedBy(cost_per_byte), hard_storage_limit_per_operation).toNumber())\n      };\n    });\n  } // Fix for Granada where the total gasLimit of a batch can not exceed the hard_gas_limit_per_block.\n  // If the total gasLimit of the batch is higher than the hard_gas_limit_per_block,\n  // the gasLimit is calculated by dividing the hard_gas_limit_per_block by the number of operation in the batch (numberOfOps).\n  // numberOfOps is incremented by 1 for safety in case a reveal operation is needed\n\n\n  ajustGasForBatchOperation(gasLimitBlock, gaslimitOp, numberOfOps) {\n    return BigNumber.min(gaslimitOp, gasLimitBlock.div(numberOfOps + 1));\n  }\n\n  getEstimationPropertiesFromOperationContent(content, size, costPerByte) {\n    const operationResults = flattenOperationResult({\n      contents: [content]\n    });\n    let totalGas = 0;\n    let totalMilligas = 0;\n    let totalStorage = 0;\n    operationResults.forEach(result => {\n      totalStorage += 'originated_contracts' in result && typeof result.originated_contracts !== 'undefined' ? result.originated_contracts.length * this.ORIGINATION_STORAGE : 0;\n      totalStorage += 'allocated_destination_contract' in result ? this.ALLOCATION_STORAGE : 0;\n      totalGas += Number(result.consumed_gas) || 0;\n      totalMilligas += Number(result.consumed_milligas) || 0;\n      totalStorage += 'paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0;\n      totalStorage += 'storage_size' in result && 'global_address' in result ? Number(result.storage_size) || 0 : 0;\n    });\n\n    if (totalGas !== 0 && totalMilligas === 0) {\n      // This will convert gas to milligas for Carthagenet where result does not contain consumed gas in milligas.\n      totalMilligas = totalGas * 1000;\n    }\n\n    if (isOpWithFee(content)) {\n      return {\n        milligasLimit: totalMilligas || 0,\n        storageLimit: Number(totalStorage || 0),\n        opSize: size,\n        minimalFeePerStorageByteMutez: costPerByte.toNumber()\n      };\n    } else {\n      return {\n        milligasLimit: 0,\n        storageLimit: 0,\n        opSize: size,\n        minimalFeePerStorageByteMutez: costPerByte.toNumber(),\n        baseFeeMutez: 0\n      };\n    }\n  }\n\n  prepareEstimate(params, constants, pkh) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const prepared = yield this.prepareOperation(params, pkh);\n      const {\n        opbytes,\n        opOb: {\n          branch,\n          contents\n        }\n      } = yield this.forge(prepared);\n      const operation = {\n        operation: {\n          branch,\n          contents,\n          signature: SIGNATURE_STUB\n        },\n        chain_id: yield this.context.readProvider.getChainId()\n      };\n      const {\n        opResponse\n      } = yield this.simulate(operation);\n      const {\n        cost_per_byte\n      } = constants;\n      const errors = [...flattenErrors(opResponse, 'backtracked'), ...flattenErrors(opResponse)]; // Fail early in case of errors\n\n      if (errors.length) {\n        throw new TezosOperationError(errors, 'Error occurred during estimation');\n      }\n\n      let numberOfOps = 1;\n\n      if (Array.isArray(params.operation) && params.operation.length > 1) {\n        numberOfOps = opResponse.contents[0].kind === 'reveal' ? params.operation.length - 1 : params.operation.length;\n      }\n\n      return opResponse.contents.map(x => {\n        return this.getEstimationPropertiesFromOperationContent(x, // TODO: Calculate a specific opSize for each operation.\n        x.kind === 'reveal' ? this.OP_SIZE_REVEAL / 2 : opbytes.length / 2 / numberOfOps, cost_per_byte);\n      });\n    });\n  }\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for an origination operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param OriginationOperation Originate operation parameter\r\n   */\n\n\n  originate(_a) {\n    var {\n      fee,\n      storageLimit,\n      gasLimit\n    } = _a,\n        rest = __rest(_a, [\"fee\", \"storageLimit\", \"gasLimit\"]);\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        publicKeyHash\n      } = yield this.getKeys();\n      const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');\n      const DEFAULT_PARAMS = yield this.getAccountLimits(publicKeyHash, protocolConstants);\n      const op = yield createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign(Object.assign({}, rest), mergeLimits({\n        fee,\n        storageLimit,\n        gasLimit\n      }, DEFAULT_PARAMS))));\n      const isRevealNeeded = yield this.isRevealOpNeeded([op], publicKeyHash);\n      const ops = isRevealNeeded ? yield this.addRevealOp([op], publicKeyHash) : op;\n      const estimateProperties = yield this.prepareEstimate({\n        operation: ops,\n        source: publicKeyHash\n      }, protocolConstants, publicKeyHash);\n\n      if (isRevealNeeded) {\n        estimateProperties.shift();\n      }\n\n      return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n    });\n  }\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for an transfer operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param TransferOperation Originate operation parameter\r\n   */\n\n\n  transfer(_a) {\n    var {\n      fee,\n      storageLimit,\n      gasLimit\n    } = _a,\n        rest = __rest(_a, [\"fee\", \"storageLimit\", \"gasLimit\"]);\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (validateAddress(rest.to) !== ValidationResult.VALID) {\n        throw new InvalidAddressError(rest.to);\n      }\n\n      if (rest.source && validateAddress(rest.source) !== ValidationResult.VALID) {\n        throw new InvalidAddressError(rest.source);\n      }\n\n      const pkh = (yield this.getKeys()).publicKeyHash;\n      const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');\n      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);\n      const op = yield createTransferOperation(Object.assign(Object.assign({}, rest), mergeLimits({\n        fee,\n        storageLimit,\n        gasLimit\n      }, DEFAULT_PARAMS)));\n      const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);\n      const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;\n      const estimateProperties = yield this.prepareEstimate({\n        operation: ops,\n        source: pkh\n      }, protocolConstants, pkh);\n\n      if (isRevealNeeded) {\n        estimateProperties.shift();\n      }\n\n      return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n    });\n  }\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param Estimate\r\n   */\n\n\n  setDelegate(_a) {\n    var {\n      fee,\n      gasLimit,\n      storageLimit\n    } = _a,\n        rest = __rest(_a, [\"fee\", \"gasLimit\", \"storageLimit\"]);\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (rest.source && validateAddress(rest.source) !== ValidationResult.VALID) {\n        throw new InvalidAddressError(rest.source);\n      }\n\n      if (rest.delegate && validateAddress(rest.delegate) !== ValidationResult.VALID) {\n        throw new InvalidAddressError(rest.delegate);\n      }\n\n      const pkh = (yield this.getKeys()).publicKeyHash;\n      const sourceOrDefault = rest.source || pkh;\n      const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');\n      const DEFAULT_PARAMS = yield this.getAccountLimits(sourceOrDefault, protocolConstants);\n      const op = yield createSetDelegateOperation(Object.assign(Object.assign({}, rest), mergeLimits({\n        fee,\n        storageLimit,\n        gasLimit\n      }, DEFAULT_PARAMS)));\n      const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);\n      const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;\n      const estimateProperties = yield this.prepareEstimate({\n        operation: ops,\n        source: pkh\n      }, protocolConstants, pkh);\n\n      if (isRevealNeeded) {\n        estimateProperties.shift();\n      }\n\n      return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n    });\n  }\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for a each operation in the batch\r\n   *\r\n   * @returns An array of Estimate objects. If a reveal operation is needed, the first element of the array is the Estimate for the reveal operation.\r\n   */\n\n\n  batch(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        publicKeyHash\n      } = yield this.getKeys();\n      let operations = [];\n      const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');\n      const DEFAULT_PARAMS = yield this.getAccountLimits(publicKeyHash, protocolConstants, params.length);\n\n      for (const param of params) {\n        switch (param.kind) {\n          case OpKind.TRANSACTION:\n            operations.push(yield createTransferOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));\n            break;\n\n          case OpKind.ORIGINATION:\n            operations.push(yield createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS)))));\n            break;\n\n          case OpKind.DELEGATION:\n            operations.push(yield createSetDelegateOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));\n            break;\n\n          case OpKind.ACTIVATION:\n            operations.push(Object.assign(Object.assign({}, param), DEFAULT_PARAMS));\n            break;\n\n          case OpKind.REGISTER_GLOBAL_CONSTANT:\n            operations.push(yield createRegisterGlobalConstantOperation(Object.assign(Object.assign({}, param), mergeLimits(param, DEFAULT_PARAMS))));\n            break;\n\n          default:\n            throw new InvalidOperationKindError(params.kind);\n        }\n      }\n\n      const isRevealNeeded = yield this.isRevealOpNeeded(operations, publicKeyHash);\n      operations = isRevealNeeded ? yield this.addRevealOp(operations, publicKeyHash) : operations;\n      const estimateProperties = yield this.prepareEstimate({\n        operation: operations,\n        source: publicKeyHash\n      }, protocolConstants, publicKeyHash);\n      return Estimate.createArrayEstimateInstancesFromProperties(estimateProperties);\n    });\n  }\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param Estimate\r\n   */\n\n\n  registerDelegate(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const pkh = (yield this.getKeys()).publicKeyHash;\n      const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');\n      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);\n      const op = yield createRegisterDelegateOperation(Object.assign(Object.assign({}, params), DEFAULT_PARAMS), pkh);\n      const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);\n      const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;\n      const estimateProperties = yield this.prepareEstimate({\n        operation: ops,\n        source: pkh\n      }, protocolConstants, pkh);\n\n      if (isRevealNeeded) {\n        estimateProperties.shift();\n      }\n\n      return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n    });\n  }\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees to reveal the current account\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation or undefined if the account is already revealed\r\n   *\r\n   * @param Estimate\r\n   */\n\n\n  reveal(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        publicKeyHash,\n        publicKey\n      } = yield this.getKeys();\n\n      if (!publicKey) {\n        throw new RevealEstimateError();\n      }\n\n      if (yield this.isAccountRevealRequired(publicKeyHash)) {\n        const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');\n        const DEFAULT_PARAMS = yield this.getAccountLimits(publicKeyHash, protocolConstants);\n        const op = yield createRevealOperation(Object.assign(Object.assign({}, params), DEFAULT_PARAMS), publicKeyHash, publicKey);\n        const estimateProperties = yield this.prepareEstimate({\n          operation: op,\n          source: publicKeyHash\n        }, protocolConstants, publicKeyHash);\n        return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n      }\n    });\n  }\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for an registerGlobalConstant operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param params registerGlobalConstant operation parameter\r\n   */\n\n\n  registerGlobalConstant(_a) {\n    var {\n      fee,\n      storageLimit,\n      gasLimit\n    } = _a,\n        rest = __rest(_a, [\"fee\", \"storageLimit\", \"gasLimit\"]);\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const pkh = (yield this.getKeys()).publicKeyHash;\n      const protocolConstants = yield this.context.readProvider.getProtocolConstants('head');\n      const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);\n      const op = yield createRegisterGlobalConstantOperation(Object.assign(Object.assign({}, rest), mergeLimits({\n        fee,\n        storageLimit,\n        gasLimit\n      }, DEFAULT_PARAMS)));\n      const isRevealNeeded = yield this.isRevealOpNeeded([op], pkh);\n      const ops = isRevealNeeded ? yield this.addRevealOp([op], pkh) : op;\n      const estimateProperties = yield this.prepareEstimate({\n        operation: ops,\n        source: pkh\n      }, protocolConstants, pkh);\n\n      if (isRevealNeeded) {\n        estimateProperties.shift();\n      }\n\n      return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n    });\n  }\n\n  addRevealOp(op, pkh) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        publicKey\n      } = yield this.getKeys();\n\n      if (!publicKey) {\n        throw new RevealEstimateError();\n      }\n\n      op.unshift(yield createRevealOperation(Object.assign({\n        fee: DEFAULT_FEE.REVEAL,\n        gasLimit: DEFAULT_GAS_LIMIT.REVEAL,\n        storageLimit: DEFAULT_STORAGE_LIMIT.REVEAL\n      }), pkh, yield this.signer.publicKey()));\n      return op;\n    });\n  }\n\n}\n/**\r\n * @description Delegation operation provide utility function to fetch newly issued delegation\r\n *\r\n * @warn Currently support only one delegation per operation\r\n */\n\n\nclass DelegateOperation extends Operation {\n  constructor(hash, params, source, raw, results, context) {\n    super(hash, raw, results, context);\n    this.params = params;\n    this.source = source;\n  }\n\n  get operationResults() {\n    const delegationOp = Array.isArray(this.results) && this.results.find(op => op.kind === 'delegation');\n    const result = delegationOp && delegationOp.metadata && delegationOp.metadata.operation_result;\n    return result ? result : undefined;\n  }\n\n  get status() {\n    const operationResults = this.operationResults;\n\n    if (operationResults) {\n      return operationResults.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  get delegate() {\n    return this.delegate;\n  }\n\n  get isRegisterOperation() {\n    return this.delegate === this.source;\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  get consumedGas() {\n    const consumedGas = this.operationResults && this.operationResults.consumed_gas;\n    return consumedGas ? consumedGas : undefined;\n  }\n\n  get errors() {\n    return this.operationResults && this.operationResults.errors;\n  }\n\n}\n/**\r\n * @description Origination operation provide utility function to fetch newly originated contract\r\n *\r\n * @warn Currently support only one origination per operation\r\n */\n\n\nclass OriginationOperation extends Operation {\n  constructor(hash, params, raw, results, context, contractProvider) {\n    super(hash, raw, results, context);\n    this.params = params;\n    this.contractProvider = contractProvider;\n    const originatedContracts = this.operationResults && this.operationResults.originated_contracts;\n\n    if (Array.isArray(originatedContracts)) {\n      this.contractAddress = originatedContracts[0];\n    }\n  }\n\n  get status() {\n    const operationResults = this.operationResults;\n\n    if (operationResults) {\n      return operationResults.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  get operationResults() {\n    const originationOp = Array.isArray(this.results) && this.results.find(op => op.kind === 'origination');\n    const result = originationOp && hasMetadataWithResult(originationOp) && originationOp.metadata.operation_result;\n    return result ? result : undefined;\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  get consumedGas() {\n    const consumedGas = this.operationResults && this.operationResults.consumed_gas;\n    return consumedGas ? consumedGas : undefined;\n  }\n\n  get storageDiff() {\n    const storageDiff = this.operationResults && this.operationResults.paid_storage_size_diff;\n    return storageDiff ? storageDiff : undefined;\n  }\n\n  get storageSize() {\n    const storageSize = this.operationResults && this.operationResults.storage_size;\n    return storageSize ? storageSize : undefined;\n  }\n\n  get errors() {\n    return this.operationResults && this.operationResults.errors;\n  }\n  /**\r\n   * @description Provide the contract abstract of the newly originated contract\r\n   */\n\n\n  contract(confirmations, timeout) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.contractAddress) {\n        throw new OriginationOperationError('No contract was originated in this operation');\n      }\n\n      yield this.confirmation(confirmations, timeout);\n      return this.contractProvider.at(this.contractAddress);\n    });\n  }\n\n}\n/**\r\n * @description RegisterGlobalConstantOperation provides utility functions to fetch a newly issued operation of kind register_global_constant\r\n */\n\n\nclass RegisterGlobalConstantOperation extends Operation {\n  constructor(hash, params, source, raw, results, context) {\n    super(hash, raw, results, context);\n    this.params = params;\n    this.source = source;\n    this.globalConstantHash = this.operationResults && this.operationResults.global_address;\n  }\n\n  get operationResults() {\n    const registerGlobalConstantOp = Array.isArray(this.results) && this.results.find(op => op.kind === 'register_global_constant');\n    const result = registerGlobalConstantOp && registerGlobalConstantOp.metadata && registerGlobalConstantOp.metadata.operation_result;\n    return result ? result : undefined;\n  }\n\n  get status() {\n    const operationResults = this.operationResults;\n\n    if (operationResults) {\n      return operationResults.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  get registeredExpression() {\n    return this.params.value;\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  get errors() {\n    return this.operationResults && this.operationResults.errors;\n  }\n\n}\n/**\r\n * @description Reveal operation provides utility functions to fetch a newly issued revelation\r\n */\n\n\nclass RevealOperation extends Operation {\n  constructor(hash, params, source, raw, results, context) {\n    super(hash, raw, results, context);\n    this.params = params;\n    this.source = source;\n  }\n\n  get operationResults() {\n    const revealOp = Array.isArray(this.results) && this.results.find(op => op.kind === 'reveal');\n    return revealOp ? [revealOp] : [];\n  }\n\n  get status() {\n    const operationResults = this.operationResults;\n    const txResult = operationResults[0];\n\n    if (txResult) {\n      return txResult.metadata.operation_result.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  get publicKey() {\n    return this.params.public_key;\n  }\n\n  sumProp(arr, prop) {\n    return arr.reduce((prev, current) => {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  }\n\n  get consumedGas() {\n    return String(this.sumProp(flattenOperationResult({\n      contents: this.operationResults\n    }), 'consumed_gas'));\n  }\n\n  get storageDiff() {\n    return String(this.sumProp(flattenOperationResult({\n      contents: this.operationResults\n    }), 'paid_storage_size_diff'));\n  }\n\n  get storageSize() {\n    return String(this.sumProp(flattenOperationResult({\n      contents: this.operationResults\n    }), 'storage_size'));\n  }\n\n  get errors() {\n    return flattenErrors({\n      contents: this.operationResults\n    });\n  }\n\n}\n/**\r\n * @description Transaction operation provides utility functions to fetch a newly issued transaction\r\n *\r\n * @warn Currently supports one transaction per operation\r\n */\n\n\nclass TransactionOperation extends Operation {\n  constructor(hash, params, source, raw, results, context) {\n    super(hash, raw, results, context);\n    this.params = params;\n    this.source = source;\n  }\n\n  get operationResults() {\n    const transactionOp = Array.isArray(this.results) && this.results.find(op => op.kind === 'transaction');\n    return transactionOp ? [transactionOp] : [];\n  }\n\n  get status() {\n    const operationResults = this.operationResults;\n    const txResult = operationResults[0];\n\n    if (txResult) {\n      return txResult.metadata.operation_result.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  get amount() {\n    return new BigNumber(this.params.amount);\n  }\n\n  get destination() {\n    return this.params.destination;\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  sumProp(arr, prop) {\n    return arr.reduce((prev, current) => {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  }\n\n  get consumedGas() {\n    return String(this.sumProp(flattenOperationResult({\n      contents: this.operationResults\n    }), 'consumed_gas'));\n  }\n\n  get storageDiff() {\n    return String(this.sumProp(flattenOperationResult({\n      contents: this.operationResults\n    }), 'paid_storage_size_diff'));\n  }\n\n  get storageSize() {\n    return String(this.sumProp(flattenOperationResult({\n      contents: this.operationResults\n    }), 'storage_size'));\n  }\n\n  get errors() {\n    return flattenErrors({\n      contents: this.operationResults\n    });\n  }\n\n}\n\nconst setDelegate = key => {\n  return [{\n    prim: 'DROP'\n  }, {\n    prim: 'NIL',\n    args: [{\n      prim: 'operation'\n    }]\n  }, {\n    prim: 'PUSH',\n    args: [{\n      prim: 'key_hash'\n    }, {\n      string: key\n    }]\n  }, {\n    prim: 'SOME'\n  }, {\n    prim: 'SET_DELEGATE'\n  }, {\n    prim: 'CONS'\n  }];\n};\n\nconst transferImplicit = (key, mutez) => {\n  return [{\n    prim: 'DROP'\n  }, {\n    prim: 'NIL',\n    args: [{\n      prim: 'operation'\n    }]\n  }, {\n    prim: 'PUSH',\n    args: [{\n      prim: 'key_hash'\n    }, {\n      string: key\n    }]\n  }, {\n    prim: 'IMPLICIT_ACCOUNT'\n  }, {\n    prim: 'PUSH',\n    args: [{\n      prim: 'mutez'\n    }, {\n      int: `${mutez}`\n    }]\n  }, {\n    prim: 'UNIT'\n  }, {\n    prim: 'TRANSFER_TOKENS'\n  }, {\n    prim: 'CONS'\n  }];\n};\n\nconst removeDelegate = () => {\n  return [{\n    prim: 'DROP'\n  }, {\n    prim: 'NIL',\n    args: [{\n      prim: 'operation'\n    }]\n  }, {\n    prim: 'NONE',\n    args: [{\n      prim: 'key_hash'\n    }]\n  }, {\n    prim: 'SET_DELEGATE'\n  }, {\n    prim: 'CONS'\n  }];\n};\n\nconst transferToContract = (key, amount) => {\n  return [{\n    prim: 'DROP'\n  }, {\n    prim: 'NIL',\n    args: [{\n      prim: 'operation'\n    }]\n  }, {\n    prim: 'PUSH',\n    args: [{\n      prim: 'address'\n    }, {\n      string: key\n    }]\n  }, {\n    prim: 'CONTRACT',\n    args: [{\n      prim: 'unit'\n    }]\n  }, [{\n    prim: 'IF_NONE',\n    args: [[[{\n      prim: 'UNIT'\n    }, {\n      prim: 'FAILWITH'\n    }]], []]\n  }], {\n    prim: 'PUSH',\n    args: [{\n      prim: 'mutez'\n    }, {\n      int: `${amount}`\n    }]\n  }, {\n    prim: 'UNIT'\n  }, {\n    prim: 'TRANSFER_TOKENS'\n  }, {\n    prim: 'CONS'\n  }];\n};\n\nconst MANAGER_LAMBDA = {\n  setDelegate,\n  removeDelegate,\n  transferImplicit,\n  transferToContract\n};\nconst code = [{\n  prim: 'parameter',\n  args: [{\n    prim: 'lambda',\n    args: [{\n      prim: 'unit'\n    }, {\n      prim: 'pair',\n      args: [{\n        prim: 'list',\n        args: [{\n          prim: 'operation'\n        }]\n      }, {\n        prim: 'unit'\n      }]\n    }]\n  }]\n}, {\n  prim: 'storage',\n  args: [{\n    prim: 'unit'\n  }]\n}, {\n  prim: 'code',\n  args: [[{\n    prim: 'CAR'\n  }, {\n    prim: 'UNIT'\n  }, {\n    prim: 'EXEC'\n  }]]\n}];\nconst storage = 'Unit';\nconst VIEW_LAMBDA = {\n  code,\n  storage\n};\n\nfunction compose(functioncomposer1, functioncomposer2) {\n  return (contractAbstraction, context) => functioncomposer2(functioncomposer1(contractAbstraction, context), context);\n}\n/**\r\n * @description Utility class to send smart contract operation\r\n * The format for the arguments is the flattened representation\r\n */\n\n\nclass ContractMethod {\n  constructor(provider, address, parameterSchema, name, args, isMultipleEntrypoint = true, isAnonymous = false) {\n    this.provider = provider;\n    this.address = address;\n    this.parameterSchema = parameterSchema;\n    this.name = name;\n    this.args = args;\n    this.isMultipleEntrypoint = isMultipleEntrypoint;\n    this.isAnonymous = isAnonymous;\n  }\n\n  validateArgs(args, schema, name) {\n    const sigs = schema.ExtractSignatures();\n\n    if (!sigs.find(x => x.length === args.length)) {\n      throw new InvalidParameterError(name, sigs, args);\n    }\n  }\n  /**\r\n   * @description Get the schema of the smart contract method\r\n   */\n\n\n  get schema() {\n    return this.isAnonymous ? this.parameterSchema.ExtractSchema()[this.name] : this.parameterSchema.ExtractSchema();\n  }\n  /**\r\n   * @description Get the signature of the smart contract method\r\n   */\n\n\n  getSignature() {\n    if (this.isAnonymous) {\n      const sig = this.parameterSchema.ExtractSignatures().find(x => x[0] === this.name);\n\n      if (sig) {\n        sig.shift();\n        return sig;\n      }\n    } else {\n      const sig = this.parameterSchema.ExtractSignatures();\n      return sig.length == 1 ? sig[0] : sig;\n    }\n  }\n  /**\r\n   *\r\n   * @description Send the smart contract operation\r\n   *\r\n   * @param Options generic operation parameter\r\n   */\n\n\n  send(params = {}) {\n    if (this.provider instanceof Wallet) {\n      return this.provider.transfer(this.toTransferParams(params)).send();\n    } else {\n      return this.provider.transfer(this.toTransferParams(params));\n    }\n  }\n  /**\r\n   *\r\n   * @description Create transfer params to be used with TezosToolkit.contract.transfer methods\r\n   *\r\n   * @param Options generic transfer operation parameters\r\n   */\n\n\n  toTransferParams({\n    fee,\n    gasLimit,\n    storageLimit,\n    source,\n    amount = 0,\n    mutez = false\n  } = {}) {\n    const fullTransferParams = {\n      to: this.address,\n      amount,\n      fee,\n      mutez,\n      source,\n      gasLimit,\n      storageLimit,\n      parameter: {\n        entrypoint: this.isMultipleEntrypoint ? this.name : DEFAULT_SMART_CONTRACT_METHOD_NAME,\n        value: this.isAnonymous ? this.parameterSchema.Encode(this.name, ...this.args) : this.parameterSchema.Encode(...this.args)\n      }\n    };\n    return fullTransferParams;\n  }\n\n}\n\nclass WalletOperationBatch {\n  constructor(walletProvider, context) {\n    this.walletProvider = walletProvider;\n    this.context = context;\n    this.operations = [];\n  }\n  /**\r\n   *\r\n   * @description Add a transaction operation to the batch\r\n   *\r\n   * @param params Transfer operation parameter\r\n   */\n\n\n  withTransfer(params) {\n    if (validateAddress(params.to) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(params.to);\n    }\n\n    this.operations.push(Object.assign({\n      kind: OpKind.TRANSACTION\n    }, params));\n    return this;\n  }\n  /**\r\n   *\r\n   * @description Add a transaction operation to the batch\r\n   *\r\n   * @param params Transfer operation parameter\r\n   */\n\n\n  withContractCall(params) {\n    return this.withTransfer(params.toTransferParams());\n  }\n  /**\r\n   *\r\n   * @description Add a delegation operation to the batch\r\n   *\r\n   * @param params Delegation operation parameter\r\n   */\n\n\n  withDelegation(params) {\n    if (params.delegate && validateAddress(params.delegate) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(params.delegate);\n    }\n\n    this.operations.push(Object.assign({\n      kind: OpKind.DELEGATION\n    }, params));\n    return this;\n  }\n  /**\r\n   *\r\n   * @description Add an origination operation to the batch\r\n   *\r\n   * @param params Origination operation parameter\r\n   */\n\n\n  withOrigination(params) {\n    this.operations.push(Object.assign({\n      kind: OpKind.ORIGINATION\n    }, params));\n    return this;\n  }\n\n  mapOperation(param) {\n    return __awaiter(this, void 0, void 0, function* () {\n      switch (param.kind) {\n        case OpKind.TRANSACTION:\n          return this.walletProvider.mapTransferParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () {\n            return param;\n          }));\n\n        case OpKind.ORIGINATION:\n          return this.walletProvider.mapOriginateParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () {\n            return this.context.parser.prepareCodeOrigination(Object.assign({}, param));\n          }));\n\n        case OpKind.DELEGATION:\n          return this.walletProvider.mapDelegateParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () {\n            return param;\n          }));\n\n        default:\n          throw new InvalidOperationKindError(param.kind);\n      }\n    });\n  }\n  /**\r\n   *\r\n   * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\r\n   *\r\n   * @param params Operations parameter\r\n   */\n\n\n  with(params) {\n    for (const param of params) {\n      switch (param.kind) {\n        case OpKind.TRANSACTION:\n          this.withTransfer(param);\n          break;\n\n        case OpKind.ORIGINATION:\n          this.withOrigination(param);\n          break;\n\n        case OpKind.DELEGATION:\n          this.withDelegation(param);\n          break;\n\n        default:\n          throw new InvalidOperationKindError(param.kind);\n      }\n    }\n\n    return this;\n  }\n  /**\r\n   *\r\n   * @description Submit batch operation to wallet\r\n   *\r\n   */\n\n\n  send() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const ops = [];\n\n      for (const op of this.operations) {\n        ops.push(yield this.mapOperation(op));\n      }\n\n      const opHash = yield this.walletProvider.sendOperations(ops);\n      return this.context.operationFactory.createBatchOperation(opHash);\n    });\n  }\n\n}\n\nclass Wallet {\n  constructor(context) {\n    this.context = context;\n\n    this.walletCommand = send => {\n      return {\n        send\n      };\n    };\n  }\n\n  get walletProvider() {\n    return this.context.walletProvider;\n  }\n  /**\r\n   * @description Retrieve the PKH of the account that is currently in use by the wallet\r\n   *\r\n   * @param option Option to use while fetching the PKH.\r\n   * If forceRefetch is specified the wallet provider implementation will refetch the PKH from the wallet\r\n   */\n\n\n  pkh({\n    forceRefetch\n  } = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this._pkh || forceRefetch) {\n        this._pkh = yield this.walletProvider.getPKH();\n      }\n\n      return this._pkh;\n    });\n  }\n  /**\r\n   *\r\n   * @description Originate a new contract according to the script in parameters.\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param originateParams Originate operation parameter\r\n   */\n\n\n  originate(params) {\n    return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {\n      const mappedParams = yield this.walletProvider.mapOriginateParamsToWalletParams(() => this.context.parser.prepareCodeOrigination(Object.assign({}, params)));\n      const opHash = yield this.walletProvider.sendOperations([mappedParams]);\n      return this.context.operationFactory.createOriginationOperation(opHash);\n    }));\n  }\n  /**\r\n   *\r\n   * @description Set the delegate for a contract.\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param delegateParams operation parameter\r\n   */\n\n\n  setDelegate(params) {\n    if (params.delegate && validateAddress(params.delegate) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(params.delegate);\n    }\n\n    return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {\n      const mappedParams = yield this.walletProvider.mapDelegateParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () {\n        return params;\n      }));\n      const opHash = yield this.walletProvider.sendOperations([mappedParams]);\n      return this.context.operationFactory.createDelegationOperation(opHash);\n    }));\n  }\n  /**\r\n   *\r\n   * @description Register the current address as delegate.\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   */\n\n\n  registerDelegate() {\n    return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {\n      const mappedParams = yield this.walletProvider.mapDelegateParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () {\n        const delegate = yield this.pkh();\n        return {\n          delegate\n        };\n      }));\n      const opHash = yield this.walletProvider.sendOperations([mappedParams]);\n      return this.context.operationFactory.createDelegationOperation(opHash);\n    }));\n  }\n  /**\r\n   *\r\n   * @description Transfer tezos tokens from current address to a specific address or call a smart contract.\r\n   *\r\n   * @returns A wallet command from which we can send the operation to the wallet\r\n   *\r\n   * @param params operation parameter\r\n   */\n\n\n  transfer(params) {\n    if (validateAddress(params.to) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(params.to);\n    }\n\n    return this.walletCommand(() => __awaiter(this, void 0, void 0, function* () {\n      const mappedParams = yield this.walletProvider.mapTransferParamsToWalletParams(() => __awaiter(this, void 0, void 0, function* () {\n        return params;\n      }));\n      const opHash = yield this.walletProvider.sendOperations([mappedParams]);\n      return this.context.operationFactory.createTransactionOperation(opHash);\n    }));\n  }\n  /**\r\n   *\r\n   * @description Create a batch of operation\r\n   *\r\n   * @returns A batch object from which we can add more operation or send a command to the wallet to execute the batch\r\n   *\r\n   * @param params List of operation to initialize the batch with\r\n   */\n\n\n  batch(params) {\n    const batch = new WalletOperationBatch(this.walletProvider, this.context);\n\n    if (Array.isArray(params)) {\n      batch.with(params);\n    }\n\n    return batch;\n  }\n  /**\r\n   *\r\n   * @description Create an smart contract abstraction for the address specified. Calling entrypoints with the returned\r\n   * smart contract abstraction will leverage the wallet provider to make smart contract calls\r\n   *\r\n   * @param address Smart contract address\r\n   */\n\n\n  at(address, contractAbstractionComposer = x => x) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (validateContractAddress(address) !== ValidationResult.VALID) {\n        throw new InvalidContractAddressError(address);\n      }\n\n      const rpc = this.context.withExtensions().rpc;\n      const readProvider = this.context.withExtensions().readProvider;\n      const script = yield readProvider.getScript(address, 'head');\n      const entrypoints = yield readProvider.getEntrypoints(address);\n      const abs = new ContractAbstraction(address, script, this, this.context.contract, entrypoints, rpc, readProvider);\n      return contractAbstractionComposer(abs, this.context);\n    });\n  }\n\n}\n\nclass LegacyWalletProvider {\n  constructor(context) {\n    this.context = context;\n  }\n\n  getPKH() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.context.signer.publicKeyHash();\n    });\n  }\n\n  mapTransferParamsToWalletParams(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return attachKind(yield params(), OpKind.TRANSACTION);\n    });\n  }\n\n  mapOriginateParamsToWalletParams(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return attachKind(yield params(), OpKind.ORIGINATION);\n    });\n  }\n\n  mapDelegateParamsToWalletParams(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return attachKind(yield params(), OpKind.DELEGATION);\n    });\n  }\n\n  sendOperations(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const op = yield this.context.batch.batch(params).send();\n      return op.hash;\n    });\n  }\n\n}\n/**\r\n * @description Utility class to send smart contract operation\r\n * The format for the arguments is the object representation\r\n */\n\n\nclass ContractMethodObject {\n  constructor(provider, address, parameterSchema, name, args = 'unit', isMultipleEntrypoint = true, isAnonymous = false) {\n    this.provider = provider;\n    this.address = address;\n    this.parameterSchema = parameterSchema;\n    this.name = name;\n    this.args = args;\n    this.isMultipleEntrypoint = isMultipleEntrypoint;\n    this.isAnonymous = isAnonymous;\n  }\n  /**\r\n   * @description Get the signature of the smart contract method\r\n   */\n\n\n  getSignature() {\n    return this.isAnonymous ? this.parameterSchema.ExtractSchema()[this.name] : this.parameterSchema.ExtractSchema();\n  }\n  /**\r\n   *\r\n   * @description Send the smart contract operation\r\n   *\r\n   * @param Options generic operation parameter\r\n   */\n\n\n  send(params = {}) {\n    if (this.provider instanceof Wallet) {\n      return this.provider.transfer(this.toTransferParams(params)).send();\n    } else {\n      return this.provider.transfer(this.toTransferParams(params));\n    }\n  }\n  /**\r\n   *\r\n   * @description Create transfer params to be used with TezosToolkit.contract.transfer methods\r\n   *\r\n   * @param Options generic transfer operation parameters\r\n   */\n\n\n  toTransferParams({\n    fee,\n    gasLimit,\n    storageLimit,\n    source,\n    amount = 0,\n    mutez = false\n  } = {}) {\n    const fullTransferParams = {\n      to: this.address,\n      amount,\n      fee,\n      mutez,\n      source,\n      gasLimit,\n      storageLimit,\n      parameter: {\n        entrypoint: this.isMultipleEntrypoint ? this.name : DEFAULT_SMART_CONTRACT_METHOD_NAME,\n        value: this.isAnonymous ? this.parameterSchema.EncodeObject({\n          [this.name]: this.args\n        }) : this.parameterSchema.EncodeObject(this.args)\n      }\n    };\n    return fullTransferParams;\n  }\n\n}\n\nconst runCodeHelper = (viewArgsType, viewReturnType, contractStorageType, viewInstructions, viewArgs, contractStorageValue, balance, chain_id, source, amount = '0') => {\n  return {\n    script: [{\n      prim: 'parameter',\n      args: [{\n        prim: 'pair',\n        args: [viewArgsType, contractStorageType]\n      }]\n    }, {\n      prim: 'storage',\n      args: [{\n        prim: 'option',\n        args: [viewReturnType]\n      }]\n    }, {\n      prim: 'code',\n      args: [[{\n        prim: 'CAR'\n      }, viewInstructions, {\n        prim: 'SOME'\n      }, {\n        prim: 'NIL',\n        args: [{\n          prim: 'operation'\n        }]\n      }, {\n        prim: 'PAIR'\n      }]]\n    }],\n    storage: {\n      prim: 'None'\n    },\n    input: {\n      prim: 'Pair',\n      args: [viewArgs, contractStorageValue]\n    },\n    amount,\n    balance,\n    chain_id,\n    source\n  };\n};\n\nclass OnChainView {\n  constructor(_rpc, _readProvider, _contractAddress, _smartContractViewSchema, _contractStorageType, _args = 'Unit') {\n    this._rpc = _rpc;\n    this._readProvider = _readProvider;\n    this._contractAddress = _contractAddress;\n    this._smartContractViewSchema = _smartContractViewSchema;\n    this._contractStorageType = _contractStorageType;\n    this._args = _args;\n  }\n  /**\r\n   * @description Get the signature of the smart contract view\r\n   */\n\n\n  getSignature() {\n    return {\n      parameter: this._smartContractViewSchema.extractArgsSchema(),\n      result: this._smartContractViewSchema.extractResultSchema()\n    };\n  }\n  /**\r\n   * @description Get the result of the view simulation\r\n   * @param executionContext.source the public key hash of the account who initialized this view execution.\r\n   * @param executionContext.viewCaller the contract address which is the caller of view.\r\n   */\n\n\n  executeView(executionContext) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.verifyContextExecution(executionContext);\n      const balance = (yield this._readProvider.getBalance(this._contractAddress, 'head')).toString();\n      const chainId = yield this._readProvider.getChainId();\n      const storage = yield this._readProvider.getStorage(this._contractAddress, 'head');\n      return this.executeViewAndDecodeResult(runCodeHelper(this._smartContractViewSchema.viewArgsType, this._smartContractViewSchema.viewReturnType, this._contractStorageType, this.adaptViewCodeToContext(this._smartContractViewSchema.instructions, executionContext.viewCaller, balance), this.transformArgsToMichelson(), storage, balance, chainId, executionContext.source));\n    });\n  }\n\n  verifyContextExecution(executionContext) {\n    if (executionContext.source && validateAddress(executionContext.source) !== ValidationResult.VALID) {\n      throw new InvalidViewSimulationContext(`The source account who initialized the view execution is invalid: ${executionContext.source}.`);\n    }\n\n    if (!executionContext.viewCaller || validateAddress(executionContext.viewCaller) !== ValidationResult.VALID) {\n      throw new InvalidViewSimulationContext(`The contract which is the caller of view is invalid: ${executionContext.viewCaller}.`);\n    }\n  }\n\n  transformArgsToMichelson() {\n    try {\n      return this._smartContractViewSchema.encodeViewArgs(this._args);\n    } catch (error) {\n      throw new InvalidViewParameterError(this._smartContractViewSchema.viewName, this.getSignature(), this._args, error);\n    }\n  }\n  /**\r\n   * @description Loops through the view's instructions and replace BALANCE, SENDER, SELF_ADDRESS and AMOUNT with Michelson expressions that match the current context, if applicable.\r\n   *\r\n   * Certain specific instructions have different semantics in view:\r\n   * BALANCE represents the current amount of mutez held by the contract where view is;\r\n   * SENDER represents the contract which is the caller of view;\r\n   * SELF_ADDRESS represents the contract where view is;\r\n   * AMOUNT is always 0 mutez.\r\n   *\r\n   */\n\n\n  adaptViewCodeToContext(instructions, viewCaller, contractBalance) {\n    const instructionsToReplace = {\n      BALANCE: [{\n        prim: 'PUSH',\n        args: [{\n          prim: 'mutez'\n        }, {\n          int: contractBalance\n        }]\n      }],\n      SENDER: [{\n        prim: 'PUSH',\n        args: [{\n          prim: 'address'\n        }, {\n          string: viewCaller\n        }]\n      }],\n      SELF_ADDRESS: [{\n        prim: 'PUSH',\n        args: [{\n          prim: 'address'\n        }, {\n          string: this._contractAddress\n        }]\n      }],\n      AMOUNT: [{\n        prim: 'PUSH',\n        args: [{\n          prim: 'mutez'\n        }, {\n          int: '0'\n        }]\n      }]\n    };\n    instructions.forEach((inst, i) => {\n      if (inst.prim in instructionsToReplace) {\n        instructions[i] = Object(instructionsToReplace)[inst.prim];\n      }\n\n      if (inst.args && inst.args.length !== 0) {\n        this.adaptViewCodeToContext(inst.args, viewCaller, contractBalance);\n      } else if (Array.isArray(inst)) {\n        this.adaptViewCodeToContext(inst, viewCaller, contractBalance);\n      }\n    });\n    return instructions;\n  }\n\n  executeViewAndDecodeResult(viewScript) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let storage;\n\n      try {\n        storage = (yield this._rpc.runCode(viewScript)).storage;\n      } catch (error) {\n        const failWith = validateAndExtractFailwith(error);\n        throw failWith ? new ViewSimulationError(`The simulation of the on-chain view named ${this._smartContractViewSchema.viewName} failed with: ${JSON.stringify(failWith)}`, this._smartContractViewSchema.viewName, failWith, error) : error;\n      }\n\n      if (!storage.args) {\n        throw new ViewSimulationError(`View simulation failed with an invalid result: ${storage}`, this._smartContractViewSchema.viewName);\n      }\n\n      return this._smartContractViewSchema.decodeViewResult(storage.args[0]);\n    });\n  }\n\n}\n\nclass ContractMethodFactory {\n  constructor(provider, contractAddress) {\n    this.provider = provider;\n    this.contractAddress = contractAddress;\n  }\n\n  createContractMethodFlatParams(smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint = true, isAnonymous = false) {\n    return new ContractMethod(this.provider, this.contractAddress, smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint, isAnonymous);\n  }\n\n  createContractMethodObjectParam(smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint = true, isAnonymous = false) {\n    return new ContractMethodObject(this.provider, this.contractAddress, smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint, isAnonymous);\n  }\n\n  createContractViewObjectParam(rpc, readProvider, smartContractViewSchema, contractStorageType, viewArgs) {\n    return new OnChainView(rpc, readProvider, this.contractAddress, smartContractViewSchema, contractStorageType, viewArgs);\n  }\n\n}\n\nconst DEFAULT_SMART_CONTRACT_METHOD_NAME = 'default';\n/**\r\n * @description Utility class to retrieve data from a smart contract's storage without incurring fees via a contract's view method\r\n */\n\nclass ContractView {\n  constructor(currentContract, name, callbackParametersSchema, parameterSchema, args, rpc, readProvider) {\n    this.currentContract = currentContract;\n    this.name = name;\n    this.callbackParametersSchema = callbackParametersSchema;\n    this.parameterSchema = parameterSchema;\n    this.args = args;\n    this.rpc = rpc;\n    this.readProvider = readProvider;\n  }\n\n  read(chainId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (validateContractAddress(chainId) == ValidationResult.VALID) {\n        throw new DeprecationError(`Since version 12, the lambda view no longer depends on a lambda contract. The read method no longer accepts a contract address as a parameter.`);\n      } else if (chainId && validateChain(chainId) !== ValidationResult.VALID) {\n        throw new InvalidChainIdError(chainId);\n      }\n\n      const arg = this.parameterSchema.Encode(...this.args);\n      const result = yield this.rpc.runView({\n        contract: this.currentContract.address,\n        entrypoint: this.name,\n        input: arg,\n        chain_id: chainId ? chainId : yield this.readProvider.getChainId()\n      });\n      return this.callbackParametersSchema.Execute(result.data);\n    });\n  }\n\n}\n\nconst validateArgs = (args, schema, name) => {\n  const sigs = schema.ExtractSignatures();\n\n  if (!sigs.find(x => x.length === args.length)) {\n    throw new InvalidParameterError(name, sigs, args);\n  }\n}; // lambda view tzip4\n\n\nconst isView = entrypoint => {\n  let isView = false;\n\n  if ('prim' in entrypoint && entrypoint.prim === 'pair' && entrypoint.args) {\n    const lastElement = entrypoint.args[entrypoint.args.length - 1];\n\n    if ('prim' in lastElement && lastElement.prim === 'contract') {\n      isView = true;\n    }\n  }\n\n  return isView;\n};\n/**\r\n * @description Smart contract abstraction\r\n */\n\n\nclass ContractAbstraction {\n  constructor(address, script, provider, storageProvider, entrypoints, rpc, readProvider) {\n    this.address = address;\n    this.script = script;\n    this.storageProvider = storageProvider;\n    this.entrypoints = entrypoints;\n    this.rpc = rpc;\n    this.readProvider = readProvider;\n    /**\r\n     * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.\r\n     * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.\r\n     *\r\n     */\n\n    this.methods = {};\n    /**\r\n     * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.\r\n     * `methodsObject` serves the exact same purpose as the `methods` member. The difference is that it allows passing the parameter in an object format when calling the smart contract method (instead of the flattened representation)\r\n     * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.\r\n     *\r\n     */\n\n    this.methodsObject = {};\n    /**\r\n     * @description Contains lamda views (tzip4) that are implemented by the target Tezos Smart Contract, and offers the user to call the lambda views as if they were native TS/JS methods.\r\n     * NB: These are the view defined in the tzip4 standard, not the views introduced by the Hangzhou protocol.\r\n     */\n\n    this.views = {};\n    /**\r\n     * @description Contains on-chain views that are defined by the target Tezos Smart Contract, and offers the user to simulate the views execution as if they were native TS/JS methods.\r\n     * NB: the expected format for the parameter when calling a smart contract view is the object format (same format as for the storage) and not the flattened representation.\r\n     *\r\n     */\n\n    this.contractViews = {};\n    this.contractMethodFactory = new ContractMethodFactory(provider, address);\n    this.schema = Schema.fromRPCResponse({\n      script: this.script\n    });\n    this.parameterSchema = ParameterSchema.fromRPCResponse({\n      script: this.script\n    });\n    this.viewSchema = ViewSchema.fromRPCResponse({\n      script: this.script\n    });\n\n    if (this.viewSchema.length !== 0) {\n      this._initializeOnChainViews(this, rpc, this.readProvider, this.viewSchema);\n    }\n\n    this._initializeMethods(this, this.entrypoints.entrypoints, this.rpc, this.readProvider);\n  }\n\n  _initializeMethods(currentContract, entrypoints, rpc, readProvider) {\n    const parameterSchema = this.parameterSchema;\n    const keys = Object.keys(entrypoints);\n\n    if (parameterSchema.isMultipleEntryPoint) {\n      keys.forEach(smartContractMethodName => {\n        const smartContractMethodSchema = new ParameterSchema(entrypoints[smartContractMethodName]);\n\n        this.methods[smartContractMethodName] = function (...args) {\n          return currentContract.contractMethodFactory.createContractMethodFlatParams(smartContractMethodSchema, smartContractMethodName, args);\n        };\n\n        this.methodsObject[smartContractMethodName] = function (args) {\n          return currentContract.contractMethodFactory.createContractMethodObjectParam(smartContractMethodSchema, smartContractMethodName, args);\n        };\n\n        if (isView(entrypoints[smartContractMethodName])) {\n          const view = function (...args) {\n            const entrypointParamWithoutCallback = entrypoints[smartContractMethodName].args[0];\n            const smartContractMethodSchemaWithoutCallback = new ParameterSchema(entrypointParamWithoutCallback);\n            const parametersCallback = entrypoints[smartContractMethodName].args[1].args[0];\n            const smartContractMethodCallbackSchema = new ParameterSchema(parametersCallback);\n            validateArgs(args, smartContractMethodSchemaWithoutCallback, smartContractMethodName);\n            return new ContractView(currentContract, smartContractMethodName, smartContractMethodCallbackSchema, smartContractMethodSchemaWithoutCallback, args, rpc, readProvider);\n          };\n\n          this.views[smartContractMethodName] = view;\n        }\n      }); // Deal with methods with no annotations which were not discovered by the RPC endpoint\n      // Methods with no annotations are discovered using parameter schema\n\n      const anonymousMethods = Object.keys(parameterSchema.ExtractSchema()).filter(key => Object.keys(entrypoints).indexOf(key) === -1);\n      anonymousMethods.forEach(smartContractMethodName => {\n        this.methods[smartContractMethodName] = function (...args) {\n          return currentContract.contractMethodFactory.createContractMethodFlatParams(parameterSchema, smartContractMethodName, args, false, true);\n        };\n\n        this.methodsObject[smartContractMethodName] = function (args) {\n          return currentContract.contractMethodFactory.createContractMethodObjectParam(parameterSchema, smartContractMethodName, args, false, true);\n        };\n      });\n    } else {\n      const smartContractMethodSchema = this.parameterSchema;\n\n      this.methods[DEFAULT_SMART_CONTRACT_METHOD_NAME] = function (...args) {\n        return currentContract.contractMethodFactory.createContractMethodFlatParams(smartContractMethodSchema, DEFAULT_SMART_CONTRACT_METHOD_NAME, args, false);\n      };\n\n      this.methodsObject[DEFAULT_SMART_CONTRACT_METHOD_NAME] = function (args) {\n        return currentContract.contractMethodFactory.createContractMethodObjectParam(smartContractMethodSchema, DEFAULT_SMART_CONTRACT_METHOD_NAME, args, false);\n      };\n    }\n  }\n\n  _initializeOnChainViews(currentContract, rpc, readProvider, allContractViews) {\n    const storageType = this.schema.val;\n    allContractViews.forEach(viewSchema => {\n      this.contractViews[viewSchema.viewName] = function (args) {\n        return currentContract.contractMethodFactory.createContractViewObjectParam(rpc, readProvider, viewSchema, storageType, args);\n      };\n    });\n  }\n  /**\r\n   * @description Return a friendly representation of the smart contract storage\r\n   */\n\n\n  storage() {\n    return this.storageProvider.getStorage(this.address, this.schema);\n  }\n  /**\r\n   *\r\n   * @description Return a friendly representation of the smart contract big map value\r\n   *\r\n   * @param key BigMap key to fetch\r\n   *\r\n   * @deprecated getBigMapKey has been deprecated in favor of getBigMapKeyByID\r\n   *\r\n   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get\r\n   */\n\n\n  bigMap(key) {\n    return this.storageProvider.getBigMapKey(this.address, key, this.schema);\n  }\n\n}\n\nclass BigMapAbstraction {\n  constructor(id, schema, provider) {\n    this.id = id;\n    this.schema = schema;\n    this.provider = provider;\n  }\n  /**\r\n   *\r\n   * @description Fetch one value in a big map\r\n   *\r\n   * @param keysToEncode Key to query (will be encoded properly according to the schema)\r\n   * @param block optional block level to fetch the values from (head will be use by default)\r\n   * @returns Return a well formatted json object of a big map value or undefined if the key is not found in the big map\r\n   *\r\n   */\n\n\n  get(keyToEncode, block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const id = yield this.provider.getBigMapKeyByID(this.id.toString(), keyToEncode, this.schema, block);\n        return id;\n      } catch (e) {\n        if (e instanceof HttpResponseError && e.status === STATUS_CODE.NOT_FOUND) {\n          return undefined;\n        } else {\n          throw e;\n        }\n      }\n    });\n  }\n  /**\r\n   *\r\n   * @description Fetch multiple values in a big map\r\n   * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.\r\n   * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.\r\n   * If one of the keys does not exist in the big map, its value will be set to undefined.\r\n   *\r\n   * @param keysToEncode Array of keys to query (will be encoded properly according to the schema)\r\n   * @param block optional block level to fetch the values from\r\n   * @param batchSize optional batch size representing the number of requests to execute in parallel\r\n   * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format\r\n   *\r\n   */\n\n\n  getMultipleValues(keysToEncode, block, batchSize = 5) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.provider.getBigMapKeysByID(this.id.toString(), keysToEncode, this.schema, block, batchSize);\n    });\n  }\n\n  toJSON() {\n    return this.id.toString();\n  }\n\n  toString() {\n    return this.id.toString();\n  }\n\n}\n\nclass SaplingStateAbstraction {\n  constructor(id, provider) {\n    this.id = id;\n    this.provider = provider;\n  }\n  /**\r\n   *\r\n   * @description Fetch the sapling state\r\n   *\r\n   * @param block optional block level to fetch the values from (head will be use by default)\r\n   * @returns Return a json object of the sapling_state\r\n   *\r\n   */\n\n\n  getSaplingDiff(block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.provider.getSaplingDiffByID(this.id.toString(), block);\n    });\n  }\n\n  getId() {\n    return this.id.toString();\n  }\n\n} // Override the default michelson encoder semantic to provide richer abstraction over storage properties\n\n\nconst smartContractAbstractionSemantic = provider => ({\n  // Provide a specific abstraction for BigMaps\n  big_map: (val, code) => {\n    if (!val || !('int' in val) || val.int === undefined) {\n      // Return an empty object in case of missing big map ID\n      return {};\n    } else {\n      const schema = new Schema(code);\n      return new BigMapAbstraction(new BigNumber(val.int), schema, provider);\n    }\n  },\n  sapling_state: val => {\n    if (!val || !('int' in val) || val.int === undefined) {\n      // Return an empty object in case of missing sapling state ID\n      return {};\n    } else {\n      return new SaplingStateAbstraction(new BigNumber(val.int), provider);\n    }\n  }\n  /*\r\n  // TODO: embed useful other abstractions\r\n  'contract':  () => {},\r\n  'address':  () => {}\r\n  */\n\n});\n\nclass RpcContractProvider extends OperationEmitter {\n  constructor(context, estimator) {\n    super(context);\n    this.estimator = estimator;\n    this.contractProviderTypeSymbol = Symbol.for('taquito--provider-type-symbol');\n  }\n  /**\r\n   *\r\n   * @description Return a well formatted json object of the contract storage\r\n   *\r\n   * @param contract contract address you want to get the storage from\r\n   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\r\n   *\r\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\r\n   */\n\n\n  getStorage(contract, schema) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (validateContractAddress(contract) !== ValidationResult.VALID) {\n        throw new InvalidContractAddressError(contract);\n      }\n\n      const script = yield this.context.readProvider.getScript(contract, 'head');\n\n      if (!schema) {\n        schema = script;\n      }\n\n      let contractSchema;\n\n      if (Schema.isSchema(schema)) {\n        contractSchema = schema;\n      } else {\n        contractSchema = Schema.fromRPCResponse({\n          script: schema\n        });\n      }\n\n      return contractSchema.Execute(script.storage, smartContractAbstractionSemantic(this)); // Cast into T because only the caller can know the true type of the storage\n    });\n  }\n  /**\r\n   *\r\n   * @description Return a well formatted json object of the contract big map storage\r\n   *\r\n   * @param contract contract address you want to get the storage from\r\n   * @param key contract big map key to fetch value from\r\n   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\r\n   *\r\n   * @deprecated Deprecated in favor of getBigMapKeyByID\r\n   *\r\n   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get\r\n   */\n\n\n  getBigMapKey(contract, key, schema) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (validateContractAddress(contract) !== ValidationResult.VALID) {\n        throw new InvalidContractAddressError(contract);\n      }\n\n      if (!schema) {\n        schema = (yield this.rpc.getContract(contract)).script;\n      }\n\n      let contractSchema;\n\n      if (Schema.isSchema(schema)) {\n        contractSchema = schema;\n      } else {\n        contractSchema = Schema.fromRPCResponse({\n          script: schema\n        });\n      }\n\n      const encodedKey = contractSchema.EncodeBigMapKey(key);\n      const val = yield this.rpc.getBigMapKey(contract, encodedKey);\n      return contractSchema.ExecuteOnBigMapValue(val); // Cast into T because only the caller can know the true type of the storage\n    });\n  }\n  /**\r\n   *\r\n   * @description Return a well formatted json object of a big map value\r\n   *\r\n   * @param id Big Map ID\r\n   * @param keyToEncode key to query (will be encoded properly according to the schema)\r\n   * @param schema Big Map schema (can be determined using your contract type)\r\n   * @param block optional block level to fetch the values from\r\n   *\r\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr\r\n   */\n\n\n  getBigMapKeyByID(id, keyToEncode, schema, block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        key,\n        type\n      } = schema.EncodeBigMapKey(keyToEncode);\n      const {\n        packed\n      } = yield this.context.packer.packData({\n        data: key,\n        type\n      });\n      const encodedExpr = encodeExpr(packed);\n      const bigMapValue = block ? yield this.context.readProvider.getBigMapValue({\n        id: id.toString(),\n        expr: encodedExpr\n      }, block) : yield this.context.readProvider.getBigMapValue({\n        id: id.toString(),\n        expr: encodedExpr\n      }, 'head');\n      return schema.ExecuteOnBigMapValue(bigMapValue, smartContractAbstractionSemantic(this));\n    });\n  }\n  /**\r\n   *\r\n   * @description Fetch multiple values in a big map\r\n   * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.\r\n   * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.\r\n   * If one of the keys does not exist in the big map, its value will be set to undefined.\r\n   *\r\n   * @param id Big Map ID\r\n   * @param keys Array of keys to query (will be encoded properly according to the schema)\r\n   * @param schema Big Map schema (can be determined using your contract type)\r\n   * @param block optional block level to fetch the values from\r\n   * @param batchSize optional batch size representing the number of requests to execute in parallel\r\n   * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format\r\n   *\r\n   */\n\n\n  getBigMapKeysByID(id, keys, schema, block, batchSize = 5) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const level = yield this.getBlockForRequest(keys, block);\n      const bigMapValues = new MichelsonMap(); // Execute batch of promises in series\n\n      let position = 0;\n      let results = [];\n\n      while (position < keys.length) {\n        const keysBatch = keys.slice(position, position + batchSize);\n        const batch = keysBatch.map(keyToEncode => this.getBigMapValueOrUndefined(keyToEncode, id, schema, level));\n        results = [...results, ...(yield Promise.all(batch))];\n        position += batchSize;\n      }\n\n      for (let i = 0; i < results.length; i++) {\n        bigMapValues.set(keys[i], results[i]);\n      }\n\n      return bigMapValues;\n    });\n  }\n\n  getBlockForRequest(keys, block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return keys.length === 1 || typeof block !== 'undefined' ? block : yield this.context.readProvider.getBlockLevel('head');\n    });\n  }\n\n  getBigMapValueOrUndefined(keyToEncode, id, schema, level) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield this.getBigMapKeyByID(id, keyToEncode, schema, level);\n      } catch (ex) {\n        if (ex instanceof HttpResponseError && ex.status === STATUS_CODE.NOT_FOUND) {\n          return;\n        } else {\n          throw ex;\n        }\n      }\n    });\n  }\n  /**\r\n   *\r\n   * @description Return a well formatted json object of a sapling state\r\n   *\r\n   * @param id Sapling state ID\r\n   * @param block optional block level to fetch the value from\r\n   *\r\n   */\n\n\n  getSaplingDiffByID(id, block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const saplingState = block ? yield this.context.readProvider.getSaplingDiffById({\n        id: id.toString()\n      }, block) : yield this.context.readProvider.getSaplingDiffById({\n        id: id.toString()\n      }, 'head');\n      return saplingState;\n    });\n  }\n\n  addRevealOperationIfNeeded(operation, publicKeyHash) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (isOpRequireReveal(operation)) {\n        const ops = [operation];\n        const publicKey = yield this.signer.publicKey();\n        const estimateReveal = yield this.estimator.reveal();\n\n        if (estimateReveal) {\n          const reveal = {\n            kind: OpKind.REVEAL\n          };\n          const estimatedReveal = yield this.estimate(reveal, () => __awaiter(this, void 0, void 0, function* () {\n            return estimateReveal;\n          }));\n          ops.unshift(yield createRevealOperation(Object.assign({}, estimatedReveal), publicKeyHash, publicKey));\n          return ops;\n        }\n      }\n\n      return operation;\n    });\n  }\n  /**\r\n   *\r\n   * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @warn You cannot specify storage and init at the same time (use init to pass the raw michelson representation of storage)\r\n   *\r\n   * @param OriginationOperation Originate operation parameter\r\n   */\n\n\n  originate(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const estimate = yield this.estimate(params, this.estimator.originate.bind(this.estimator));\n      const publicKeyHash = yield this.signer.publicKeyHash();\n      const operation = yield createOriginationOperation(yield this.context.parser.prepareCodeOrigination(Object.assign(Object.assign({}, params), estimate)));\n      const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);\n      const preparedOrigination = yield this.prepareOperation({\n        operation: ops,\n        source: publicKeyHash\n      });\n      const forgedOrigination = yield this.forge(preparedOrigination);\n      const {\n        hash,\n        context,\n        forgedBytes,\n        opResponse\n      } = yield this.signAndInject(forgedOrigination);\n      return new OriginationOperation(hash, operation, forgedBytes, opResponse, context, this);\n    });\n  }\n  /**\r\n   *\r\n   * @description Set the delegate for a contract. Will sign and inject an operation using the current context\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param SetDelegate operation parameter\r\n   */\n\n\n  setDelegate(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (params.source && validateAddress(params.source) !== ValidationResult.VALID) {\n        throw new InvalidAddressError(params.source);\n      }\n\n      if (params.delegate && validateAddress(params.delegate) !== ValidationResult.VALID) {\n        throw new InvalidAddressError(params.delegate);\n      } // Since babylon delegation source cannot smart contract\n\n\n      if (/kt1/i.test(params.source)) {\n        throw new InvalidDelegationSource(params.source);\n      }\n\n      const estimate = yield this.estimate(params, this.estimator.setDelegate.bind(this.estimator));\n      const publicKeyHash = yield this.signer.publicKeyHash();\n      const operation = yield createSetDelegateOperation(Object.assign(Object.assign({}, params), estimate));\n      const sourceOrDefault = params.source || publicKeyHash;\n      const ops = yield this.addRevealOperationIfNeeded(operation, publicKeyHash);\n      const prepared = yield this.prepareOperation({\n        operation: ops,\n        source: sourceOrDefault\n      });\n      const opBytes = yield this.forge(prepared);\n      const {\n        hash,\n        context,\n        forgedBytes,\n        opResponse\n      } = yield this.signAndInject(opBytes);\n      return new DelegateOperation(hash, operation, sourceOrDefault, forgedBytes, opResponse, context);\n    });\n  }\n  /**\r\n   *\r\n   * @description Register the current address as delegate. Will sign and inject an operation using the current context\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param RegisterDelegate operation parameter\r\n   */\n\n\n  registerDelegate(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const estimate = yield this.estimate(params, this.estimator.registerDelegate.bind(this.estimator));\n      const source = yield this.signer.publicKeyHash();\n      const operation = yield createRegisterDelegateOperation(Object.assign(Object.assign({}, params), estimate), source);\n      const ops = yield this.addRevealOperationIfNeeded(operation, source);\n      const prepared = yield this.prepareOperation({\n        operation: ops\n      });\n      const opBytes = yield this.forge(prepared);\n      const {\n        hash,\n        context,\n        forgedBytes,\n        opResponse\n      } = yield this.signAndInject(opBytes);\n      return new DelegateOperation(hash, operation, source, forgedBytes, opResponse, context);\n    });\n  }\n  /**\r\n   *\r\n   * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param Transfer operation parameter\r\n   */\n\n\n  transfer(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (validateAddress(params.to) !== ValidationResult.VALID) {\n        throw new InvalidAddressError(params.to);\n      }\n\n      if (params.source && validateAddress(params.source) !== ValidationResult.VALID) {\n        throw new InvalidAddressError(params.source);\n      }\n\n      const publickKeyHash = yield this.signer.publicKeyHash();\n      const estimate = yield this.estimate(params, this.estimator.transfer.bind(this.estimator));\n      const operation = yield createTransferOperation(Object.assign(Object.assign({}, params), estimate));\n      const source = params.source || publickKeyHash;\n      const ops = yield this.addRevealOperationIfNeeded(operation, publickKeyHash);\n      const prepared = yield this.prepareOperation({\n        operation: ops,\n        source: params.source\n      });\n      const opBytes = yield this.forge(prepared);\n      const {\n        hash,\n        context,\n        forgedBytes,\n        opResponse\n      } = yield this.signAndInject(opBytes);\n      return new TransactionOperation(hash, operation, source, forgedBytes, opResponse, context);\n    });\n  }\n  /**\r\n   *\r\n   * @description Reveal the current address. Will throw an error if the address is already revealed.\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param RevealParams operation parameter\r\n   */\n\n\n  reveal(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const publicKeyHash = yield this.signer.publicKeyHash();\n      const estimateReveal = yield this.estimator.reveal(params);\n\n      if (estimateReveal) {\n        const estimated = yield this.estimate(params, () => __awaiter(this, void 0, void 0, function* () {\n          return estimateReveal;\n        }));\n        const operation = yield createRevealOperation(Object.assign({}, estimated), publicKeyHash, yield this.signer.publicKey());\n        const prepared = yield this.prepareOperation({\n          operation,\n          source: publicKeyHash\n        });\n        const opBytes = yield this.forge(prepared);\n        const {\n          hash,\n          context,\n          forgedBytes,\n          opResponse\n        } = yield this.signAndInject(opBytes);\n        return new RevealOperation(hash, operation, publicKeyHash, forgedBytes, opResponse, context);\n      } else {\n        throw new RevealOperationError(`The publicKeyHash '${publicKeyHash}' has already been revealed.`);\n      }\n    });\n  }\n  /**\r\n   *\r\n   * @description Register a Micheline expression in a global table of constants. Will sign and inject an operation using the current context\r\n   *\r\n   * @returns An operation handle with the result from the rpc node\r\n   *\r\n   * @param params registerGlobalConstant operation parameter\r\n   */\n\n\n  registerGlobalConstant(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const publickKeyHash = yield this.signer.publicKeyHash();\n      const estimate = yield this.estimate(params, this.estimator.registerGlobalConstant.bind(this.estimator));\n      const operation = yield createRegisterGlobalConstantOperation(Object.assign(Object.assign({}, params), estimate));\n      const ops = yield this.addRevealOperationIfNeeded(operation, publickKeyHash);\n      const prepared = yield this.prepareOperation({\n        operation: ops,\n        source: publickKeyHash\n      });\n      const opBytes = yield this.forge(prepared);\n      const {\n        hash,\n        context,\n        forgedBytes,\n        opResponse\n      } = yield this.signAndInject(opBytes);\n      return new RegisterGlobalConstantOperation(hash, operation, publickKeyHash, forgedBytes, opResponse, context);\n    });\n  }\n\n  at(address, contractAbstractionComposer = x => x) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (validateContractAddress(address) !== ValidationResult.VALID) {\n        throw new InvalidContractAddressError(address);\n      }\n\n      const rpc = this.context.withExtensions().rpc;\n      const readProvider = this.context.withExtensions().readProvider;\n      const script = yield readProvider.getScript(address, 'head');\n      const entrypoints = yield readProvider.getEntrypoints(address);\n      const abs = new ContractAbstraction(address, script, this, this, entrypoints, rpc, readProvider);\n      return contractAbstractionComposer(abs, this.context);\n    });\n  }\n  /**\r\n   *\r\n   * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\r\n   *\r\n   * @returns A batch object from which we can add more operation or send a command to execute the batch\r\n   *\r\n   * @param params List of operation to batch together\r\n   */\n\n\n  batch(params) {\n    const batch = new OperationBatch(this.context, this.estimator);\n\n    if (Array.isArray(params)) {\n      batch.with(params);\n    }\n\n    return batch;\n  }\n\n}\n\nclass MichelCodecParser {\n  constructor(context) {\n    this.context = context;\n  }\n\n  getNextProto() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.context.proto) {\n        const nextProto = yield this.context.readProvider.getNextProtocol('head');\n        this.context.proto = nextProto;\n      }\n\n      return this.context.proto;\n    });\n  }\n\n  parseScript(src) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const parser = new Parser({\n        protocol: yield this.getNextProto()\n      });\n      return parser.parseScript(src);\n    });\n  }\n\n  parseMichelineExpression(src) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const parser = new Parser({\n        protocol: yield this.getNextProto()\n      });\n      return parser.parseMichelineExpression(src);\n    });\n  }\n\n  parseJSON(src) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const parser = new Parser({\n        protocol: yield this.getNextProto()\n      });\n      return parser.parseJSON(src);\n    });\n  }\n\n  prepareCodeOrigination(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const parsedParams = params;\n      parsedParams.code = yield this.formatCodeParam(params.code);\n\n      if (params.init) {\n        parsedParams.init = yield this.formatInitParam(params.init);\n      } else if (params.storage) {\n        const storageType = parsedParams.code.find(p => 'prim' in p && p.prim === 'storage');\n\n        if (!(storageType === null || storageType === void 0 ? void 0 : storageType.args)) {\n          throw new InvalidCodeParameter('The storage section is missing from the script', params.code);\n        }\n\n        const schema = new Schema(storageType.args[0]);\n        const globalconstantsHashAndValue = yield this.findGlobalConstantsHashAndValue(schema);\n\n        if (Object.keys(globalconstantsHashAndValue).length !== 0) {\n          // If there are global constants in the storage part of the contract code,\n          // they need to be locally expanded in order to encode the storage arguments\n          const p = new Parser({\n            expandGlobalConstant: globalconstantsHashAndValue\n          });\n          const storageTypeNoGlobalConst = p.parseJSON(storageType.args[0]);\n          const schemaNoGlobalConst = new Schema(storageTypeNoGlobalConst);\n          parsedParams.init = schemaNoGlobalConst.Encode(params.storage);\n        } else {\n          parsedParams.init = schema.Encode(params.storage);\n        }\n\n        delete parsedParams.storage;\n      }\n\n      return parsedParams;\n    });\n  }\n\n  formatCodeParam(code) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let parsedCode;\n\n      if (typeof code === 'string') {\n        const c = yield this.parseScript(code);\n\n        if (c === null) {\n          throw new InvalidCodeParameter('Invalid code parameter', code);\n        }\n\n        parsedCode = c;\n      } else {\n        const c = yield this.parseJSON(code);\n        const order = ['parameter', 'storage', 'code']; // Ensure correct ordering for RPC\n\n        parsedCode = c.sort((a, b) => order.indexOf(a.prim) - order.indexOf(b.prim));\n      }\n\n      return parsedCode;\n    });\n  }\n\n  formatInitParam(init) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let parsedInit;\n\n      if (typeof init === 'string') {\n        const c = yield this.parseMichelineExpression(init);\n\n        if (c === null) {\n          throw new InvalidInitParameter('Invalid init parameter', init);\n        }\n\n        parsedInit = c;\n      } else {\n        parsedInit = yield this.parseJSON(init);\n      }\n\n      return parsedInit;\n    });\n  }\n\n  findGlobalConstantsHashAndValue(schema) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const globalConstantTokens = schema.findToken('constant');\n      const globalConstantsHashAndValue = {};\n\n      if (globalConstantTokens.length !== 0) {\n        for (const token of globalConstantTokens) {\n          const tokenArgs = token.tokenVal.args;\n\n          if (tokenArgs) {\n            const hash = tokenArgs[0]['string'];\n            const michelineValue = yield this.context.globalConstantsProvider.getGlobalConstantByHash(hash);\n            Object.assign(globalConstantsHashAndValue, {\n              [hash]: michelineValue\n            });\n          }\n        }\n      }\n\n      return globalConstantsHashAndValue;\n    });\n  }\n\n}\n\nclass RpcPacker {\n  constructor(context) {\n    this.context = context;\n  }\n\n  packData(data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.context.rpc.packData(data);\n    });\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates that a global constant does not exist\r\n */\n\n\nclass GlobalConstantNotFound extends Error {\n  constructor(hash) {\n    super(`Please load the value associated with the constant ${hash} using the loadGlobalConstant method of the DefaultGlobalConstantsProvider.`);\n    this.hash = hash;\n    this.name = 'GlobalConstantNotFound';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates the global constant provider not being configured under TezosToolkit\r\n */\n\n\nclass UnconfiguredGlobalConstantsProviderError extends Error {\n  constructor() {\n    super('No global constants provider has been configured. Please configure one by calling setGlobalConstantsProvider({globalConstantsProvider}) on your TezosToolkit instance.');\n    this.name = 'UnconfiguredGlobalConstantsProviderError';\n  }\n\n}\n\nclass NoopGlobalConstantsProvider {\n  getGlobalConstantByHash(_hash) {\n    return __awaiter(this, void 0, void 0, function* () {\n      throw new UnconfiguredGlobalConstantsProviderError();\n    });\n  }\n\n}\n/**\r\n * @description Converts calls from TzReadProvider into calls to the wrapped RpcClient in a format it can understand.\r\n */\n\n\nclass RpcReadAdapter {\n  constructor(context) {\n    this.context = context;\n  }\n  /**\r\n   * @description Access the balance of a contract.\r\n   * @param address address from which we want to retrieve the balance\r\n   * @param block from which we want to retrieve the balance\r\n   * @returns the balance in mutez\r\n   */\n\n\n  getBalance(address, block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.context.rpc.getBalance(address, {\n        block: String(block)\n      });\n    });\n  }\n  /**\r\n   * @description Access the delegate of a contract, if any.\r\n   * @param address contract address from which we want to retrieve the delegate (baker)\r\n   * @param block from which we want to retrieve the delegate\r\n   * @returns the public key hash of the delegate or null if no delegate\r\n   */\n\n\n  getDelegate(address, block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.context.rpc.getDelegate(address, {\n        block: String(block)\n      });\n    });\n  }\n  /**\r\n   * @description Access the next protocol hash\r\n   * @param block from which we want to retrieve the next protocol hash\r\n   */\n\n\n  getNextProtocol(block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const protocols = yield this.context.rpc.getProtocols({\n        block: String(block)\n      });\n      return protocols.next_protocol;\n    });\n  }\n  /**\r\n   * @description Access protocol constants used in Taquito\r\n   * @param block from which we want to retrieve the constants\r\n   */\n\n\n  getProtocolConstants(block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        time_between_blocks,\n        minimal_block_delay,\n        hard_gas_limit_per_operation,\n        hard_gas_limit_per_block,\n        hard_storage_limit_per_operation,\n        cost_per_byte\n      } = yield this.context.rpc.getConstants({\n        block: String(block)\n      });\n      return {\n        time_between_blocks,\n        minimal_block_delay,\n        hard_gas_limit_per_operation,\n        hard_gas_limit_per_block,\n        hard_storage_limit_per_operation,\n        cost_per_byte\n      };\n    });\n  }\n  /**\r\n   * @description Access the script (code and storage) of a smart contract\r\n   * @param contract contract address from which we want to retrieve the script\r\n   * @param block from which we want to retrieve the storage value\r\n   * @returns Note: The code must be in the JSON format and not contain global constant\r\n   */\n\n\n  getScript(contract, block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        script\n      } = yield this.context.rpc.getContract(contract, {\n        block: String(block)\n      });\n      return script;\n    });\n  }\n  /**\r\n   * @description Access the storage value of a contract\r\n   * @param contract contract address from which we want to retrieve the storage\r\n   * @param block from which we want to retrieve the storage value\r\n   */\n\n\n  getStorage(contract, block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.context.rpc.getStorage(contract, {\n        block: String(block)\n      });\n    });\n  }\n  /**\r\n   * @description Access the block hash\r\n   */\n\n\n  getBlockHash(block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        hash\n      } = yield this.context.rpc.getBlockHeader({\n        block: String(block)\n      });\n      return hash;\n    });\n  }\n  /**\r\n   * @description Access the block level\r\n   */\n\n\n  getBlockLevel(block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        level\n      } = yield this.context.rpc.getBlockHeader({\n        block: String(block)\n      });\n      return level;\n    });\n  }\n  /**\r\n   * @description Access the counter of an address\r\n   * @param pkh from which we want to retrieve the counter\r\n   * @param block from which we want to retrieve the counter\r\n   */\n\n\n  getCounter(pkh, block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        counter\n      } = yield this.context.rpc.getContract(pkh, {\n        block: String(block)\n      });\n      return counter || '0';\n    });\n  }\n  /**\r\n   * @description Access the timestamp of a block\r\n   * @param block from which we want to retrieve the timestamp\r\n   * @returns date ISO format zero UTC offset (\"2022-01-19T22:37:07Z\")\r\n   */\n\n\n  getBlockTimestamp(block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        timestamp\n      } = yield this.context.rpc.getBlockHeader({\n        block: String(block)\n      });\n      return timestamp;\n    });\n  }\n  /**\r\n   * @description Access the value associated with a key in a big map.\r\n   * @param bigMapQuery Big Map ID and Expression hash to query (A b58check encoded Blake2b hash of the expression)\r\n   * @param block from which we want to retrieve the big map value\r\n   */\n\n\n  getBigMapValue(bigMapQuery, block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.context.rpc.getBigMapExpr(bigMapQuery.id, bigMapQuery.expr, {\n        block: String(block)\n      });\n    });\n  }\n  /**\r\n   * @description Access the value associated with a sapling state ID.\r\n   * @param id Sapling state ID\r\n   * @param block from which we want to retrieve the sapling state\r\n   */\n\n\n  getSaplingDiffById(saplingStateQuery, block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.context.rpc.getSaplingDiffById(saplingStateQuery.id, {\n        block: String(block)\n      });\n    });\n  }\n  /**\r\n   * @description Return the list of entrypoints of the contract\r\n   * @param contract address of the contract we want to get the entrypoints of\r\n   */\n\n\n  getEntrypoints(contract) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.context.rpc.getEntrypoints(contract);\n    });\n  }\n  /**\r\n   * @description Access the chain id\r\n   */\n\n\n  getChainId() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.context.rpc.getChainId();\n    });\n  }\n  /**\r\n   * @description Indicate if an account is revealed\r\n   * @param publicKeyHash of the account\r\n   * @param block from which we want to know if the account is revealed\r\n   */\n\n\n  isAccountRevealed(publicKeyHash, block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const manager = yield this.context.rpc.getManagerKey(publicKeyHash, {\n        block: String(block)\n      });\n      const haveManager = manager && typeof manager === 'object' ? !!manager.key : !!manager;\n      return haveManager;\n    });\n  }\n  /**\r\n   * @description Return all the information about a block\r\n   * @param block from which we want to retrieve the information\r\n   */\n\n\n  getBlock(block) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.context.rpc.getBlock({\n        block: String(block)\n      });\n    });\n  }\n  /**\r\n   * @description Return a list of the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.\r\n   * @param block from which we want to retrieve the information\r\n   */\n\n\n  getLiveBlocks(block) {\n    return this.context.rpc.getLiveBlocks({\n      block: String(block)\n    });\n  }\n\n}\n\nconst opHashFilter = (op, filter) => op.hash === filter.opHash;\n\nconst sourceFilter = (x, filter) => {\n  switch (x.kind) {\n    case 'endorsement':\n      return 'metadata' in x && x.metadata.delegate === filter.source;\n\n    case 'activate_account':\n      return 'metadata' in x && x.pkh === filter.source;\n\n    default:\n      return 'source' in x && x.source === filter.source;\n  }\n};\n\nconst kindFilter = (x, filter) => 'kind' in x && x.kind === filter.kind;\n\nconst destinationFilter = (x, filter) => {\n  switch (x.kind) {\n    case 'delegation':\n      return x.delegate === filter.destination;\n\n    case 'origination':\n      if ('metadata' in x && 'operation_result' in x.metadata && 'originated_contracts' in x.metadata.operation_result && Array.isArray(x.metadata.operation_result.originated_contracts)) {\n        return x.metadata.operation_result.originated_contracts.some(contract => contract === filter.destination);\n      }\n\n      break;\n\n    case 'transaction':\n      return x.destination === filter.destination;\n\n    default:\n      return false;\n  }\n};\n\nconst evaluateOpFilter = (op, filter) => {\n  if ('opHash' in filter) {\n    return opHashFilter(op, filter);\n  } else if ('source' in filter) {\n    return sourceFilter(op, filter);\n  } else if ('kind' in filter) {\n    return kindFilter(op, filter);\n  } else if ('destination' in filter) {\n    return destinationFilter(op, filter);\n  }\n\n  return false;\n};\n\nconst evaluateExpression = (op, exp) => {\n  if (Array.isArray(exp.and)) {\n    return exp.and.every(x => evaluateFilter(op, x));\n  } else if (Array.isArray(exp.or)) {\n    return exp.or.some(x => evaluateFilter(op, x));\n  } else {\n    throw new InvalidFilterExpressionError('Filter expression must contain either and/or property');\n  }\n};\n\nconst evaluateFilter = (op, filter) => {\n  const filters = [];\n\n  if (!Array.isArray(filter)) {\n    filters.push(filter);\n  } else {\n    filters.push(...filter);\n  }\n\n  return filters.every(filterOrExp => {\n    if ('and' in filterOrExp || 'or' in filterOrExp) {\n      return evaluateExpression(op, filterOrExp);\n    } else {\n      return evaluateOpFilter(op, filterOrExp);\n    }\n  });\n};\n/* eslint-disable no-dupe-class-members */\n\n/**\r\n *  @category Error\r\n *  @description Error that indicates an unsupported event being passed or used\r\n */\n\n\nclass UnsupportedEventError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'UnsupportedEventError';\n  }\n\n}\n\nclass ObservableSubscription {\n  constructor(obs, shouldRetry = false, operatorFunction = retry()) {\n    this.shouldRetry = shouldRetry;\n    this.operatorFunction = operatorFunction;\n    this.errorListeners = [];\n    this.messageListeners = [];\n    this.closeListeners = [];\n    this.completed$ = new Subject();\n    obs.pipe(takeUntil(this.completed$), tap(data => {\n      this.call(this.messageListeners, data);\n    }, error => {\n      this.call(this.errorListeners, error);\n    }, () => {\n      this.call(this.closeListeners);\n    }), this.shouldRetry ? operatorFunction : tap(), catchError(() => NEVER)).subscribe();\n  }\n\n  call(listeners, value) {\n    for (const l of listeners) {\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        l(value);\n      } catch (ex) {\n        console.error(ex);\n      }\n    }\n  }\n\n  remove(listeners, value) {\n    const idx = listeners.indexOf(value);\n\n    if (idx !== -1) {\n      listeners.splice(idx, 1);\n    }\n  }\n\n  on(type, cb) {\n    switch (type) {\n      case 'data':\n        this.messageListeners.push(cb);\n        break;\n\n      case 'error':\n        this.errorListeners.push(cb);\n        break;\n\n      case 'close':\n        this.closeListeners.push(cb);\n        break;\n\n      default:\n        throw new UnsupportedEventError(`Trying to register on an unsupported event: ${type}`);\n    }\n  }\n\n  off(type, cb) {\n    switch (type) {\n      case 'data':\n        this.remove(this.messageListeners, cb);\n        break;\n\n      case 'error':\n        this.remove(this.errorListeners, cb);\n        break;\n\n      case 'close':\n        this.remove(this.closeListeners, cb);\n        break;\n\n      default:\n        throw new UnsupportedEventError(`Trying to unregister on an unsupported event: ${type}`);\n    }\n  }\n\n  close() {\n    this.completed$.next();\n  }\n\n}\n\nconst defaultConfigStreamer = {\n  shouldObservableSubscriptionRetry: false,\n  observableSubscriptionRetryFunction: retry()\n};\n\nconst getLastBlock = context => {\n  return from(context.rpc.getBlock()).pipe(first());\n};\n\nconst applyFilter = filter => concatMap(block => {\n  return new Observable(sub => {\n    for (const ops of block.operations) {\n      for (const op of ops) {\n        for (const content of op.contents) {\n          if (evaluateFilter(Object.assign({\n            hash: op.hash\n          }, content), filter)) {\n            sub.next(Object.assign({\n              hash: op.hash\n            }, content));\n          }\n        }\n      }\n    }\n\n    sub.complete();\n  });\n});\n\nclass PollingSubscribeProvider {\n  constructor(context, config = {}) {\n    this.context = context;\n    this._config$ = new BehaviorSubject(Object.assign(Object.assign({}, defaultConfigStreamer), config));\n    this.timer$ = this._config$.pipe(pluck('pollingIntervalMilliseconds'), switchMap(pollingIntervalMilliseconds => {\n      if (!pollingIntervalMilliseconds) {\n        return from(this.getConfirmationPollingInterval()).pipe(switchMap(interval => {\n          return timer(0, interval);\n        }));\n      } else {\n        return timer(0, pollingIntervalMilliseconds);\n      }\n    }));\n    this.newBlock$ = this.timer$.pipe(switchMap(() => getLastBlock(this.context)), distinctUntilKeyChanged('hash'), publish(), refCount());\n  }\n\n  get config() {\n    return this._config$.getValue();\n  }\n\n  getConfirmationPollingInterval() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.config.pollingIntervalMilliseconds) {\n        const defaultIntervalTestnetsMainnet = 5000;\n        const defaultIntervalSandbox = 1000;\n\n        try {\n          const constants = yield this.context.readProvider.getProtocolConstants('head');\n          const blockTime = constants.minimal_block_delay ? constants.minimal_block_delay.multipliedBy(1000) : constants.time_between_blocks ? constants.time_between_blocks[0].multipliedBy(1000) : new BigNumber(defaultIntervalTestnetsMainnet);\n          const confirmationPollingInterval = blockTime.dividedBy(3);\n          this.config.pollingIntervalMilliseconds = confirmationPollingInterval.toNumber() === 0 ? defaultIntervalSandbox : confirmationPollingInterval.toNumber();\n        } catch (exception) {\n          return defaultIntervalTestnetsMainnet;\n        }\n      }\n\n      return this.config.pollingIntervalMilliseconds;\n    });\n  }\n\n  subscribeBlock(_filter) {\n    return new ObservableSubscription(this.newBlock$, this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);\n  }\n\n  subscribe(_filter) {\n    return new ObservableSubscription(this.newBlock$.pipe(pluck('hash')), this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);\n  }\n\n  subscribeOperation(filter) {\n    return new ObservableSubscription(this.newBlock$.pipe(applyFilter(filter)), this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);\n  }\n\n}\n\nclass TaquitoLocalForger {\n  constructor(context) {\n    this.context = context;\n  }\n\n  getNextProto() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.context.proto) {\n        const nextProto = yield this.context.readProvider.getNextProtocol('head');\n        this.context.proto = nextProto;\n      }\n\n      return this.context.proto;\n    });\n  }\n\n  forge({\n    branch,\n    contents\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const forger = new LocalForger(yield this.getNextProto());\n      return forger.forge({\n        branch,\n        contents\n      });\n    });\n  }\n\n}\n\nconst defaultConfigConfirmation = {\n  defaultConfirmationCount: 1,\n  confirmationPollingTimeoutSecond: 180\n};\n/**\r\n * @description Encapsulate common service used throughout different part of the library\r\n */\n\nclass Context {\n  constructor(_rpc, _signer = new NoopSigner(), _proto, _config = new BehaviorSubject(Object.assign({}, defaultConfigConfirmation)), forger, injector, packer, wallet, parser, globalConstantsProvider, readProvider, stream) {\n    this._rpc = _rpc;\n    this._signer = _signer;\n    this._proto = _proto;\n    this._config = _config;\n    this.providerDecorator = [];\n    this.tz = new RpcTzProvider(this);\n    this.estimate = new RPCEstimateProvider(this);\n    this.contract = new RpcContractProvider(this, this.estimate);\n    this.batch = new RPCBatchProvider(this, this.estimate);\n    this.wallet = new Wallet(this);\n    /**\r\n     * @description Applies the decorators on a cloned instance of the context and returned this cloned instance.\r\n     * The decorators are functions that inject logic into the context.\r\n     * They are provided by the extensions set on the TezosToolkit by calling the registerProviderDecorator method.\r\n     */\n\n    this.withExtensions = () => {\n      let clonedContext = this.clone();\n      this.providerDecorator.forEach(decorator => {\n        clonedContext = decorator(clonedContext);\n      });\n      return clonedContext;\n    };\n\n    if (typeof this._rpc === 'string') {\n      this._rpcClient = new RpcClient(this._rpc);\n    } else {\n      this._rpcClient = this._rpc;\n    }\n\n    this._forger = forger ? forger : new TaquitoLocalForger(this);\n    this._injector = injector ? injector : new RpcInjector(this);\n    this.operationFactory = new OperationFactory(this);\n    this._walletProvider = wallet ? wallet : new LegacyWalletProvider(this);\n    this._parser = parser ? parser : new MichelCodecParser(this);\n    this._packer = packer ? packer : new RpcPacker(this);\n    this._globalConstantsProvider = globalConstantsProvider ? globalConstantsProvider : new NoopGlobalConstantsProvider();\n    this._readProvider = readProvider ? readProvider : new RpcReadAdapter(this);\n    this._stream = stream ? stream : new PollingSubscribeProvider(this);\n  }\n\n  get config() {\n    return this._config.getValue();\n  }\n\n  set config(value) {\n    this._config.next(Object.assign({}, value));\n  }\n\n  setPartialConfig(value) {\n    this._config.next(Object.assign(Object.assign({}, this._config.getValue()), value));\n  }\n\n  get rpc() {\n    return this._rpcClient;\n  }\n\n  set rpc(value) {\n    this._rpcClient = value;\n  }\n\n  get injector() {\n    return this._injector;\n  }\n\n  set injector(value) {\n    this._injector = value;\n  }\n\n  get forger() {\n    return this._forger;\n  }\n\n  set forger(value) {\n    this._forger = value;\n  }\n\n  get signer() {\n    return this._signer;\n  }\n\n  set signer(value) {\n    this._signer = value;\n  }\n\n  get walletProvider() {\n    return this._walletProvider;\n  }\n\n  set walletProvider(value) {\n    this._walletProvider = value;\n  }\n\n  set proto(value) {\n    this._proto = value;\n  }\n\n  get proto() {\n    return this._proto;\n  }\n\n  get parser() {\n    return this._parser;\n  }\n\n  set parser(value) {\n    this._parser = value;\n  }\n\n  get packer() {\n    return this._packer;\n  }\n\n  set packer(value) {\n    this._packer = value;\n  }\n\n  get globalConstantsProvider() {\n    return this._globalConstantsProvider;\n  }\n\n  set globalConstantsProvider(value) {\n    this._globalConstantsProvider = value;\n  }\n\n  get readProvider() {\n    return this._readProvider;\n  }\n\n  set readProvider(value) {\n    this._readProvider = value;\n  }\n\n  get stream() {\n    return this._stream;\n  }\n\n  set stream(value) {\n    this._stream = value;\n  }\n\n  isAnyProtocolActive(protocol = []) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._proto) {\n        return protocol.includes(this._proto);\n      } else {\n        const next_protocol = yield this.readProvider.getNextProtocol('head');\n        return protocol.includes(next_protocol);\n      }\n    });\n  }\n\n  isAnySignerConfigured() {\n    return !(this.signer instanceof NoopSigner);\n  }\n  /**\r\n   * @description Create a copy of the current context. Useful when you have long running operation and you do not want a context change to affect the operation\r\n   */\n\n\n  clone() {\n    return new Context(this.rpc, this.signer, this.proto, this._config, this.forger, this._injector, this.packer, this._walletProvider, this._parser, this._globalConstantsProvider, this._readProvider, this._stream);\n  }\n  /**\r\n   * @description Allows extensions set on the TezosToolkit to inject logic into the context\r\n   */\n\n\n  registerProviderDecorator(fx) {\n    this.providerDecorator.push(fx);\n  }\n\n} // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\n\n\nconst VERSION = {\n  \"commitHash\": \"cbdd0af87e400489076259d065e2d328feb8e1b4\",\n  \"version\": \"12.1.0\"\n};\n/**\r\n *  @category Error\r\n *  @description Error that indicates a value mismatch when forging\r\n */\n\nclass ForgingMismatchError extends Error {\n  constructor(results) {\n    super('Forging mismatch error');\n    this.results = results;\n    this.name = 'ForgingMismatchError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates a forger not being specified in TezosToolkit\r\n */\n\n\nclass UnspecifiedForgerError extends Error {\n  constructor() {\n    super('At least one forger must be specified');\n    this.name = 'UnspecifiedForgerError';\n  }\n\n}\n\nclass CompositeForger {\n  constructor(forgers) {\n    this.forgers = forgers;\n\n    if (forgers.length === 0) {\n      throw new UnspecifiedForgerError();\n    }\n  }\n\n  forge({\n    branch,\n    contents\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const results = yield Promise.all(this.forgers.map(forger => {\n        return forger.forge({\n          branch,\n          contents\n        });\n      }));\n\n      if (results.length === 0) {\n        throw new UnspecifiedForgerError();\n      } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n      let lastResult = results.pop(); // Assumed to be more than one since we\n\n      while (results.length) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const currentResult = results.pop();\n\n        if (currentResult !== lastResult) {\n          throw new ForgingMismatchError([lastResult, currentResult]);\n        }\n\n        lastResult = currentResult;\n      }\n\n      return lastResult;\n    });\n  }\n\n}\n\nclass RpcForger {\n  constructor(context) {\n    this.context = context;\n  }\n\n  forge({\n    branch,\n    contents\n  }) {\n    return this.context.rpc.forgeOperations({\n      branch,\n      contents\n    });\n  }\n\n}\n\nclass NoopParser {\n  prepareCodeOrigination(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return params;\n    });\n  }\n\n}\n\nclass MichelCodecPacker {\n  packData(data) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        bytes\n      } = packDataBytes(data.data, data.type);\n      return {\n        packed: bytes\n      };\n    });\n  }\n\n}\n\nclass DefaultGlobalConstantsProvider {\n  constructor() {\n    this._globalConstantsLibrary = {};\n  }\n  /**\r\n   *\r\n   * @description Allows to load global constant hashes and their corresponding Michelson JSON values\r\n   */\n\n\n  loadGlobalConstant(globalConstant) {\n    for (const hash in globalConstant) {\n      Object.assign(this._globalConstantsLibrary, {\n        [hash]: globalConstant[hash]\n      });\n    }\n  }\n  /**\r\n   *\r\n   * @description Retrieve the Michelson value of a global constant based on its hash\r\n   *\r\n   * @param hash a string representing the global constant hash\r\n   * @returns Expr, the JSON Michelson value\r\n   */\n\n\n  getGlobalConstantByHash(hash) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const value = this._globalConstantsLibrary[hash];\n\n      if (!value) {\n        throw new GlobalConstantNotFound(hash);\n      }\n\n      return value;\n    });\n  }\n\n}\n/**\r\n * @description Nave implementation of an estimate provider. Will work for basic transaction but your operation risk to fail if they are more complex (smart contract interaction)\r\n *\r\n * @deprecated Deprecated in favor of RPCEstimateProvider\r\n */\n\n\nclass NaiveEstimateProvider {\n  constructor(protocol) {\n    this.protocol = protocol;\n    this._costPerByte = 250;\n  }\n\n  registerGlobalConstant(params) {\n    throw new InvalidOperationKindError(params.kind);\n  }\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for an origination operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param OriginationOperation Originate operation parameter\r\n   */\n\n\n  originate({\n    fee = DEFAULT_FEE.ORIGINATION,\n    storageLimit = DEFAULT_STORAGE_LIMIT.ORIGINATION,\n    gasLimit = DEFAULT_GAS_LIMIT.ORIGINATION * 1000\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Estimate(gasLimit, storageLimit, 185, this._costPerByte, fee);\n    });\n  }\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for an transfer operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param TransferOperation Originate operation parameter\r\n   */\n\n\n  transfer({\n    fee = DEFAULT_FEE.TRANSFER,\n    storageLimit = DEFAULT_STORAGE_LIMIT.TRANSFER,\n    gasLimit = DEFAULT_GAS_LIMIT.TRANSFER * 1000\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Estimate(gasLimit, storageLimit, 162, this._costPerByte, fee);\n    });\n  }\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param Estimate\r\n   */\n\n\n  setDelegate({\n    fee = DEFAULT_FEE.DELEGATION,\n    gasLimit = DEFAULT_GAS_LIMIT.DELEGATION * 1000\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Estimate(gasLimit, 0, 157, this._costPerByte, fee);\n    });\n  }\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param Estimate\r\n   */\n\n\n  registerDelegate({\n    fee = DEFAULT_FEE.DELEGATION,\n    gasLimit = DEFAULT_GAS_LIMIT.DELEGATION * 1000\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Estimate(gasLimit, 0, 157, this._costPerByte, fee);\n    });\n  }\n  /**\r\n   *\r\n   * @description Estimate gasLimit, storageLimit and fees for a reveal operation\r\n   *\r\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\r\n   *\r\n   * @param Estimate\r\n   */\n\n\n  reveal() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Estimate(DEFAULT_GAS_LIMIT.REVEAL * 1000, DEFAULT_STORAGE_LIMIT.REVEAL, 64, this._costPerByte, DEFAULT_FEE.REVEAL);\n    });\n  }\n\n  batch(params) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const estimates = [];\n\n      for (const param of params) {\n        switch (param.kind) {\n          case 'transaction':\n            estimates.push(yield this.transfer(param));\n            break;\n\n          case 'origination':\n            estimates.push(yield this.originate(param));\n            break;\n\n          case 'delegation':\n            estimates.push(yield this.setDelegate(param));\n            break;\n\n          case 'activate_account':\n            estimates.push(new Estimate(0, 0, 0, this._costPerByte, 0));\n            break;\n\n          default:\n            throw new InvalidOperationKindError(params.kind);\n        }\n      }\n\n      return estimates;\n    });\n  }\n\n}\n/**\r\n * @packageDocumentation\r\n * @module @taquito/taquito\r\n */\n\n/**\r\n * @description Facade class that surfaces all of the libraries capability and allow it's configuration\r\n *\r\n * @param _rpc The RPC server to use\r\n */\n\n\nclass TezosToolkit {\n  constructor(_rpc) {\n    this._rpc = _rpc;\n    this._options = {};\n    this.format = format;\n\n    if (typeof this._rpc === 'string') {\n      this._rpcClient = new RpcClient(this._rpc);\n    } else {\n      this._rpcClient = this._rpc;\n    }\n\n    this._context = new Context(_rpc);\n    this._wallet = new Wallet(this._context);\n    this.setProvider({\n      rpc: this._rpcClient\n    });\n    this.batch = this._context.batch.batch.bind(this._context.batch);\n  }\n  /**\r\n   * @description Sets configuration on the Tezos Taquito instance. Allows user to choose which signer, rpc client, rpc url, forger and so forth\r\n   *\r\n   * @param options rpc url or rpcClient to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setProvider({rpc: 'https://mainnet.api.tez.ie/', signer: new InMemorySigner.fromSecretKey(edsk...)})\r\n   * @example Tezos.setProvider({ config: { confirmationPollingTimeoutSecond: 300 }})\r\n   *\r\n   */\n\n\n  setProvider({\n    rpc,\n    stream,\n    signer,\n    protocol,\n    config,\n    forger,\n    wallet,\n    packer,\n    globalConstantsProvider,\n    readProvider\n  }) {\n    this.setRpcProvider(rpc);\n    this.setStreamProvider(stream);\n    this.setSignerProvider(signer);\n    this.setForgerProvider(forger);\n    this.setWalletProvider(wallet);\n    this.setPackerProvider(packer);\n    this.setGlobalConstantsProvider(globalConstantsProvider);\n    this.setReadProvider(readProvider);\n    this._context.proto = protocol;\n\n    if (config) {\n      this._context.setPartialConfig(config);\n    }\n  }\n  /**\r\n   * @description Sets signer provider on the Tezos Taquito instance.\r\n   *\r\n   * @param options signer to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setSignerProvider(new InMemorySigner.fromSecretKey('edsk...'))\r\n   *\r\n   */\n\n\n  setSignerProvider(signer) {\n    if (!this._options.signer && typeof signer === 'undefined') {\n      this._context.signer = new NoopSigner();\n      this._options.signer = signer;\n    } else if (typeof signer !== 'undefined') {\n      this._context.signer = signer;\n      this._options.signer = signer;\n    }\n  }\n  /**\r\n   * @description Sets rpc provider on the Tezos Taquito instance\r\n   *\r\n   * @param options rpc url or rpcClient to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setRpcProvider('https://mainnet.api.tez.ie/')\r\n   *\r\n   */\n\n\n  setRpcProvider(rpc) {\n    if (typeof rpc === 'string') {\n      this._rpcClient = new RpcClient(rpc);\n    } else if (rpc === undefined) ;else {\n      this._rpcClient = rpc;\n    }\n\n    this._options.rpc = this._rpcClient;\n    this._context.rpc = this._rpcClient;\n  }\n  /**\r\n   * @description Sets forger provider on the Tezos Taquito instance\r\n   * The `LocalForger` from `@taquito/local-forging` is set by default.\r\n   *\r\n   * @param options forger to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setForgerProvider(this.getFactory(RpcForger)())\r\n   *\r\n   */\n\n\n  setForgerProvider(forger) {\n    if (typeof forger !== 'undefined') {\n      this._options.forger = forger;\n      this._context.forger = forger;\n    } else if (this._options.forger === undefined) {\n      const f = this.getFactory(TaquitoLocalForger)();\n      this._options.forger = f;\n      this._context.forger = f;\n    }\n  }\n  /**\r\n   * @description Sets stream provider on the Tezos Taquito instance\r\n   *\r\n   * @param options stream to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setStreamProvider(...)\r\n   *\r\n   */\n\n\n  setStreamProvider(stream) {\n    if (typeof stream === 'string') {\n      const s = new PollingSubscribeProvider(new Context(new RpcClient(stream)));\n      this._options.stream = s;\n      this._context.stream = s;\n    } else if (typeof stream !== 'undefined') {\n      this._options.stream = stream;\n      this._context.stream = stream;\n    } else if (this._options.stream === undefined) {\n      const s = this.getFactory(PollingSubscribeProvider)();\n      this._options.stream = s;\n      this._context.stream = s;\n    }\n  }\n  /**\r\n   * @description Sets wallet provider on the Tezos Taquito instance\r\n   *\r\n   * @param options wallet to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setWalletProvider(...)\r\n   *\r\n   */\n\n\n  setWalletProvider(wallet) {\n    if (!this._options.wallet && typeof wallet === 'undefined') {\n      const w = this.getFactory(LegacyWalletProvider)();\n      this._options.wallet = w;\n      this._context.walletProvider = w;\n    } else if (typeof wallet !== 'undefined') {\n      this._options.wallet = wallet;\n      this._context.walletProvider = wallet;\n    }\n  }\n  /**\r\n   * @description Sets Packer provider on the Tezos Taquito instance\r\n   *\r\n   * @param options packer to use to interact with the Tezos network\r\n   *\r\n   * @example Tezos.setPackerProvider(new MichelCodecPacker())\r\n   *\r\n   */\n\n\n  setPackerProvider(packer) {\n    if (!this._options.packer && typeof packer === 'undefined') {\n      const p = this.getFactory(RpcPacker)();\n      this._context.packer = p;\n      this._options.packer = p;\n    } else if (typeof packer !== 'undefined') {\n      this._context.packer = packer;\n      this._options.packer = packer;\n    }\n  }\n  /**\r\n   * @description Sets global constants provider on the Tezos Taquito instance\r\n   *\r\n   * @param options globalConstantsProvider to use to interact with the Tezos network\r\n   *\r\n   * @example\r\n   * ```\r\n   * const globalConst = new DefaultGlobalConstantsProvider();\r\n   * globalConst.loadGlobalConstant({\r\n   *  \"expruu5BTdW7ajqJ9XPTF3kgcV78pRiaBW3Gq31mgp3WSYjjUBYxre\": { prim: \"int\" },\r\n   *  // ...\r\n   * })\r\n   * Tezos.setGlobalConstantsProvider(globalConst);\r\n   * ```\r\n   *\r\n   */\n\n\n  setGlobalConstantsProvider(globalConstantsProvider) {\n    if (!this._options.globalConstantsProvider && typeof globalConstantsProvider === 'undefined') {\n      const g = new NoopGlobalConstantsProvider();\n      this._context.globalConstantsProvider = g;\n      this._options.globalConstantsProvider = g;\n    } else if (typeof globalConstantsProvider !== 'undefined') {\n      this._context.globalConstantsProvider = globalConstantsProvider;\n      this._options.globalConstantsProvider = globalConstantsProvider;\n    }\n  }\n  /**\r\n   * @description Sets read provider on the Tezos Taquito instance\r\n   * By default reads are done from the RPC usign the RpcReadAdapter class, this can be overridden to read from an indexer that implements the TzReadProvider interface\r\n   *\r\n   * @param options TzReadProvider to use to interact with the Tezos network\r\n   *\r\n   */\n\n\n  setReadProvider(readProvider) {\n    const readP = typeof readProvider === 'undefined' ? this.getFactory(RpcReadAdapter)() : readProvider;\n    this._options.readProvider = readP;\n    this._context.readProvider = readP;\n  }\n  /**\r\n   * @description Provide access to tezos account management\r\n   */\n\n\n  get tz() {\n    return this._context.tz;\n  }\n  /**\r\n   * @description Provide access to smart contract utilities\r\n   */\n\n\n  get contract() {\n    return this._context.contract;\n  }\n\n  get wallet() {\n    return this._wallet;\n  }\n\n  get operation() {\n    return this._context.operationFactory;\n  }\n  /**\r\n   * @description Provide access to operation estimation utilities\r\n   */\n\n\n  get estimate() {\n    return this._context.estimate;\n  }\n  /**\r\n   * @description Provide access to streaming utilities backed by an streamer implementation\r\n   */\n\n\n  get stream() {\n    return this._context.stream;\n  }\n  /**\r\n   * @description Provide access to the currently used rpc client\r\n   */\n\n\n  get rpc() {\n    return this._context.rpc;\n  }\n  /**\r\n   * @description Provide access to the currently used signer\r\n   */\n\n\n  get signer() {\n    return this._context.signer;\n  }\n  /**\r\n   * @description Provide access to the currently used globalConstantsProvider\r\n   */\n\n\n  get globalConstants() {\n    return this._context.globalConstantsProvider;\n  }\n  /**\r\n   * @description Allow to add a module to the TezosToolkit instance. This method adds the appropriate Providers(s) required by the module to the internal context.\r\n   *\r\n   * @param module extension to add to the TezosToolkit instance\r\n   *\r\n   * @example Tezos.addExtension(new Tzip16Module());\r\n   */\n\n\n  addExtension(module) {\n    if (Array.isArray(module)) {\n      module.forEach(extension => extension.configureContext(this._context));\n    } else {\n      module.configureContext(this._context);\n    }\n  }\n\n  getFactory(ctor) {\n    return (...args) => {\n      return new ctor(this._context, ...args);\n    };\n  }\n  /**\r\n   * @description Gets an object containing the version of Taquito library and git sha of the commit this library is compiled from\r\n   */\n\n\n  getVersionInfo() {\n    return VERSION;\n  }\n\n}\n\nexport { BatchOperation, BigMapAbstraction, ChainIds, CompositeForger, Context, ContractAbstraction, ContractMethod, ContractMethodObject, ContractView, DEFAULT_FEE, DEFAULT_GAS_LIMIT, DEFAULT_SMART_CONTRACT_METHOD_NAME, DEFAULT_STORAGE_LIMIT, DefaultGlobalConstantsProvider, DelegateOperation, DelegationWalletOperation, Estimate, GlobalConstantNotFound, InvalidCodeParameter, InvalidDelegationSource, InvalidInitParameter, InvalidParameterError, InvalidViewParameterError, InvalidViewSimulationContext, LegacyWalletProvider, MANAGER_LAMBDA, MichelCodecPacker, MichelCodecParser, MissedBlockDuringConfirmationError, NaiveEstimateProvider, NoopParser, ObservableSubscription, Operation, OperationBatch, OriginationOperation, OriginationParameterError, OriginationWalletOperation, PollingSubscribeProvider, Protocols, RPCEstimateProvider, RevealEstimateError, RevealOperationError, RpcForger, RpcPacker, RpcReadAdapter, TaquitoLocalForger, TezosOperationError, TezosPreapplyFailureError, TezosToolkit, TransactionOperation, TransactionWalletOperation, UnconfiguredGlobalConstantsProviderError, VIEW_LAMBDA, ViewSimulationError, Wallet, WalletOperation, WalletOperationBatch, compose, createOriginationOperation, createRegisterDelegateOperation, createRegisterGlobalConstantOperation, createRevealOperation, createSetDelegateOperation, createTransferOperation, defaultConfigConfirmation, protocols, validateAndExtractFailwith };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAGaA,YAAW;EACtBC,YAAoBC,OAApB,EAAoC;IAAhB;EAAoB;;EACxCC,MAAM,CAACC,oBAAD,EAA6B;IACjC,OAAO,KAAKF,OAAL,CAAaG,GAAb,CAAiBC,eAAjB,CAAiCF,oBAAjC,CAAP;EACD;;AAJqB;ACDxB;;;;;;MAIaG,gCAAgCC,MAAK;EAGhDP;IACE,MACE,qHADF;IAHF,YAAO,yBAAP;EAMC;;AAP+C;AAUlD;;;;;MAGaQ,WAAU;EACfC,SAAS;;MACb,MAAM,IAAIH,uBAAJ,EAAN;IACD;EAAA;;EACKI,aAAa;;MACjB,MAAM,IAAIJ,uBAAJ,EAAN;IACD;EAAA;;EACKK,SAAS;;MACb,MAAM,IAAIL,uBAAJ,EAAN;IACD;EAAA;;EACKM,IAAI,CAACC,MAAD,EAAiBC,UAAjB,EAAwC;;MAChD,MAAM,IAAIR,uBAAJ,EAAN;IACD;EAAA;;AAZoB;;SCfPS,iCAEdC,KAAoB;EACpB,OAAO,IAAIC,UAAJ,CAAmBC,UAAD,IAAW;IAClCF,GAAG,CAACG,EAAJ,CAAO,MAAP,EAAgBC,IAAD,IAAQ;MACrBF,UAAU,CAACG,IAAX,CAAgBD,IAAhB;IACD,CAFD;IAIAJ,GAAG,CAACG,EAAJ,CAAO,OAAP,EAAiBG,KAAD,IAAa;MAC3BJ,UAAU,CAACI,KAAX,CAAiBA,KAAjB;IACD,CAFD;IAIAN,GAAG,CAACG,EAAJ,CAAO,OAAP,EAAgB;MACdD,UAAU,CAACK,QAAX;IACD,CAFD;IAIA,OAAO;MACLP,GAAG,CAACQ,KAAJ;IACD,CAFD;EAGD,CAhBM,CAAP;AAiBF;;ICxBYC;;AAAZ,WAAYA,iBAAZ,EAA6B;EAC3BA;EACAA;EACAA;EACAA;AACD,CALD,EAAYA,iBAAiB,KAAjBA,iBAAiB,MAA7B;;IAMYC;;AAAZ,WAAYA,WAAZ,EAAuB;EACrBA;EACAA;EACAA;EACAA;AACD,CALD,EAAYA,WAAW,KAAXA,WAAW,MAAvB;;IAMYC;;AAAZ,WAAYA,qBAAZ,EAAiC;EAC/BA;EACAA;EACAA;EACAA;AACD,CALD,EAAYA,qBAAqB,KAArBA,qBAAqB,MAAjC;;IAOYC;;AAAZ,WAAYA,SAAZ,EAAqB;EACnBA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;AACD,CAbD,EAAYA,SAAS,KAATA,SAAS,MAArB;;MAeaC,SAAS,GAAG;EACvB,OAAO,CAACD,SAAS,CAACE,QAAX,CADgB;EAEvB,OAAO,CAACF,SAAS,CAACG,QAAX,EAAqBH,SAAS,CAACI,QAA/B,CAFgB;EAGvB,OAAO,CAACJ,SAAS,CAACK,QAAX,CAHgB;EAIvB,OAAO,CAACL,SAAS,CAACM,QAAX,CAJgB;EAKvB,OAAO,CAACN,SAAS,CAACO,QAAX,CALgB;EAMvB,OAAO,CAACP,SAAS,CAACQ,SAAX,CANgB;EAOvB,OAAO,CAACR,SAAS,CAACS,SAAX,CAPgB;EAQvB,OAAO,CAACT,SAAS,CAACU,QAAX,CARgB;EASvB,OAAO,CAACV,SAAS,CAACW,QAAX,CATgB;EAUvB,OAAO,CAACX,SAAS,CAACY,SAAX,CAVgB;EAWvB,OAAO,CAACZ,SAAS,CAACa,UAAX;AAXgB;IAcbC;;AAAZ,WAAYA,QAAZ,EAAoB;EAClBA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;EACAA;AACD,CAVD,EAAYA,QAAQ,KAARA,QAAQ,MAApB;;AC9CA,MAAMC,WAAW,GAAG,CAApB;AACA,MAAMC,YAAY,GAAG,CAArB;;AAIA,SAASC,UAAT,CAAoBC,MAApB,EAAkC;EAChC,QAAQA,MAAR;IACE,KAAK,IAAL;MACE,OAAOH,WAAP;;IACF,KAAK,KAAL;MACE,OAAOC,YAAP;;IACF,KAAK,OAAL;IACA;MACE,OAAO,CAAP;EAPJ;AASD;;SAEeE,OACdC,OAAe,SACfC,KAAa,SACbC,QAAmC;EAEnC,MAAMC,MAAM,GAAG,IAAIC,SAAJ,CAAcF,MAAd,CAAf;;EACA,IAAIC,MAAM,CAACE,KAAP,EAAJ,EAAoB;IAClB,OAAOH,MAAP;EACD;;EAED,OAAOC,MAAM,CACVG,YADI,CACSC,IAAI,CAACC,GAAL,CAAS,EAAT,EAAaV,UAAU,CAACE,IAAD,CAAvB,CADT,EAEJS,SAFI,CAEMF,IAAI,CAACC,GAAL,CAAS,EAAT,EAAaV,UAAU,CAACG,EAAD,CAAvB,CAFN,CAAP;AAGF;AC7BA;;;;;;MAIaS,8BAA8BlD,MAAK;EAE9CP,YAAmB0D,uBAAnB,EAA2DC,IAA3D,EAA+EC,IAA/E,EAA0F;IACxF,MACE,GAAGF,uBAAuB,aACxBE,IAAI,CAACC,MACP,+DAA+DC,IAAI,CAACC,SAAL,CAAeJ,IAAf,CAAoB,GAHrF;IADiB;IAAwC;IAAoB;IAD/E,YAAO,0BAAP;EAOC;;AAR6C;AAWhD;;;;;;MAIaK,gCAAgCzD,MAAK;EAGhDP,YAAmBiE,MAAnB,EAAiC;IAC/B,MACE,uEAAuEA,MAAM,mEAD/E;IADiB;IAFnB,YAAO,iCAAP;EAMC;;AAP+C;AAUlD;;;;;;MAIaC,6BAA6B3D,MAAK;EAE7CP,YAAmBmE,OAAnB,EAAoD/C,IAApD,EAA6D;IAC3D,MAAM+C,OAAN;IADiB;IAAiC;IAD7C,YAAO,sBAAP;EAGN;;AAJ4C;AAO/C;;;;;;MAIaC,6BAA6B7D,MAAK;EAE7CP,YAAmBmE,OAAnB,EAAoD/C,IAApD,EAA6D;IAC3D,MAAM+C,OAAN;IADiB;IAAiC;IAD7C,YAAO,sBAAP;EAGN;;AAJ4C;AAO/C;;;;;;MAIaE,kCAAkC9D,MAAK;EAGlDP,YACSsE,qBADT,EAESX,IAFT,EAGSC,IAHT,EAISW,aAJT,EAI2B;IAEzB,MACE,+CAA+CD,qBAAqB,cAAcV,IAAI,kEAAkEE,IAAI,CAACC,SAAL,CACtJJ,IADsJ,CAEvJ,GAHH;IALO;IACA;IACA;IACA;IANT,YAAO,+BAAP;IAaE,KAAKa,KAAL,GAAaD,aAAb;EACD;;AAfiD;AAkBpD;;;;;;MAIaE,4BAA4BlE,MAAK;EAE5CP,YACSmE,OADT,EAESO,QAFT,EAGSC,QAHT,EAISJ,aAJT,EAI4B;IAE1B,MAAMJ,OAAN;IALO;IACA;IACA;IACA;IALT,YAAO,qBAAP;EAQC;;AAT2C;;MAYjCS,0BAA0B,GACrCtD,KADwC,IAChB;EAExB,IAAIuD,YAAY,CAACvD,KAAK,CAACwD,IAAP,CAAhB,EAA8B;IAC5B,MAAMC,WAAW,GAAGjB,IAAI,CAACkB,KAAL,CAAW1D,KAAK,CAACwD,IAAjB,CAApB;;IACA,IAAIG,KAAK,CAACC,OAAN,CAAcH,WAAd,KAA8B,UAAUA,WAAW,CAACA,WAAW,CAAClB,MAAZ,GAAqB,CAAtB,CAAvD,EAAiF;MAC/E,OAAOkB,WAAW,CAACA,WAAW,CAAClB,MAAZ,GAAqB,CAAtB,CAAX,CAAoCsB,IAA3C;IACD;EACF;AACH;;AAEA,MAAMN,YAAY,GAAIO,GAAD,IAAY;EAC/B,IAAI;IACFtB,IAAI,CAACkB,KAAL,CAAWI,GAAX;EACD,CAFD,CAEE,OAAOC,CAAP,EAAU;IACV,OAAO,KAAP;EACD;;EACD,OAAO,IAAP;AACD,CAPD;AASA;;;;;;MAIaC,qCAAqC/E,MAAK;EAErDP,YAAmBuF,IAAnB,EAA+B;IAC7B,MAAM,GAAGA,IAAI,gFAAb;IADiB;IADZ,YAAO,8BAAP;EAGN;;AAJoD;AAOvD;;;;;;MAIaC,6BAA6BjF,MAAK;EAE7CP,YAAmBmE,OAAnB,EAAkC;IAChC,MAAMA,OAAN;IADiB;IADZ,YAAO,sBAAP;EAGN;;AAJ4C;AAO/C;;;;;;MAIasB,kCAAkClF,MAAK;EAElDP,YAAmBmE,OAAnB,EAAkC;IAChC,MAAMA,OAAN;IADiB;IADZ,YAAO,2BAAP;EAGN;;AAJiD;;MCtHvCuB,0BAA0B,GAAG,CAAO;EAC/CC,IAD+C;EAE/CC,IAF+C;EAG/CC,OAAO,GAAG,GAHqC;EAI/CC,QAJ+C;EAK/CC,OAL+C;EAM/CC,GAAG,GAAGtE,WAAW,CAACuE,WAN6B;EAO/CC,QAAQ,GAAGzE,iBAAiB,CAACwE,WAPkB;EAQ/CE,YAAY,GAAGxE,qBAAqB,CAACsE,WARU;EAS/CG,KAAK,GAAG;AATuC,CAAP,KAUxBC;EAChB,IAAIN,OAAO,KAAKO,SAAZ,IAAyBV,IAAI,KAAKU,SAAtC,EAAiD;IAC/C,MAAM,IAAIb,yBAAJ,CACJ,iGADI,CAAN;EAGD;;EAED,IAAI,CAACR,KAAK,CAACC,OAAN,CAAcS,IAAd,CAAL,EAA0B;IACxB,MAAM,IAAIzB,oBAAJ,CAAyB,8CAAzB,EAAyEyB,IAAzE,CAAN;EACD;;EAED,IAAIY,eAAJ;;EACA,IAAIR,OAAO,KAAKO,SAAhB,EAA2B;IACzB,MAAME,WAAW,GAAIb,IAAe,CAACc,IAAhB,CAClBC,CAAD,IAAkB,UAAUA,CAAV,IAAeA,CAAC,CAACC,IAAF,KAAW,SADzB,CAArB;;IAGA,IAAI,YAAW,SAAX,eAAW,WAAX,GAAW,MAAX,cAAW,CAAE/C,IAAb,MAAsB0C,SAA1B,EAAqC;MACnC,MAAM,IAAIpC,oBAAJ,CAAyB,gDAAzB,EAA2EyB,IAA3E,CAAN;IACD;;IACD,MAAMiB,MAAM,GAAG,IAAIC,MAAJ,CAAWL,WAAW,CAAC5C,IAAZ,CAAiB,CAAjB,CAAX,CAAf,CAPyB,CAO+C;;IACxE2C,eAAe,GAAGK,MAAM,CAACE,MAAP,CAAcf,OAAd,CAAlB;EACD,CATD,MASO,IAAIH,IAAI,KAAKU,SAAT,IAAsB,OAAOV,IAAP,KAAgB,QAA1C,EAAoD;IACzDW,eAAe,GAAGX,IAAlB;EACD,CAFM,MAEA;IACL,MAAM,IAAIxB,oBAAJ,CAAyB,oDAAzB,EAA+EwB,IAA/E,CAAN;EACD;;EAED,MAAMmB,MAAM,GAAG;IACbpB,IADa;IAEbI,OAAO,EAAEQ;EAFI,CAAf;EAKA,MAAMS,SAAS,GAA4B;IACzCC,IAAI,EAAEC,MAAM,CAACjB,WAD4B;IAEzCD,GAFyC;IAGzCmB,SAAS,EAAEjB,QAH8B;IAIzCkB,aAAa,EAAEjB,YAJ0B;IAKzCN,OAAO,EAAEO,KAAK,GAAGP,OAAO,CAACwB,QAAR,EAAH,GAAwBvE,MAAM,CAAC,IAAD,EAAO,OAAP,EAAgB+C,OAAhB,CAAN,CAA+BwB,QAA/B,EALG;IAMzCN;EANyC,CAA3C;;EASA,IAAIjB,QAAJ,EAAc;IACZkB,SAAS,CAAClB,QAAV,GAAqBA,QAArB;EACD;;EACD,OAAOkB,SAAP;AACD,CA7CiB;;MA+CLM,uBAAuB,GAAG,CAAO;EAC5CtE,EAD4C;EAE5CC,MAF4C;EAG5CsE,SAH4C;EAI5CvB,GAAG,GAAGtE,WAAW,CAAC8F,QAJ0B;EAK5CtB,QAAQ,GAAGzE,iBAAiB,CAAC+F,QALe;EAM5CrB,YAAY,GAAGxE,qBAAqB,CAAC6F,QANO;EAO5CpB,KAAK,GAAG;AAPoC,CAAP,KAQtBC;EACf,MAAMW,SAAS,GAAyB;IACtCC,IAAI,EAAEC,MAAM,CAACO,WADyB;IAEtCzB,GAFsC;IAGtCmB,SAAS,EAAEjB,QAH2B;IAItCkB,aAAa,EAAEjB,YAJuB;IAKtClD,MAAM,EAAEmD,KAAK,GAAGnD,MAAM,CAACoE,QAAP,EAAH,GAAuBvE,MAAM,CAAC,IAAD,EAAO,OAAP,EAAgBG,MAAhB,CAAN,CAA8BoE,QAA9B,EALE;IAMtCK,WAAW,EAAE1E,EANyB;IAOtC2E,UAAU,EAAEJ;EAP0B,CAAxC;EASA,OAAOP,SAAP;AACD,CAXgB;;MAaJY,0BAA0B,GAAG,CAAO;EAC/C9B,QAD+C;EAE/C7B,MAF+C;EAG/C+B,GAAG,GAAGtE,WAAW,CAACmG,UAH6B;EAI/C3B,QAAQ,GAAGzE,iBAAiB,CAACoG,UAJkB;EAK/C1B,YAAY,GAAGxE,qBAAqB,CAACkG;AALU,CAAP,KAMzBxB;EACf,MAAMW,SAAS,GAAyB;IACtCC,IAAI,EAAEC,MAAM,CAACW,UADyB;IAEtC5D,MAFsC;IAGtC+B,GAHsC;IAItCmB,SAAS,EAAEjB,QAJ2B;IAKtCkB,aAAa,EAAEjB,YALuB;IAMtCL;EANsC,CAAxC;EAQA,OAAOkB,SAAP;AACD,CAVgB;;MAYJc,+BAA+B,GAAG,CAC7C;EACE9B,GAAG,GAAGtE,WAAW,CAACmG,UADpB;EAEE3B,QAAQ,GAAGzE,iBAAiB,CAACoG,UAF/B;EAGE1B,YAAY,GAAGxE,qBAAqB,CAACkG;AAHvC,CAD6C,EAM7C5D,MAN6C,KAM/BoC;EAEd,OAAO;IACLY,IAAI,EAAEC,MAAM,CAACW,UADR;IAEL7B,GAFK;IAGLmB,SAAS,EAAEjB,QAHN;IAILkB,aAAa,EAAEjB,YAJV;IAKLL,QAAQ,EAAE7B;EALL,CAAP;AAOD,CATe;;MAWH8D,qBAAqB,GAAG,CACnC;EACE/B,GAAG,GAAGtE,WAAW,CAACsG,MADpB;EAEE9B,QAAQ,GAAGzE,iBAAiB,CAACuG,MAF/B;EAGE7B,YAAY,GAAGxE,qBAAqB,CAACqG;AAHvC,CADmC,EAMnC/D,MANmC,EAOnCxD,SAPmC,KAOlB4F;EAEjB,OAAO;IACLY,IAAI,EAAEC,MAAM,CAACc,MADR;IAELhC,GAFK;IAGLiC,UAAU,EAAExH,SAHP;IAILwD,MAJK;IAKLkD,SAAS,EAAEjB,QALN;IAMLkB,aAAa,EAAEjB;EANV,CAAP;AAQD,CAVkB;;MAYN+B,qCAAqC,GAAG,CAAO;EAC1DC,KAD0D;EAE1DlE,MAF0D;EAG1D+B,GAH0D;EAI1DE,QAJ0D;EAK1DC;AAL0D,CAAP,KAMtBE;EAC7B,OAAO;IACLY,IAAI,EAAEC,MAAM,CAACkB,wBADR;IAELD,KAFK;IAGLnC,GAHK;IAILmB,SAAS,EAAEjB,QAJN;IAKLkB,aAAa,EAAEjB,YALV;IAMLlC;EANK,CAAP;AAQD,CAT8B;;ACvIxB,MAAMoE,UAAU,GAAG,CAAsBC,EAAtB,EAA6BrB,IAA7B,KAAoC;EAC5D,OAAOsB,gCAAKD,EAAL,GAAO;IAAErB;EAAF,CAAP,CAAP;AACD,CAFM;;AAIA,MAAMuB,YAAY,GAAG,CAC1BC,GAD0B,EAE1BxB,IAF0B,KAEnB;EAEP,IAAIhC,KAAK,CAACC,OAAN,CAAcuD,GAAd,CAAJ,EAAwB;IACtB,MAAMC,KAAK,GAAGD,GAAG,CAAChC,IAAJ,CAAS6B,EAAE,IAAIA,EAAE,CAACrB,IAAH,KAAYA,IAA3B,CAAd;;IAEA,IAAIyB,KAAK,IAAIC,MAAM,CAACD,KAAD,EAAQzB,IAAR,CAAnB,EAAkC;MAChC,OAAOyB,KAAP;IACD;EACF;AACF,CAXM;;AAaA,MAAMC,MAAM,GAAG,CACpBL,EADoB,EAEpBrB,IAFoB,KAEb;EAEP,OAAOqB,EAAE,CAACrB,IAAH,KAAYA,IAAnB;AACD,CALM;;AAoBA,MAAM2B,WAAW,GACtBN,EADyB,IACpB;EAEL,OAAO,CAAC,aAAD,EAAgB,YAAhB,EAA8B,aAA9B,EAA6C,QAA7C,EAAuD,0BAAvD,EAAmFO,OAAnF,CAA2FP,EAAE,CAACrB,IAA9F,MAAwG,CAAC,CAAhH;AACD,CAJM;;AAMA,MAAM6B,iBAAiB,GAC5BR,EAD+B,IAC1B;EAEL,OAAO,CAAC,aAAD,EAAgB,YAAhB,EAA8B,aAA9B,EAA6C,0BAA7C,EAAyEO,OAAzE,CAAiFP,EAAE,CAACrB,IAApF,MAA8F,CAAC,CAAtG;AACD,CAJM;;AAYA,MAAM8B,WAAW,GACtBT,EADyB,IACpB;EAIL,OAAO,cAAcA,EAArB;AACD,CANM;;AAQA,MAAMU,qBAAqB,GAChCV,EADmC,IAC9B;EAML,OAAOS,WAAW,CAAST,EAAT,CAAX,IAA2B,sBAAsBA,EAAE,CAACW,QAA3D;AACD,CARM;;AAUA,MAAMC,sCAAsC,GACjDZ,EADoD,IAC/C;EAML,OAAOS,WAAW,CAAST,EAAT,CAAX,IAA2B,gCAAgCA,EAAE,CAACW,QAArE;AACD,CARM;;AC5EP,MAAME,kBAAkB,GAAI7H,KAAD,IAAW;EACpC,OAAO,UAAUA,KAAjB;AACD,CAFD;AAIA;;;;;;MAIa8H,4BAA4B7I,MAAK;EAK5CP,YAAmBqJ,MAAnB,EAAgEC,YAAhE,EAAqF;IACnF;IADiB;IAA6C;IAJhE,YAAO,qBAAP,CAIqF;;IAGnF,MAAMC,SAAS,GAAGF,MAAM,CAACA,MAAM,CAACxF,MAAP,GAAgB,CAAjB,CAAxB;IACA,KAAK2F,EAAL,GAAUD,SAAS,CAACC,EAApB;IACA,KAAKvC,IAAL,GAAYsC,SAAS,CAACtC,IAAtB;IAEA,KAAK9C,OAAL,GAAe,IAAI,KAAK8C,IAAI,KAAK,KAAKuC,EAAE,EAAxC;;IAEA,IAAIL,kBAAkB,CAACI,SAAD,CAAtB,EAAmC;MACjC,IAAIA,SAAS,CAACpE,IAAV,CAAesE,MAAnB,EAA2B;QACzB,KAAKtF,OAAL,GAAeoF,SAAS,CAACpE,IAAV,CAAesE,MAA9B;MACD,CAFD,MAEO,IAAIF,SAAS,CAACpE,IAAV,CAAeuE,GAAnB,EAAwB;QAC7B,KAAKvF,OAAL,GAAeoF,SAAS,CAACpE,IAAV,CAAeuE,GAA9B;MACD,CAFM,MAEA;QACL,KAAKvF,OAAL,GAAeL,IAAI,CAACC,SAAL,CAAewF,SAAS,CAACpE,IAAzB,CAAf;MACD;IACF;EACF;;AAvB2C;AA0B9C;;;;;;MAIawE,kCAAkCpJ,MAAK;EAGlDP,YAAmB4J,MAAnB,EAA8B;IAC5B,MAAM,wCAAN;IADiB;IAFnB,YAAO,2BAAP;EAIC;;AALiD,C,CAgBpD;AACA;AACA;AACA;AACA;;;AACO,MAAMC,sBAAsB,GAAIC,QAAD,IAAgD;EACpF,MAAMC,OAAO,GAAG9E,KAAK,CAACC,OAAN,CAAc4E,QAAd,IAA0BA,QAA1B,GAAqC,CAACA,QAAD,CAArD;EAEA,MAAME,eAAe,GAA4B,EAAjD;;EACA,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,OAAO,CAAClG,MAA5B,EAAoCoG,CAAC,EAArC,EAAyC;IACvC,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,OAAO,CAACE,CAAD,CAAP,CAAWE,QAAX,CAAoBtG,MAAxC,EAAgDqG,CAAC,EAAjD,EAAqD;MACnD,MAAME,OAAO,GAAGL,OAAO,CAACE,CAAD,CAAP,CAAWE,QAAX,CAAoBD,CAApB,CAAhB;;MACA,IAAIlB,qBAAqB,CAACoB,OAAD,CAAzB,EAAoC;QAClCJ,eAAe,CAACK,IAAhB,CAAoB9B;UAClBvC,GAAG,EAAEoE,OAAO,CAACpE;QADK,GAEfoE,OAAO,CAACnB,QAAR,CAAiBqB,gBAFF,CAApB;;QAKA,IAAIrF,KAAK,CAACC,OAAN,CAAckF,OAAO,CAACnB,QAAR,CAAiBsB,0BAA/B,CAAJ,EAAgE;UAC9DH,OAAO,CAACnB,QAAR,CAAiBsB,0BAAjB,CAA4CC,OAA5C,CAAqDC,CAAD,IAClDT,eAAe,CAACK,IAAhB,CAAqBI,CAAC,CAACb,MAAvB,CADF;QAGD;MACF;IACF;EACF;;EAED,OAAOI,eAAP;AACD,CAvBM;AAyBP;;;;;AAGO,MAAMU,aAAa,GAAG,CAC3BZ,QAD2B,EAE3Ba,MAAM,GAAG,QAFkB,KAEV;EAEjB,MAAMZ,OAAO,GAAG9E,KAAK,CAACC,OAAN,CAAc4E,QAAd,IAA0BA,QAA1B,GAAqC,CAACA,QAAD,CAArD;EAEA,IAAIT,MAAM,GAAiC,EAA3C,CAJiB;;EAMjB,KAAK,IAAIY,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,OAAO,CAAClG,MAA5B,EAAoCoG,CAAC,EAArC,EAAyC;IACvC,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,OAAO,CAACE,CAAD,CAAP,CAAWE,QAAX,CAAoBtG,MAAxC,EAAgDqG,CAAC,EAAjD,EAAqD;MACnD,MAAME,OAAO,GAAGL,OAAO,CAACE,CAAD,CAAP,CAAWE,QAAX,CAAoBD,CAApB,CAAhB;;MACA,IAAInB,WAAW,CAACqB,OAAD,CAAf,EAA0B;QACxB,IAAIpB,qBAAqB,CAACoB,OAAD,CAArB,IAAkCA,OAAO,CAACnB,QAAR,CAAiBqB,gBAAjB,CAAkCK,MAAlC,KAA6CA,MAAnF,EAA2F;UACzFtB,MAAM,GAAGA,MAAM,CAACuB,MAAP,CAAcR,OAAO,CAACnB,QAAR,CAAiBqB,gBAAjB,CAAkCjB,MAAlC,IAA4C,EAA1D,CAAT;QACD;;QACD,IACEH,sCAAsC,CAACkB,OAAD,CAAtC,IACAnF,KAAK,CAACC,OAAN,CAAckF,OAAO,CAACnB,QAAR,CAAiBsB,0BAA/B,CAFF,EAGE;UACA,KAAK,MAAMM,cAAX,IAA6BT,OAAO,CAACnB,QAAR,CAAiBsB,0BAA9C,EAA0E;YACxE,IAAI,YAAYM,cAAZ,IAA8BA,cAAc,CAACjB,MAAf,CAAsBe,MAAtB,KAAiCA,MAAnE,EAA2E;cACzEtB,MAAM,GAAGA,MAAM,CAACuB,MAAP,CAAcC,cAAc,CAACjB,MAAf,CAAsBP,MAAtB,IAAgC,EAA9C,CAAT;YACD;UACF;QACF;MACF;IACF;EACF;;EAED,OAAOA,MAAP;AACD,CA9BM;AAgCP;;;;;;MAIayB,kCAAkCvK,MAAK;EAElDP,YAAmBmE,OAAnB,EAAkC;IAChC,MAAMA,OAAN;IADiB;IADZ,YAAO,2BAAP;EAGN;;AAJiD;AC/IpD;;;;;;MAIa4G,sCAAsCxK,MAAK;EAEtDP,YAAmBmE,OAAnB,EAAkC;IAChC,MAAMA,OAAN;IADiB;IADZ,YAAO,+BAAP;EAGN;;AAJqD;AAOxD;;;;;;MAIa6G,mCAAmCzK,MAAK;EAEnDP,YAAmBmE,OAAnB,EAAkC;IAChC,MAAMA,OAAN;IADiB;IADZ,YAAO,4BAAP;EAGN;;AAJkD;AAOrD;;;;;;MAIa8G,qCAAqC1K,MAAK;EAErDP,YAAmBmE,OAAnB,EAAkC;IAChC,MAAMA,OAAN;IADiB;IADZ,YAAO,8BAAP;EAGN;;AAJoD;ACJvD;;;;;MAGa+G,UAAS;;;;;;;EA4CpBlL,YACkBmL,IADlB,EAEkBC,GAFlB,EAGkBrB,OAHlB,EAIqB9J,OAJrB,EAIqC;IAHnB;IACA;IACA;IACG;IA/Cb,uBAAkB,IAAIoL,aAAJ,CAAiC,CAAjC,CAAlB;IAEA,oBAAe,KAAKC,eAAL,CAAqBC,IAArB,CACrBC,SAAS,CAAEC,MAAD,IAAO;MACf,OAAOC,KAAK,CAAC,MACX3K,gCAAgC,CAAC,KAAKd,OAAL,CAAa0L,MAAb,CAAoBC,cAApB,CAAmC,MAAnC,CAAD,CADtB,CAAL,CAELL,IAFK,CAGLM,WAAW,CAACJ,MAAM,CAACK,OAAP,GAAiB,IAAlB,EAAwBC,UAAU,CAAC,IAAIxL,KAAJ,CAAU,gCAAV,CAAD,CAAlC,CAHN,CAAP;IAKD,CANQ,CADY,EAQrByL,WAAW,CAAC;MAAEC,QAAQ,EAAE;IAAZ,CAAD,CARU,CAAf,CA6C6B;;IAjC7B,kBAAa,KAAKC,YAAL,CAAkBX,IAAlB,CACnBY,GAAG,CAAEC,IAAD,IAAK;MACP,KAAK,IAAInC,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,CAArB,EAAwBA,CAAC,EAAzB,EAA6B;QAC3BmC,IAAI,CAACC,UAAL,CAAgBpC,CAAhB,EAAmBO,OAAnB,CAA4BlC,EAAD,IAAG;UAC5B,IAAIA,EAAE,CAAC6C,IAAH,KAAY,KAAKA,IAArB,EAA2B;YACzB,KAAKmB,QAAL,GAAgBF,IAAI,CAACG,MAAL,CAAYC,KAA5B;UACD;QACF,CAJD;MAKD;;MAED,IAAIJ,IAAI,CAACG,MAAL,CAAYC,KAAZ,GAAoB,KAAKF,QAAzB,IAAqC,CAAzC,EAA4C;QAC1C,OAAO,KAAKA,QAAZ;MACD;IACF,CAZE,CADgB,EAcnBG,MAAM,CAAEhC,CAAD,IAAOA,CAAC,KAAKnE,SAAd,CAda,EAenBoG,KAAK,EAfc,EAgBnBV,WAAW,EAhBQ,CAAb;IAmBE,gBAAWW,MAAM,CAACC,iBAAlB;;IAgBR,IAAIC,iBAAiB,CAAC,KAAK1B,IAAN,CAAjB,KAAiC2B,gBAAgB,CAACC,KAAtD,EAA6D;MAC3D,MAAM,IAAIC,yBAAJ,CAA8B,KAAK7B,IAAnC,CAAN;IACD;;IAED,KAAK8B,UAAL,CACG1B,IADH,CAEImB,KAAK,EAFT,EAGIQ,UAAU,CAAC;MACT,OAAOC,EAAE,CAACC,KAAD,CAAT;IACD,CAFS,CAHd,EAOGC,SAPH;EAQD;;EA3BkB,IAAfC,eAAe;IACjB,OAAO,KAAKhB,QAAZ;EACD;;EA2BkB,IAAfiB,eAAe;IACjB,OACEtI,KAAK,CAACC,OAAN,CAAc,KAAK6E,OAAnB,KACC,KAAKA,OAAL,CAAatD,IAAb,CAAmB6B,EAAD,IAAQA,EAAE,CAACrB,IAAH,KAAY,QAAtC,CAFH;EAMD;;EAEsB,IAAZuG,YAAY;IACrB,IAAI,KAAKD,eAAT,EAA0B;MACxB,OAAO,KAAKA,eAAL,CAAqBtE,QAArB,CAA8BqB,gBAA9B,CAA+CK,MAAtD;IACD,CAFD,MAEO;MACL,OAAO,SAAP;IACD;EACF;;EAEgB,IAANA,MAAM;IACf,OACE,KAAKZ,OAAL,CAAaoC,GAAb,CAAkBvC,MAAD,IAAO;MACtB,IAAIZ,qBAAqB,CAACY,MAAD,CAAzB,EAAmC;QACjC,OAAOA,MAAM,CAACX,QAAP,CAAgBqB,gBAAhB,CAAiCK,MAAxC;MACD,CAFD,MAEO;QACL,OAAO,SAAP;MACD;IACF,CAND,EAMG,CANH,KAMS,SAPX;EASD;;;;;;;;EAOK8C,YAAY,CAACC,aAAD,EAAyB5B,OAAzB,EAAyC;;MACzD,IAAI,OAAO4B,aAAP,KAAyB,WAAzB,IAAwCA,aAAa,GAAG,CAA5D,EAA+D;QAC7D,MAAM,IAAI3C,6BAAJ,CAAkC,uCAAlC,CAAN;MACD;;MAED,MAAM;QAAE4C,wBAAF;QAA4BC;MAA5B,IAAiE,KAAK3N,OAAL,CAAawL,MAApF;;MACA,KAAKH,eAAL,CAAqBjK,IAArB,CAA0B;QACxByK,OAAO,EAAEA,OAAO,IAAI8B;MADI,CAA1B;;MAIA,MAAMC,IAAI,GAAGH,aAAa,KAAKpH,SAAlB,GAA8BoH,aAA9B,GAA8CC,wBAA3D;MAEA,OAAO,IAAIG,OAAJ,CAAoB,CAACC,OAAD,EAAUC,MAAV,KAAgB;QACzC,KAAKf,UAAL,CACG1B,IADH,CAEIC,SAAS,CAAC,MAAM,KAAKU,YAAZ,CAFb,EAGIO,MAAM,CAAEL,IAAD,IAAUA,IAAI,CAACG,MAAL,CAAYC,KAAZ,GAAoB,KAAKF,QAAzB,IAAqCuB,IAAI,GAAG,CAAvD,CAHV,EAIInB,KAAK,EAJT,EAMGW,SANH,CAMcY,CAAD,IAAE;UACXF,OAAO,CAAC,KAAKzB,QAAL,IAAiBuB,IAAI,GAAG,CAAxB,CAAD,CAAP;QACD,CARH,EAQKG,MARL;MASD,CAVM,CAAP;IAWD;EAAA;;AAzHmB;;MCXTE,uBACHhD,UAAS;EAGjBlL,YACEmL,IADF,EAEmBgD,MAFnB,EAGkBlK,MAHlB,EAIEmH,GAJF,EAKErB,OALF,EAME9J,OANF,EAMkB;IAEhB,MAAMkL,IAAN,EAAYC,GAAZ,EAAiBrB,OAAjB,EAA0B9J,OAA1B;IANiB;IACD;EAMjB;;EAEOmO,OAAO,CAAC3F,GAAD,EAAa4F,IAAb,EAAyB;IACtC,OAAO5F,GAAG,CAAC6F,MAAJ,CAAW,CAACC,IAAD,EAAOC,OAAP,KAAc;MAC9B,OAAOH,IAAI,IAAIG,OAAR,GAAkB7B,MAAM,CAAC6B,OAAO,CAACH,IAAD,CAAR,CAAN,GAAwBE,IAA1C,GAAiDA,IAAxD;IACD,CAFM,EAEJ,CAFI,CAAP;EAGD;;EAEgB,IAAN5D,MAAM;IACf,OACE,KAAKZ,OAAL,CACG0C,MADH,CACW7C,MAAD,IAAY6E,WAAW,CAAC5F,OAAZ,CAAoBe,MAAM,CAAC3C,IAA3B,MAAqC,CAAC,CAD5D,EAEGkF,GAFH,CAEQvC,MAAD,IAAO;MACV,IAAIZ,qBAAqB,CAACY,MAAD,CAAzB,EAAmC;QACjC,OAAOA,MAAM,CAACX,QAAP,CAAgBqB,gBAAhB,CAAiCK,MAAxC;MACD,CAFD,MAEO;QACL,OAAO,SAAP;MACD;IACF,CARH,EAQK,CARL,KAQW,SATb;EAWD;;EAEM,IAAH3E,GAAG;IACL,OAAO,KAAKoI,OAAL,CAAa,KAAKD,MAAlB,EAA0B,KAA1B,CAAP;EACD;;EAEW,IAARjI,QAAQ;IACV,OAAO,KAAKkI,OAAL,CAAa,KAAKD,MAAlB,EAA0B,WAA1B,CAAP;EACD;;EAEe,IAAZhI,YAAY;IACd,OAAO,KAAKiI,OAAL,CAAa,KAAKD,MAAlB,EAA0B,eAA1B,CAAP;EACD;;EAEc,IAAXO,WAAW;IACb,OAAOC,MAAM,CAAC,KAAKP,OAAL,CAAavE,sBAAsB,CAAC;MAAEM,QAAQ,EAAE,KAAKJ;IAAjB,CAAD,CAAnC,EAAiE,cAAjE,CAAD,CAAb;EACD;;EAEc,IAAX6E,WAAW;IACb,OAAOD,MAAM,CACX,KAAKP,OAAL,CAAavE,sBAAsB,CAAC;MAAEM,QAAQ,EAAE,KAAKJ;IAAjB,CAAD,CAAnC,EAAiE,wBAAjE,CADW,CAAb;EAGD;;EAES,IAANV,MAAM;IACR,OAAOqB,aAAa,CAAC;MAAEP,QAAQ,EAAE,KAAKJ;IAAjB,CAAD,CAApB;EACD;;AA1DgB;;MCgBG8E,iBAAgB;EASpC7O,YAAsBC,OAAtB,EAAsC;IAAhB;EAAoB;;EARnC,IAAHG,GAAG;IACL,OAAO,KAAKH,OAAL,CAAaG,GAApB;EACD;;EAES,IAAN0O,MAAM;IACR,OAAO,KAAK7O,OAAL,CAAa6O,MAApB;EACD;;EAIeC,gBAAgB,CAACzG,EAAD,EAAwC0G,GAAxC,EAAmD;;MACjF,OAAO,EAAE,MAAM,KAAKC,uBAAL,CAA6BD,GAA7B,CAAR,KAA8C,CAAC,KAAKE,yBAAL,CAA+B5G,EAA/B,CAA/C,GACH,KADG,GAEH,IAFJ;IAGD;EAAA;;EAEe2G,uBAAuB,CAACvO,aAAD,EAAsB;;MAC3D,OAAO,EAAE,MAAM,KAAKT,OAAL,CAAakP,YAAb,CAA0BC,iBAA1B,CAA4C1O,aAA5C,EAA2D,MAA3D,CAAR,CAAP;IACD;EAAA;;EAESwO,yBAAyB,CAAC5G,EAAD,EAAsC;IACvE,IAAI+G,eAAe,GAAG,KAAtB;;IACA,KAAK,MAAMrI,SAAX,IAAwBsB,EAAxB,EAA4B;MAC1B,IAAIQ,iBAAiB,CAAC9B,SAAD,CAArB,EAAkC;QAChCqI,eAAe,GAAG,IAAlB;MACD;IACF;;IACD,OAAOA,eAAP;EACD,CA7BmC;;;EAgCpBC,gBAAgB,CAC9B;IAAEtI,SAAF;IAAa/C;EAAb,CAD8B,EAE9B+K,GAF8B,EAElB;;MAEZ,MAAMO,QAAQ,GAA8B,EAA5C;MACA,IAAIC,GAAG,GAAmB,EAA1B;MAEA,MAAMC,gBAAgB,GAAG,KAAKxP,OAAL,CAAakP,YAAb,CAA0BO,YAA1B,CAAuC,QAAvC,CAAzB;MACA,MAAMC,iBAAiB,GAAG,KAAK1P,OAAL,CAAakP,YAAb,CAA0BS,eAA1B,CAA0C,MAA1C,CAA1B;;MAEA,IAAI3K,KAAK,CAACC,OAAN,CAAc8B,SAAd,CAAJ,EAA8B;QAC5BwI,GAAG,GAAG,CAAC,GAAGxI,SAAJ,CAAN;MACD,CAFD,MAEO;QACLwI,GAAG,GAAG,CAACxI,SAAD,CAAN;MACD;;;MAGD,MAAMtG,aAAa,GAAGsO,GAAG,GAAGA,GAAH,GAAS,MAAM,KAAKF,MAAL,CAAYpO,aAAZ,EAAxC;MACA,IAAImP,cAAc,GAAgC/B,OAAO,CAACC,OAAR,CAAgBzH,SAAhB,CAAlD;;MAEA,KAAK,IAAI2D,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGuF,GAAG,CAAC3L,MAAxB,EAAgCoG,CAAC,EAAjC,EAAqC;QACnC,IAAInB,iBAAiB,CAAC0G,GAAG,CAACvF,CAAD,CAAJ,CAAjB,IAA6BuF,GAAG,CAACvF,CAAD,CAAH,CAAOhD,IAAP,KAAgB,QAAjD,EAA2D;UACzD4I,cAAc,GAAG,KAAK5P,OAAL,CAAakP,YAAb,CAA0BW,UAA1B,CAAqCpP,aAArC,EAAoD,MAApD,CAAjB;UACA;QACD;MACF;;MAED,MAAM,CAACyK,IAAD,EAAO4E,QAAP,EAAiBC,WAAjB,IAAgC,MAAMlC,OAAO,CAACmC,GAAR,CAAY,CACtDR,gBADsD,EAEtDE,iBAFsD,EAGtDE,cAHsD,CAAZ,CAA5C;MAMA,MAAMK,OAAO,GAAGC,QAAQ,CAACH,WAAW,IAAI,GAAhB,EAAqB,EAArB,CAAxB;;MACA,IAAI,CAACT,QAAQ,CAAC7O,aAAD,CAAT,IAA4B6O,QAAQ,CAAC7O,aAAD,CAAR,GAA0BwP,OAA1D,EAAmE;QACjEX,QAAQ,CAAC7O,aAAD,CAAR,GAA0BwP,OAA1B;MACD;;MAED,MAAME,MAAM,GAAI9H,EAAD,IAAiB;QAC9B,MAAM+H,SAAS,GAAG,EAAEd,QAAQ,CAAC7O,aAAD,CAA5B;QACA,OAAO;UACLwP,OAAO,EAAE,GAAGG,SAAS,EADhB;UAELrK,GAAG,EAAE,OAAOsC,EAAE,CAACtC,GAAV,KAAkB,WAAlB,GAAgC,GAAhC,GAAsC,GAAGsC,EAAE,CAACtC,GAAG,EAF/C;UAGLmB,SAAS,EAAE,OAAOmB,EAAE,CAACnB,SAAV,KAAwB,WAAxB,GAAsC,GAAtC,GAA4C,GAAGmB,EAAE,CAACnB,SAAS,EAHjE;UAILC,aAAa,EAAE,OAAOkB,EAAE,CAAClB,aAAV,KAA4B,WAA5B,GAA0C,GAA1C,GAAgD,GAAGkB,EAAE,CAAClB,aAAa;QAJ7E,CAAP;MAMD,CARD;;MAUA,MAAMkJ,SAAS,GAAIhI,EAAD,IAAoB;QACpC,OAAO;UACLrE,MAAM,EAAE,OAAOqE,EAAE,CAACrE,MAAV,KAAqB,WAArB,GAAmCA,MAAM,IAAIvD,aAA7C,GAA6D4H,EAAE,CAACrE;QADnE,CAAP;MAGD,CAJD;;MAMA,MAAMsM,YAAY,GAAIC,IAAD,IACnBA,IAAI,CAACrE,GAAL,CAAU7D,EAAD,IAAiB;QACxB,QAAQA,EAAE,CAACrB,IAAX;UACE,KAAKC,MAAM,CAACuJ,UAAZ;YACE,yBACKnI,EADL;;UAGF,KAAKpB,MAAM,CAACc,MAAZ;YACE,qDACKM,EADL,GAEKgI,SAAS,CAAChI,EAAD,CAFd,GAGK8H,MAAM,CAAC9H,EAAD,CAHX;;UAKF,KAAKpB,MAAM,CAACjB,WAAZ;YACE,mEACKqC,EADL,GACO;cACLzC,OAAO,EAAE,OAAOyC,EAAE,CAACzC,OAAV,KAAsB,WAAtB,GAAoC,GAAGyC,EAAE,CAACzC,OAAO,EAAjD,GAAsD;YAD1D,CADP,GAGKyK,SAAS,CAAChI,EAAD,CAHd,GAIK8H,MAAM,CAAC9H,EAAD,CAJX;;UAMF,KAAKpB,MAAM,CAACO,WAAZ;YAAyB;cACvB,MAAMiJ,IAAI,+DACLpI,EADK,GACH;gBACLrF,MAAM,EAAE,OAAOqF,EAAE,CAACrF,MAAV,KAAqB,WAArB,GAAmC,GAAGqF,EAAE,CAACrF,MAAM,EAA/C,GAAoD;cADvD,CADG,GAGLqN,SAAS,CAAChI,EAAD,CAHJ,GAIL8H,MAAM,CAAC9H,EAAD,CAJD,CAAV;;cAMA,IAAIoI,IAAI,CAACzM,MAAL,CAAY0M,WAAZ,GAA0BC,UAA1B,CAAqC,KAArC,CAAJ,EAAiD;gBAC/C,MAAM,IAAIC,gBAAJ,CACJ,mDAAmDjP,SAAS,CAACI,QAAQ,EADjE,CAAN;cAGD;;cACD,OAAO0O,IAAP;YACD;;UACD,KAAKxJ,MAAM,CAACW,UAAZ;YACE,qDACKS,EADL,GAEKgI,SAAS,CAAChI,EAAD,CAFd,GAGK8H,MAAM,CAAC9H,EAAD,CAHX;;UAKF,KAAKpB,MAAM,CAACkB,wBAAZ;YACE,qDACKE,EADL,GAEKgI,SAAS,CAAChI,EAAD,CAFd,GAGK8H,MAAM,CAAC9H,EAAD,CAHX;;UAKF;YACE,MAAM,IAAIwI,yBAAJ,CAA+BxI,EAAU,CAACrB,IAA1C,CAAN;QA7CJ;MA+CD,CAhDD,CADF;;MAmDA,MAAMkD,QAAQ,GAAGoG,YAAY,CAACf,GAAD,CAA7B;MAEA,OAAO;QACLuB,IAAI,EAAE;UACJC,MAAM,EAAE7F,IADJ;UAEJhB,QAFI;UAGJ4F;QAHI,CADD;QAMLG;MANK,CAAP;IAQD;EAAA;;EAEee,KAAK,CAAC;IAAEF,IAAI,EAAE;MAAEC,MAAF;MAAU7G,QAAV;MAAoB4F;IAApB,CAAR;IAAwCG;EAAxC,CAAD,EAAqE;;MACxF,MAAMgB,WAAW,GAAG,MAAM,KAAKjR,OAAL,CAAakR,MAAb,CAAoBF,KAApB,CAA0B;QAAED,MAAF;QAAU7G;MAAV,CAA1B,CAA1B;MAEA,OAAO;QACLiH,OAAO,EAAEF,WADJ;QAELH,IAAI,EAAE;UACJC,MADI;UAEJ7G,QAFI;UAGJ4F;QAHI,CAFD;QAOLG;MAPK,CAAP;IASD;EAAA;;EAEemB,QAAQ,CAAC/I,EAAD,EAAyB;;MAC/C,OAAO;QACLgJ,UAAU,EAAE,MAAM,KAAKlR,GAAL,CAASmR,YAAT,CAAsBjJ,EAAtB,CADb;QAELA,EAFK;QAGLrI,OAAO,EAAE,KAAKA,OAAL,CAAauR,KAAb;MAHJ,CAAP;IAKD;EAAA;;EAEeC,QAAQ,CACtBC,EADsB,EAEtBC,SAFsB,EAEoB;QAD1C;MAAE3L,GAAF;MAAOE,QAAP;MAAiBC;IAAjB,IAA6BuL;QAAKE,IAAI,cAAtC,mCAAsC;;;MAGtC,IAAIC,aAAa,GAAG7L,GAApB;MACA,IAAI8L,aAAa,GAAG5L,QAApB;MACA,IAAI6L,iBAAiB,GAAG5L,YAAxB;;MAEA,IAAIH,GAAG,KAAKM,SAAR,IAAqBJ,QAAQ,KAAKI,SAAlC,IAA+CH,YAAY,KAAKG,SAApE,EAA+E;QAC7E,MAAM0L,UAAU,GAAG,MAAML,SAAS;UAAG3L,GAAH;UAAQE,QAAR;UAAkBC;QAAlB,GAAoCyL,IAApC,EAAlC;;QAEA,IAAIC,aAAa,KAAKvL,SAAtB,EAAiC;UAC/BuL,aAAa,GAAGG,UAAU,CAACC,iBAA3B;QACD;;QAED,IAAIH,aAAa,KAAKxL,SAAtB,EAAiC;UAC/BwL,aAAa,GAAGE,UAAU,CAAC9L,QAA3B;QACD;;QAED,IAAI6L,iBAAiB,KAAKzL,SAA1B,EAAqC;UACnCyL,iBAAiB,GAAGC,UAAU,CAAC7L,YAA/B;QACD;MACF;;MAED,OAAO;QACLH,GAAG,EAAE6L,aADA;QAEL3L,QAAQ,EAAE4L,aAFL;QAGL3L,YAAY,EAAE4L;MAHT,CAAP;;EAKD;;EAEeG,aAAa,CAAChB,WAAD,EAAyB;;MACpD,MAAMiB,MAAM,GAAG,MAAM,KAAKrD,MAAL,CAAYlO,IAAZ,CAAiBsQ,WAAW,CAACE,OAA7B,EAAsC,IAAIgB,UAAJ,CAAe,CAAC,CAAD,CAAf,CAAtC,CAArB;MACAlB,WAAW,CAACE,OAAZ,GAAsBe,MAAM,CAACE,MAA7B;MACAnB,WAAW,CAACH,IAAZ,CAAiBuB,SAAjB,GAA6BH,MAAM,CAACI,SAApC;MAEA,MAAMjB,UAAU,GAAiC,EAAjD;MACA,MAAMvH,OAAO,GAAG,MAAM,KAAK3J,GAAL,CAASoS,kBAAT,CAA4B,CAACtB,WAAW,CAACH,IAAb,CAA5B,CAAtB;;MAEA,IAAI,CAAC9L,KAAK,CAACC,OAAN,CAAc6E,OAAd,CAAL,EAA6B;QAC3B,MAAM,IAAIJ,yBAAJ,CAA8BI,OAA9B,CAAN;MACD;;MAED,KAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,OAAO,CAAClG,MAA5B,EAAoCoG,CAAC,EAArC,EAAyC;QACvC,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,OAAO,CAACE,CAAD,CAAP,CAAWE,QAAX,CAAoBtG,MAAxC,EAAgDqG,CAAC,EAAjD,EAAqD;UACnDoH,UAAU,CAACjH,IAAX,CAAgBN,OAAO,CAACE,CAAD,CAAP,CAAWE,QAAX,CAAoBD,CAApB,CAAhB;QACD;MACF;;MAED,MAAMb,MAAM,GAAGqB,aAAa,CAACX,OAAD,CAA5B;;MAEA,IAAIV,MAAM,CAACxF,MAAX,EAAmB;QACjB,MAAM,IAAIuF,mBAAJ,CACJC,MADI,EAEJ,0DAFI,CAAN;MAID;;MAED,OAAO;QACL8B,IAAI,EAAE,MAAM,KAAKlL,OAAL,CAAawS,QAAb,CAAsBvS,MAAtB,CAA6BgR,WAAW,CAACE,OAAzC,CADP;QAELF,WAFK;QAGLI,UAHK;QAILrR,OAAO,EAAE,KAAKA,OAAL,CAAauR,KAAb;MAJJ,CAAP;IAMD;EAAA;;AA3OmC;;ACM/B,MAAM/C,WAAW,GAAG,CACzBvH,MAAM,CAACuJ,UADkB,EAEzBvJ,MAAM,CAACjB,WAFkB,EAGzBiB,MAAM,CAACO,WAHkB,EAIzBP,MAAM,CAACW,UAJkB,CAApB;;MAYM6K,uBAAuB7D,iBAAgB;EAGlD7O,YAAYC,OAAZ,EAAsC0R,SAAtC,EAAmE;IACjE,MAAM1R,OAAN;IADoC;IAF9B,kBAA+B,EAA/B;EAIP;;;;;;;;;EAQD0S,YAAY,CAACxE,MAAD,EAAuB;IACjC,IAAIyE,eAAe,CAACzE,MAAM,CAACnL,EAAR,CAAf,KAA+B8J,gBAAgB,CAACC,KAApD,EAA2D;MACzD,MAAM,IAAI8F,mBAAJ,CAAwB1E,MAAM,CAACnL,EAA/B,CAAN;IACD;;IACD,KAAKqJ,UAAL,CAAgBhC,IAAhB,CAAoB9B;MAAGtB,IAAI,EAAEC,MAAM,CAACO;IAAhB,GAAgC0G,MAAhC,CAApB;IACA,OAAO,IAAP;EACD;;;;;;;;;EAQD2E,gBAAgB,CACd3E,MADc,EACmE;IAEjF,OAAO,KAAKwE,YAAL,CAAkBxE,MAAM,CAAC4E,gBAAP,EAAlB,CAAP;EACD;;;;;;;;;EAQDC,cAAc,CAAC7E,MAAD,EAAuB;IACnC,IAAIA,MAAM,CAAClK,MAAP,IAAiB2O,eAAe,CAACzE,MAAM,CAAClK,MAAR,CAAf,KAAmC6I,gBAAgB,CAACC,KAAzE,EAAgF;MAC9E,MAAM,IAAI8F,mBAAJ,CAAwB1E,MAAM,CAAClK,MAA/B,CAAN;IACD;;IACD,IAAIkK,MAAM,CAACrI,QAAP,IAAmB8M,eAAe,CAACzE,MAAM,CAACrI,QAAR,CAAf,KAAqCgH,gBAAgB,CAACC,KAA7E,EAAoF;MAClF,MAAM,IAAI8F,mBAAJ,CAAwB1E,MAAM,CAACrI,QAA/B,CAAN;IACD;;IACD,KAAKuG,UAAL,CAAgBhC,IAAhB,CAAoB9B;MAAGtB,IAAI,EAAEC,MAAM,CAACW;IAAhB,GAA+BsG,MAA/B,CAApB;IACA,OAAO,IAAP;EACD;;;;;;;;;EAQD8E,cAAc,CAAC;IAAEjE,GAAF;IAAOkE;EAAP,CAAD,EAAkC;IAC9C,IAAIC,eAAe,CAACnE,GAAD,CAAf,KAAyBlC,gBAAgB,CAACC,KAA9C,EAAqD;MACnD,MAAM,IAAIqG,mBAAJ,CAAwBpE,GAAxB,CAAN;IACD;;IACD,KAAK3C,UAAL,CAAgBhC,IAAhB,CAAqB;MAAEpD,IAAI,EAAEC,MAAM,CAACuJ,UAAf;MAA2BzB,GAA3B;MAAgCkE;IAAhC,CAArB;IACA,OAAO,IAAP;EACD;;;;;;;;;EAQDG,eAAe,CACblF,MADa,EAC0C;IAEvD,KAAK9B,UAAL,CAAgBhC,IAAhB,CAAoB9B;MAAGtB,IAAI,EAAEC,MAAM,CAACjB;IAAhB,GAAgCkI,MAAhC,CAApB;IACA,OAAO,IAAP;EACD;;;;;;;;;EAQDmF,0BAA0B,CAACnF,MAAD,EAAqC;IAC7D,KAAK9B,UAAL,CAAgBhC,IAAhB,CAAoB9B;MAAGtB,IAAI,EAAEC,MAAM,CAACkB;IAAhB,GAA6C+F,MAA7C,CAApB;IACA,OAAO,IAAP;EACD;;EAEaoF,QAAQ,CAACC,KAAD,EAAsB;;MAC1C,QAAQA,KAAK,CAACvM,IAAd;QACE,KAAKC,MAAM,CAACO,WAAZ;UACE,OAAOH,uBAAuB,mBACzBkM,KADyB,EAA9B;;QAGF,KAAKtM,MAAM,CAACjB,WAAZ;UACE,OAAOP,0BAA0B,CAC/B,MAAM,KAAKzF,OAAL,CAAawT,MAAb,CAAoBC,sBAApB,CAA0CnL,kBAC3CiL,KAD2C,CAA1C,CADyB,CAAjC;;QAKF,KAAKtM,MAAM,CAACW,UAAZ;UACE,OAAOD,0BAA0B,mBAC5B4L,KAD4B,EAAjC;;QAGF,KAAKtM,MAAM,CAACuJ,UAAZ;UACE,yBACK+C,KADL;;QAGF,KAAKtM,MAAM,CAACkB,wBAAZ;UACE,OAAOF,qCAAqC,mBACvCsL,KADuC,EAA5C;;QAGF;UACE,MAAM,IAAI1C,yBAAJ,CAA+B0C,KAAa,CAACvM,IAA7C,CAAN;MAxBJ;IA0BD;EAAA;;;;;;;;;EAQD9B,IAAI,CAACgJ,MAAD,EAAyB;IAC3B,KAAK,MAAMqF,KAAX,IAAoBrF,MAApB,EAA4B;MAC1B,QAAQqF,KAAK,CAACvM,IAAd;QACE,KAAKC,MAAM,CAACO,WAAZ;UACE,KAAKkL,YAAL,CAAkBa,KAAlB;UACA;;QACF,KAAKtM,MAAM,CAACjB,WAAZ;UACE,KAAKoN,eAAL,CAAqBG,KAArB;UACA;;QACF,KAAKtM,MAAM,CAACW,UAAZ;UACE,KAAKmL,cAAL,CAAoBQ,KAApB;UACA;;QACF,KAAKtM,MAAM,CAACuJ,UAAZ;UACE,KAAKwC,cAAL,CAAoBO,KAApB;UACA;;QACF,KAAKtM,MAAM,CAACkB,wBAAZ;UACE,KAAKkL,0BAAL,CAAgCE,KAAhC;UACA;;QACF;UACE,MAAM,IAAI1C,yBAAJ,CAA+B0C,KAAa,CAACvM,IAA7C,CAAN;MAjBJ;IAmBD;;IAED,OAAO,IAAP;EACD;;;;;;;;;EAQK0M,IAAI,CAACxF,MAAD,EAA6B;;MACrC,MAAMzN,aAAa,GAAG,MAAM,KAAKoO,MAAL,CAAYpO,aAAZ,EAA5B;MACA,MAAMD,SAAS,GAAG,MAAM,KAAKqO,MAAL,CAAYrO,SAAZ,EAAxB;MACA,MAAMmT,SAAS,GAAG,MAAM,KAAKjC,SAAL,CAAekC,KAAf,CAAqB,KAAKxH,UAA1B,CAAxB;MAEA,MAAMyH,YAAY,GAAG,MAAM,KAAK/E,gBAAL,CAAsB,KAAK1C,UAA3B,EAAuC3L,aAAvC,CAA3B;MACA,IAAIuJ,CAAC,GAAG6J,YAAY,GAAG,CAAH,GAAO,CAA3B;MAEA,MAAMtE,GAAG,GAAmB,EAA5B;;MACA,KAAK,MAAMlH,EAAX,IAAiB,KAAK+D,UAAtB,EAAkC;QAChC,IAAIzD,WAAW,CAACN,EAAD,CAAf,EAAqB;UACnB,MAAMyL,SAAS,GAAG,MAAM,KAAKtC,QAAL,CAAcnJ,EAAd,EAAkB;YAAY,gBAAS,CAAC2B,CAAD,CAAT;UAAY,CAAxB,CAAlB,CAAxB;UACAuF,GAAG,CAACnF,IAAJ,CAAS,MAAM,KAAKkJ,QAAL,CAAahL,gCAAMD,EAAN,GAAayL,SAAb,CAAb,CAAf;QACD,CAHD,MAGO;UACLvE,GAAG,CAACnF,IAAJ,CAAQ9B,kBAAMD,EAAN,CAAR;QACD;;QACD2B,CAAC;MACF;;MACD,IAAI6J,YAAJ,EAAkB;QAChB,MAAME,MAAM,GAA0C;UAAE/M,IAAI,EAAEC,MAAM,CAACc;QAAf,CAAtD;QACA,MAAMiM,eAAe,GAAG,MAAM,KAAKxC,QAAL,CAAcuC,MAAd,EAAsB;UAAY,gBAAS,CAAC,CAAD,CAAT;QAAY,CAAxB,CAAtB,CAA9B;QACAxE,GAAG,CAAC0E,OAAJ,CAAY,MAAMnM,qBAAqB,mBAAMkM,eAAN,GAAyBvT,aAAzB,EAAwCD,SAAxC,CAAvC;MACD;;MAED,MAAMwD,MAAM,GAAIkK,MAAM,IAAIA,MAAM,CAAClK,MAAlB,IAA6BvD,aAA5C;MACA,MAAMyT,QAAQ,GAAG,MAAM,KAAK7E,gBAAL,CAAsB;QAC3CtI,SAAS,EAAEwI,GADgC;QAE3CvL;MAF2C,CAAtB,CAAvB;MAIA,MAAMmQ,OAAO,GAAG,MAAM,KAAKnD,KAAL,CAAWkD,QAAX,CAAtB;MACA,MAAM;QAAEhJ,IAAF;QAAQlL,OAAR;QAAiBiR,WAAjB;QAA8BI;MAA9B,IAA6C,MAAM,KAAKY,aAAL,CAAmBkC,OAAnB,CAAzD;MACA,OAAO,IAAIlG,cAAJ,CAAmB/C,IAAnB,EAAyBqE,GAAzB,EAA8BvL,MAA9B,EAAsCiN,WAAtC,EAAmDI,UAAnD,EAA+DrR,OAA/D,CAAP;IACD;EAAA;;AA3LiD;;MA8LvCoU,iBAAgB;EAC3BrU,YAAoBC,OAApB,EAA8C0R,SAA9C,EAA2E;IAAvD;IAA0B;EAAiC;;;;;;;;;EAQ/EkC,KAAK,CAAC1F,MAAD,EAA0B;IAC7B,MAAM0F,KAAK,GAAG,IAAInB,cAAJ,CAAmB,KAAKzS,OAAxB,EAAiC,KAAK0R,SAAtC,CAAd;;IAEA,IAAI1M,KAAK,CAACC,OAAN,CAAciJ,MAAd,CAAJ,EAA2B;MACzB0F,KAAK,CAAC1O,IAAN,CAAWgJ,MAAX;IACD;;IAED,OAAO0F,KAAP;EACD;;AAjB0B;;ACjOtB,MAAMS,oBAAoB,GAAG,CAClChM,EADkC,EAElC;EAAEiM,eAAF;EAAmBC;AAAnB,IAAwC;EACtCD,eAAe,EAAE,GADqB;EAEtCC,gBAAgB,EAAE;AAFoB,CAFN,KAKjC;EAED,MAAMC,gBAAgB,GAAG5K,sBAAsB,CAAC;IAAEM,QAAQ,EAAE7B;EAAZ,CAAD,CAA/C;EACA,IAAIoM,QAAQ,GAAG,IAAIvR,SAAJ,CAAc,CAAd,CAAf;EACA,IAAIwR,YAAY,GAAG,IAAIxR,SAAJ,CAAc,CAAd,CAAnB;EACA,IAAIyR,QAAQ,GAAG,IAAIzR,SAAJ,CAAc,CAAd,CAAf;EACA,IAAI0R,oBAAoB,GAAG,IAAI1R,SAAJ,CAAc,CAAd,CAA3B;EACA,IAAI2R,mBAAmB,GAAG,IAAI3R,SAAJ,CAAc,CAAd,CAA1B;EACA,IAAI4R,oBAAoB,GAAG,IAAI5R,SAAJ,CAAc,CAAd,CAA3B;EACAsR,gBAAgB,CAACjK,OAAjB,CAAyBZ,MAAM;IAC7BgL,QAAQ,GAAGA,QAAQ,CAACI,IAAT,CAAcpL,MAAM,CAAC5D,GAAP,IAAc,CAA5B,CAAX;IACA6O,oBAAoB,GAAGA,oBAAoB,CAACG,IAArB,CACrB/P,KAAK,CAACC,OAAN,CAAc0E,MAAM,CAACqL,oBAArB,IACIrL,MAAM,CAACqL,oBAAP,CAA4BpR,MAA5B,GAAqC2Q,gBADzC,GAEI,CAHiB,CAAvB;IAKAM,mBAAmB,GAAGA,mBAAmB,CAACE,IAApB,CACpB,oCAAoCpL,MAApC,GAA6C2K,eAA7C,GAA+D,CAD3C,CAAtB;IAGAG,QAAQ,GAAGA,QAAQ,CAACM,IAAT,CAAcpL,MAAM,CAACsL,YAAP,IAAuB,CAArC,CAAX;IACAH,oBAAoB,GAAGA,oBAAoB,CAACC,IAArB,CACrB,4BAA4BpL,MAA5B,GAAqC+C,MAAM,CAAC/C,MAAM,CAACuL,sBAAR,CAAN,IAAyC,CAA9E,GAAkF,CAD7D,CAAvB;EAGD,CAdD;EAgBAR,YAAY,GAAGA,YAAY,CACxBK,IADY,CACPF,mBADO,EAEZE,IAFY,CAEPH,oBAFO,EAGZG,IAHY,CAGPD,oBAHO,CAAf;EAKA,OAAO;IACLH,QADK;IAELF,QAFK;IAGLC,YAHK;IAILG,mBAJK;IAKLD,oBALK;IAMLE,oBANK;IAOLK,gBAAgB,EAAE,IAAIjS,SAAJ,CAAcwR,YAAY,CAACtR,YAAb,CAA0B,IAA1B,CAAd;EAPb,CAAP;AASD,CA5CM;ACMP;;;;;;MAIagS,2CAA2C9U,MAAK;EAG3DP;IACE,MACE,wGADF;IAHF,YAAO,oCAAP;EAMC;;AAP0D;;AAU7D,MAAMsV,oBAAoB,GAAG,EAA7B;AAEA;;;;MAGaC,gBAAe;;;;;;;EA8D1BvV,YACkBwV,MADlB,EAEqBvV,OAFrB,EAGUwV,SAHV,EAG8C;IAF5B;IACG;IACX;IAhEA,wBAAmB,IAAIpK,aAAJ,CAAgD,CAAhD,CAAnB;IACA,wBAAmB,IAAIA,aAAJ,CAAiC,CAAjC,CAAnB;IACA,iBAAY,KAAZ;IAGA,gBAAsC,KAAKoK,SAAL,CAAelK,IAAf,CAC9CmK,GAAG,CAAEC,OAAD,IAAQ;MACV,IACE,CAAC,KAAKC,SAAN,IACA,KAAKC,QADL,IAEAF,OAAO,CAACpJ,MAAR,CAAeC,KAAf,GAAuB,KAAKqJ,QAAL,CAActJ,MAAd,CAAqBC,KAA5C,GAAoD,CAHtD,EAIE;QACA,MAAM,IAAI6I,kCAAJ,EAAN;MACD;;MAED,KAAKQ,QAAL,GAAgBF,OAAhB;IACD,CAVE,CAD2C,EAY9C3J,WAAW,CAAC;MAAE8J,UAAU,EAAE,CAAd;MAAiB7J,QAAQ,EAAE;IAA3B,CAAD,CAZmC,CAAtC,CA2DoC;;IA3CtC,kBAAa,KAAK8J,QAAL,CAAcxK,IAAd,CACnBY,GAAG,CAAEC,IAAD,IAAK;MACP,KAAK,MAAM4J,OAAX,IAAsB5J,IAAI,CAACC,UAA3B,EAAuC;QACrC,KAAK,MAAM/D,EAAX,IAAiB0N,OAAjB,EAA0B;UACxB,IAAI1N,EAAE,CAAC6C,IAAH,KAAY,KAAKqK,MAArB,EAA6B;YAC3B,KAAKI,SAAL,GAAiB,IAAjB;;YACA,KAAKK,gBAAL,CAAsB5U,IAAtB,CAA2B+K,IAA3B;;YACA,KAAK8J,gBAAL,CAAsB7U,IAAtB,CAA2BiH,EAAE,CAAC6B,QAA9B,EAH2B;;;YAM3B,OAAOiC,IAAP;UACD;QACF;MACF;IACF,CAbE,CADgB,EAenBK,MAAM,CAA4ChC,CAAD,IAAE;MACjD,OAAO,OAAOA,CAAP,KAAa,WAApB;IACD,CAFK,CAfa,EAkBnBiC,KAAK,EAlBc,EAmBnBV,WAAW,CAAC;MAAE8J,UAAU,EAAE,CAAd;MAAiB7J,QAAQ,EAAE;IAA3B,CAAD,CAnBQ,CAAb;;IA6CN,IAAIY,iBAAiB,CAAC,KAAK2I,MAAN,CAAjB,KAAmC1I,gBAAgB,CAACC,KAAxD,EAA+D;MAC7D,MAAM,IAAIC,yBAAJ,CAA8B,KAAKwI,MAAnC,CAAN;IACD;;IACD,KAAKvI,UAAL,CACG1B,IADH,CAEImB,KAAK,EAFT,EAGIQ,UAAU,CAAC,MAAMC,EAAE,CAAC7G,SAAD,CAAT,CAHd,EAKG+G,SALH;EAMD;;EAhCKoH,gBAAgB;;MACpB,OAAO,KAAKyB,gBAAL,CAAsB3K,IAAtB,CAA2BmB,KAAK,EAAhC,EAAoCyJ,SAApC,EAAP;IACD;EAAA;;;;;;;EAMKC,OAAO;;MACX,OAAO9B,oBAAoB,CAAC,MAAM,KAAKG,gBAAL,EAAP,CAA3B;IACD;EAAA;;EAwBK4B,sBAAsB;;MAC1B,IAAI,CAAC,KAAKT,SAAV,EAAqB;QACnB,OAAO,CAAP;MACD;;MAED,OAAOU,aAAa,CAAC,CAAC,KAAKL,gBAAN,EAAwBlT,IAAI,CAAC,KAAK9C,OAAL,CAAakP,YAAb,CAA0BoH,QAA1B,CAAmC,MAAnC,CAAD,CAA5B,CAAD,CAAb,CACJhL,IADI,CAEHY,GAAG,CAAC,CAAC,CAACqK,YAAD,EAAepK,IAAf,CAAD,KAAqB;QACvB,OAAOA,IAAI,CAACG,MAAL,CAAYC,KAAZ,GAAoBgK,YAAY,CAACjK,MAAb,CAAoBC,KAAxC,GAAgD,CAAvD;MACD,CAFE,CAFA,EAKHE,KAAK,EALF,EAOJyJ,SAPI,EAAP;IAQD;EAAA;;EAEKM,iBAAiB,CAACC,qBAAsC,MAAvC,EAA6C;;;MAElE,IAAI,CAAC,KAAKd,SAAV,EAAqB;QACnB,OAAO,IAAP;MACD;;MAED,MAAMe,mBAAmB,GAAG,MAAM,KAAK1W,OAAL,CAAakP,YAAb,CAA0ByH,aAA1B,CAAwCF,kBAAxC,CAAlC;MACA,MAAMG,cAAc,GAAG,MAAM,KAAKZ,gBAAL,CAAsB1K,IAAtB,CAA2BmB,KAAK,EAAhC,EAAoCyJ,SAApC,EAA7B;MAEA,MAAMW,SAAS,GAAGH,mBAAmB,GAAGE,cAAc,CAACtK,MAAf,CAAsBC,KAA9D;;MAGA,IAAIsK,SAAS,IAAI,CAAjB,EAAoB;QAClB,OAAO,IAAP;MACD;;MAED,MAAMC,aAAa,GAAGzT,IAAI,CAAC0T,GAAL,CACpBH,cAAc,CAACtK,MAAf,CAAsBC,KAAtB,GAA8BsK,SADV,EAEpBD,cAAc,CAACtK,MAAf,CAAsBC,KAAtB,GAA8B8I,oBAFV,CAAtB;MAKA,MAAM2B,MAAM,GAAG,IAAIC,GAAJ,CAAQ,MAAM,KAAKjX,OAAL,CAAakP,YAAb,CAA0BgI,aAA1B,CAAwCJ,aAAxC,CAAd,CAAf;MACA,OAAOE,MAAM,CAACG,GAAP,CAAWP,cAAc,CAAC1L,IAA1B,CAAP;IACD;EAAA;;EAEDkM,sBAAsB,CAAC3J,aAAD,EAAuB;IAC3C,IAAI,OAAOA,aAAP,KAAyB,WAAzB,IAAwCA,aAAa,GAAG,CAA5D,EAA+D;MAC7D,MAAM,IAAI3C,6BAAJ,CAAkC,uCAAlC,CAAN;IACD;;IAED,MAAM;MAAE4C;IAAF,IAA+B,KAAK1N,OAAL,CAAawL,MAAlD;IAEA,MAAMoC,IAAI,GAAGH,aAAa,KAAKpH,SAAlB,GAA8BoH,aAA9B,GAA8CC,wBAA3D;;IAEA,IAAIE,IAAI,KAAKvH,SAAb,EAAwB;MACtB,MAAM,IAAI0E,0BAAJ,CAA+B,kDAA/B,CAAN;IACD;;IAED,OAAOsL,aAAa,CAAC,CAAC,KAAKL,gBAAN,EAAwB,KAAKF,QAA7B,CAAD,CAAb,CAAsDxK,IAAtD,CACL+L,oBAAoB,CAAC,CAAC,GAAGC,YAAH,CAAD,EAAmB,GAAG5B,OAAH,CAAnB,KAA8B;MACjD,OAAO4B,YAAY,CAACpM,IAAb,KAAsBwK,OAAO,CAACxK,IAArC;IACD,CAFmB,CADf,EAILgB,GAAG,CAAC,CAAC,CAACqK,YAAD,EAAepK,IAAf,CAAD,KAAqB;MACvB,OAAO;QACLoL,KAAK,EAAEpL,IADF;QAELqL,oBAAoB,EAAE5J,IAFjB;QAGL6J,mBAAmB,EAAEtL,IAAI,CAACG,MAAL,CAAYC,KAAZ,GAAoBgK,YAAY,CAACjK,MAAb,CAAoBC,KAAxC,GAAgD,CAHhE;QAILmL,SAAS,EAAEvL,IAAI,CAACG,MAAL,CAAYC,KAAZ,GAAoBgK,YAAY,CAACjK,MAAb,CAAoBC,KAAxC,IAAiDqB,IAAI,GAAG,CAJ9D;QAKL4I,iBAAiB,EAAE,MAAM,KAAKA,iBAAL,CAAuBrK,IAAI,CAACjB,IAA5B;MALpB,CAAP;IAOD,CARE,CAJE,EAaLyM,SAAS,CAAC,CAAC;MAAED;IAAF,CAAD,KAAmB,CAACA,SAArB,EAAgC,IAAhC,CAbJ,CAAP;EAeD;;;;;;;EAMDlK,YAAY,CAACC,aAAD,EAAuB;IACjC,OAAO,KAAK2J,sBAAL,CAA4B3J,aAA5B,EAA2CyI,SAA3C,EAAP;EACD;;AA1JyB;;MChCf0B,6BAA6BtC,gBAAe;EACvDvV,YACkBwV,MADlB,EAEqBvV,OAFrB,EAGE8V,QAHF,EAGqC;IAEnC,MAAMP,MAAN,EAAcvV,OAAd,EAAuB8V,QAAvB;IAJgB;IACG;EAIpB;;EAEYxI,eAAe;;MAC1B,MAAMuK,eAAe,GAAG,MAAM,KAAKrD,gBAAL,EAA9B;MACA,OAAOqD,eAAe,CAACrR,IAAhB,CAAqBgE,CAAC,IAAIA,CAAC,CAACxD,IAAF,KAAWC,MAAM,CAACc,MAA5C,CAAP;IAGD;EAAA;;EAEK2C,MAAM;;MACV,IAAI,CAAC,KAAKiL,SAAV,EAAqB;QACnB,OAAO,SAAP;MACD;;MAED,MAAMtN,EAAE,GAAG,MAAM,KAAKmM,gBAAL,EAAjB;MAEA,OACEnM,EAAE,CACCmE,MADH,CACW7C,MAAD,IAAY6E,WAAW,CAAC5F,OAAZ,CAAoBe,MAAM,CAAC3C,IAA3B,MAAqC,CAAC,CAD5D,EAEGkF,GAFH,CAEQvC,MAAD,IAAO;QACV,IAAIZ,qBAAqB,CAACY,MAAD,CAAzB,EAAmC;UACjC,OAAOA,MAAM,CAACX,QAAP,CAAgBqB,gBAAhB,CAAiCK,MAAxC;QACD,CAFD,MAEO;UACL,OAAO,SAAP;QACD;MACF,CARH,EAQK,CARL,KAQW,SATb;IAWD;EAAA;;AAlCsD;;MCG5CoN,kCAAkCxC,gBAAe;EAC5DvV,YACkBwV,MADlB,EAEqBvV,OAFrB,EAGE8V,QAHF,EAGqC;IAEnC,MAAMP,MAAN,EAAcvV,OAAd,EAAuB8V,QAAvB;IAJgB;IACG;EAIpB;;EAEYxI,eAAe;;MAC1B,MAAMuK,eAAe,GAAG,MAAM,KAAKrD,gBAAL,EAA9B;MACA,OAAOqD,eAAe,CAACrR,IAAhB,CAAsBgE,CAAD,IAAOA,CAAC,CAACxD,IAAF,KAAWC,MAAM,CAACc,MAA9C,CAAP;IAGD;EAAA;;EAEYgQ,mBAAmB;;MAC9B,MAAMF,eAAe,GAAG,MAAM,KAAKrD,gBAAL,EAA9B;MACA,OAAOqD,eAAe,CAACrR,IAAhB,CAAsBgE,CAAD,IAAOA,CAAC,CAACxD,IAAF,KAAWC,MAAM,CAACW,UAA9C,CAAP;IAGD;EAAA;;EAEY8C,MAAM;;MACjB,IAAI,CAAC,KAAKiL,SAAV,EAAqB;QACnB,OAAO,SAAP;MACD;;MAED,MAAMtN,EAAE,GAAG,MAAM,KAAK0P,mBAAL,EAAjB;;MACA,IAAI,CAAC1P,EAAL,EAAS;QACP,OAAO,SAAP;MACD;;MAED,OAAOA,EAAE,CAACW,QAAH,CAAYqB,gBAAZ,CAA6BK,MAApC;IACD;EAAA;;AAlC2D;;MCEjDsN,mCAA0F1C,gBAAe;EACpHvV,YACkBwV,MADlB,EAEqBvV,OAFrB,EAGE8V,QAHF,EAGqC;IAEnC,MAAMP,MAAN,EAAcvV,OAAd,EAAuB8V,QAAvB;IAJgB;IACG;EAIpB;;EAEYmC,oBAAoB;;MAC/B,MAAMJ,eAAe,GAAG,MAAM,KAAKrD,gBAAL,EAA9B;MACA,OAAOjM,YAAY,CAACsP,eAAD,EAAkB5Q,MAAM,CAACjB,WAAzB,CAAnB;IAGD;EAAA;;EAEYsH,eAAe;;MAC1B,MAAMuK,eAAe,GAAG,MAAM,KAAKrD,gBAAL,EAA9B;MACA,OAAOjM,YAAY,CAACsP,eAAD,EAAkB5Q,MAAM,CAACc,MAAzB,CAAnB;IAGD;EAAA;;EAEY2C,MAAM;;MACjB,IAAI,CAAC,KAAKiL,SAAV,EAAqB;QACnB,OAAO,SAAP;MACD;;MAED,MAAMtN,EAAE,GAAG,MAAM,KAAK4P,oBAAL,EAAjB;;MACA,IAAI,CAAC5P,EAAL,EAAS;QACP,OAAO,SAAP;MACD;;MAED,OAAOA,EAAE,CAACW,QAAH,CAAYqB,gBAAZ,CAA6BK,MAApC;IACD;EAAA;;EAEYwN,QAAQ;;MACnB,MAAM7P,EAAE,GAAG,MAAM,KAAK4P,oBAAL,EAAjB;MACA,MAAME,OAAO,GAAG,CAAC,GAAE,SAAF,MAAE,WAAF,GAAE,MAAF,KAAE,CAAEnP,QAAJ,CAAaqB,gBAAb,CAA8B2K,oBAA9B,KAAsD,EAAvD,EAA2D,CAA3D,CAAhB;MACA,OAAO,KAAKhV,OAAL,CAAaoY,MAAb,CAAoBC,EAApB,CAAgCF,OAAhC,CAAP;IACD;EAAA;;AAxCmH;;MCFzGG,mCAAmChD,gBAAe;EAC7DvV,YACkBwV,MADlB,EAEqBvV,OAFrB,EAGE8V,QAHF,EAGqC;IAEnC,MAAMP,MAAN,EAAcvV,OAAd,EAAuB8V,QAAvB;IAJgB;IACG;EAIpB;;EAEYxI,eAAe;;MAC1B,MAAMuK,eAAe,GAAG,MAAM,KAAKrD,gBAAL,EAA9B;MACA,OAAOqD,eAAe,CAACrR,IAAhB,CAAqBgE,CAAC,IAAIA,CAAC,CAACxD,IAAF,KAAWC,MAAM,CAACc,MAA5C,CAAP;IAGD;EAAA;;EAEYwQ,oBAAoB;;MAC/B,MAAMV,eAAe,GAAG,MAAM,KAAKrD,gBAAL,EAA9B;MACA,OAAOqD,eAAe,CAACrR,IAAhB,CAAqBgE,CAAC,IAAIA,CAAC,CAACxD,IAAF,KAAWC,MAAM,CAACO,WAA5C,CAAP;IAGD;EAAA;;EAEYkD,MAAM;;MACjB,IAAI,CAAC,KAAKiL,SAAV,EAAqB;QACnB,OAAO,SAAP;MACD;;MAED,MAAMtN,EAAE,GAAG,MAAM,KAAKkQ,oBAAL,EAAjB;;MACA,IAAI,CAAClQ,EAAL,EAAS;QACP,OAAO,SAAP;MACD;;MAED,OAAOA,EAAE,CAACW,QAAH,CAAYqB,gBAAZ,CAA6BK,MAApC;IACD;EAAA;;AAlC4D;;ACExD,MAAM8N,mCAAmC,GAAG,CACjDC,YADiD,EAEjDzY,OAFiD,EAGjD0Y,SAHiD,KAGxB;EAEzB,OAAOD,YAAY,CAACnN,IAAb,CACLM,WAAW,CACT5L,OAAO,CAACwL,MAAR,CAAemC,gCAAf,GAAkD,IADzC,EAET7B,UAAU,CAAC,IAAIxL,KAAJ,CAAU,gCAAV,CAAD,CAFD,EAGToY,SAHS,CADN,EAML3M,WAAW,CAAC;IACVC,QAAQ,EAAE,IADA;IAEV0M;EAFU,CAAD,CANN,CAAP;AAWD,CAhBM;;MAsBMC,iBAAgB;EAC3B5Y,YAAoBC,OAApB,EAAoC;IAAhB,uBAAgB;;IAG5B,qBAAgByL,KAAK,CAAC;MAC5B,OAAO3K,gCAAgC,CAAC,KAAKd,OAAL,CAAa0L,MAAb,CAAoBC,cAApB,CAAmC,MAAnC,CAAD,CAAvC;IACD,CAF4B,CAArB;EAHgC;;EAO1BiN,uBAAuB;;MACnC,OAAOJ,mCAAmC,CAAC,KAAKK,aAAN,EAAqB,KAAK7Y,OAA1B,CAA1C;IACD;EAAA;;EAEO8Y,qBAAqB,CAACC,UAAD,EAAqBC,KAAK,GAAG,CAA7B,EAA8B;IACzD,OAAOlW,IAAI,CAAC,KAAK9C,OAAL,CAAakP,YAAb,CAA0BoH,QAA1B,CAAmCyC,UAAnC,CAAD,CAAJ,CAAwEzN,IAAxE,CACLC,SAAS,CAAEgM,KAAD,IAAM;MACd,IAAIyB,KAAK,KAAK,CAAd,EAAiB;QACf,OAAO9L,EAAE,CAACqK,KAAD,CAAT;MACD;;MAED,OAAO0B,KAAK,CAAC1B,KAAK,CAACjL,MAAN,CAAaC,KAAd,EAAqByM,KAAK,GAAG,CAA7B,CAAL,CAAqC1N,IAArC,CACL4N,SAAS,CAAC3B,KAAD,CADJ,EAEL4B,SAAS,CAAQ5M,KAAP,IAAYnG;QACpB,OAAO,KAAKpG,OAAL,CAAakP,YAAb,CAA0BoH,QAA1B,CACL,OAAO/J,KAAP,KAAiB,QAAjB,GAA4BA,KAA5B,GAAoCA,KAAK,CAACD,MAAN,CAAaC,KAD5C,CAAP;MAGD,CAJqB,CAAb,CAFJ,CAAP;IAQD,CAbQ,CADJ,CAAP;EAgBD;;EAEa6M,8BAA8B,CAAC;IAAEC;EAAF,CAAD,EAA4C;;MACtF,MAAMC,kBAAkB,GAAgC,EAAxD;;MAEA,IAAID,eAAJ,EAAqB;QACnBC,kBAAkB,CAAClP,IAAnB,CAAwB,KAAK0O,qBAAL,CAA2BO,eAA3B,CAAxB;MACD;;MAEDC,kBAAkB,CAAClP,IAAnB,CAAwB,MAAM,KAAKwO,uBAAL,EAA9B;MAEA,OAAOjO,MAAM,CAAC,GAAG2O,kBAAJ,CAAb;IACD;EAAA;;EAEKC,eAAe,CACnBrO,IADmB,EAEnBM,SAAiC,EAFd,EAEgB;;MAEnC,OAAO,IAAI8J,eAAJ,CACLpK,IADK,EAEL,KAAKlL,OAAL,CAAauR,KAAb,EAFK,EAGL,MAAM,KAAK6H,8BAAL,CAAoC5N,MAApC,CAHD,CAAP;IAKD;EAAA;;EAEKgO,oBAAoB,CACxBtO,IADwB,EAExBM,SAAiC,EAFT,EAEW;;MAEnC,OAAO,IAAIoM,oBAAJ,CACL1M,IADK,EAEL,KAAKlL,OAAL,CAAauR,KAAb,EAFK,EAGL,MAAM,KAAK6H,8BAAL,CAAoC5N,MAApC,CAHD,CAAP;IAKD;EAAA;;EAEKiO,0BAA0B,CAC9BvO,IAD8B,EAE9BM,SAAiC,EAFH,EAEK;;MAEnC,OAAO,IAAI8M,0BAAJ,CACLpN,IADK,EAEL,KAAKlL,OAAL,CAAauR,KAAb,EAFK,EAGL,MAAM,KAAK6H,8BAAL,CAAoC5N,MAApC,CAHD,CAAP;IAKD;EAAA;;EAEKkO,yBAAyB,CAC7BxO,IAD6B,EAE7BM,SAAiC,EAFJ,EAEM;;MAEnC,OAAO,IAAIsM,yBAAJ,CACL5M,IADK,EAEL,KAAKlL,OAAL,CAAauR,KAAb,EAFK,EAGL,MAAM,KAAK6H,8BAAL,CAAoC5N,MAApC,CAHD,CAAP;IAKD;EAAA;;EAEK/F,0BAA0B,CAC9ByF,IAD8B,EAE9BM,SAAiC,EAFH,EAEK;;MAEnC,OAAO,IAAIwM,0BAAJ,CACL9M,IADK,EAEL,KAAKlL,OAAL,CAAauR,KAAb,EAFK,EAGL,MAAM,KAAK6H,8BAAL,CAAoC5N,MAApC,CAHD,CAAP;IAKD;EAAA;;AAhG0B;;MCnBhBmO,sBAAsB/K,iBAAgB;EACjD7O,YAAYC,OAAZ,EAA4B;IAC1B,MAAMA,OAAN;EACD;;EAEK4Z,UAAU,CAACzB,OAAD,EAAgB;;MAC9B,IAAIxF,eAAe,CAACwF,OAAD,CAAf,KAA6BtL,gBAAgB,CAACC,KAAlD,EAAyD;QACvD,MAAM,IAAI8F,mBAAJ,CAAwBuF,OAAxB,CAAN;MACD;;MACD,OAAO,KAAKnY,OAAL,CAAakP,YAAb,CAA0B0K,UAA1B,CAAqCzB,OAArC,EAA8C,MAA9C,CAAP;IACD;EAAA;;EAEK0B,WAAW,CAAC1B,OAAD,EAAgB;;MAC/B,IAAIxF,eAAe,CAACwF,OAAD,CAAf,KAA6BtL,gBAAgB,CAACC,KAAlD,EAAyD;QACvD,MAAM,IAAI8F,mBAAJ,CAAwBuF,OAAxB,CAAN;MACD;;MACD,OAAO,KAAKnY,OAAL,CAAakP,YAAb,CAA0B2K,WAA1B,CAAsC1B,OAAtC,EAA+C,MAA/C,CAAP;IACD;EAAA;;EAEK2B,QAAQ,CAAC/K,GAAD,EAAckE,MAAd,EAA4B;;MACxC,IAAIC,eAAe,CAACnE,GAAD,CAAf,KAAyBlC,gBAAgB,CAACC,KAA9C,EAAqD;QACnD,MAAM,IAAIqG,mBAAJ,CAAwBpE,GAAxB,CAAN;MACD;;MACD,MAAMhI,SAAS,GAAyB;QACtCC,IAAI,EAAEC,MAAM,CAACuJ,UADyB;QAEtCzB,GAFsC;QAGtCkE;MAHsC,CAAxC;MAMA,MAAMiB,QAAQ,GAAG,MAAM,KAAK7E,gBAAL,CAAsB;QAAEtI,SAAS,EAAE,CAACA,SAAD,CAAb;QAA0B/C,MAAM,EAAE+K;MAAlC,CAAtB,CAAvB;MACA,MAAMkC,WAAW,GAAG,MAAM,KAAKD,KAAL,CAAWkD,QAAX,CAA1B;MACA,MAAM6F,KAAK,GAAG,GAAG9I,WAAW,CAACE,OAAO,kIAApC;MACA,OAAO,IAAIlG,SAAJ,CACL,MAAM,KAAK9K,GAAL,CAASC,eAAT,CAAyB2Z,KAAzB,CADD,EACgCzR,gCAChC2I,WADgC,GACrB;QAAEE,OAAO,EAAE4I;MAAX,CADqB,CADhC,EAGL,EAHK,EAIL,KAAK/Z,OAAL,CAAauR,KAAb,EAJK,CAAP;IAMD;EAAA;;AAtCgD;;ACfnD,MAAMyI,iBAAiB,GAAG,GAA1B;AACA,MAAMC,0BAA0B,GAAG,CAAnC;AACA,MAAMC,yBAAyB,GAAG,GAAlC;AAEA,MAAMC,UAAU,GAAG,GAAnB;AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAoCaC,SAAQ;EACnBra,YACmBsa,cADnB,EAEmBC,aAFnB,EAGkBC,MAHlB,EAImBC,6BAJnB;;;;EAQmBC,eAAgCT,iBARnD,EAQoE;IAPjD;IACA;IACD;IACC;IAIA;EACf;;;;;;EAKY,IAAZU,YAAY;IACd,OAAO,KAAKC,OAAL,CAAajO,MAAM,CAAC,KAAKxG,YAAN,CAAN,GAA4BwG,MAAM,CAAC,KAAK8N,6BAAN,CAA/C,CAAP;EACD;;;;;;EAKe,IAAZtU,YAAY;IACd,MAAM0U,KAAK,GAAGvX,IAAI,CAACwX,GAAL,CAASnO,MAAM,CAAC,KAAK4N,aAAN,CAAf,EAAqC,CAArC,CAAd;IACA,OAAOM,KAAK,GAAG,CAAR,GAAYA,KAAZ,GAAoB,CAA3B;EACD;;;;;;EAKW,IAAR3U,QAAQ;IACV,OAAO,KAAK0U,OAAL,CAAajO,MAAM,CAAC,KAAK2N,cAAN,CAAN,GAA8B,IAA9B,GAAqCF,UAAlD,CAAP;EACD;;EAE4B,IAAjBW,iBAAiB;IAC3B,OACE,CAACpO,MAAM,CAAC,KAAK2N,cAAN,CAAN,GAA8B,IAA9B,GAAqCF,UAAtC,IAAoDD,yBAApD,GACAxN,MAAM,CAAC,KAAK6N,MAAN,CAAN,GAAsBN,0BAFxB;EAID;;EAEOU,OAAO,CAACI,OAAD,EAAgB;IAC7B,OAAO1X,IAAI,CAAC2X,IAAL,CAAUtO,MAAM,CAACqO,OAAD,CAAhB,CAAP;EACD;;;;;;EAKkB,IAAfE,eAAe;IACjB,OAAO,KAAKN,OAAL,CAAaX,iBAAiB,GAAG,KAAKc,iBAAtC,CAAP;EACD;;;;;;EAKoB,IAAjB9I,iBAAiB;IACnB,OAAO,KAAK2I,OAAL,CAAa,KAAKG,iBAAL,GAAyBd,iBAAiB,GAAG,CAA1D,CAAP;EACD;;;;;;EAKoB,IAAjBkB,iBAAiB;IACnB,OACE7X,IAAI,CAACwX,GAAL,CAASnO,MAAM,CAAC,KAAK+N,YAAN,CAAf,EAAoCT,iBAApC,IAAyD,KAAKW,OAAL,CAAa,KAAKG,iBAAlB,CAD3D;EAGD;;;;;;EAKY,IAATK,SAAS;IACX,OAAO,KAAKF,eAAL,GAAuB,KAAKP,YAAnC;EACD;;;;;;;EAMmB,IAAhBU,gBAAgB;IAClB,OAAO1O,MAAM,CAAC,KAAK2N,cAAN,CAAb;EACD;;EAE0C,OAApCgB,oCAAoC,CAACC,kBAAD,EAAyC;IAClF,IAAIC,aAAa,GAAG,CAApB;IACA,IAAIrV,YAAY,GAAG,CAAnB;IACA,IAAIqU,MAAM,GAAG,CAAb;IACA,IAAIC,6BAA6B,GAAG,CAApC;IACA,IAAIC,YAAJ;IAEAa,kBAAkB,CAAC/Q,OAAnB,CAA4BiH,QAAD,IAAS;MAClC+J,aAAa,IAAI/J,QAAQ,CAAC+J,aAA1B;MACArV,YAAY,IAAIsL,QAAQ,CAACtL,YAAzB;MACAqU,MAAM,IAAI/I,QAAQ,CAAC+I,MAAnB;MACAC,6BAA6B,GAAGnX,IAAI,CAACwX,GAAL,CAC9BrJ,QAAQ,CAACgJ,6BADqB,EAE9BA,6BAF8B,CAAhC;;MAIA,IAAIhJ,QAAQ,CAACiJ,YAAb,EAA2B;QACzBA,YAAY,GAAGA,YAAY,GAAGA,YAAY,GAAGjJ,QAAQ,CAACiJ,YAA3B,GAA0CjJ,QAAQ,CAACiJ,YAA9E;MACD;IACF,CAXD;IAYA,OAAO,IAAIL,QAAJ,CACLmB,aADK,EAELrV,YAFK,EAGLqU,MAHK,EAILC,6BAJK,EAKLC,YALK,CAAP;EAOD;;EAEgD,OAA1Ce,0CAA0C,CAACF,kBAAD,EAAyC;IACxF,OAAOA,kBAAkB,CAACpP,GAAnB,CACJ1B,CAAD,IACE,IAAI4P,QAAJ,CACE5P,CAAC,CAAC+Q,aADJ,EAEE/Q,CAAC,CAACtE,YAFJ,EAGEsE,CAAC,CAAC+P,MAHJ,EAIE/P,CAAC,CAACgQ,6BAJJ,EAKEhQ,CAAC,CAACiQ,YALJ,CAFG,CAAP;EAUD;;AA1HkB;AClDrB;;;;;;MAIagB,4BAA4Bnb,MAAK;EAE5CP;IACE,MAAM,oEAAN;IAFF,YAAO,uBAAP;EAGC;;AAJ2C;;ACyC9C,MAAM2b,WAAW,GAAG,CAClBC,gBADkB,EAElBC,aAFkB,KAEa;EAE/B,OAAO;IACL7V,GAAG,EAAE,OAAO4V,gBAAgB,CAAC5V,GAAxB,KAAgC,WAAhC,GAA8C6V,aAAa,CAAC7V,GAA5D,GAAkE4V,gBAAgB,CAAC5V,GADnF;IAELE,QAAQ,EACN,OAAO0V,gBAAgB,CAAC1V,QAAxB,KAAqC,WAArC,GACI2V,aAAa,CAAC3V,QADlB,GAEI0V,gBAAgB,CAAC1V,QALlB;IAMLC,YAAY,EACV,OAAOyV,gBAAgB,CAACzV,YAAxB,KAAyC,WAAzC,GACI0V,aAAa,CAAC1V,YADlB,GAEIyV,gBAAgB,CAACzV;EATlB,CAAP;AAWD,CAfD,C,CAiBA;;;AACA,MAAM2V,cAAc,GAClB,qGADF;;MAGaC,4BAA4BlN,iBAAgB;EAAzD7O;;IACmB,0BAAqB,GAArB;IACA,2BAAsB,GAAtB;IACA,sBAAiB,GAAjB;EAwblB;;EAtbegc,OAAO;;MAInB,MAAMC,kBAAkB,GAAG,KAAKhc,OAAL,CAAaic,qBAAb,EAA3B;MACA,OAAO;QACLxb,aAAa,EAAEub,kBAAkB,GAC7B,MAAM,KAAKnN,MAAL,CAAYpO,aAAZ,EADuB,GAE7B,MAAM,KAAKT,OAAL,CAAakc,cAAb,CAA4BC,MAA5B,EAHL;QAIL3b,SAAS,EAAEwb,kBAAkB,GAAG,MAAM,KAAKnN,MAAL,CAAYrO,SAAZ,EAAT,GAAmC6F;MAJ3D,CAAP;IAMD;EAAA,CAhBsD;;;EAmBzC+V,gBAAgB,CAC5BrN,GAD4B,EAE5BsN,SAF4B,EAS5BC,WAT4B,EASR;;MAEpB,MAAM1W,OAAO,GAAG,MAAM,KAAK5F,OAAL,CAAakP,YAAb,CAA0B0K,UAA1B,CAAqC7K,GAArC,EAA0C,MAA1C,CAAtB;MACA,MAAM;QACJwN,4BADI;QAEJC,wBAFI;QAGJC,gCAHI;QAIJC;MAJI,IAKFL,SALJ;MAMA,OAAO;QACLtW,GAAG,EAAE,CADA;QAELE,QAAQ,EAAEqW,WAAW,GACjBjZ,IAAI,CAACsZ,KAAL,CACE,KAAKC,yBAAL,CACEJ,wBADF,EAEED,4BAFF,EAGED,WAHF,EAIEO,QAJF,EADF,CADiB,GAQjBN,4BAA4B,CAACM,QAA7B,EAVC;QAWL3W,YAAY,EAAE7C,IAAI,CAACsZ,KAAL,CACZzZ,SAAS,CAAC6T,GAAV,CAAcnR,OAAO,CAACrC,SAAR,CAAkBmZ,aAAlB,CAAd,EAAgDD,gCAAhD,EAAkFI,QAAlF,EADY;MAXT,CAAP;IAeD;EAAA,CApDsD;;;;;;EA0D/CD,yBAAyB,CAC/BE,aAD+B,EAE/BC,UAF+B,EAG/BT,WAH+B,EAGZ;IAEnB,OAAOpZ,SAAS,CAAC6T,GAAV,CAAcgG,UAAd,EAA0BD,aAAa,CAACE,GAAd,CAAkBV,WAAW,GAAG,CAAhC,CAA1B,CAAP;EACD;;EAEOW,2CAA2C,CACjD9S,OADiD,EAEjD+S,IAFiD,EAGjDC,WAHiD,EAG3B;IAEtB,MAAM3I,gBAAgB,GAAG5K,sBAAsB,CAAC;MAAEM,QAAQ,EAAE,CAACC,OAAD;IAAZ,CAAD,CAA/C;IACA,IAAIsK,QAAQ,GAAG,CAAf;IACA,IAAI2I,aAAa,GAAG,CAApB;IACA,IAAI1I,YAAY,GAAG,CAAnB;IACAF,gBAAgB,CAACjK,OAAjB,CAA0BZ,MAAD,IAAO;MAC9B+K,YAAY,IACV,0BAA0B/K,MAA1B,IAAoC,OAAOA,MAAM,CAACqL,oBAAd,KAAuC,WAA3E,GACIrL,MAAM,CAACqL,oBAAP,CAA4BpR,MAA5B,GAAqC,KAAKyZ,mBAD9C,GAEI,CAHN;MAIA3I,YAAY,IAAI,oCAAoC/K,MAApC,GAA6C,KAAK2T,kBAAlD,GAAuE,CAAvF;MACA7I,QAAQ,IAAI/H,MAAM,CAAC/C,MAAM,CAACsL,YAAR,CAAN,IAA+B,CAA3C;MACAmI,aAAa,IAAI1Q,MAAM,CAAC/C,MAAM,CAAC4T,iBAAR,CAAN,IAAoC,CAArD;MACA7I,YAAY,IACV,4BAA4B/K,MAA5B,GAAqC+C,MAAM,CAAC/C,MAAM,CAACuL,sBAAR,CAAN,IAAyC,CAA9E,GAAkF,CADpF;MAEAR,YAAY,IACV,kBAAkB/K,MAAlB,IAA4B,oBAAoBA,MAAhD,GACI+C,MAAM,CAAC/C,MAAM,CAAC6T,YAAR,CAAN,IAA+B,CADnC,GAEI,CAHN;IAID,CAdD;;IAgBA,IAAI/I,QAAQ,KAAK,CAAb,IAAkB2I,aAAa,KAAK,CAAxC,EAA2C;;MAEzCA,aAAa,GAAG3I,QAAQ,GAAG,IAA3B;IACD;;IAED,IAAI9L,WAAW,CAACwB,OAAD,CAAf,EAA0B;MACxB,OAAO;QACLoR,aAAa,EAAE6B,aAAa,IAAI,CAD3B;QAELlX,YAAY,EAAEwG,MAAM,CAACgI,YAAY,IAAI,CAAjB,CAFf;QAGL6F,MAAM,EAAE2C,IAHH;QAIL1C,6BAA6B,EAAE2C,WAAW,CAACN,QAAZ;MAJ1B,CAAP;IAMD,CAPD,MAOO;MACL,OAAO;QACLtB,aAAa,EAAE,CADV;QAELrV,YAAY,EAAE,CAFT;QAGLqU,MAAM,EAAE2C,IAHH;QAIL1C,6BAA6B,EAAE2C,WAAW,CAACN,QAAZ,EAJ1B;QAKLpC,YAAY,EAAE;MALT,CAAP;IAOD;EACF;;EAEagD,eAAe,CAC3BvP,MAD2B,EAE3BmO,SAF2B,EAG3BtN,GAH2B,EAGhB;;MAEX,MAAMmF,QAAQ,GAAG,MAAM,KAAK7E,gBAAL,CAAsBnB,MAAtB,EAA8Ba,GAA9B,CAAvB;MACA,MAAM;QACJoC,OADI;QAEJL,IAAI,EAAE;UAAEC,MAAF;UAAU7G;QAAV;MAFF,IAGF,MAAM,KAAK8G,KAAL,CAAWkD,QAAX,CAHV;MAIA,MAAMnN,SAAS,GAAyB;QACtCA,SAAS,EAAE;UAAEgK,MAAF;UAAU7G,QAAV;UAAoBmI,SAAS,EAAEwJ;QAA/B,CAD2B;QAEtC6B,QAAQ,EAAE,MAAM,KAAK1d,OAAL,CAAakP,YAAb,CAA0ByO,UAA1B;MAFsB,CAAxC;MAKA,MAAM;QAAEtM;MAAF,IAAiB,MAAM,KAAKD,QAAL,CAAcrK,SAAd,CAA7B;MACA,MAAM;QAAE2V;MAAF,IAAoBL,SAA1B;MACA,MAAMjT,MAAM,GAAG,CAAC,GAAGqB,aAAa,CAAC4G,UAAD,EAAa,aAAb,CAAjB,EAA8C,GAAG5G,aAAa,CAAC4G,UAAD,CAA9D,CAAf;;MAGA,IAAIjI,MAAM,CAACxF,MAAX,EAAmB;QACjB,MAAM,IAAIuF,mBAAJ,CAAwBC,MAAxB,EAAgC,kCAAhC,CAAN;MACD;;MAED,IAAIkT,WAAW,GAAG,CAAlB;;MACA,IAAItX,KAAK,CAACC,OAAN,CAAciJ,MAAM,CAACnH,SAArB,KAAmCmH,MAAM,CAACnH,SAAP,CAAiBnD,MAAjB,GAA0B,CAAjE,EAAoE;QAClE0Y,WAAW,GACTjL,UAAU,CAACnH,QAAX,CAAoB,CAApB,EAAuBlD,IAAvB,KAAgC,QAAhC,GACIkH,MAAM,CAACnH,SAAP,CAAiBnD,MAAjB,GAA0B,CAD9B,GAEIsK,MAAM,CAACnH,SAAP,CAAiBnD,MAHvB;MAID;;MAED,OAAOyN,UAAU,CAACnH,QAAX,CAAoBgC,GAApB,CAAyB1B,CAAD,IAAE;QAC/B,OAAO,KAAKyS,2CAAL,CACLzS,CADK;QAGLA,CAAC,CAACxD,IAAF,KAAW,QAAX,GAAsB,KAAK4W,cAAL,GAAsB,CAA5C,GAAgDzM,OAAO,CAACvN,MAAR,GAAiB,CAAjB,GAAqB0Y,WAHhE,EAILI,aAJK,CAAP;MAMD,CAPM,CAAP;IAQD;EAAA;;;;;;;;;;;EAUKmB,SAAS,CAACpM,EAAD,EAA0D;QAAzD;MAAE1L,GAAF;MAAOG,YAAP;MAAqBD;IAArB,IAA6BwL;QAAKE,IAAI,cAAtC,mCAAsC;;;MACpD,MAAM;QAAElR;MAAF,IAAoB,MAAM,KAAKsb,OAAL,EAAhC;MACA,MAAM+B,iBAAiB,GAAG,MAAM,KAAK9d,OAAL,CAAakP,YAAb,CAA0B6O,oBAA1B,CAA+C,MAA/C,CAAhC;MACA,MAAMC,cAAc,GAAG,MAAM,KAAK5B,gBAAL,CAAsB3b,aAAtB,EAAqCqd,iBAArC,CAA7B;MACA,MAAMzV,EAAE,GAAG,MAAM5C,0BAA0B,CACzC,MAAM,KAAKzF,OAAL,CAAawT,MAAb,CAAoBC,sBAApB,CAA0CnL,gCAC3CqJ,IAD2C,GAE3C+J,WAAW,CAAC;QAAE3V,GAAF;QAAOG,YAAP;QAAqBD;MAArB,CAAD,EAAkC+X,cAAlC,CAFgC,CAA1C,CADmC,CAA3C;MAMA,MAAMC,cAAc,GAAG,MAAM,KAAKnP,gBAAL,CAAsB,CAACzG,EAAD,CAAtB,EAA4B5H,aAA5B,CAA7B;MACA,MAAM8O,GAAG,GAAG0O,cAAc,GAAG,MAAM,KAAKC,WAAL,CAAiB,CAAC7V,EAAD,CAAjB,EAAuB5H,aAAvB,CAAT,GAAiD4H,EAA3E;MACA,MAAMiT,kBAAkB,GAAG,MAAM,KAAKmC,eAAL,CAC/B;QAAE1W,SAAS,EAAEwI,GAAb;QAAkBvL,MAAM,EAAEvD;MAA1B,CAD+B,EAE/Bqd,iBAF+B,EAG/Brd,aAH+B,CAAjC;;MAKA,IAAIwd,cAAJ,EAAoB;QAClB3C,kBAAkB,CAAC6C,KAAnB;MACD;;MACD,OAAO/D,QAAQ,CAACiB,oCAAT,CAA8CC,kBAA9C,CAAP;;EACD;;;;;;;;;;;EASK8C,QAAQ,CAAC3M,EAAD,EAAyD;QAAxD;MAAE1L,GAAF;MAAOG,YAAP;MAAqBD;IAArB,IAA6BwL;QAAKE,IAAI,cAAtC,mCAAsC;;;MACnD,IAAIgB,eAAe,CAAChB,IAAI,CAAC5O,EAAN,CAAf,KAA6B8J,gBAAgB,CAACC,KAAlD,EAAyD;QACvD,MAAM,IAAI8F,mBAAJ,CAAwBjB,IAAI,CAAC5O,EAA7B,CAAN;MACD;;MACD,IAAI4O,IAAI,CAAC3N,MAAL,IAAe2O,eAAe,CAAChB,IAAI,CAAC3N,MAAN,CAAf,KAAiC6I,gBAAgB,CAACC,KAArE,EAA4E;QAC1E,MAAM,IAAI8F,mBAAJ,CAAwBjB,IAAI,CAAC3N,MAA7B,CAAN;MACD;;MACD,MAAM+K,GAAG,GAAG,CAAC,MAAM,KAAKgN,OAAL,EAAP,EAAuBtb,aAAnC;MACA,MAAMqd,iBAAiB,GAAG,MAAM,KAAK9d,OAAL,CAAakP,YAAb,CAA0B6O,oBAA1B,CAA+C,MAA/C,CAAhC;MACA,MAAMC,cAAc,GAAG,MAAM,KAAK5B,gBAAL,CAAsBrN,GAAtB,EAA2B+O,iBAA3B,CAA7B;MACA,MAAMzV,EAAE,GAAG,MAAMhB,uBAAuB,iCACnCsK,IADmC,GAEnC+J,WAAW,CAAC;QAAE3V,GAAF;QAAOG,YAAP;QAAqBD;MAArB,CAAD,EAAkC+X,cAAlC,CAFwB,EAAxC;MAIA,MAAMC,cAAc,GAAG,MAAM,KAAKnP,gBAAL,CAAsB,CAACzG,EAAD,CAAtB,EAA4B0G,GAA5B,CAA7B;MACA,MAAMQ,GAAG,GAAG0O,cAAc,GAAG,MAAM,KAAKC,WAAL,CAAiB,CAAC7V,EAAD,CAAjB,EAAuB0G,GAAvB,CAAT,GAAuC1G,EAAjE;MACA,MAAMiT,kBAAkB,GAAG,MAAM,KAAKmC,eAAL,CAC/B;QAAE1W,SAAS,EAAEwI,GAAb;QAAkBvL,MAAM,EAAE+K;MAA1B,CAD+B,EAE/B+O,iBAF+B,EAG/B/O,GAH+B,CAAjC;;MAKA,IAAIkP,cAAJ,EAAoB;QAClB3C,kBAAkB,CAAC6C,KAAnB;MACD;;MACD,OAAO/D,QAAQ,CAACiB,oCAAT,CAA8CC,kBAA9C,CAAP;;EACD;;;;;;;;;;;EAUK+C,WAAW,CAAC5M,EAAD,EAAyD;QAAxD;MAAE1L,GAAF;MAAOE,QAAP;MAAiBC;IAAjB,IAA6BuL;QAAKE,IAAI,cAAtC,mCAAsC;;;MACtD,IAAIA,IAAI,CAAC3N,MAAL,IAAe2O,eAAe,CAAChB,IAAI,CAAC3N,MAAN,CAAf,KAAiC6I,gBAAgB,CAACC,KAArE,EAA4E;QAC1E,MAAM,IAAI8F,mBAAJ,CAAwBjB,IAAI,CAAC3N,MAA7B,CAAN;MACD;;MACD,IAAI2N,IAAI,CAAC9L,QAAL,IAAiB8M,eAAe,CAAChB,IAAI,CAAC9L,QAAN,CAAf,KAAmCgH,gBAAgB,CAACC,KAAzE,EAAgF;QAC9E,MAAM,IAAI8F,mBAAJ,CAAwBjB,IAAI,CAAC9L,QAA7B,CAAN;MACD;;MAED,MAAMkJ,GAAG,GAAG,CAAC,MAAM,KAAKgN,OAAL,EAAP,EAAuBtb,aAAnC;MACA,MAAM6d,eAAe,GAAG3M,IAAI,CAAC3N,MAAL,IAAe+K,GAAvC;MACA,MAAM+O,iBAAiB,GAAG,MAAM,KAAK9d,OAAL,CAAakP,YAAb,CAA0B6O,oBAA1B,CAA+C,MAA/C,CAAhC;MACA,MAAMC,cAAc,GAAG,MAAM,KAAK5B,gBAAL,CAAsBkC,eAAtB,EAAuCR,iBAAvC,CAA7B;MACA,MAAMzV,EAAE,GAAG,MAAMV,0BAA0B,iCACtCgK,IADsC,GAEtC+J,WAAW,CAAC;QAAE3V,GAAF;QAAOG,YAAP;QAAqBD;MAArB,CAAD,EAAkC+X,cAAlC,CAF2B,EAA3C;MAIA,MAAMC,cAAc,GAAG,MAAM,KAAKnP,gBAAL,CAAsB,CAACzG,EAAD,CAAtB,EAA4B0G,GAA5B,CAA7B;MACA,MAAMQ,GAAG,GAAG0O,cAAc,GAAG,MAAM,KAAKC,WAAL,CAAiB,CAAC7V,EAAD,CAAjB,EAAuB0G,GAAvB,CAAT,GAAuC1G,EAAjE;MACA,MAAMiT,kBAAkB,GAAG,MAAM,KAAKmC,eAAL,CAC/B;QAAE1W,SAAS,EAAEwI,GAAb;QAAkBvL,MAAM,EAAE+K;MAA1B,CAD+B,EAE/B+O,iBAF+B,EAG/B/O,GAH+B,CAAjC;;MAKA,IAAIkP,cAAJ,EAAoB;QAClB3C,kBAAkB,CAAC6C,KAAnB;MACD;;MACD,OAAO/D,QAAQ,CAACiB,oCAAT,CAA8CC,kBAA9C,CAAP;;EACD;;;;;;;;;EAQK1H,KAAK,CAAC1F,MAAD,EAAyB;;MAClC,MAAM;QAAEzN;MAAF,IAAoB,MAAM,KAAKsb,OAAL,EAAhC;MACA,IAAI3P,UAAU,GAAmB,EAAjC;MACA,MAAM0R,iBAAiB,GAAG,MAAM,KAAK9d,OAAL,CAAakP,YAAb,CAA0B6O,oBAA1B,CAA+C,MAA/C,CAAhC;MACA,MAAMC,cAAc,GAAG,MAAM,KAAK5B,gBAAL,CAC3B3b,aAD2B,EAE3Bqd,iBAF2B,EAG3B5P,MAAM,CAACtK,MAHoB,CAA7B;;MAKA,KAAK,MAAM2P,KAAX,IAAoBrF,MAApB,EAA4B;QAC1B,QAAQqF,KAAK,CAACvM,IAAd;UACE,KAAKC,MAAM,CAACO,WAAZ;YACE4E,UAAU,CAAChC,IAAX,CACE,MAAM/C,uBAAuB,iCACxBkM,KADwB,GAExBmI,WAAW,CAACnI,KAAD,EAAQyK,cAAR,CAFa,EAD/B;YAMA;;UACF,KAAK/W,MAAM,CAACjB,WAAZ;YACEoG,UAAU,CAAChC,IAAX,CACE,MAAM3E,0BAA0B,CAC9B,MAAM,KAAKzF,OAAL,CAAawT,MAAb,CAAoBC,sBAApB,CAA0CnL,gCAC3CiL,KAD2C,GAE3CmI,WAAW,CAACnI,KAAD,EAAQyK,cAAR,CAFgC,CAA1C,CADwB,CADlC;YAQA;;UACF,KAAK/W,MAAM,CAACW,UAAZ;YACEwE,UAAU,CAAChC,IAAX,CACE,MAAMzC,0BAA0B,iCAC3B4L,KAD2B,GAE3BmI,WAAW,CAACnI,KAAD,EAAQyK,cAAR,CAFgB,EADlC;YAMA;;UACF,KAAK/W,MAAM,CAACuJ,UAAZ;YACEpE,UAAU,CAAChC,IAAX,CAAe9B,gCACViL,KADU,GAEVyK,cAFU,CAAf;YAIA;;UACF,KAAK/W,MAAM,CAACkB,wBAAZ;YACEiE,UAAU,CAAChC,IAAX,CACE,MAAMnC,qCAAqC,iCACtCsL,KADsC,GAEtCmI,WAAW,CAACnI,KAAD,EAAQyK,cAAR,CAF2B,EAD7C;YAMA;;UACF;YACE,MAAM,IAAInN,yBAAJ,CAA+B3C,MAAc,CAAClH,IAA9C,CAAN;QA1CJ;MA4CD;;MACD,MAAMiX,cAAc,GAAG,MAAM,KAAKnP,gBAAL,CAAsB1C,UAAtB,EAAkC3L,aAAlC,CAA7B;MACA2L,UAAU,GAAG6R,cAAc,GAAG,MAAM,KAAKC,WAAL,CAAiB9R,UAAjB,EAA6B3L,aAA7B,CAAT,GAAuD2L,UAAlF;MACA,MAAMkP,kBAAkB,GAAG,MAAM,KAAKmC,eAAL,CAC/B;QAAE1W,SAAS,EAAEqF,UAAb;QAAyBpI,MAAM,EAAEvD;MAAjC,CAD+B,EAE/Bqd,iBAF+B,EAG/Brd,aAH+B,CAAjC;MAMA,OAAO2Z,QAAQ,CAACoB,0CAAT,CAAoDF,kBAApD,CAAP;IACD;EAAA;;;;;;;;;;;EAUKiD,gBAAgB,CAACrQ,MAAD,EAA+B;;MACnD,MAAMa,GAAG,GAAG,CAAC,MAAM,KAAKgN,OAAL,EAAP,EAAuBtb,aAAnC;MACA,MAAMqd,iBAAiB,GAAG,MAAM,KAAK9d,OAAL,CAAakP,YAAb,CAA0B6O,oBAA1B,CAA+C,MAA/C,CAAhC;MACA,MAAMC,cAAc,GAAG,MAAM,KAAK5B,gBAAL,CAAsBrN,GAAtB,EAA2B+O,iBAA3B,CAA7B;MACA,MAAMzV,EAAE,GAAG,MAAMR,+BAA+B,iCAAMqG,MAAN,GAAiB8P,cAAjB,GAAmCjP,GAAnC,CAAhD;MACA,MAAMkP,cAAc,GAAG,MAAM,KAAKnP,gBAAL,CAAsB,CAACzG,EAAD,CAAtB,EAA4B0G,GAA5B,CAA7B;MACA,MAAMQ,GAAG,GAAG0O,cAAc,GAAG,MAAM,KAAKC,WAAL,CAAiB,CAAC7V,EAAD,CAAjB,EAAuB0G,GAAvB,CAAT,GAAuC1G,EAAjE;MACA,MAAMiT,kBAAkB,GAAG,MAAM,KAAKmC,eAAL,CAC/B;QAAE1W,SAAS,EAAEwI,GAAb;QAAkBvL,MAAM,EAAE+K;MAA1B,CAD+B,EAE/B+O,iBAF+B,EAG/B/O,GAH+B,CAAjC;;MAKA,IAAIkP,cAAJ,EAAoB;QAClB3C,kBAAkB,CAAC6C,KAAnB;MACD;;MACD,OAAO/D,QAAQ,CAACiB,oCAAT,CAA8CC,kBAA9C,CAAP;IACD;EAAA;;;;;;;;;;;EAUKvH,MAAM,CAAC7F,MAAD,EAAsB;;MAChC,MAAM;QAAEzN,aAAF;QAAiBD;MAAjB,IAA+B,MAAM,KAAKub,OAAL,EAA3C;;MACA,IAAI,CAACvb,SAAL,EAAgB;QACd,MAAM,IAAIib,mBAAJ,EAAN;MACD;;MACD,IAAI,MAAM,KAAKzM,uBAAL,CAA6BvO,aAA7B,CAAV,EAAuD;QACrD,MAAMqd,iBAAiB,GAAG,MAAM,KAAK9d,OAAL,CAAakP,YAAb,CAA0B6O,oBAA1B,CAA+C,MAA/C,CAAhC;QACA,MAAMC,cAAc,GAAG,MAAM,KAAK5B,gBAAL,CAAsB3b,aAAtB,EAAqCqd,iBAArC,CAA7B;QACA,MAAMzV,EAAE,GAAG,MAAMP,qBAAqB,iCAE/BoG,MAF+B,GAG/B8P,cAH+B,GAKpCvd,aALoC,EAMpCD,SANoC,CAAtC;QAQA,MAAM8a,kBAAkB,GAAG,MAAM,KAAKmC,eAAL,CAC/B;UAAE1W,SAAS,EAAEsB,EAAb;UAAiBrE,MAAM,EAAEvD;QAAzB,CAD+B,EAE/Bqd,iBAF+B,EAG/Brd,aAH+B,CAAjC;QAKA,OAAO2Z,QAAQ,CAACiB,oCAAT,CAA8CC,kBAA9C,CAAP;MACD;IACF;EAAA;;;;;;;;;;;EAUKkD,sBAAsB,CAAC/M,EAAD,EAKG;QALF;MAC3B1L,GAD2B;MAE3BG,YAF2B;MAG3BD;IAH2B,IAGnBwL;QACLE,IAAI,cAJoB,mCAIpB;;;MAEP,MAAM5C,GAAG,GAAG,CAAC,MAAM,KAAKgN,OAAL,EAAP,EAAuBtb,aAAnC;MACA,MAAMqd,iBAAiB,GAAG,MAAM,KAAK9d,OAAL,CAAakP,YAAb,CAA0B6O,oBAA1B,CAA+C,MAA/C,CAAhC;MACA,MAAMC,cAAc,GAAG,MAAM,KAAK5B,gBAAL,CAAsBrN,GAAtB,EAA2B+O,iBAA3B,CAA7B;MACA,MAAMzV,EAAE,GAAG,MAAMJ,qCAAqC,iCACjD0J,IADiD,GAEjD+J,WAAW,CAAC;QAAE3V,GAAF;QAAOG,YAAP;QAAqBD;MAArB,CAAD,EAAkC+X,cAAlC,CAFsC,EAAtD;MAIA,MAAMC,cAAc,GAAG,MAAM,KAAKnP,gBAAL,CAAsB,CAACzG,EAAD,CAAtB,EAA4B0G,GAA5B,CAA7B;MACA,MAAMQ,GAAG,GAAG0O,cAAc,GAAG,MAAM,KAAKC,WAAL,CAAiB,CAAC7V,EAAD,CAAjB,EAAuB0G,GAAvB,CAAT,GAAuC1G,EAAjE;MACA,MAAMiT,kBAAkB,GAAG,MAAM,KAAKmC,eAAL,CAC/B;QAAE1W,SAAS,EAAEwI,GAAb;QAAkBvL,MAAM,EAAE+K;MAA1B,CAD+B,EAE/B+O,iBAF+B,EAG/B/O,GAH+B,CAAjC;;MAKA,IAAIkP,cAAJ,EAAoB;QAClB3C,kBAAkB,CAAC6C,KAAnB;MACD;;MACD,OAAO/D,QAAQ,CAACiB,oCAAT,CAA8CC,kBAA9C,CAAP;;EACD;;EAEa4C,WAAW,CAAC7V,EAAD,EAAqB0G,GAArB,EAAgC;;MACvD,MAAM;QAAEvO;MAAF,IAAgB,MAAM,KAAKub,OAAL,EAA5B;;MACA,IAAI,CAACvb,SAAL,EAAgB;QACd,MAAM,IAAIib,mBAAJ,EAAN;MACD;;MACDpT,EAAE,CAAC4L,OAAH,CACE,MAAMnM,qBAAqB,eAEpB;QACD/B,GAAG,EAAEtE,WAAW,CAACsG,MADhB;QAED9B,QAAQ,EAAEzE,iBAAiB,CAACuG,MAF3B;QAGD7B,YAAY,EAAExE,qBAAqB,CAACqG;MAHnC,CAFoB,GAQzBgH,GARyB,EASzB,MAAM,KAAKF,MAAL,CAAYrO,SAAZ,EATmB,CAD7B;MAaA,OAAO6H,EAAP;IACD;EAAA;;AA1bsD;ACvDzD;;;;;;;MAKaoW,0BAA0BxT,UAAS;EAE9ClL,YACEmL,IADF,EAEmBgD,MAFnB,EAGkBlK,MAHlB,EAIEmH,GAJF,EAKErB,OALF,EAME9J,OANF,EAMkB;IAEhB,MAAMkL,IAAN,EAAYC,GAAZ,EAAiBrB,OAAjB,EAA0B9J,OAA1B;IANiB;IACD;EAMjB;;EAEmB,IAAhBwU,gBAAgB;IAClB,MAAMkK,YAAY,GAChB1Z,KAAK,CAACC,OAAN,CAAc,KAAK6E,OAAnB,KACC,KAAKA,OAAL,CAAatD,IAAb,CAAkB6B,EAAE,IAAIA,EAAE,CAACrB,IAAH,KAAY,YAApC,CAFH;IAGA,MAAM2C,MAAM,GAAG+U,YAAY,IAAIA,YAAY,CAAC1V,QAA7B,IAAyC0V,YAAY,CAAC1V,QAAb,CAAsBqB,gBAA9E;IACA,OAAOV,MAAM,GAAGA,MAAH,GAAYtD,SAAzB;EACD;;EAES,IAANqE,MAAM;IACR,MAAM8J,gBAAgB,GAAG,KAAKA,gBAA9B;;IACA,IAAIA,gBAAJ,EAAsB;MACpB,OAAOA,gBAAgB,CAAC9J,MAAxB;IACD,CAFD,MAEO;MACL,OAAO,SAAP;IACD;EACF;;EAEW,IAAR7E,QAAQ;IACV,OAAO,KAAKA,QAAZ;EACD;;EAEsB,IAAnB8Y,mBAAmB;IACrB,OAAO,KAAK9Y,QAAL,KAAkB,KAAK7B,MAA9B;EACD;;EAEM,IAAH+B,GAAG;IACL,OAAO,KAAKmI,MAAL,CAAYnI,GAAnB;EACD;;EAEW,IAARE,QAAQ;IACV,OAAO,KAAKiI,MAAL,CAAYhH,SAAnB;EACD;;EAEe,IAAZhB,YAAY;IACd,OAAO,KAAKgI,MAAL,CAAY/G,aAAnB;EACD;;EAEc,IAAXsH,WAAW;IACb,MAAMA,WAAW,GAAG,KAAK+F,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBS,YAAnE;IACA,OAAOxG,WAAW,GAAGA,WAAH,GAAiBpI,SAAnC;EACD;;EAES,IAAN+C,MAAM;IACR,OAAO,KAAKoL,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBpL,MAAtD;EACD;;AAzD6C;ACDhD;;;;;;;MAKawV,6BACH3T,UAAS;EAQjBlL,YACEmL,IADF,EAEmBgD,MAFnB,EAGE/C,GAHF,EAIErB,OAJF,EAKE9J,OALF,EAMU6e,gBANV,EAM+C;IAE7C,MAAM3T,IAAN,EAAYC,GAAZ,EAAiBrB,OAAjB,EAA0B9J,OAA1B;IANiB;IAIT;IAIR,MAAM8e,mBAAmB,GAAG,KAAKtK,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBQ,oBAA3E;;IACA,IAAIhQ,KAAK,CAACC,OAAN,CAAc6Z,mBAAd,CAAJ,EAAwC;MACtC,KAAKC,eAAL,GAAuBD,mBAAmB,CAAC,CAAD,CAA1C;IACD;EACF;;EAES,IAANpU,MAAM;IACR,MAAM8J,gBAAgB,GAAG,KAAKA,gBAA9B;;IACA,IAAIA,gBAAJ,EAAsB;MACpB,OAAOA,gBAAgB,CAAC9J,MAAxB;IACD,CAFD,MAEO;MACL,OAAO,SAAP;IACD;EACF;;EAEmB,IAAhB8J,gBAAgB;IAClB,MAAMwK,aAAa,GACjBha,KAAK,CAACC,OAAN,CAAc,KAAK6E,OAAnB,KACC,KAAKA,OAAL,CAAatD,IAAb,CAAmB6B,EAAD,IAAQA,EAAE,CAACrB,IAAH,KAAY,aAAtC,CAFH;IAMA,MAAM2C,MAAM,GACVqV,aAAa,IACbjW,qBAAqB,CAACiW,aAAD,CADrB,IAEAA,aAAa,CAAChW,QAAd,CAAuBqB,gBAHzB;IAIA,OAAOV,MAAM,GAAGA,MAAH,GAAYtD,SAAzB;EACD;;EAEM,IAAHN,GAAG;IACL,OAAO,KAAKmI,MAAL,CAAYnI,GAAnB;EACD;;EAEW,IAARE,QAAQ;IACV,OAAO,KAAKiI,MAAL,CAAYhH,SAAnB;EACD;;EAEe,IAAZhB,YAAY;IACd,OAAO,KAAKgI,MAAL,CAAY/G,aAAnB;EACD;;EAEc,IAAXsH,WAAW;IACb,MAAMA,WAAW,GAAG,KAAK+F,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBS,YAAnE;IACA,OAAOxG,WAAW,GAAGA,WAAH,GAAiBpI,SAAnC;EACD;;EAEc,IAAXsI,WAAW;IACb,MAAMA,WAAW,GAAG,KAAK6F,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBU,sBAAnE;IACA,OAAOvG,WAAW,GAAGA,WAAH,GAAiBtI,SAAnC;EACD;;EAEc,IAAX4Y,WAAW;IACb,MAAMA,WAAW,GAAG,KAAKzK,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBgJ,YAAnE;IACA,OAAOyB,WAAW,GAAGA,WAAH,GAAiB5Y,SAAnC;EACD;;EAES,IAAN+C,MAAM;IACR,OAAO,KAAKoL,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBpL,MAAtD;EACD;;;;;;EAKK8O,QAAQ,CAACzK,aAAD,EAAyB5B,OAAzB,EAAyC;;MACrD,IAAI,CAAC,KAAKkT,eAAV,EAA2B;QACzB,MAAM,IAAIlU,yBAAJ,CAA8B,8CAA9B,CAAN;MACD;;MAED,MAAM,KAAK2C,YAAL,CAAkBC,aAAlB,EAAiC5B,OAAjC,CAAN;MACA,OAAO,KAAKgT,gBAAL,CAAsBxG,EAAtB,CAAoC,KAAK0G,eAAzC,CAAP;IACD;EAAA;;AAxFgB;ACVnB;;;;;MAGaG,wCAAwCjU,UAAS;EAO1DlL,YACImL,IADJ,EAEqBgD,MAFrB,EAGoBlK,MAHpB,EAIImH,GAJJ,EAKIrB,OALJ,EAMI9J,OANJ,EAMoB;IAEhB,MAAMkL,IAAN,EAAYC,GAAZ,EAAiBrB,OAAjB,EAA0B9J,OAA1B;IANiB;IACD;IAOhB,KAAKmf,kBAAL,GAA0B,KAAK3K,gBAAL,IAAyB,KAAKA,gBAAL,CAAsB4K,cAAzE;EACH;;EAEmB,IAAhB5K,gBAAgB;IAChB,MAAM6K,wBAAwB,GAC1Bra,KAAK,CAACC,OAAN,CAAc,KAAK6E,OAAnB,KACC,KAAKA,OAAL,CAAatD,IAAb,CAAkB6B,EAAE,IAAIA,EAAE,CAACrB,IAAH,KAAY,0BAApC,CAFL;IAGA,MAAM2C,MAAM,GAAG0V,wBAAwB,IAAIA,wBAAwB,CAACrW,QAArD,IAAiEqW,wBAAwB,CAACrW,QAAzB,CAAkCqB,gBAAlH;IACA,OAAOV,MAAM,GAAGA,MAAH,GAAYtD,SAAzB;EACH;;EAES,IAANqE,MAAM;IACN,MAAM8J,gBAAgB,GAAG,KAAKA,gBAA9B;;IACA,IAAIA,gBAAJ,EAAsB;MAClB,OAAOA,gBAAgB,CAAC9J,MAAxB;IACH,CAFD,MAEO;MACH,OAAO,SAAP;IACH;EACJ;;EAEuB,IAApB4U,oBAAoB;IACpB,OAAO,KAAKpR,MAAL,CAAYhG,KAAnB;EACH;;EAEM,IAAHnC,GAAG;IACH,OAAO,KAAKmI,MAAL,CAAYnI,GAAnB;EACH;;EAEW,IAARE,QAAQ;IACR,OAAO,KAAKiI,MAAL,CAAYhH,SAAnB;EACH;;EAEe,IAAZhB,YAAY;IACZ,OAAO,KAAKgI,MAAL,CAAY/G,aAAnB;EACH;;EAES,IAANiC,MAAM;IACN,OAAO,KAAKoL,gBAAL,IAAyB,KAAKA,gBAAL,CAAsBpL,MAAtD;EACH;;AAvDyD;ACF9D;;;;;MAGamW,wBAAwBtU,UAAS;EAE5ClL,YACEmL,IADF,EAEmBgD,MAFnB,EAGkBlK,MAHlB,EAIEmH,GAJF,EAKErB,OALF,EAME9J,OANF,EAMkB;IAEhB,MAAMkL,IAAN,EAAYC,GAAZ,EAAiBrB,OAAjB,EAA0B9J,OAA1B;IANiB;IACD;EAMjB;;EAEmB,IAAhBwU,gBAAgB;IAClB,MAAMgL,QAAQ,GACZxa,KAAK,CAACC,OAAN,CAAc,KAAK6E,OAAnB,KACC,KAAKA,OAAL,CAAatD,IAAb,CAAkB6B,EAAE,IAAIA,EAAE,CAACrB,IAAH,KAAY,QAApC,CAFH;IAGA,OAAOwY,QAAQ,GAAG,CAACA,QAAD,CAAH,GAAgB,EAA/B;EACD;;EAES,IAAN9U,MAAM;IACR,MAAM8J,gBAAgB,GAAG,KAAKA,gBAA9B;IACA,MAAMiL,QAAQ,GAAGjL,gBAAgB,CAAC,CAAD,CAAjC;;IACA,IAAIiL,QAAJ,EAAc;MACZ,OAAOA,QAAQ,CAACzW,QAAT,CAAkBqB,gBAAlB,CAAmCK,MAA1C;IACD,CAFD,MAEO;MACL,OAAO,SAAP;IACD;EACF;;EAEM,IAAH3E,GAAG;IACL,OAAO,KAAKmI,MAAL,CAAYnI,GAAnB;EACD;;EAEW,IAARE,QAAQ;IACV,OAAO,KAAKiI,MAAL,CAAYhH,SAAnB;EACD;;EAEe,IAAZhB,YAAY;IACd,OAAO,KAAKgI,MAAL,CAAY/G,aAAnB;EACD;;EAEY,IAAT3G,SAAS;IACX,OAAO,KAAK0N,MAAL,CAAYlG,UAAnB;EACD;;EAEOmG,OAAO,CAAC3F,GAAD,EAAa4F,IAAb,EAAyB;IACtC,OAAO5F,GAAG,CAAC6F,MAAJ,CAAW,CAACC,IAAD,EAAOC,OAAP,KAAc;MAC9B,OAAOH,IAAI,IAAIG,OAAR,GAAkB7B,MAAM,CAAC6B,OAAO,CAACH,IAAD,CAAR,CAAN,GAAwBE,IAA1C,GAAiDA,IAAxD;IACD,CAFM,EAEJ,CAFI,CAAP;EAGD;;EAEc,IAAXG,WAAW;IACb,OAAOC,MAAM,CACX,KAAKP,OAAL,CAAavE,sBAAsB,CAAC;MAAEM,QAAQ,EAAE,KAAKsK;IAAjB,CAAD,CAAnC,EAA0E,cAA1E,CADW,CAAb;EAGD;;EAEc,IAAX7F,WAAW;IACb,OAAOD,MAAM,CACX,KAAKP,OAAL,CACEvE,sBAAsB,CAAC;MAAEM,QAAQ,EAAE,KAAKsK;IAAjB,CAAD,CADxB,EAEE,wBAFF,CADW,CAAb;EAMD;;EAEc,IAAXyK,WAAW;IACb,OAAOvQ,MAAM,CACX,KAAKP,OAAL,CAAavE,sBAAsB,CAAC;MAAEM,QAAQ,EAAE,KAAKsK;IAAjB,CAAD,CAAnC,EAA0E,cAA1E,CADW,CAAb;EAGD;;EAES,IAANpL,MAAM;IACR,OAAOqB,aAAa,CAAC;MAAEP,QAAQ,EAAE,KAAKsK;IAAjB,CAAD,CAApB;EACD;;AA3E2C;ACF9C;;;;;;;MAKakL,6BAA6BzU,UAAS;EAEjDlL,YACEmL,IADF,EAEmBgD,MAFnB,EAGkBlK,MAHlB,EAIEmH,GAJF,EAKErB,OALF,EAME9J,OANF,EAMkB;IAEhB,MAAMkL,IAAN,EAAYC,GAAZ,EAAiBrB,OAAjB,EAA0B9J,OAA1B;IANiB;IACD;EAMjB;;EAEmB,IAAhBwU,gBAAgB;IAClB,MAAMmL,aAAa,GACjB3a,KAAK,CAACC,OAAN,CAAc,KAAK6E,OAAnB,KACC,KAAKA,OAAL,CAAatD,IAAb,CAAkB6B,EAAE,IAAIA,EAAE,CAACrB,IAAH,KAAY,aAApC,CAFH;IAGA,OAAO2Y,aAAa,GAAG,CAACA,aAAD,CAAH,GAAqB,EAAzC;EACD;;EAES,IAANjV,MAAM;IACR,MAAM8J,gBAAgB,GAAG,KAAKA,gBAA9B;IACA,MAAMiL,QAAQ,GAAGjL,gBAAgB,CAAC,CAAD,CAAjC;;IACA,IAAIiL,QAAJ,EAAc;MACZ,OAAOA,QAAQ,CAACzW,QAAT,CAAkBqB,gBAAlB,CAAmCK,MAA1C;IACD,CAFD,MAEO;MACL,OAAO,SAAP;IACD;EACF;;EAES,IAAN1H,MAAM;IACR,OAAO,IAAIE,SAAJ,CAAc,KAAKgL,MAAL,CAAYlL,MAA1B,CAAP;EACD;;EAEc,IAAXyE,WAAW;IACb,OAAO,KAAKyG,MAAL,CAAYzG,WAAnB;EACD;;EAEM,IAAH1B,GAAG;IACL,OAAO,KAAKmI,MAAL,CAAYnI,GAAnB;EACD;;EAEW,IAARE,QAAQ;IACV,OAAO,KAAKiI,MAAL,CAAYhH,SAAnB;EACD;;EAEe,IAAZhB,YAAY;IACd,OAAO,KAAKgI,MAAL,CAAY/G,aAAnB;EACD;;EAEOgH,OAAO,CAAC3F,GAAD,EAAa4F,IAAb,EAAyB;IACtC,OAAO5F,GAAG,CAAC6F,MAAJ,CAAW,CAACC,IAAD,EAAOC,OAAP,KAAc;MAC9B,OAAOH,IAAI,IAAIG,OAAR,GAAkB7B,MAAM,CAAC6B,OAAO,CAACH,IAAD,CAAR,CAAN,GAAwBE,IAA1C,GAAiDA,IAAxD;IACD,CAFM,EAEJ,CAFI,CAAP;EAGD;;EAEc,IAAXG,WAAW;IACb,OAAOC,MAAM,CACX,KAAKP,OAAL,CAAavE,sBAAsB,CAAC;MAAEM,QAAQ,EAAE,KAAKsK;IAAjB,CAAD,CAAnC,EAA0E,cAA1E,CADW,CAAb;EAGD;;EAEc,IAAX7F,WAAW;IACb,OAAOD,MAAM,CACX,KAAKP,OAAL,CACEvE,sBAAsB,CAAC;MAAEM,QAAQ,EAAE,KAAKsK;IAAjB,CAAD,CADxB,EAEE,wBAFF,CADW,CAAb;EAMD;;EAEc,IAAXyK,WAAW;IACb,OAAOvQ,MAAM,CACX,KAAKP,OAAL,CAAavE,sBAAsB,CAAC;MAAEM,QAAQ,EAAE,KAAKsK;IAAjB,CAAD,CAAnC,EAA0E,cAA1E,CADW,CAAb;EAGD;;EAES,IAANpL,MAAM;IACR,OAAOqB,aAAa,CAAC;MAAEP,QAAQ,EAAE,KAAKsK;IAAjB,CAAD,CAApB;EACD;;AA/EgD;;AClBnD,MAAM6J,WAAW,GAAIuB,GAAD,IAAY;EAC9B,OAAO,CACL;IAAElZ,IAAI,EAAE;EAAR,CADK,EAEL;IAAEA,IAAI,EAAE,KAAR;IAAe/C,IAAI,EAAE,CAAC;MAAE+C,IAAI,EAAE;IAAR,CAAD;EAArB,CAFK,EAGL;IACEA,IAAI,EAAE,MADR;IAEE/C,IAAI,EAAE,CAAC;MAAE+C,IAAI,EAAE;IAAR,CAAD,EAAuB;MAAE8C,MAAM,EAAEoW;IAAV,CAAvB;EAFR,CAHK,EAOL;IAAElZ,IAAI,EAAE;EAAR,CAPK,EAQL;IAAEA,IAAI,EAAE;EAAR,CARK,EASL;IAAEA,IAAI,EAAE;EAAR,CATK,CAAP;AAWD,CAZD;;AAcA,MAAMmZ,gBAAgB,GAAG,CAACD,GAAD,EAAczZ,KAAd,KAA2B;EAClD,OAAO,CACL;IAAEO,IAAI,EAAE;EAAR,CADK,EAEL;IAAEA,IAAI,EAAE,KAAR;IAAe/C,IAAI,EAAE,CAAC;MAAE+C,IAAI,EAAE;IAAR,CAAD;EAArB,CAFK,EAGL;IACEA,IAAI,EAAE,MADR;IAEE/C,IAAI,EAAE,CAAC;MAAE+C,IAAI,EAAE;IAAR,CAAD,EAAuB;MAAE8C,MAAM,EAAEoW;IAAV,CAAvB;EAFR,CAHK,EAOL;IAAElZ,IAAI,EAAE;EAAR,CAPK,EAQL;IACEA,IAAI,EAAE,MADR;IAEE/C,IAAI,EAAE,CAAC;MAAE+C,IAAI,EAAE;IAAR,CAAD,EAAoB;MAAE+C,GAAG,EAAE,GAAGtD,KAAK;IAAf,CAApB;EAFR,CARK,EAYL;IAAEO,IAAI,EAAE;EAAR,CAZK,EAaL;IAAEA,IAAI,EAAE;EAAR,CAbK,EAcL;IAAEA,IAAI,EAAE;EAAR,CAdK,CAAP;AAgBD,CAjBD;;AAmBA,MAAMoZ,cAAc,GAAG;EACrB,OAAO,CACL;IAAEpZ,IAAI,EAAE;EAAR,CADK,EAEL;IAAEA,IAAI,EAAE,KAAR;IAAe/C,IAAI,EAAE,CAAC;MAAE+C,IAAI,EAAE;IAAR,CAAD;EAArB,CAFK,EAGL;IAAEA,IAAI,EAAE,MAAR;IAAgB/C,IAAI,EAAE,CAAC;MAAE+C,IAAI,EAAE;IAAR,CAAD;EAAtB,CAHK,EAIL;IAAEA,IAAI,EAAE;EAAR,CAJK,EAKL;IAAEA,IAAI,EAAE;EAAR,CALK,CAAP;AAOD,CARD;;AAUA,MAAMqZ,kBAAkB,GAAG,CAACH,GAAD,EAAc5c,MAAd,KAA4B;EACrD,OAAO,CACL;IAAE0D,IAAI,EAAE;EAAR,CADK,EAEL;IAAEA,IAAI,EAAE,KAAR;IAAe/C,IAAI,EAAE,CAAC;MAAE+C,IAAI,EAAE;IAAR,CAAD;EAArB,CAFK,EAGL;IACEA,IAAI,EAAE,MADR;IAEE/C,IAAI,EAAE,CAAC;MAAE+C,IAAI,EAAE;IAAR,CAAD,EAAsB;MAAE8C,MAAM,EAAEoW;IAAV,CAAtB;EAFR,CAHK,EAOL;IAAElZ,IAAI,EAAE,UAAR;IAAoB/C,IAAI,EAAE,CAAC;MAAE+C,IAAI,EAAE;IAAR,CAAD;EAA1B,CAPK,EAQL,CACE;IACEA,IAAI,EAAE,SADR;IAEE/C,IAAI,EAAE,CAAC,CAAC,CAAC;MAAE+C,IAAI,EAAE;IAAR,CAAD,EAAmB;MAAEA,IAAI,EAAE;IAAR,CAAnB,CAAD,CAAD,EAA6C,EAA7C;EAFR,CADF,CARK,EAcL;IACEA,IAAI,EAAE,MADR;IAEE/C,IAAI,EAAE,CAAC;MAAE+C,IAAI,EAAE;IAAR,CAAD,EAAoB;MAAE+C,GAAG,EAAE,GAAGzG,MAAM;IAAhB,CAApB;EAFR,CAdK,EAkBL;IAAE0D,IAAI,EAAE;EAAR,CAlBK,EAmBL;IAAEA,IAAI,EAAE;EAAR,CAnBK,EAoBL;IAAEA,IAAI,EAAE;EAAR,CApBK,CAAP;AAsBD,CAvBD;;MAyBasZ,cAAc,GAAG;EAC5B3B,WAD4B;EAE5ByB,cAF4B;EAG5BD,gBAH4B;EAI5BE;AAJ4B;ACpE9B,MAAMra,IAAI,GAAG,CACX;EACEgB,IAAI,EAAE,WADR;EAEE/C,IAAI,EAAE,CACJ;IACE+C,IAAI,EAAE,QADR;IAEE/C,IAAI,EAAE,CACJ;MAAE+C,IAAI,EAAE;IAAR,CADI,EAEJ;MACEA,IAAI,EAAE,MADR;MAEE/C,IAAI,EAAE,CAAC;QAAE+C,IAAI,EAAE,MAAR;QAAgB/C,IAAI,EAAE,CAAC;UAAE+C,IAAI,EAAE;QAAR,CAAD;MAAtB,CAAD,EAAkD;QAAEA,IAAI,EAAE;MAAR,CAAlD;IAFR,CAFI;EAFR,CADI;AAFR,CADW,EAgBX;EAAEA,IAAI,EAAE,SAAR;EAAmB/C,IAAI,EAAE,CAAC;IAAE+C,IAAI,EAAE;EAAR,CAAD;AAAzB,CAhBW,EAiBX;EAAEA,IAAI,EAAE,MAAR;EAAgB/C,IAAI,EAAE,CAAC,CAAC;IAAE+C,IAAI,EAAE;EAAR,CAAD,EAAkB;IAAEA,IAAI,EAAE;EAAR,CAAlB,EAAoC;IAAEA,IAAI,EAAE;EAAR,CAApC,CAAD;AAAtB,CAjBW,CAAb;AAoBA,MAAMZ,OAAO,GAAG,MAAhB;MAEama,WAAW,GAAG;EACzBva,IADyB;EAEzBI;AAFyB;;SCjBXoa,QAKZC,mBACAC,mBAA+F;EAE/F,OAAO,CAACC,mBAAD,EAAsBrgB,OAAtB,KACHogB,iBAAiB,CAACD,iBAAiB,CAACE,mBAAD,EAAsBrgB,OAAtB,CAAlB,EAAkDA,OAAlD,CADrB;AAEJ;ACFA;;;;;;MAIasgB,eAAc;EAGzBvgB,YACUwgB,QADV,EAEUpI,OAFV,EAGUqI,eAHV,EAIUC,IAJV,EAKU9c,IALV,EAMU+c,uBAAuB,IANjC,EAOUC,cAAc,KAPxB,EAO6B;IANnB;IACA;IACA;IACA;IACA;IACA;IACA;EACN;;EAEIC,YAAY,CAACjd,IAAD,EAAcgD,MAAd,EAAuC8Z,IAAvC,EAAmD;IACrE,MAAM/c,IAAI,GAAGiD,MAAM,CAACka,iBAAP,EAAb;;IAEA,IAAI,CAACnd,IAAI,CAAC8C,IAAL,CAAWgE,CAAD,IAAcA,CAAC,CAAC5G,MAAF,KAAaD,IAAI,CAACC,MAA1C,CAAL,EAAwD;MACtD,MAAM,IAAIJ,qBAAJ,CAA0Bid,IAA1B,EAAgC/c,IAAhC,EAAsCC,IAAtC,CAAN;IACD;EACF;;;;;;EAKS,IAANgD,MAAM;IACR,OAAO,KAAKga,WAAL,GACH,KAAKH,eAAL,CAAqBM,aAArB,GAAqC,KAAKL,IAA1C,CADG,GAEH,KAAKD,eAAL,CAAqBM,aAArB,EAFJ;EAGD;;;;;;EAKDC,YAAY;IACV,IAAI,KAAKJ,WAAT,EAAsB;MACpB,MAAMK,GAAG,GAAG,KAAKR,eAAL,CAAqBK,iBAArB,GAAyCra,IAAzC,CAA+CgE,CAAD,IAAcA,CAAC,CAAC,CAAD,CAAD,KAAS,KAAKiW,IAA1E,CAAZ;;MACA,IAAIO,GAAJ,EAAS;QACPA,GAAG,CAAC7C,KAAJ;QACA,OAAO6C,GAAP;MACD;IACF,CAND,MAMO;MACL,MAAMA,GAAG,GAAG,KAAKR,eAAL,CAAqBK,iBAArB,EAAZ;MACA,OAAOG,GAAG,CAACpd,MAAJ,IAAc,CAAd,GAAkBod,GAAG,CAAC,CAAD,CAArB,GAA2BA,GAAlC;IACD;EACF;;;;;;;;;EAQDtN,IAAI,CACFxF,SAA8B,EAD5B,EAC8B;IAEhC,IAAI,KAAKqS,QAAL,YAAyBU,MAA7B,EAAqC;MACnC,OAAQ,KAAKV,QAAL,CACLnC,QADK,CACI,KAAKtL,gBAAL,CAAsB5E,MAAtB,CADJ,EAELwF,IAFK,EAAR;IAGD,CAJD,MAIO;MACL,OAAO,KAAK6M,QAAL,CAAcnC,QAAd,CAAuB,KAAKtL,gBAAL,CAAsB5E,MAAtB,CAAvB,CAAP;IACD;EACF;;;;;;;;;EAQD4E,gBAAgB,CAAC;IACf/M,GADe;IAEfE,QAFe;IAGfC,YAHe;IAIflC,MAJe;IAKfhB,MAAM,GAAG,CALM;IAMfmD,KAAK,GAAG;EANO,IAOQ,EAPT,EAOW;IACzB,MAAM+a,kBAAkB,GAA2B;MACjDne,EAAE,EAAE,KAAKoV,OADwC;MAEjDnV,MAFiD;MAGjD+C,GAHiD;MAIjDI,KAJiD;MAKjDnC,MALiD;MAMjDiC,QANiD;MAOjDC,YAPiD;MAQjDoB,SAAS,EAAE;QACT6Z,UAAU,EAAE,KAAKT,oBAAL,GAA4B,KAAKD,IAAjC,GAAwCW,kCAD3C;QAETlZ,KAAK,EAAE,KAAKyY,WAAL,GACH,KAAKH,eAAL,CAAqB3Z,MAArB,CAA4B,KAAK4Z,IAAjC,EAAuC,GAAG,KAAK9c,IAA/C,CADG,GAEH,KAAK6c,eAAL,CAAqB3Z,MAArB,CAA4B,GAAG,KAAKlD,IAApC;MAJK;IARsC,CAAnD;IAeA,OAAOud,kBAAP;EACD;;AA9FwB;;MCedG,qBAAoB;EAG/BthB,YAAoBmc,cAApB,EAA4Dlc,OAA5D,EAA4E;IAAxD;IAAwC;IAFpD,kBAAqC,EAArC;EAEwE;;;;;;;;;EAQhF0S,YAAY,CAACxE,MAAD,EAA6B;IACvC,IAAIyE,eAAe,CAACzE,MAAM,CAACnL,EAAR,CAAf,KAA+B8J,gBAAgB,CAACC,KAApD,EAA2D;MACzD,MAAM,IAAI8F,mBAAJ,CAAwB1E,MAAM,CAACnL,EAA/B,CAAN;IACD;;IACD,KAAKqJ,UAAL,CAAgBhC,IAAhB,CAAoB9B;MAAGtB,IAAI,EAAEC,MAAM,CAACO;IAAhB,GAAgC0G,MAAhC,CAApB;IACA,OAAO,IAAP;EACD;;;;;;;;;EAQD2E,gBAAgB,CAAC3E,MAAD,EAA8D;IAC5E,OAAO,KAAKwE,YAAL,CAAkBxE,MAAM,CAAC4E,gBAAP,EAAlB,CAAP;EACD;;;;;;;;;EAQDC,cAAc,CAAC7E,MAAD,EAA6B;IACzC,IAAIA,MAAM,CAACrI,QAAP,IAAmB8M,eAAe,CAACzE,MAAM,CAACrI,QAAR,CAAf,KAAqCgH,gBAAgB,CAACC,KAA7E,EAAoF;MAClF,MAAM,IAAI8F,mBAAJ,CAAwB1E,MAAM,CAACrI,QAA/B,CAAN;IACD;;IACD,KAAKuG,UAAL,CAAgBhC,IAAhB,CAAoB9B;MAAGtB,IAAI,EAAEC,MAAM,CAACW;IAAhB,GAA+BsG,MAA/B,CAApB;IACA,OAAO,IAAP;EACD;;;;;;;;;EAQDkF,eAAe,CACblF,MADa,EAC8C;IAE3D,KAAK9B,UAAL,CAAgBhC,IAAhB,CAAoB9B;MAAGtB,IAAI,EAAEC,MAAM,CAACjB;IAAhB,GAAgCkI,MAAhC,CAApB;IACA,OAAO,IAAP;EACD;;EAEaoT,YAAY,CAAC/N,KAAD,EAA4B;;MACpD,QAAQA,KAAK,CAACvM,IAAd;QACE,KAAKC,MAAM,CAACO,WAAZ;UACE,OAAO,KAAK0U,cAAL,CAAoBqF,+BAApB,CAAoD;YAAY;UAAK,CAAjB,CAApD,CAAP;;QACF,KAAKta,MAAM,CAACjB,WAAZ;UACE,OAAO,KAAKkW,cAAL,CAAoBsF,gCAApB,CAAqD;YAC1D,YAAKxhB,OAAL,CAAawT,MAAb,CAAoBC,sBAApB,CAA0CnL,kBACrCiL,KADqC,CAA1C;WAD0D,CAArD,CAAP;;QAKF,KAAKtM,MAAM,CAACW,UAAZ;UACE,OAAO,KAAKsU,cAAL,CAAoBuF,+BAApB,CAAoD;YAAY;UAAK,CAAjB,CAApD,CAAP;;QACF;UACE,MAAM,IAAI5Q,yBAAJ,CAA+B0C,KAAa,CAACvM,IAA7C,CAAN;MAZJ;IAcD;EAAA;;;;;;;;;EAQD9B,IAAI,CAACgJ,MAAD,EAA+B;IACjC,KAAK,MAAMqF,KAAX,IAAoBrF,MAApB,EAA4B;MAC1B,QAAQqF,KAAK,CAACvM,IAAd;QACE,KAAKC,MAAM,CAACO,WAAZ;UACE,KAAKkL,YAAL,CAAkBa,KAAlB;UACA;;QACF,KAAKtM,MAAM,CAACjB,WAAZ;UACE,KAAKoN,eAAL,CAAqBG,KAArB;UACA;;QACF,KAAKtM,MAAM,CAACW,UAAZ;UACE,KAAKmL,cAAL,CAAoBQ,KAApB;UACA;;QACF;UACE,MAAM,IAAI1C,yBAAJ,CAA+B0C,KAAa,CAACvM,IAA7C,CAAN;MAXJ;IAaD;;IAED,OAAO,IAAP;EACD;;;;;;;;EAOK0M,IAAI;;MACR,MAAMnE,GAAG,GAA2B,EAApC;;MAEA,KAAK,MAAMlH,EAAX,IAAiB,KAAK+D,UAAtB,EAAkC;QAChCmD,GAAG,CAACnF,IAAJ,CAAS,MAAM,KAAKkX,YAAL,CAAkBjZ,EAAlB,CAAf;MACD;;MAED,MAAMkN,MAAM,GAAG,MAAM,KAAK2G,cAAL,CAAoBwF,cAApB,CAAmCnS,GAAnC,CAArB;MAEA,OAAO,KAAKvP,OAAL,CAAa2hB,gBAAb,CAA8BnI,oBAA9B,CAAmDjE,MAAnD,CAAP;IACD;EAAA;;AAlH8B;;MAqHpB0L,OAAM;EACjBlhB,YAAoBC,OAApB,EAAoC;IAAhB;;IAsBZ,qBAAoB0T,IAAJ,IAA0B;MAChD,OAAO;QACLA;MADK,CAAP;IAGD,CAJO;EAtBgC;;EAEd,IAAdwI,cAAc;IACxB,OAAO,KAAKlc,OAAL,CAAakc,cAApB;EACD;;;;;;;;;EAUKnN,GAAG,CAAC;IAAE6S;EAAF,IAA8B,EAA/B,EAAiC;;MACxC,IAAI,CAAC,KAAKC,IAAN,IAAcD,YAAlB,EAAgC;QAC9B,KAAKC,IAAL,GAAY,MAAM,KAAK3F,cAAL,CAAoBC,MAApB,EAAlB;MACD;;MAED,OAAO,KAAK0F,IAAZ;IACD;EAAA;;;;;;;;;;;EAgBDhE,SAAS,CACP3P,MADO,EACoD;IAE3D,OAAO,KAAK4T,aAAL,CAAmB;MACxB,MAAMC,YAAY,GAAG,MAAM,KAAK7F,cAAL,CAAoBsF,gCAApB,CAAqD,MAC9E,KAAKxhB,OAAL,CAAawT,MAAb,CAAoBC,sBAApB,CAA0CnL,kBACpC4F,MADoC,CAA1C,CADyB,CAA3B;MAKA,MAAMqH,MAAM,GAAG,MAAM,KAAK2G,cAAL,CAAoBwF,cAApB,CAAmC,CAACK,YAAD,CAAnC,CAArB;MACA,OAAO,KAAK/hB,OAAL,CAAa2hB,gBAAb,CAA8Blc,0BAA9B,CAAyD8P,MAAzD,CAAP;IAGD,CAVyB,CAAnB,CAAP;EAWD;;;;;;;;;;;EAUD8I,WAAW,CAACnQ,MAAD,EAA6B;IACtC,IAAIA,MAAM,CAACrI,QAAP,IAAmB8M,eAAe,CAACzE,MAAM,CAACrI,QAAR,CAAf,KAAqCgH,gBAAgB,CAACC,KAA7E,EAAoF;MAClF,MAAM,IAAI8F,mBAAJ,CAAwB1E,MAAM,CAACrI,QAA/B,CAAN;IACD;;IACD,OAAO,KAAKic,aAAL,CAAmB;MACxB,MAAMC,YAAY,GAAG,MAAM,KAAK7F,cAAL,CAAoBuF,+BAApB,CACzB;QAAY;MAAM,CAAlB,CADyB,CAA3B;MAGA,MAAMlM,MAAM,GAAG,MAAM,KAAK2G,cAAL,CAAoBwF,cAApB,CAAmC,CAACK,YAAD,CAAnC,CAArB;MACA,OAAO,KAAK/hB,OAAL,CAAa2hB,gBAAb,CAA8BjI,yBAA9B,CAAwDnE,MAAxD,CAAP;IACD,CANyB,CAAnB,CAAP;EAOD;;;;;;;;;;EASDgJ,gBAAgB;IACd,OAAO,KAAKuD,aAAL,CAAmB;MACxB,MAAMC,YAAY,GAAG,MAAM,KAAK7F,cAAL,CAAoBuF,+BAApB,CAAoD;QAC7E,MAAM5b,QAAQ,GAAG,MAAM,KAAKkJ,GAAL,EAAvB;QACA,OAAO;UAAElJ;QAAF,CAAP;MACD,CAH8E,CAApD,CAA3B;MAIA,MAAM0P,MAAM,GAAG,MAAM,KAAK2G,cAAL,CAAoBwF,cAApB,CAAmC,CAACK,YAAD,CAAnC,CAArB;MACA,OAAO,KAAK/hB,OAAL,CAAa2hB,gBAAb,CAA8BjI,yBAA9B,CAAwDnE,MAAxD,CAAP;IACD,CAPyB,CAAnB,CAAP;EAQD;;;;;;;;;;;EAUD6I,QAAQ,CAAClQ,MAAD,EAA6B;IACnC,IAAIyE,eAAe,CAACzE,MAAM,CAACnL,EAAR,CAAf,KAA+B8J,gBAAgB,CAACC,KAApD,EAA2D;MACzD,MAAM,IAAI8F,mBAAJ,CAAwB1E,MAAM,CAACnL,EAA/B,CAAN;IACD;;IACD,OAAO,KAAK+e,aAAL,CAAmB;MACxB,MAAMC,YAAY,GAAG,MAAM,KAAK7F,cAAL,CAAoBqF,+BAApB,CACzB;QAAY;MAAM,CAAlB,CADyB,CAA3B;MAGA,MAAMhM,MAAM,GAAG,MAAM,KAAK2G,cAAL,CAAoBwF,cAApB,CAAmC,CAACK,YAAD,CAAnC,CAArB;MACA,OAAO,KAAK/hB,OAAL,CAAa2hB,gBAAb,CAA8BlI,0BAA9B,CAAyDlE,MAAzD,CAAP;IACD,CANyB,CAAnB,CAAP;EAOD;;;;;;;;;;;EAUD3B,KAAK,CAAC1F,MAAD,EAAqD;IACxD,MAAM0F,KAAK,GAAG,IAAIyN,oBAAJ,CAAyB,KAAKnF,cAA9B,EAA8C,KAAKlc,OAAnD,CAAd;;IAEA,IAAIgF,KAAK,CAACC,OAAN,CAAciJ,MAAd,CAAJ,EAA2B;MACzB0F,KAAK,CAAC1O,IAAN,CAAWgJ,MAAX;IACD;;IAED,OAAO0F,KAAP;EACD;;;;;;;;;;EASKyE,EAAE,CACNF,OADM,EAEN6J,8BAA0FxX,CAAD,IACvFA,CAHI,EAGI;;MAEV,IAAIyX,uBAAuB,CAAC9J,OAAD,CAAvB,KAAqCtL,gBAAgB,CAACC,KAA1D,EAAiE;QAC/D,MAAM,IAAIoV,2BAAJ,CAAgC/J,OAAhC,CAAN;MACD;;MACD,MAAMhY,GAAG,GAAG,KAAKH,OAAL,CAAamiB,cAAb,GAA8BhiB,GAA1C;MACA,MAAM+O,YAAY,GAAG,KAAKlP,OAAL,CAAamiB,cAAb,GAA8BjT,YAAnD;MACA,MAAMpI,MAAM,GAAG,MAAMoI,YAAY,CAACkT,SAAb,CAAuBjK,OAAvB,EAAgC,MAAhC,CAArB;MACA,MAAMkK,WAAW,GAAG,MAAMnT,YAAY,CAACoT,cAAb,CAA4BnK,OAA5B,CAA1B;MACA,MAAMoK,GAAG,GAAG,IAAIC,mBAAJ,CACVrK,OADU,EAEVrR,MAFU,EAGV,IAHU,EAIV,KAAK9G,OAAL,CAAakY,QAJH,EAKVmK,WALU,EAMVliB,GANU,EAOV+O,YAPU,CAAZ;MASA,OAAO8S,2BAA2B,CAACO,GAAD,EAAM,KAAKviB,OAAX,CAAlC;IACD;EAAA;;AAhKgB;;MC3INyiB,qBAAoB;EAC/B1iB,YAAoBC,OAApB,EAAoC;IAAhB;EAAoB;;EAElCmc,MAAM;;MACV,OAAO,KAAKnc,OAAL,CAAa6O,MAAb,CAAoBpO,aAApB,EAAP;IACD;EAAA;;EAEK8gB,+BAA+B,CAACrT,MAAD,EAA4C;;MAC/E,OAAO9F,UAAU,CAAC,MAAM8F,MAAM,EAAb,EAAiBjH,MAAM,CAACO,WAAxB,CAAjB;IACD;EAAA;;EAEKga,gCAAgC,CAACtT,MAAD,EAA6C;;MACjF,OAAO9F,UAAU,CAAC,MAAM8F,MAAM,EAAb,EAAiBjH,MAAM,CAACjB,WAAxB,CAAjB;IACD;EAAA;;EAEKyb,+BAA+B,CAACvT,MAAD,EAA4C;;MAC/E,OAAO9F,UAAU,CAAC,MAAM8F,MAAM,EAAb,EAAiBjH,MAAM,CAACW,UAAxB,CAAjB;IACD;EAAA;;EAEK8Z,cAAc,CAACxT,MAAD,EAA+B;;MACjD,MAAM7F,EAAE,GAAG,MAAM,KAAKrI,OAAL,CAAa4T,KAAb,CAAmBA,KAAnB,CAAyB1F,MAAzB,EAAwCwF,IAAxC,EAAjB;MACA,OAAOrL,EAAE,CAAC6C,IAAV;IACD;EAAA;;AAtB8B;ACFjC;;;;;;MAIawX,qBAAoB;EAC7B3iB,YACYwgB,QADZ,EAEYpI,OAFZ,EAGYqI,eAHZ,EAIYC,IAJZ,EAKY9c,OAAY,MALxB,EAMY+c,uBAAuB,IANnC,EAOYC,cAAc,KAP1B,EAO+B;IANnB;IACA;IACA;IACA;IACA;IACA;IACA;EACP;;;;;;EAKLI,YAAY;IACR,OAAO,KAAKJ,WAAL,GACD,KAAKH,eAAL,CAAqBM,aAArB,GAAqC,KAAKL,IAA1C,CADC,GAED,KAAKD,eAAL,CAAqBM,aAArB,EAFN;EAGH;;;;;;;;;EAQDpN,IAAI,CACAxF,SAA8B,EAD9B,EACgC;IAEhC,IAAI,KAAKqS,QAAL,YAAyBU,MAA7B,EAAqC;MACjC,OAAQ,KAAKV,QAAL,CAAoCnC,QAApC,CAA6C,KAAKtL,gBAAL,CAAsB5E,MAAtB,CAA7C,EAA4EwF,IAA5E,EAAR;IACH,CAFD,MAEO;MACH,OAAO,KAAK6M,QAAL,CAAcnC,QAAd,CAAuB,KAAKtL,gBAAL,CAAsB5E,MAAtB,CAAvB,CAAP;IACH;EACJ;;;;;;;;;EAQD4E,gBAAgB,CAAC;IACb/M,GADa;IAEbE,QAFa;IAGbC,YAHa;IAIblC,MAJa;IAKbhB,MAAM,GAAG,CALI;IAMbmD,KAAK,GAAG;EANK,IAOQ,EAPT,EAOW;IACvB,MAAM+a,kBAAkB,GAA2B;MAC/Cne,EAAE,EAAE,KAAKoV,OADsC;MAE/CnV,MAF+C;MAG/C+C,GAH+C;MAI/CI,KAJ+C;MAK/CnC,MAL+C;MAM/CiC,QAN+C;MAO/CC,YAP+C;MAQ/CoB,SAAS,EAAE;QACP6Z,UAAU,EAAE,KAAKT,oBAAL,GAA4B,KAAKD,IAAjC,GAAwCW,kCAD7C;QAEPlZ,KAAK,EAAE,KAAKyY,WAAL,GACD,KAAKH,eAAL,CAAqBmC,YAArB,CAAkC;UAAE,CAAC,KAAKlC,IAAN,GAAa,KAAK9c;QAApB,CAAlC,CADC,GAED,KAAK6c,eAAL,CAAqBmC,YAArB,CAAkC,KAAKhf,IAAvC;MAJC;IARoC,CAAnD;IAeA,OAAOud,kBAAP;EACH;;AAlE4B;;ACIjC,MAAM0B,aAAa,GAAG,CACpBC,YADoB,EAEpBC,cAFoB,EAGpBC,mBAHoB,EAIpBC,gBAJoB,EAKpBC,QALoB,EAMpBC,oBANoB,EAOpBtd,OAPoB,EAQpB8X,QARoB,EASpB1Z,MAToB,EAUpBhB,MAAM,GAAG,GAVW,KAUR;EAEZ,OAAO;IACL8D,MAAM,EAAE,CACN;MAAEJ,IAAI,EAAE,WAAR;MAAqB/C,IAAI,EAAE,CAAC;QAAE+C,IAAI,EAAE,MAAR;QAAgB/C,IAAI,EAAE,CAACkf,YAAD,EAAeE,mBAAf;MAAtB,CAAD;IAA3B,CADM,EAEN;MAAErc,IAAI,EAAE,SAAR;MAAmB/C,IAAI,EAAE,CAAC;QAAE+C,IAAI,EAAE,QAAR;QAAkB/C,IAAI,EAAE,CAACmf,cAAD;MAAxB,CAAD;IAAzB,CAFM,EAGN;MACEpc,IAAI,EAAE,MADR;MAEE/C,IAAI,EAAE,CACJ,CACE;QAAE+C,IAAI,EAAE;MAAR,CADF,EAEEsc,gBAFF,EAGE;QAAEtc,IAAI,EAAE;MAAR,CAHF,EAIE;QAAEA,IAAI,EAAE,KAAR;QAAe/C,IAAI,EAAE,CAAC;UAAE+C,IAAI,EAAE;QAAR,CAAD;MAArB,CAJF,EAKE;QAAEA,IAAI,EAAE;MAAR,CALF,CADI;IAFR,CAHM,CADH;IAiBLZ,OAAO,EAAE;MAAEY,IAAI,EAAE;IAAR,CAjBJ;IAkBLyc,KAAK,EAAE;MAAEzc,IAAI,EAAE,MAAR;MAAgB/C,IAAI,EAAE,CAACsf,QAAD,EAAWC,oBAAX;IAAtB,CAlBF;IAmBLlgB,MAnBK;IAoBL4C,OApBK;IAqBL8X,QArBK;IAsBL1Z;EAtBK,CAAP;AAwBD,CApCD;;MA2Caof,YAAW;EACtBrjB,YACUsjB,IADV,EAEUC,aAFV,EAGUC,gBAHV,EAIUC,wBAJV,EAKUC,oBALV,EAMUC,QAAa,MANvB,EAM6B;IALnB;IACA;IACA;IACA;IACA;IACA;EACN;;;;;;EAKJ3C,YAAY;IACV,OAAO;MACLzZ,SAAS,EAAE,KAAKkc,wBAAL,CAA8BG,iBAA9B,EADN;MAELha,MAAM,EAAE,KAAK6Z,wBAAL,CAA8BI,mBAA9B;IAFH,CAAP;EAID;;;;;;;;EAOKC,WAAW,CAACC,gBAAD,EAAyC;;MACxD,KAAKC,sBAAL,CAA4BD,gBAA5B;MACA,MAAMle,OAAO,GAAG,CAAC,MAAM,KAAK0d,aAAL,CAAmB1J,UAAnB,CAA8B,KAAK2J,gBAAnC,EAAqD,MAArD,CAAP,EAAqEnc,QAArE,EAAhB;MACA,MAAM4c,OAAO,GAAG,MAAM,KAAKV,aAAL,CAAmB3F,UAAnB,EAAtB;MACA,MAAM7X,OAAO,GAAG,MAAM,KAAKwd,aAAL,CAAmBW,UAAnB,CAA8B,KAAKV,gBAAnC,EAAqD,MAArD,CAAtB;MACA,OAAO,KAAKW,0BAAL,CACLtB,aAAa,CACX,KAAKY,wBAAL,CAA8BX,YADnB,EAEX,KAAKW,wBAAL,CAA8BV,cAFnB,EAGX,KAAKW,oBAHM,EAIX,KAAKU,sBAAL,CACE,KAAKX,wBAAL,CAA8BY,YADhC,EAEEN,gBAAgB,CAACO,UAFnB,EAGEze,OAHF,CAJW,EASX,KAAK0e,wBAAL,EATW,EAUXxe,OAVW,EAWXF,OAXW,EAYXoe,OAZW,EAaXF,gBAAgB,CAAC9f,MAbN,CADR,CAAP;IAiBD;EAAA;;EAEO+f,sBAAsB,CAACD,gBAAD,EAAyC;IACrE,IACEA,gBAAgB,CAAC9f,MAAjB,IACA2O,eAAe,CAACmR,gBAAgB,CAAC9f,MAAlB,CAAf,KAA6C6I,gBAAgB,CAACC,KAFhE,EAGE;MACA,MAAM,IAAIzH,4BAAJ,CACJ,qEAAqEye,gBAAgB,CAAC9f,MAAM,GADxF,CAAN;IAGD;;IACD,IACE,CAAC8f,gBAAgB,CAACO,UAAlB,IACA1R,eAAe,CAACmR,gBAAgB,CAACO,UAAlB,CAAf,KAAiDxX,gBAAgB,CAACC,KAFpE,EAGE;MACA,MAAM,IAAIzH,4BAAJ,CACJ,wDAAwDye,gBAAgB,CAACO,UAAU,GAD/E,CAAN;IAGD;EACF;;EAEOC,wBAAwB;IAC9B,IAAI;MACF,OAAO,KAAKd,wBAAL,CAA8Be,cAA9B,CAA6C,KAAKb,KAAlD,CAAP;IACD,CAFD,CAEE,OAAOriB,KAAP,EAAc;MACd,MAAM,IAAI+C,yBAAJ,CACJ,KAAKof,wBAAL,CAA8B/e,QAD1B,EAEJ,KAAKsc,YAAL,EAFI,EAGJ,KAAK2C,KAHD,EAIJriB,KAJI,CAAN;IAMD;EACF;;;;;;;;;;;;;EAWO8iB,sBAAsB,CAC5BC,YAD4B,EAE5BC,UAF4B,EAG5BG,eAH4B,EAGL;IAEvB,MAAMC,qBAAqB,GAAG;MAC5BC,OAAO,EAAE,CAAC;QAAEhe,IAAI,EAAE,MAAR;QAAgB/C,IAAI,EAAE,CAAC;UAAE+C,IAAI,EAAE;QAAR,CAAD,EAAoB;UAAE+C,GAAG,EAAE+a;QAAP,CAApB;MAAtB,CAAD,CADmB;MAE5BG,MAAM,EAAE,CAAC;QAAEje,IAAI,EAAE,MAAR;QAAgB/C,IAAI,EAAE,CAAC;UAAE+C,IAAI,EAAE;QAAR,CAAD,EAAsB;UAAE8C,MAAM,EAAE6a;QAAV,CAAtB;MAAtB,CAAD,CAFoB;MAG5BO,YAAY,EAAE,CACZ;QAAEle,IAAI,EAAE,MAAR;QAAgB/C,IAAI,EAAE,CAAC;UAAE+C,IAAI,EAAE;QAAR,CAAD,EAAsB;UAAE8C,MAAM,EAAE,KAAK+Z;QAAf,CAAtB;MAAtB,CADY,CAHc;MAM5BsB,MAAM,EAAE,CAAC;QAAEne,IAAI,EAAE,MAAR;QAAgB/C,IAAI,EAAE,CAAC;UAAE+C,IAAI,EAAE;QAAR,CAAD,EAAoB;UAAE+C,GAAG,EAAE;QAAP,CAApB;MAAtB,CAAD;IANoB,CAA9B;IASA2a,YAAY,CAAC7Z,OAAb,CAAqB,CAACua,IAAD,EAAY9a,CAAZ,KAAqB;MACxC,IAAI8a,IAAI,CAACpe,IAAL,IAAa+d,qBAAjB,EAAwC;QACtCL,YAAY,CAACpa,CAAD,CAAZ,GAAkB1B,MAAM,CAACmc,qBAAD,CAAN,CAA8BK,IAAI,CAACpe,IAAnC,CAAlB;MACD;;MACD,IAAIoe,IAAI,CAACnhB,IAAL,IAAamhB,IAAI,CAACnhB,IAAL,CAAUC,MAAV,KAAqB,CAAtC,EAAyC;QACvC,KAAKugB,sBAAL,CAA4BW,IAAI,CAACnhB,IAAjC,EAAuC0gB,UAAvC,EAAmDG,eAAnD;MACD,CAFD,MAEO,IAAIxf,KAAK,CAACC,OAAN,CAAc6f,IAAd,CAAJ,EAAyB;QAC9B,KAAKX,sBAAL,CAA4BW,IAA5B,EAAkCT,UAAlC,EAA8CG,eAA9C;MACD;IACF,CATD;IAUA,OAAOJ,YAAP;EACD;;EAEaF,0BAA0B,CAACa,UAAD,EAA4B;;MAClE,IAAIjf,OAAJ;;MACA,IAAI;QACFA,OAAO,GAAG,CAAC,MAAM,KAAKud,IAAL,CAAU2B,OAAV,CAAkBD,UAAlB,CAAP,EAAsCjf,OAAhD;MACD,CAFD,CAEE,OAAOzE,KAAP,EAAmB;QACnB,MAAMqD,QAAQ,GAAGC,0BAA0B,CAACtD,KAAD,CAA3C;QACA,MAAMqD,QAAQ,GACV,IAAIF,mBAAJ,CACE,6CACE,KAAKgf,wBAAL,CAA8B/e,QAChC,iBAAiBZ,IAAI,CAACC,SAAL,CAAeY,QAAf,CAAwB,EAH3C,EAIE,KAAK8e,wBAAL,CAA8B/e,QAJhC,EAKEC,QALF,EAMErD,KANF,CADU,GASVA,KATJ;MAUD;;MACD,IAAI,CAACyE,OAAO,CAACnC,IAAb,EAAmB;QACjB,MAAM,IAAIa,mBAAJ,CACJ,kDAAkDsB,OAAO,EADrD,EAEJ,KAAK0d,wBAAL,CAA8B/e,QAF1B,CAAN;MAID;;MACD,OAAO,KAAK+e,wBAAL,CAA8ByB,gBAA9B,CAA+Cnf,OAAO,CAACnC,IAAR,CAAa,CAAb,CAA/C,CAAP;IACD;EAAA;;AA7IqB;;MClDXuhB,sBAAqB;EAChCnlB,YAAoBwgB,QAApB,EAAyCxB,eAAzC,EAAgE;IAA5C;IAAqB;EAA2B;;EAEpEoG,8BAA8B,CAC5BC,yBAD4B,EAE5B3hB,uBAF4B,EAG5BE,IAH4B,EAI5B+c,oBAAoB,GAAG,IAJK,EAK5BC,WAAW,GAAG,KALc,EAKT;IAEnB,OAAO,IAAIL,cAAJ,CACL,KAAKC,QADA,EAEL,KAAKxB,eAFA,EAGLqG,yBAHK,EAIL3hB,uBAJK,EAKLE,IALK,EAML+c,oBANK,EAOLC,WAPK,CAAP;EASD;;EAED0E,+BAA+B,CAC7BD,yBAD6B,EAE7B3hB,uBAF6B,EAG7BE,IAH6B,EAI7B+c,oBAAoB,GAAG,IAJM,EAK7BC,WAAW,GAAG,KALe,EAKV;IAEnB,OAAO,IAAI+B,oBAAJ,CACL,KAAKnC,QADA,EAEL,KAAKxB,eAFA,EAGLqG,yBAHK,EAIL3hB,uBAJK,EAKLE,IALK,EAML+c,oBANK,EAOLC,WAPK,CAAP;EASD;;EAED2E,6BAA6B,CAC3BnlB,GAD2B,EAE3B+O,YAF2B,EAG3BqW,uBAH2B,EAI3BxC,mBAJ2B,EAK3BE,QAL2B,EAKd;IAEb,OAAO,IAAIG,WAAJ,CACLjjB,GADK,EAEL+O,YAFK,EAGL,KAAK6P,eAHA,EAILwG,uBAJK,EAKLxC,mBALK,EAMLE,QANK,CAAP;EAQD;;AAtD+B;;MCerB7B,kCAAkC,GAAG;AAElD;;;;MAGaoE,aAAY;EACvBzlB,YACU0lB,eADV,EAEUhF,IAFV,EAGUiF,wBAHV,EAIUlF,eAJV,EAKU7c,IALV,EAMUxD,GANV,EAOU+O,YAPV,EAOsC;IAN5B;IACA;IACA;IACA;IACA;IACA;IACA;EACN;;EAEEyW,IAAI,CAAC3B,OAAD,EAAmB;;MAC3B,IAAI/B,uBAAuB,CAAC+B,OAAD,CAAvB,IAAoCnX,gBAAgB,CAACC,KAAzD,EAAgE;QAC9D,MAAM,IAAI8D,gBAAJ,CACJ,gJADI,CAAN;MAGD,CAJD,MAIO,IAAIoT,OAAO,IAAI4B,aAAa,CAAC5B,OAAD,CAAb,KAA2BnX,gBAAgB,CAACC,KAA3D,EAAkE;QACvE,MAAM,IAAI+Y,mBAAJ,CAAwB7B,OAAxB,CAAN;MACD;;MACD,MAAM8B,GAAG,GAAG,KAAKtF,eAAL,CAAqB3Z,MAArB,CAA4B,GAAG,KAAKlD,IAApC,CAAZ;MACA,MAAMgG,MAAM,GAAG,MAAM,KAAKxJ,GAAL,CAAS4lB,OAAT,CAAiB;QACpC7N,QAAQ,EAAE,KAAKuN,eAAL,CAAqBtN,OADK;QAEpCgJ,UAAU,EAAE,KAAKV,IAFmB;QAGpC0C,KAAK,EAAE2C,GAH6B;QAIpCpI,QAAQ,EAAEsG,OAAO,GAAGA,OAAH,GAAa,MAAM,KAAK9U,YAAL,CAAkByO,UAAlB;MAJA,CAAjB,CAArB;MAMA,OAAO,KAAK+H,wBAAL,CAA8BM,OAA9B,CAAsCrc,MAAM,CAACxI,IAA7C,CAAP;IACD;EAAA;;AA3BsB;;AA8BzB,MAAMyf,YAAY,GAAG,CAACjd,IAAD,EAAcgD,MAAd,EAAuC8Z,IAAvC,KAAmD;EACtE,MAAM/c,IAAI,GAAGiD,MAAM,CAACka,iBAAP,EAAb;;EAEA,IAAI,CAACnd,IAAI,CAAC8C,IAAL,CAAWgE,CAAD,IAAcA,CAAC,CAAC5G,MAAF,KAAaD,IAAI,CAACC,MAA1C,CAAL,EAAwD;IACtD,MAAM,IAAIJ,qBAAJ,CAA0Bid,IAA1B,EAAgC/c,IAAhC,EAAsCC,IAAtC,CAAN;EACD;AACF,CAND,C,CAQA;;;AACA,MAAMsiB,MAAM,GAAI9E,UAAD,IAAkC;EAC/C,IAAI8E,MAAM,GAAG,KAAb;;EACA,IAAI,UAAU9E,UAAV,IAAwBA,UAAU,CAACza,IAAX,KAAoB,MAA5C,IAAsDya,UAAU,CAACxd,IAArE,EAA2E;IACzE,MAAMuiB,WAAW,GAAG/E,UAAU,CAACxd,IAAX,CAAgBwd,UAAU,CAACxd,IAAX,CAAgBC,MAAhB,GAAyB,CAAzC,CAApB;;IACA,IAAI,UAAUsiB,WAAV,IAAyBA,WAAW,CAACxf,IAAZ,KAAqB,UAAlD,EAA8D;MAC5Duf,MAAM,GAAG,IAAT;IACD;EACF;;EACD,OAAOA,MAAP;AACD,CATD;AAuCA;;;;;MAGazD,oBAAmB;EAuC9BziB,YACkBoY,OADlB,EAEkBrR,MAFlB,EAGEyZ,QAHF,EAIU4F,eAJV,EAKkB9D,WALlB,EAMUliB,GANV,EAOU+O,YAPV,EAOsC;IANpB;IACA;IAER;IACQ;IACR;IACA;;;;;;;IAhCH,eAAoB,EAApB;;;;;;;;IAOA,qBAAgC,EAAhC;;;;;;IAKA,aAAgB,EAAhB;;;;;;;IAMA,qBAAgC,EAAhC;IAgBL,KAAKkX,qBAAL,GAA6B,IAAIlB,qBAAJ,CAA0B3E,QAA1B,EAAoCpI,OAApC,CAA7B;IACA,KAAKxR,MAAL,GAAcC,MAAM,CAACyf,eAAP,CAAuB;MAAEvf,MAAM,EAAE,KAAKA;IAAf,CAAvB,CAAd;IACA,KAAK0Z,eAAL,GAAuB8F,eAAe,CAACD,eAAhB,CAAgC;MAAEvf,MAAM,EAAE,KAAKA;IAAf,CAAhC,CAAvB;IAEA,KAAKyf,UAAL,GAAkBC,UAAU,CAACH,eAAX,CAA2B;MAAEvf,MAAM,EAAE,KAAKA;IAAf,CAA3B,CAAlB;;IACA,IAAI,KAAKyf,UAAL,CAAgB3iB,MAAhB,KAA2B,CAA/B,EAAkC;MAChC,KAAK6iB,uBAAL,CAA6B,IAA7B,EAAmCtmB,GAAnC,EAAwC,KAAK+O,YAA7C,EAA2D,KAAKqX,UAAhE;IACD;;IACD,KAAKG,kBAAL,CAAwB,IAAxB,EAA8B,KAAKrE,WAAL,CAAiBA,WAA/C,EAA4D,KAAKliB,GAAjE,EAAsE,KAAK+O,YAA3E;EACD;;EAEOwX,kBAAkB,CACxBjB,eADwB,EAExBpD,WAFwB,EAKxBliB,GALwB,EAMxB+O,YANwB,EAMI;IAE5B,MAAMsR,eAAe,GAAG,KAAKA,eAA7B;IACA,MAAMmG,IAAI,GAAGre,MAAM,CAACqe,IAAP,CAAYtE,WAAZ,CAAb;;IACA,IAAI7B,eAAe,CAACoG,oBAApB,EAA0C;MACxCD,IAAI,CAACpc,OAAL,CAAc9G,uBAAD,IAAwB;QACnC,MAAM2hB,yBAAyB,GAAG,IAAIkB,eAAJ,CAAoBjE,WAAW,CAAC5e,uBAAD,CAA/B,CAAlC;;QAEC,KAAKojB,OAAL,CAAmCpjB,uBAAnC,IAA8D,UAAU,GAAGE,IAAb,EAAwB;UACrF,OAAO8hB,eAAe,CAACW,qBAAhB,CAAsCjB,8BAAtC,CACLC,yBADK,EAEL3hB,uBAFK,EAGLE,IAHK,CAAP;QAKD,CANA;;QAQA,KAAKmjB,aAAL,CAA+CrjB,uBAA/C,IAA0E,UACzEE,IADyE,EAChE;UAET,OAAO8hB,eAAe,CAACW,qBAAhB,CAAsCf,+BAAtC,CACLD,yBADK,EAEL3hB,uBAFK,EAGLE,IAHK,CAAP;QAKD,CARA;;QAUD,IAAIsiB,MAAM,CAAC5D,WAAW,CAAC5e,uBAAD,CAAZ,CAAV,EAAkD;UAChD,MAAMsjB,IAAI,GAAG,UAAU,GAAGpjB,IAAb,EAAwB;YACnC,MAAMqjB,8BAA8B,GAAI3E,WAAW,CAAC5e,uBAAD,CAAX,CACrCE,IADqC,CAChC,CADgC,CAAxC;YAEA,MAAMsjB,wCAAwC,GAAG,IAAIX,eAAJ,CAC/CU,8BAD+C,CAAjD;YAGA,MAAME,kBAAkB,GAAI7E,WAAW,CAAC5e,uBAAD,CAAX,CAA6CE,IAA7C,CAAkD,CAAlD,EACzBA,IADyB,CACpB,CADoB,CAA5B;YAEA,MAAMwjB,iCAAiC,GAAG,IAAIb,eAAJ,CAAoBY,kBAApB,CAA1C;YAEAtG,YAAY,CAACjd,IAAD,EAAOsjB,wCAAP,EAAiDxjB,uBAAjD,CAAZ;YACA,OAAO,IAAI+hB,YAAJ,CACLC,eADK,EAELhiB,uBAFK,EAGL0jB,iCAHK,EAILF,wCAJK,EAKLtjB,IALK,EAMLxD,GANK,EAOL+O,YAPK,CAAP;UASD,CApBD;;UAqBC,KAAKkY,KAAL,CAA4B3jB,uBAA5B,IAAuDsjB,IAAvD;QACF;MACF,CA7CD,EADwC;;;MAkDxC,MAAMM,gBAAgB,GAAG/e,MAAM,CAACqe,IAAP,CAAYnG,eAAe,CAACM,aAAhB,EAAZ,EAA6CtU,MAA7C,CACtBoT,GAAD,IAAStX,MAAM,CAACqe,IAAP,CAAYtE,WAAZ,EAAyBzZ,OAAzB,CAAiCgX,GAAjC,MAA0C,CAAC,CAD7B,CAAzB;MAIAyH,gBAAgB,CAAC9c,OAAjB,CAA0B9G,uBAAD,IAAwB;QAC9C,KAAKojB,OAAL,CAAmCpjB,uBAAnC,IAA8D,UAAU,GAAGE,IAAb,EAAwB;UACrF,OAAO8hB,eAAe,CAACW,qBAAhB,CAAsCjB,8BAAtC,CACL3E,eADK,EAEL/c,uBAFK,EAGLE,IAHK,EAIL,KAJK,EAKL,IALK,CAAP;QAOD,CARA;;QAUA,KAAKmjB,aAAL,CAA+CrjB,uBAA/C,IAA0E,UACzEE,IADyE,EAChE;UAET,OAAO8hB,eAAe,CAACW,qBAAhB,CAAsCf,+BAAtC,CACL7E,eADK,EAEL/c,uBAFK,EAGLE,IAHK,EAIL,KAJK,EAKL,IALK,CAAP;QAOD,CAVA;MAWF,CAtBD;IAuBD,CA7ED,MA6EO;MACL,MAAMyhB,yBAAyB,GAAG,KAAK5E,eAAvC;;MACC,KAAKqG,OAAL,CAAmCzF,kCAAnC,IAAyE,UACxE,GAAGzd,IADqE,EAC1D;QAEd,OAAO8hB,eAAe,CAACW,qBAAhB,CAAsCjB,8BAAtC,CACLC,yBADK,EAELhE,kCAFK,EAGLzd,IAHK,EAIL,KAJK,CAAP;MAMD,CATA;;MAWA,KAAKmjB,aAAL,CAA+C1F,kCAA/C,IACC,UAAUzd,IAAV,EAAmB;QACjB,OAAO8hB,eAAe,CAACW,qBAAhB,CAAsCf,+BAAtC,CACLD,yBADK,EAELhE,kCAFK,EAGLzd,IAHK,EAIL,KAJK,CAAP;MAMD,CARF;IASF;EACF;;EAEO8iB,uBAAuB,CAC7BhB,eAD6B,EAE7BtlB,GAF6B,EAG7B+O,YAH6B,EAI7BoY,gBAJ6B,EAIC;IAE9B,MAAM/gB,WAAW,GAAG,KAAKI,MAAL,CAAY4gB,GAAhC;IAEAD,gBAAgB,CAAC/c,OAAjB,CAA0Bgc,UAAD,IAAW;MACjC,KAAKiB,aAAL,CAA4CjB,UAAU,CAAC9hB,QAAvD,IAAmE,UAAUd,IAAV,EAAmB;QACrF,OAAO8hB,eAAe,CAACW,qBAAhB,CAAsCd,6BAAtC,CACLnlB,GADK,EAEL+O,YAFK,EAGLqX,UAHK,EAILhgB,WAJK,EAKL5C,IALK,CAAP;MAOD,CARA;IASF,CAVD;EAWD;;;;;;EAKMmC,OAAO;IACZ,OAAO,KAAKqgB,eAAL,CAAqBlC,UAArB,CAAmC,KAAK9L,OAAxC,EAAiD,KAAKxR,MAAtD,CAAP;EACD;;;;;;;;;;;;;EAYM8gB,MAAM,CAAC7H,GAAD,EAAY;IACvB,OAAO,KAAKuG,eAAL,CAAqBuB,YAArB,CAAkC,KAAKvP,OAAvC,EAAgDyH,GAAhD,EAAqD,KAAKjZ,MAA1D,CAAP;EACD;;AAnN6B;;MCzGnBghB,kBAAiB;EAC5B5nB,YAAoBwJ,EAApB,EAA2C5C,MAA3C,EAAmE4Z,QAAnE,EAA6F;IAAzE;IAAuB;IAAwB;EAA8B;;;;;;;;;;;;EAW3FqH,GAAG,CAAIC,WAAJ,EAAgCtQ,KAAhC,EAA8C;;MACrD,IAAI;QACF,MAAMhO,EAAE,GAAG,MAAM,KAAKgX,QAAL,CAAcuH,gBAAd,CACf,KAAKve,EAAL,CAAQnC,QAAR,EADe,EAEfygB,WAFe,EAGf,KAAKlhB,MAHU,EAIf4Q,KAJe,CAAjB;QAMA,OAAOhO,EAAP;MACD,CARD,CAQE,OAAOnE,CAAP,EAAU;QACV,IAAIA,CAAC,YAAY2iB,iBAAb,IAAkC3iB,CAAC,CAACsF,MAAF,KAAasd,WAAW,CAACC,SAA/D,EAA0E;UACxE,OAAO5hB,SAAP;QACD,CAFD,MAEO;UACL,MAAMjB,CAAN;QACD;MACF;IACF;EAAA;;;;;;;;;;;;;;;;EAeK8iB,iBAAiB,CAAIC,YAAJ,EAAwC5Q,KAAxC,EAAwD6Q,SAAS,GAAG,CAApE,EAAqE;;MAC1F,OAAO,KAAK7H,QAAL,CAAc8H,iBAAd,CACL,KAAK9e,EAAL,CAAQnC,QAAR,EADK,EAEL+gB,YAFK,EAGL,KAAKxhB,MAHA,EAIL4Q,KAJK,EAKL6Q,SALK,CAAP;IAOD;EAAA;;EAEDE,MAAM;IACJ,OAAO,KAAK/e,EAAL,CAAQnC,QAAR,EAAP;EACD;;EAEDA,QAAQ;IACN,OAAO,KAAKmC,EAAL,CAAQnC,QAAR,EAAP;EACD;;AA3D2B;;MCFjBmhB,wBAAuB;EAChCxoB,YAAoBwJ,EAApB,EAA2CgX,QAA3C,EAAqE;IAAjD;IAAuB;EAA+B;;;;;;;;;;;EAUpEiI,cAAc,CAACjR,KAAD,EAAe;;MAC/B,OAAO,KAAKgJ,QAAL,CAAckI,kBAAd,CAAiC,KAAKlf,EAAL,CAAQnC,QAAR,EAAjC,EAAqDmQ,KAArD,CAAP;IACH;EAAA;;EAEDmR,KAAK;IACD,OAAO,KAAKnf,EAAL,CAAQnC,QAAR,EAAP;EACH;;AAjB+B,C,CCIpC;;;AACO,MAAMuhB,gCAAgC,GAC3CpI,QADiF,KAE7E;;EAEJqI,OAAO,EAAE,CAACrB,GAAD,EAA6B7hB,IAA7B,KAAwD;IAC/D,IAAI,CAAC6hB,GAAD,IAAQ,EAAE,SAASA,GAAX,CAAR,IAA2BA,GAAG,CAAC9d,GAAJ,KAAYpD,SAA3C,EAAsD;;MAEpD,OAAO,EAAP;IACD,CAHD,MAGO;MACL,MAAMM,MAAM,GAAG,IAAIC,MAAJ,CAAWlB,IAAX,CAAf;MACA,OAAO,IAAIiiB,iBAAJ,CAAsB,IAAIzkB,SAAJ,CAAcqkB,GAAG,CAAC9d,GAAlB,CAAtB,EAA8C9C,MAA9C,EAAsD4Z,QAAtD,CAAP;IACD;EACF,CAVG;EAWJsI,aAAa,EAAGtB,GAAD,IAA2B;IACxC,IAAI,CAACA,GAAD,IAAQ,EAAE,SAASA,GAAX,CAAR,IAA2BA,GAAG,CAAC9d,GAAJ,KAAYpD,SAA3C,EAAsD;;MAEpD,OAAO,EAAP;IACD,CAHD,MAGO;MACL,OAAO,IAAIkiB,uBAAJ,CAA4B,IAAIrlB,SAAJ,CAAcqkB,GAAG,CAAC9d,GAAlB,CAA5B,EAAoD8W,QAApD,CAAP;IACD;EACF;;;;;;;AAlBG,CAF6E,CAA5E;;MCoCMuI,4BACHla,iBAAgB;EAGxB7O,YAAYC,OAAZ,EAAsC0R,SAAtC,EAAmE;IACjE,MAAM1R,OAAN;IADoC;IAGtC,kCAA6B+oB,MAAM,CAACC,GAAP,CAAW,+BAAX,CAA7B;EADC;;;;;;;;;;;;EAYK/E,UAAU,CAAI/L,QAAJ,EAAsBvR,MAAtB,EAA6C;;MAC3D,IAAIsb,uBAAuB,CAAC/J,QAAD,CAAvB,KAAsCrL,gBAAgB,CAACC,KAA3D,EAAkE;QAChE,MAAM,IAAIoV,2BAAJ,CAAgChK,QAAhC,CAAN;MACD;;MACD,MAAMpR,MAAM,GAAG,MAAM,KAAK9G,OAAL,CAAakP,YAAb,CAA0BkT,SAA1B,CAAoClK,QAApC,EAA8C,MAA9C,CAArB;;MACA,IAAI,CAACvR,MAAL,EAAa;QACXA,MAAM,GAAGG,MAAT;MACD;;MAED,IAAImiB,cAAJ;;MACA,IAAIriB,MAAM,CAACsiB,QAAP,CAAgBviB,MAAhB,CAAJ,EAA6B;QAC3BsiB,cAAc,GAAGtiB,MAAjB;MACD,CAFD,MAEO;QACLsiB,cAAc,GAAGriB,MAAM,CAACyf,eAAP,CAAuB;UAAEvf,MAAM,EAAEH;QAAV,CAAvB,CAAjB;MACD;;MAED,OAAOsiB,cAAc,CAACjD,OAAf,CAAuBlf,MAAM,CAAChB,OAA9B,EAAuC6iB,gCAAgC,CAAC,IAAD,CAAvE,CAAP,EAA2F;IAC5F;EAAA;;;;;;;;;;;;;;;EAcKjB,YAAY,CAAIxP,QAAJ,EAAsB0H,GAAtB,EAAmCjZ,MAAnC,EAA0D;;MAC1E,IAAIsb,uBAAuB,CAAC/J,QAAD,CAAvB,KAAsCrL,gBAAgB,CAACC,KAA3D,EAAkE;QAChE,MAAM,IAAIoV,2BAAJ,CAAgChK,QAAhC,CAAN;MACD;;MACD,IAAI,CAACvR,MAAL,EAAa;QACXA,MAAM,GAAG,CAAC,MAAM,KAAKxG,GAAL,CAASgpB,WAAT,CAAqBjR,QAArB,CAAP,EAAuCpR,MAAhD;MACD;;MAED,IAAImiB,cAAJ;;MACA,IAAIriB,MAAM,CAACsiB,QAAP,CAAgBviB,MAAhB,CAAJ,EAA6B;QAC3BsiB,cAAc,GAAGtiB,MAAjB;MACD,CAFD,MAEO;QACLsiB,cAAc,GAAGriB,MAAM,CAACyf,eAAP,CAAuB;UAAEvf,MAAM,EAAEH;QAAV,CAAvB,CAAjB;MACD;;MAED,MAAMyiB,UAAU,GAAGH,cAAc,CAACI,eAAf,CAA+BzJ,GAA/B,CAAnB;MAEA,MAAM2H,GAAG,GAAG,MAAM,KAAKpnB,GAAL,CAASunB,YAAT,CAAsBxP,QAAtB,EAAgCkR,UAAhC,CAAlB;MAEA,OAAOH,cAAc,CAACK,oBAAf,CAAoC/B,GAApC,CAAP,EAAqD;IACtD;EAAA;;;;;;;;;;;;;;EAaKO,gBAAgB,CACpBve,EADoB,EAEpBse,WAFoB,EAGpBlhB,MAHoB,EAIpB4Q,KAJoB,EAIN;;MAEd,MAAM;QAAEqI,GAAF;QAAO2J;MAAP,IAAgB5iB,MAAM,CAAC0iB,eAAP,CAAuBxB,WAAvB,CAAtB;MACA,MAAM;QAAE2B;MAAF,IAAa,MAAM,KAAKxpB,OAAL,CAAaypB,MAAb,CAAoBC,QAApB,CAA6B;QAAEvoB,IAAI,EAAEye,GAAR;QAAa2J;MAAb,CAA7B,CAAzB;MAEA,MAAMI,WAAW,GAAGC,UAAU,CAACJ,MAAD,CAA9B;MAEA,MAAMK,WAAW,GAAGtS,KAAK,GACrB,MAAM,KAAKvX,OAAL,CAAakP,YAAb,CAA0B4a,cAA1B,CACJ;QAAEvgB,EAAE,EAAEA,EAAE,CAACnC,QAAH,EAAN;QAAqB2iB,IAAI,EAAEJ;MAA3B,CADI,EAEJpS,KAFI,CADe,GAKrB,MAAM,KAAKvX,OAAL,CAAakP,YAAb,CAA0B4a,cAA1B,CACJ;QAAEvgB,EAAE,EAAEA,EAAE,CAACnC,QAAH,EAAN;QAAqB2iB,IAAI,EAAEJ;MAA3B,CADI,EAEJ,MAFI,CALV;MAUA,OAAOhjB,MAAM,CAAC2iB,oBAAP,CAA4BO,WAA5B,EAAyClB,gCAAgC,CAAC,IAAD,CAAzE,CAAP;IACD;EAAA;;;;;;;;;;;;;;;;;;EAiBKN,iBAAiB,CACrB9e,EADqB,EAErBod,IAFqB,EAGrBhgB,MAHqB,EAIrB4Q,KAJqB,EAKrB6Q,SAAS,GAAG,CALS,EAKR;;MAEb,MAAM7b,KAAK,GAAG,MAAM,KAAKyd,kBAAL,CAAwBrD,IAAxB,EAA8BpP,KAA9B,CAApB;MACA,MAAM0S,YAAY,GAAG,IAAIC,YAAJ,EAArB;;MAGA,IAAIC,QAAQ,GAAG,CAAf;MACA,IAAIrgB,OAAO,GAAyB,EAApC;;MAEA,OAAOqgB,QAAQ,GAAGxD,IAAI,CAAC/iB,MAAvB,EAA+B;QAC7B,MAAMwmB,SAAS,GAAGzD,IAAI,CAAC0D,KAAL,CAAWF,QAAX,EAAqBA,QAAQ,GAAG/B,SAAhC,CAAlB;QACA,MAAMxU,KAAK,GAAGwW,SAAS,CAACle,GAAV,CAAe2b,WAAD,IAC1B,KAAKyC,yBAAL,CAAkCzC,WAAlC,EAA+Cte,EAA/C,EAAmD5C,MAAnD,EAA2D4F,KAA3D,CADY,CAAd;QAGAzC,OAAO,GAAG,CAAC,GAAGA,OAAJ,EAAa,IAAI,MAAM+D,OAAO,CAACmC,GAAR,CAAY4D,KAAZ,CAAV,CAAb,CAAV;QACAuW,QAAQ,IAAI/B,SAAZ;MACD;;MAED,KAAK,IAAIpe,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,OAAO,CAAClG,MAA5B,EAAoCoG,CAAC,EAArC,EAAyC;QACvCigB,YAAY,CAACM,GAAb,CAAiB5D,IAAI,CAAC3c,CAAD,CAArB,EAA0BF,OAAO,CAACE,CAAD,CAAjC;MACD;;MAED,OAAOigB,YAAP;IACD;EAAA;;EAEaD,kBAAkB,CAACrD,IAAD,EAA6BpP,KAA7B,EAA2C;;MACzE,OAAOoP,IAAI,CAAC/iB,MAAL,KAAgB,CAAhB,IAAqB,OAAO2T,KAAP,KAAiB,WAAtC,GACHA,KADG,GAEH,MAAM,KAAKvX,OAAL,CAAakP,YAAb,CAA0ByH,aAA1B,CAAwC,MAAxC,CAFV;IAGD;EAAA;;EAEa2T,yBAAyB,CACrCzC,WADqC,EAErCte,EAFqC,EAGrC5C,MAHqC,EAIrC4F,KAJqC,EAIvB;;MAEd,IAAI;QACF,OAAO,MAAM,KAAKub,gBAAL,CAAyBve,EAAzB,EAA6Bse,WAA7B,EAA0ClhB,MAA1C,EAAkD4F,KAAlD,CAAb;MACD,CAFD,CAEE,OAAOie,EAAP,EAAW;QACX,IAAIA,EAAE,YAAYzC,iBAAd,IAAmCyC,EAAE,CAAC9f,MAAH,KAAcsd,WAAW,CAACC,SAAjE,EAA4E;UAC1E;QACD,CAFD,MAEO;UACL,MAAMuC,EAAN;QACD;MACF;IACF;EAAA;;;;;;;;;;;EAUK/B,kBAAkB,CAAClf,EAAD,EAAagO,KAAb,EAA2B;;MACjD,MAAMkT,YAAY,GAAGlT,KAAK,GACtB,MAAM,KAAKvX,OAAL,CAAakP,YAAb,CAA0Bwb,kBAA1B,CAA6C;QAAEnhB,EAAE,EAAEA,EAAE,CAACnC,QAAH;MAAN,CAA7C,EAAoEmQ,KAApE,CADgB,GAEtB,MAAM,KAAKvX,OAAL,CAAakP,YAAb,CAA0Bwb,kBAA1B,CAA6C;QAAEnhB,EAAE,EAAEA,EAAE,CAACnC,QAAH;MAAN,CAA7C,EAAoE,MAApE,CAFV;MAGA,OAAOqjB,YAAP;IACD;EAAA;;EAEaE,0BAA0B,CAAC5jB,SAAD,EAA0BtG,aAA1B,EAA+C;;MACrF,IAAIoI,iBAAiB,CAAC9B,SAAD,CAArB,EAAkC;QAChC,MAAMwI,GAAG,GAAmB,CAACxI,SAAD,CAA5B;QACA,MAAMvG,SAAS,GAAG,MAAM,KAAKqO,MAAL,CAAYrO,SAAZ,EAAxB;QACA,MAAMoqB,cAAc,GAAG,MAAM,KAAKlZ,SAAL,CAAeqC,MAAf,EAA7B;;QACA,IAAI6W,cAAJ,EAAoB;UAClB,MAAM7W,MAAM,GAA0C;YAAE/M,IAAI,EAAEC,MAAM,CAACc;UAAf,CAAtD;UACA,MAAMiM,eAAe,GAAG,MAAM,KAAKxC,QAAL,CAAcuC,MAAd,EAAsB;YAAY;UAAc,CAA1B,CAAtB,CAA9B;UACAxE,GAAG,CAAC0E,OAAJ,CAAY,MAAMnM,qBAAqB,mBAAMkM,eAAN,GAAyBvT,aAAzB,EAAwCD,SAAxC,CAAvC;UACA,OAAO+O,GAAP;QACD;MACF;;MACD,OAAOxI,SAAP;IACD;EAAA;;;;;;;;;;;;;EAYK8W,SAAS,CACb3P,MADa,EAC0C;;MAEvD,MAAMsD,QAAQ,GAAG,MAAM,KAAKA,QAAL,CAActD,MAAd,EAAsB,KAAKwD,SAAL,CAAemM,SAAf,CAAyBgN,IAAzB,CAA8B,KAAKnZ,SAAnC,CAAtB,CAAvB;MAEA,MAAMjR,aAAa,GAAG,MAAM,KAAKoO,MAAL,CAAYpO,aAAZ,EAA5B;MACA,MAAMsG,SAAS,GAAG,MAAMtB,0BAA0B,CAChD,MAAM,KAAKzF,OAAL,CAAawT,MAAb,CAAoBC,sBAApB,CAA0CnL,gCAC3C4F,MAD2C,GAE3CsD,QAF2C,CAA1C,CAD0C,CAAlD;MAMA,MAAMjC,GAAG,GAAG,MAAM,KAAKob,0BAAL,CAAgC5jB,SAAhC,EAA2CtG,aAA3C,CAAlB;MACA,MAAMqqB,mBAAmB,GAAG,MAAM,KAAKzb,gBAAL,CAAsB;QACtDtI,SAAS,EAAEwI,GAD2C;QAEtDvL,MAAM,EAAEvD;MAF8C,CAAtB,CAAlC;MAIA,MAAMsqB,iBAAiB,GAAG,MAAM,KAAK/Z,KAAL,CAAW8Z,mBAAX,CAAhC;MACA,MAAM;QAAE5f,IAAF;QAAQlL,OAAR;QAAiBiR,WAAjB;QAA8BI;MAA9B,IAA6C,MAAM,KAAKY,aAAL,CAAmB8Y,iBAAnB,CAAzD;MACA,OAAO,IAAInM,oBAAJ,CACL1T,IADK,EAELnE,SAFK,EAGLkK,WAHK,EAILI,UAJK,EAKLrR,OALK,EAML,IANK,CAAP;IAQD;EAAA;;;;;;;;;;;EAUKqe,WAAW,CAACnQ,MAAD,EAAuB;;MACtC,IAAIA,MAAM,CAAClK,MAAP,IAAiB2O,eAAe,CAACzE,MAAM,CAAClK,MAAR,CAAf,KAAmC6I,gBAAgB,CAACC,KAAzE,EAAgF;QAC9E,MAAM,IAAI8F,mBAAJ,CAAwB1E,MAAM,CAAClK,MAA/B,CAAN;MACD;;MACD,IAAIkK,MAAM,CAACrI,QAAP,IAAmB8M,eAAe,CAACzE,MAAM,CAACrI,QAAR,CAAf,KAAqCgH,gBAAgB,CAACC,KAA7E,EAAoF;QAClF,MAAM,IAAI8F,mBAAJ,CAAwB1E,MAAM,CAACrI,QAA/B,CAAN;MACD;;;MAGD,IAAI,OAAOmlB,IAAP,CAAY9c,MAAM,CAAClK,MAAnB,CAAJ,EAAgC;QAC9B,MAAM,IAAID,uBAAJ,CAA4BmK,MAAM,CAAClK,MAAnC,CAAN;MACD;;MAED,MAAMwN,QAAQ,GAAG,MAAM,KAAKA,QAAL,CAActD,MAAd,EAAsB,KAAKwD,SAAL,CAAe2M,WAAf,CAA2BwM,IAA3B,CAAgC,KAAKnZ,SAArC,CAAtB,CAAvB;MACA,MAAMjR,aAAa,GAAG,MAAM,KAAKoO,MAAL,CAAYpO,aAAZ,EAA5B;MACA,MAAMsG,SAAS,GAAG,MAAMY,0BAA0B,iCAAMuG,MAAN,GAAiBsD,QAAjB,EAAlD;MACA,MAAM8M,eAAe,GAAGpQ,MAAM,CAAClK,MAAP,IAAiBvD,aAAzC;MACA,MAAM8O,GAAG,GAAG,MAAM,KAAKob,0BAAL,CAAgC5jB,SAAhC,EAA2CtG,aAA3C,CAAlB;MACA,MAAMyT,QAAQ,GAAG,MAAM,KAAK7E,gBAAL,CAAsB;QAC3CtI,SAAS,EAAEwI,GADgC;QAE3CvL,MAAM,EAAEsa;MAFmC,CAAtB,CAAvB;MAIA,MAAMnK,OAAO,GAAG,MAAM,KAAKnD,KAAL,CAAWkD,QAAX,CAAtB;MACA,MAAM;QAAEhJ,IAAF;QAAQlL,OAAR;QAAiBiR,WAAjB;QAA8BI;MAA9B,IAA6C,MAAM,KAAKY,aAAL,CAAmBkC,OAAnB,CAAzD;MACA,OAAO,IAAIsK,iBAAJ,CACLvT,IADK,EAELnE,SAFK,EAGLuX,eAHK,EAILrN,WAJK,EAKLI,UALK,EAMLrR,OANK,CAAP;IAQD;EAAA;;;;;;;;;;;EAUKue,gBAAgB,CAACrQ,MAAD,EAA+B;;MACnD,MAAMsD,QAAQ,GAAG,MAAM,KAAKA,QAAL,CACrBtD,MADqB,EAErB,KAAKwD,SAAL,CAAe6M,gBAAf,CAAgCsM,IAAhC,CAAqC,KAAKnZ,SAA1C,CAFqB,CAAvB;MAIA,MAAM1N,MAAM,GAAG,MAAM,KAAK6K,MAAL,CAAYpO,aAAZ,EAArB;MACA,MAAMsG,SAAS,GAAG,MAAMc,+BAA+B,iCAAMqG,MAAN,GAAiBsD,QAAjB,GAA6BxN,MAA7B,CAAvD;MACA,MAAMuL,GAAG,GAAG,MAAM,KAAKob,0BAAL,CAAgC5jB,SAAhC,EAA2C/C,MAA3C,CAAlB;MACA,MAAMkQ,QAAQ,GAAG,MAAM,KAAK7E,gBAAL,CAAsB;QAAEtI,SAAS,EAAEwI;MAAb,CAAtB,CAAvB;MACA,MAAM4E,OAAO,GAAG,MAAM,KAAKnD,KAAL,CAAWkD,QAAX,CAAtB;MACA,MAAM;QAAEhJ,IAAF;QAAQlL,OAAR;QAAiBiR,WAAjB;QAA8BI;MAA9B,IAA6C,MAAM,KAAKY,aAAL,CAAmBkC,OAAnB,CAAzD;MACA,OAAO,IAAIsK,iBAAJ,CAAsBvT,IAAtB,EAA4BnE,SAA5B,EAAuC/C,MAAvC,EAA+CiN,WAA/C,EAA4DI,UAA5D,EAAwErR,OAAxE,CAAP;IACD;EAAA;;;;;;;;;;;EAUKoe,QAAQ,CAAClQ,MAAD,EAAuB;;MACnC,IAAIyE,eAAe,CAACzE,MAAM,CAACnL,EAAR,CAAf,KAA+B8J,gBAAgB,CAACC,KAApD,EAA2D;QACzD,MAAM,IAAI8F,mBAAJ,CAAwB1E,MAAM,CAACnL,EAA/B,CAAN;MACD;;MACD,IAAImL,MAAM,CAAClK,MAAP,IAAiB2O,eAAe,CAACzE,MAAM,CAAClK,MAAR,CAAf,KAAmC6I,gBAAgB,CAACC,KAAzE,EAAgF;QAC9E,MAAM,IAAI8F,mBAAJ,CAAwB1E,MAAM,CAAClK,MAA/B,CAAN;MACD;;MAED,MAAMinB,cAAc,GAAG,MAAM,KAAKpc,MAAL,CAAYpO,aAAZ,EAA7B;MACA,MAAM+Q,QAAQ,GAAG,MAAM,KAAKA,QAAL,CAActD,MAAd,EAAsB,KAAKwD,SAAL,CAAe0M,QAAf,CAAwByM,IAAxB,CAA6B,KAAKnZ,SAAlC,CAAtB,CAAvB;MACA,MAAM3K,SAAS,GAAG,MAAMM,uBAAuB,iCAC1C6G,MAD0C,GAE1CsD,QAF0C,EAA/C;MAIA,MAAMxN,MAAM,GAAGkK,MAAM,CAAClK,MAAP,IAAiBinB,cAAhC;MACA,MAAM1b,GAAG,GAAG,MAAM,KAAKob,0BAAL,CAAgC5jB,SAAhC,EAA2CkkB,cAA3C,CAAlB;MACA,MAAM/W,QAAQ,GAAG,MAAM,KAAK7E,gBAAL,CAAsB;QAAEtI,SAAS,EAAEwI,GAAb;QAAkBvL,MAAM,EAAEkK,MAAM,CAAClK;MAAjC,CAAtB,CAAvB;MACA,MAAMmQ,OAAO,GAAG,MAAM,KAAKnD,KAAL,CAAWkD,QAAX,CAAtB;MACA,MAAM;QAAEhJ,IAAF;QAAQlL,OAAR;QAAiBiR,WAAjB;QAA8BI;MAA9B,IAA6C,MAAM,KAAKY,aAAL,CAAmBkC,OAAnB,CAAzD;MACA,OAAO,IAAIuL,oBAAJ,CAAyBxU,IAAzB,EAA+BnE,SAA/B,EAA0C/C,MAA1C,EAAkDiN,WAAlD,EAA+DI,UAA/D,EAA2ErR,OAA3E,CAAP;IACD;EAAA;;;;;;;;;;;EAUK+T,MAAM,CAAC7F,MAAD,EAAqB;;MAC/B,MAAMzN,aAAa,GAAG,MAAM,KAAKoO,MAAL,CAAYpO,aAAZ,EAA5B;MACA,MAAMmqB,cAAc,GAAG,MAAM,KAAKlZ,SAAL,CAAeqC,MAAf,CAAsB7F,MAAtB,CAA7B;;MACA,IAAI0c,cAAJ,EAAoB;QAClB,MAAM9W,SAAS,GAAG,MAAM,KAAKtC,QAAL,CAActD,MAAd,EAAsB;UAAY;QAAc,CAA1B,CAAtB,CAAxB;QACA,MAAMnH,SAAS,GAAG,MAAMe,qBAAqB,mBAEtCgM,SAFsC,GAI3CrT,aAJ2C,EAK3C,MAAM,KAAKoO,MAAL,CAAYrO,SAAZ,EALqC,CAA7C;QAOA,MAAM0T,QAAQ,GAAG,MAAM,KAAK7E,gBAAL,CAAsB;UAAEtI,SAAF;UAAa/C,MAAM,EAAEvD;QAArB,CAAtB,CAAvB;QACA,MAAM0T,OAAO,GAAG,MAAM,KAAKnD,KAAL,CAAWkD,QAAX,CAAtB;QACA,MAAM;UAAEhJ,IAAF;UAAQlL,OAAR;UAAiBiR,WAAjB;UAA8BI;QAA9B,IAA6C,MAAM,KAAKY,aAAL,CAAmBkC,OAAnB,CAAzD;QACA,OAAO,IAAIoL,eAAJ,CAAoBrU,IAApB,EAA0BnE,SAA1B,EAAqCtG,aAArC,EAAoDwQ,WAApD,EAAiEI,UAAjE,EAA6ErR,OAA7E,CAAP;MACD,CAbD,MAaO;QACL,MAAM,IAAIuF,oBAAJ,CACJ,sBAAsB9E,aAAa,8BAD/B,CAAN;MAGD;IACF;EAAA;;;;;;;;;;;EAUK+d,sBAAsB,CAACtQ,MAAD,EAAqC;;MAC/D,MAAM+c,cAAc,GAAG,MAAM,KAAKpc,MAAL,CAAYpO,aAAZ,EAA7B;MACA,MAAM+Q,QAAQ,GAAG,MAAM,KAAKA,QAAL,CACrBtD,MADqB,EAErB,KAAKwD,SAAL,CAAe8M,sBAAf,CAAsCqM,IAAtC,CAA2C,KAAKnZ,SAAhD,CAFqB,CAAvB;MAIA,MAAM3K,SAAS,GAAG,MAAMkB,qCAAqC,iCACxDiG,MADwD,GAExDsD,QAFwD,EAA7D;MAIA,MAAMjC,GAAG,GAAG,MAAM,KAAKob,0BAAL,CAAgC5jB,SAAhC,EAA2CkkB,cAA3C,CAAlB;MACA,MAAM/W,QAAQ,GAAG,MAAM,KAAK7E,gBAAL,CAAsB;QAAEtI,SAAS,EAAEwI,GAAb;QAAkBvL,MAAM,EAAEinB;MAA1B,CAAtB,CAAvB;MACA,MAAM9W,OAAO,GAAG,MAAM,KAAKnD,KAAL,CAAWkD,QAAX,CAAtB;MACA,MAAM;QAAEhJ,IAAF;QAAQlL,OAAR;QAAiBiR,WAAjB;QAA8BI;MAA9B,IAA6C,MAAM,KAAKY,aAAL,CAAmBkC,OAAnB,CAAzD;MACA,OAAO,IAAI+K,+BAAJ,CACLhU,IADK,EAELnE,SAFK,EAGLkkB,cAHK,EAILha,WAJK,EAKLI,UALK,EAMLrR,OANK,CAAP;IAQD;EAAA;;EAEKqY,EAAE,CACNF,OADM,EAEN6J,8BAA+DxX,CAAD,IAAOA,CAF/D,EAEuE;;MAE7E,IAAIyX,uBAAuB,CAAC9J,OAAD,CAAvB,KAAqCtL,gBAAgB,CAACC,KAA1D,EAAiE;QAC/D,MAAM,IAAIoV,2BAAJ,CAAgC/J,OAAhC,CAAN;MACD;;MACD,MAAMhY,GAAG,GAAG,KAAKH,OAAL,CAAamiB,cAAb,GAA8BhiB,GAA1C;MACA,MAAM+O,YAAY,GAAG,KAAKlP,OAAL,CAAamiB,cAAb,GAA8BjT,YAAnD;MACA,MAAMpI,MAAM,GAAG,MAAMoI,YAAY,CAACkT,SAAb,CAAuBjK,OAAvB,EAAgC,MAAhC,CAArB;MACA,MAAMkK,WAAW,GAAG,MAAMnT,YAAY,CAACoT,cAAb,CAA4BnK,OAA5B,CAA1B;MACA,MAAMoK,GAAG,GAAG,IAAIC,mBAAJ,CACVrK,OADU,EAEVrR,MAFU,EAGV,IAHU,EAIV,IAJU,EAKVub,WALU,EAMVliB,GANU,EAOV+O,YAPU,CAAZ;MASA,OAAO8S,2BAA2B,CAACO,GAAD,EAAM,KAAKviB,OAAX,CAAlC;IACD;EAAA;;;;;;;;;;;EAUD4T,KAAK,CAAC1F,MAAD,EAA0B;IAC7B,MAAM0F,KAAK,GAAG,IAAInB,cAAJ,CAAmB,KAAKzS,OAAxB,EAAiC,KAAK0R,SAAtC,CAAd;;IAEA,IAAI1M,KAAK,CAACC,OAAN,CAAciJ,MAAd,CAAJ,EAA2B;MACzB0F,KAAK,CAAC1O,IAAN,CAAWgJ,MAAX;IACD;;IAED,OAAO0F,KAAP;EACD;;AAtbuB;;MCpCbsX,kBAAiB;EAC5BnrB,YAAoBC,OAApB,EAAoC;IAAhB;EAAoB;;EAE1BmrB,YAAY;;MACxB,IAAI,CAAC,KAAKnrB,OAAL,CAAaorB,KAAlB,EAAyB;QACvB,MAAMC,SAAS,GAAG,MAAM,KAAKrrB,OAAL,CAAakP,YAAb,CAA0BS,eAA1B,CAA0C,MAA1C,CAAxB;QACA,KAAK3P,OAAL,CAAaorB,KAAb,GAAqBC,SAArB;MACD;;MACD,OAAO,KAAKrrB,OAAL,CAAaorB,KAApB;IACD;EAAA;;EAEKE,WAAW,CAACC,GAAD,EAAY;;MAC3B,MAAM/X,MAAM,GAAG,IAAIgY,MAAJ,CAAW;QAAE1b,QAAQ,EAAE,MAAM,KAAKqb,YAAL;MAAlB,CAAX,CAAf;MACA,OAAO3X,MAAM,CAAC8X,WAAP,CAAmBC,GAAnB,CAAP;IACD;EAAA;;EAEKE,wBAAwB,CAACF,GAAD,EAAY;;MACxC,MAAM/X,MAAM,GAAG,IAAIgY,MAAJ,CAAW;QAAE1b,QAAQ,EAAE,MAAM,KAAKqb,YAAL;MAAlB,CAAX,CAAf;MACA,OAAO3X,MAAM,CAACiY,wBAAP,CAAgCF,GAAhC,CAAP;IACD;EAAA;;EAEKG,SAAS,CAACH,GAAD,EAAY;;MACzB,MAAM/X,MAAM,GAAG,IAAIgY,MAAJ,CAAW;QAAE1b,QAAQ,EAAE,MAAM,KAAKqb,YAAL;MAAlB,CAAX,CAAf;MACA,OAAO3X,MAAM,CAACkY,SAAP,CAAiBH,GAAjB,CAAP;IACD;EAAA;;EAEK9X,sBAAsB,CAACvF,MAAD,EAAwB;;MAClD,MAAMyd,YAAY,GAAGzd,MAArB;MACAyd,YAAY,CAACjmB,IAAb,GAAoB,MAAM,KAAKkmB,eAAL,CAAqB1d,MAAM,CAACxI,IAA5B,CAA1B;;MACA,IAAIwI,MAAM,CAACvI,IAAX,EAAiB;QACfgmB,YAAY,CAAChmB,IAAb,GAAoB,MAAM,KAAKkmB,eAAL,CAAqB3d,MAAM,CAACvI,IAA5B,CAA1B;MACD,CAFD,MAEO,IAAIuI,MAAM,CAACpI,OAAX,EAAoB;QACzB,MAAMS,WAAW,GAAIolB,YAAY,CAACjmB,IAAb,CAA6Bc,IAA7B,CAClBC,CAAD,IAAkB,UAAUA,CAAV,IAAeA,CAAC,CAACC,IAAF,KAAW,SADzB,CAArB;;QAGA,IAAI,EAACH,WAAW,SAAX,eAAW,WAAX,GAAW,MAAX,cAAW,CAAE5C,IAAd,CAAJ,EAAwB;UACtB,MAAM,IAAIM,oBAAJ,CACJ,gDADI,EAEJiK,MAAM,CAACxI,IAFH,CAAN;QAID;;QACD,MAAMiB,MAAM,GAAG,IAAIC,MAAJ,CAAWL,WAAW,CAAC5C,IAAZ,CAAiB,CAAjB,CAAX,CAAf;QACA,MAAMmoB,2BAA2B,GAAG,MAAM,KAAKC,+BAAL,CAAqCplB,MAArC,CAA1C;;QAEA,IAAI2B,MAAM,CAACqe,IAAP,CAAYmF,2BAAZ,EAAyCloB,MAAzC,KAAoD,CAAxD,EAA2D;;;UAGzD,MAAM6C,CAAC,GAAG,IAAI+kB,MAAJ,CAAW;YAAEQ,oBAAoB,EAAEF;UAAxB,CAAX,CAAV;UACA,MAAMG,wBAAwB,GAAGxlB,CAAC,CAACilB,SAAF,CAAYnlB,WAAW,CAAC5C,IAAZ,CAAiB,CAAjB,CAAZ,CAAjC;UACA,MAAMuoB,mBAAmB,GAAG,IAAItlB,MAAJ,CAAWqlB,wBAAX,CAA5B;UACAN,YAAY,CAAChmB,IAAb,GAAoBumB,mBAAmB,CAACrlB,MAApB,CAA2BqH,MAAM,CAACpI,OAAlC,CAApB;QACD,CAPD,MAOO;UACL6lB,YAAY,CAAChmB,IAAb,GAAoBgB,MAAM,CAACE,MAAP,CAAcqH,MAAM,CAACpI,OAArB,CAApB;QACD;;QACD,OAAO6lB,YAAY,CAAC7lB,OAApB;MACD;;MACD,OAAO6lB,YAAP;IACD;EAAA;;EAEaC,eAAe,CAAClmB,IAAD,EAAwB;;MACnD,IAAIymB,UAAJ;;MACA,IAAI,OAAOzmB,IAAP,KAAgB,QAApB,EAA8B;QAC5B,MAAM0mB,CAAC,GAAG,MAAM,KAAKd,WAAL,CAAiB5lB,IAAjB,CAAhB;;QACA,IAAI0mB,CAAC,KAAK,IAAV,EAAgB;UACd,MAAM,IAAInoB,oBAAJ,CAAyB,wBAAzB,EAAmDyB,IAAnD,CAAN;QACD;;QACDymB,UAAU,GAAGC,CAAb;MACD,CAND,MAMO;QACL,MAAMA,CAAC,GAAG,MAAM,KAAKV,SAAL,CAAehmB,IAAf,CAAhB;QACA,MAAM2mB,KAAK,GAAG,CAAC,WAAD,EAAc,SAAd,EAAyB,MAAzB,CAAd,CAFK;;QAILF,UAAU,GAAIC,CAAY,CAACE,IAAb,CAAkB,CAACC,CAAD,EAAIC,CAAJ,KAAUH,KAAK,CAACzjB,OAAN,CAAc2jB,CAAC,CAAC7lB,IAAhB,IAAwB2lB,KAAK,CAACzjB,OAAN,CAAc4jB,CAAC,CAAC9lB,IAAhB,CAApD,CAAd;MACD;;MACD,OAAOylB,UAAP;IACD;EAAA;;EAEaN,eAAe,CAAClmB,IAAD,EAAsB;;MACjD,IAAI8mB,UAAJ;;MACA,IAAI,OAAO9mB,IAAP,KAAgB,QAApB,EAA8B;QAC5B,MAAMymB,CAAC,GAAG,MAAM,KAAKX,wBAAL,CAA8B9lB,IAA9B,CAAhB;;QACA,IAAIymB,CAAC,KAAK,IAAV,EAAgB;UACd,MAAM,IAAIjoB,oBAAJ,CAAyB,wBAAzB,EAAmDwB,IAAnD,CAAN;QACD;;QACD8mB,UAAU,GAAGL,CAAb;MACD,CAND,MAMO;QACLK,UAAU,GAAG,MAAM,KAAKf,SAAL,CAAe/lB,IAAf,CAAnB;MACD;;MACD,OAAO8mB,UAAP;IACD;EAAA;;EAEaV,+BAA+B,CAACplB,MAAD,EAAe;;MAC1D,MAAM+lB,oBAAoB,GAAG/lB,MAAM,CAACgmB,SAAP,CAAiB,UAAjB,CAA7B;MACA,MAAMC,2BAA2B,GAA+B,EAAhE;;MAEA,IAAIF,oBAAoB,CAAC9oB,MAArB,KAAgC,CAApC,EAAuC;QACrC,KAAK,MAAMipB,KAAX,IAAoBH,oBAApB,EAA0C;UACxC,MAAMI,SAAS,GAAGD,KAAK,CAACE,QAAN,CAAeppB,IAAjC;;UACA,IAAImpB,SAAJ,EAAe;YACb,MAAM5hB,IAAI,GAAW4hB,SAAS,CAAC,CAAD,CAAT,CAAa,QAAb,CAArB;YACA,MAAME,cAAc,GAAG,MAAM,KAAKhtB,OAAL,CAAaitB,uBAAb,CAAqCC,uBAArC,CAC3BhiB,IAD2B,CAA7B;YAGA5C,MAAM,CAAC6kB,MAAP,CAAcP,2BAAd,EAA2C;cACzC,CAAC1hB,IAAD,GAAQ8hB;YADiC,CAA3C;UAGD;QACF;MACF;;MACD,OAAOJ,2BAAP;IACD;EAAA;;AA7G2B;;MCLjBQ,UAAS;EACpBrtB,YAAoBC,OAApB,EAAoC;IAAhB;EAAoB;;EAElC0pB,QAAQ,CAACvoB,IAAD,EAAqB;;MACjC,OAAO,KAAKnB,OAAL,CAAaG,GAAb,CAAiBupB,QAAjB,CAA0BvoB,IAA1B,CAAP;IACD;EAAA;;AALmB;ACJtB;;;;;;MAIaksB,+BAA+B/sB,MAAK;EAG/CP,YAAmBmL,IAAnB,EAA+B;IAC7B,MACE,sDAAsDA,IAAI,6EAD5D;IADiB;IAFnB,YAAO,wBAAP;EAMC;;AAP8C;AAUjD;;;;;;MAIaoiB,iDAAiDhtB,MAAK;EAGjEP;IACE,MACE,wKADF;IAHF,YAAO,0CAAP;EAMC;;AAPgE;;MCdtDwtB,4BAA2B;EAC9BL,uBAAuB,CAACM,KAAD,EAA0B;;MACnD,MAAM,IAAIF,wCAAJ,EAAN;IACH;EAAA;;AAHmC;ACOxC;;;;;MAGaG,eAAc;EACzB1tB,YAAoBC,OAApB,EAAoC;IAAhB;EAAoB;;;;;;;;;EAQlC4Z,UAAU,CAACzB,OAAD,EAAkBZ,KAAlB,EAAwC;;MACtD,OAAO,KAAKvX,OAAL,CAAaG,GAAb,CAAiByZ,UAAjB,CAA4BzB,OAA5B,EAAqC;QAAEZ,KAAK,EAAE7I,MAAM,CAAC6I,KAAD;MAAf,CAArC,CAAP;IACD;EAAA;;;;;;;;;EAQKsC,WAAW,CAAC1B,OAAD,EAAkBZ,KAAlB,EAAwC;;MACvD,OAAO,KAAKvX,OAAL,CAAaG,GAAb,CAAiB0Z,WAAjB,CAA6B1B,OAA7B,EAAsC;QAAEZ,KAAK,EAAE7I,MAAM,CAAC6I,KAAD;MAAf,CAAtC,CAAP;IACD;EAAA;;;;;;;EAMK5H,eAAe,CAAC4H,KAAD,EAAuB;;MAC1C,MAAM3V,SAAS,GAAG,MAAM,KAAK5B,OAAL,CAAaG,GAAb,CAAiButB,YAAjB,CAA8B;QAAEnW,KAAK,EAAE7I,MAAM,CAAC6I,KAAD;MAAf,CAA9B,CAAxB;MACA,OAAO3V,SAAS,CAAC+rB,aAAjB;IACD;EAAA;;;;;;;EAMK5P,oBAAoB,CAACxG,KAAD,EAAuB;;MAQ/C,MAAM;QACJqW,mBADI;QAEJC,mBAFI;QAGJtR,4BAHI;QAIJC,wBAJI;QAKJC,gCALI;QAMJC;MANI,IAOF,MAAM,KAAK1c,OAAL,CAAaG,GAAb,CAAiB2tB,YAAjB,CAA8B;QAAEvW,KAAK,EAAE7I,MAAM,CAAC6I,KAAD;MAAf,CAA9B,CAPV;MAQA,OAAO;QACLqW,mBADK;QAELC,mBAFK;QAGLtR,4BAHK;QAILC,wBAJK;QAKLC,gCALK;QAMLC;MANK,CAAP;IAQD;EAAA;;;;;;;;;EAQK0F,SAAS,CAAClK,QAAD,EAAmBX,KAAnB,EAAyC;;MACtD,MAAM;QAAEzQ;MAAF,IAAa,MAAM,KAAK9G,OAAL,CAAaG,GAAb,CAAiBgpB,WAAjB,CAA6BjR,QAA7B,EAAuC;QAAEX,KAAK,EAAE7I,MAAM,CAAC6I,KAAD;MAAf,CAAvC,CAAzB;MACA,OAAOzQ,MAAP;IACD;EAAA;;;;;;;;EAOKmd,UAAU,CAAC/L,QAAD,EAAmBX,KAAnB,EAAyC;;MACvD,OAAO,KAAKvX,OAAL,CAAaG,GAAb,CAAiB8jB,UAAjB,CAA4B/L,QAA5B,EAAsC;QAAEX,KAAK,EAAE7I,MAAM,CAAC6I,KAAD;MAAf,CAAtC,CAAP;IACD;EAAA;;;;;;EAKK9H,YAAY,CAAC8H,KAAD,EAAuB;;MACvC,MAAM;QAAErM;MAAF,IAAW,MAAM,KAAKlL,OAAL,CAAaG,GAAb,CAAiB4tB,cAAjB,CAAgC;QAAExW,KAAK,EAAE7I,MAAM,CAAC6I,KAAD;MAAf,CAAhC,CAAvB;MACA,OAAOrM,IAAP;IACD;EAAA;;;;;;EAKKyL,aAAa,CAACY,KAAD,EAAuB;;MACxC,MAAM;QAAEhL;MAAF,IAAY,MAAM,KAAKvM,OAAL,CAAaG,GAAb,CAAiB4tB,cAAjB,CAAgC;QAAExW,KAAK,EAAE7I,MAAM,CAAC6I,KAAD;MAAf,CAAhC,CAAxB;MACA,OAAOhL,KAAP;IACD;EAAA;;;;;;;;EAOKsD,UAAU,CAACd,GAAD,EAAcwI,KAAd,EAAoC;;MAClD,MAAM;QAAEtH;MAAF,IAAc,MAAM,KAAKjQ,OAAL,CAAaG,GAAb,CAAiBgpB,WAAjB,CAA6Bpa,GAA7B,EAAkC;QAAEwI,KAAK,EAAE7I,MAAM,CAAC6I,KAAD;MAAf,CAAlC,CAA1B;MACA,OAAOtH,OAAO,IAAI,GAAlB;IACD;EAAA;;;;;;;;EAOK+d,iBAAiB,CAACzW,KAAD,EAAuB;;MAC5C,MAAM;QAAE0W;MAAF,IAAgB,MAAM,KAAKjuB,OAAL,CAAaG,GAAb,CAAiB4tB,cAAjB,CAAgC;QAAExW,KAAK,EAAE7I,MAAM,CAAC6I,KAAD;MAAf,CAAhC,CAA5B;MACA,OAAO0W,SAAP;IACD;EAAA;;;;;;;;EAOKnE,cAAc,CAClBoE,WADkB,EAElB3W,KAFkB,EAEI;;MAEtB,OAAO,KAAKvX,OAAL,CAAaG,GAAb,CAAiBguB,aAAjB,CAA+BD,WAAW,CAAC3kB,EAA3C,EAA+C2kB,WAAW,CAACnE,IAA3D,EAAiE;QACtExS,KAAK,EAAE7I,MAAM,CAAC6I,KAAD;MADyD,CAAjE,CAAP;IAGD;EAAA;;;;;;;;EAOKmT,kBAAkB,CACtB0D,iBADsB,EAEtB7W,KAFsB,EAEA;;MAEtB,OAAO,KAAKvX,OAAL,CAAaG,GAAb,CAAiBuqB,kBAAjB,CAAoC0D,iBAAiB,CAAC7kB,EAAtD,EAA0D;QAAEgO,KAAK,EAAE7I,MAAM,CAAC6I,KAAD;MAAf,CAA1D,CAAP;IACD;EAAA;;;;;;;EAMK+K,cAAc,CAACpK,QAAD,EAAiB;;MACnC,OAAO,KAAKlY,OAAL,CAAaG,GAAb,CAAiBmiB,cAAjB,CAAgCpK,QAAhC,CAAP;IACD;EAAA;;;;;;EAKKyF,UAAU;;MACd,OAAO,KAAK3d,OAAL,CAAaG,GAAb,CAAiBwd,UAAjB,EAAP;IACD;EAAA;;;;;;;;EAOKxO,iBAAiB,CAAC1O,aAAD,EAAwB8W,KAAxB,EAA8C;;MACnE,MAAM8W,OAAO,GAAG,MAAM,KAAKruB,OAAL,CAAaG,GAAb,CAAiBmuB,aAAjB,CAA+B7tB,aAA/B,EAA8C;QAAE8W,KAAK,EAAE7I,MAAM,CAAC6I,KAAD;MAAf,CAA9C,CAAtB;MACA,MAAMgX,WAAW,GAAGF,OAAO,IAAI,OAAOA,OAAP,KAAmB,QAA9B,GAAyC,CAAC,CAACA,OAAO,CAACzO,GAAnD,GAAyD,CAAC,CAACyO,OAA/E;MACA,OAAOE,WAAP;IACD;EAAA;;;;;;;EAMKjY,QAAQ,CAACiB,KAAD,EAAuB;;MACnC,OAAO,KAAKvX,OAAL,CAAaG,GAAb,CAAiBmW,QAAjB,CAA0B;QAAEiB,KAAK,EAAE7I,MAAM,CAAC6I,KAAD;MAAf,CAA1B,CAAP;IACD;EAAA;;;;;;;EAMDL,aAAa,CAACK,KAAD,EAAuB;IAClC,OAAO,KAAKvX,OAAL,CAAaG,GAAb,CAAiB+W,aAAjB,CAA+B;MAAEK,KAAK,EAAE7I,MAAM,CAAC6I,KAAD;IAAf,CAA/B,CAAP;EACD;;AAxLwB;;ACD3B,MAAMiX,YAAY,GAAG,CAACnmB,EAAD,EAAuBmE,MAAvB,KAAgDnE,EAAE,CAAC6C,IAAH,KAAYsB,MAAM,CAAC+I,MAAxF;;AAEA,MAAMkZ,YAAY,GAAG,CAACjkB,CAAD,EAAsBgC,MAAtB,KAA0C;EAC7D,QAAQhC,CAAC,CAACxD,IAAV;IACE,KAAK,aAAL;MACE,OAAO,cAAcwD,CAAd,IAAmBA,CAAC,CAACxB,QAAF,CAAWnD,QAAX,KAAwB2G,MAAM,CAACxI,MAAzD;;IACF,KAAK,kBAAL;MACE,OAAO,cAAcwG,CAAd,IAAmBA,CAAC,CAACuE,GAAF,KAAUvC,MAAM,CAACxI,MAA3C;;IACF;MACE,OAAO,YAAYwG,CAAZ,IAAiBA,CAAC,CAACxG,MAAF,KAAawI,MAAM,CAACxI,MAA5C;EANJ;AAQD,CATD;;AAWA,MAAM0qB,UAAU,GAAG,CAAClkB,CAAD,EAAsBgC,MAAtB,KACjB,UAAUhC,CAAV,IAAeA,CAAC,CAACxD,IAAF,KAAWwF,MAAM,CAACxF,IADnC;;AAGA,MAAM2nB,iBAAiB,GAAG,CAACnkB,CAAD,EAAsBgC,MAAtB,KAA+C;EACvE,QAAQhC,CAAC,CAACxD,IAAV;IACE,KAAK,YAAL;MACE,OAAOwD,CAAC,CAAC3E,QAAF,KAAe2G,MAAM,CAAC/E,WAA7B;;IACF,KAAK,aAAL;MACE,IACE,cAAc+C,CAAd,IACA,sBAAsBA,CAAC,CAACxB,QADxB,IAEA,0BAA0BwB,CAAC,CAACxB,QAAF,CAAWqB,gBAFrC,IAGArF,KAAK,CAACC,OAAN,CAAcuF,CAAC,CAACxB,QAAF,CAAWqB,gBAAX,CAA4B2K,oBAA1C,CAJF,EAKE;QACA,OAAOxK,CAAC,CAACxB,QAAF,CAAWqB,gBAAX,CAA4B2K,oBAA5B,CAAiD4Z,IAAjD,CACJ1W,QAAD,IAAcA,QAAQ,KAAK1L,MAAM,CAAC/E,WAD7B,CAAP;MAGD;;MACD;;IACF,KAAK,aAAL;MACE,OAAO+C,CAAC,CAAC/C,WAAF,KAAkB+E,MAAM,CAAC/E,WAAhC;;IACF;MACE,OAAO,KAAP;EAlBJ;AAoBD,CArBD;;AAuBO,MAAMonB,gBAAgB,GAAG,CAACxmB,EAAD,EAAuBmE,MAAvB,KAAuC;EACrE,IAAI,YAAYA,MAAhB,EAAwB;IACtB,OAAOgiB,YAAY,CAACnmB,EAAD,EAAKmE,MAAL,CAAnB;EACD,CAFD,MAEO,IAAI,YAAYA,MAAhB,EAAwB;IAC7B,OAAOiiB,YAAY,CAACpmB,EAAD,EAAKmE,MAAL,CAAnB;EACD,CAFM,MAEA,IAAI,UAAUA,MAAd,EAAsB;IAC3B,OAAOkiB,UAAU,CAACrmB,EAAD,EAAKmE,MAAL,CAAjB;EACD,CAFM,MAEA,IAAI,iBAAiBA,MAArB,EAA6B;IAClC,OAAOmiB,iBAAiB,CAACtmB,EAAD,EAAKmE,MAAL,CAAxB;EACD;;EAED,OAAO,KAAP;AACD,CAZM;;AAcA,MAAMsiB,kBAAkB,GAAG,CAACzmB,EAAD,EAAuB0mB,GAAvB,KAA4C;EAC5E,IAAI/pB,KAAK,CAACC,OAAN,CAAc8pB,GAAG,CAACC,GAAlB,CAAJ,EAA4B;IAC1B,OAAOD,GAAG,CAACC,GAAJ,CAAQC,KAAR,CAAezkB,CAAD,IAAoC0kB,cAAc,CAAC7mB,EAAD,EAAKmC,CAAL,CAAhE,CAAP;EACD,CAFD,MAEO,IAAIxF,KAAK,CAACC,OAAN,CAAc8pB,GAAG,CAACI,EAAlB,CAAJ,EAA2B;IAChC,OAAOJ,GAAG,CAACI,EAAJ,CAAOP,IAAP,CAAapkB,CAAD,IAAoC0kB,cAAc,CAAC7mB,EAAD,EAAKmC,CAAL,CAA9D,CAAP;EACD,CAFM,MAEA;IACL,MAAM,IAAIQ,4BAAJ,CAAiC,uDAAjC,CAAN;EACD;AACF,CARM;;AAUA,MAAMkkB,cAAc,GAAG,CAAC7mB,EAAD,EAAuBmE,MAAvB,KAAqC;EACjE,MAAM4iB,OAAO,GAAoC,EAAjD;;EACA,IAAI,CAACpqB,KAAK,CAACC,OAAN,CAAcuH,MAAd,CAAL,EAA4B;IAC1B4iB,OAAO,CAAChlB,IAAR,CAAaoC,MAAb;EACD,CAFD,MAEO;IACL4iB,OAAO,CAAChlB,IAAR,CAAa,GAAIoC,MAAjB;EACD;;EAED,OAAQ4iB,OAAiB,CAACH,KAAlB,CAAyBI,WAAD,IAAyC;IACvE,IAAI,SAASA,WAAT,IAAwB,QAAQA,WAApC,EAAiD;MAC/C,OAAOP,kBAAkB,CAACzmB,EAAD,EAAKgnB,WAAL,CAAzB;IACD,CAFD,MAEO;MACL,OAAOR,gBAAgB,CAACxmB,EAAD,EAAKgnB,WAAL,CAAvB;IACD;EACF,CANO,CAAR;AAOD,CAfM;AC5EP;;AAKA;;;;;;MAIaC,8BAA8BhvB,MAAK;EAE9CP,YAAmBmE,OAAnB,EAAkC;IAChC,MAAMA,OAAN;IADiB;IADZ,YAAO,uBAAP;EAGN;;AAJ6C;;MAMnCqrB,uBAAsB;EAMjCxvB,YACEyvB,GADF,EAEUC,cAAuB,KAFjC,EAGUC,mBAA2CC,KAAK,EAH1D,EAG+D;IADrD;IACA;IARF,sBAAgD,EAAhD;IACA,wBAA6C,EAA7C;IACA,sBAAoC,EAApC;IACA,kBAAa,IAAIC,OAAJ,EAAb;IAONJ,GAAG,CACAlkB,IADH,CAEIukB,SAAS,CAAC,KAAKC,UAAN,CAFb,EAGIra,GAAG,CACAtU,IAAD,IAAQ;MACN,KAAK4uB,IAAL,CAAU,KAAKC,gBAAf,EAAiC7uB,IAAjC;IACD,CAHA,EAIAE,KAAD,IAAM;MACJ,KAAK0uB,IAAL,CAAU,KAAKE,cAAf,EAA+B5uB,KAA/B;IACD,CANA,EAOD;MACE,KAAK0uB,IAAL,CAAU,KAAKG,cAAf;IACD,CATA,CAHP,EAcI,KAAKT,WAAL,GAAmBC,gBAAnB,GAAsCja,GAAG,EAd7C,EAeIxI,UAAU,CAAC,MAAMkjB,KAAP,CAfd,EAiBG/iB,SAjBH;EAkBD;;EAEO2iB,IAAI,CAAIK,SAAJ,EAAwCloB,KAAxC,EAAiD;IAC3D,KAAK,MAAMmoB,CAAX,IAAgBD,SAAhB,EAA2B;MACzB,IAAI;;QAEFC,CAAC,CAACnoB,KAAD,CAAD;MACD,CAHD,CAGE,OAAOsiB,EAAP,EAAW;QACX8F,OAAO,CAACjvB,KAAR,CAAcmpB,EAAd;MACD;IACF;EACF;;EAEO+F,MAAM,CAACH,SAAD,EAAwBloB,KAAxB,EAAkC;IAC9C,MAAMsoB,GAAG,GAAGJ,SAAS,CAACxnB,OAAV,CAAkBV,KAAlB,CAAZ;;IACA,IAAIsoB,GAAG,KAAK,CAAC,CAAb,EAAgB;MACdJ,SAAS,CAACK,MAAV,CAAiBD,GAAjB,EAAsB,CAAtB;IACD;EACF;;EAMMtvB,EAAE,CAACqoB,IAAD,EAAmCmH,EAAnC,EAA0C;IACjD,QAAQnH,IAAR;MACE,KAAK,MAAL;QACE,KAAKyG,gBAAL,CAAsB5lB,IAAtB,CAA2BsmB,EAA3B;QACA;;MACF,KAAK,OAAL;QACE,KAAKT,cAAL,CAAoB7lB,IAApB,CAAyBsmB,EAAzB;QACA;;MACF,KAAK,OAAL;QACE,KAAKR,cAAL,CAAoB9lB,IAApB,CAAyBsmB,EAAzB;QACA;;MACF;QACE,MAAM,IAAIpB,qBAAJ,CAA0B,+CAA+C/F,IAAI,EAA7E,CAAN;IAXJ;EAaD;;EAMMoH,GAAG,CAACpH,IAAD,EAAmCmH,EAAnC,EAA0C;IAClD,QAAQnH,IAAR;MACE,KAAK,MAAL;QACE,KAAKgH,MAAL,CAAY,KAAKP,gBAAjB,EAAmCU,EAAnC;QACA;;MACF,KAAK,OAAL;QACE,KAAKH,MAAL,CAAY,KAAKN,cAAjB,EAAiCS,EAAjC;QACA;;MACF,KAAK,OAAL;QACE,KAAKH,MAAL,CAAY,KAAKL,cAAjB,EAAiCQ,EAAjC;QACA;;MACF;QACE,MAAM,IAAIpB,qBAAJ,CAA0B,iDAAiD/F,IAAI,EAA/E,CAAN;IAXJ;EAaD;;EAEMhoB,KAAK;IACV,KAAKuuB,UAAL,CAAgB1uB,IAAhB;EACD;;AA3FgC;;ACS5B,MAAMwvB,qBAAqB,GAAmC;EACnEC,iCAAiC,EAAE,KADgC;EAEnEC,mCAAmC,EAAEnB,KAAK;AAFyB,CAA9D;;AAKP,MAAMoB,YAAY,GAAI/wB,OAAD,IAAiB;EACpC,OAAO8C,IAAI,CAAC9C,OAAO,CAACG,GAAR,CAAYmW,QAAZ,EAAD,CAAJ,CAA6BhL,IAA7B,CAAkCmB,KAAK,EAAvC,CAAP;AACD,CAFD;;AAIA,MAAMukB,WAAW,GAAIxkB,MAAD,IAClB2M,SAAS,CAAoD5B,KAAD,IAAM;EAChE,OAAO,IAAIvW,UAAJ,CAAkCD,GAAD,IAAI;IAC1C,KAAK,MAAMwO,GAAX,IAAkBgI,KAAK,CAACnL,UAAxB,EAAoC;MAClC,KAAK,MAAM/D,EAAX,IAAiBkH,GAAjB,EAAsB;QACpB,KAAK,MAAMpF,OAAX,IAAsB9B,EAAE,CAAC6B,QAAzB,EAAmC;UACjC,IAAIglB,cAAc;YAAGhkB,IAAI,EAAE7C,EAAE,CAAC6C;UAAZ,GAAqBf,OAArB,GAAgCqC,MAAhC,CAAlB,EAA2D;YACzDzL,GAAG,CAACK,IAAJ,CAAQkH;cAAG4C,IAAI,EAAE7C,EAAE,CAAC6C;YAAZ,GAAqBf,OAArB,CAAR;UACD;QACF;MACF;IACF;;IACDpJ,GAAG,CAACO,QAAJ;EACD,CAXM,CAAP;AAYD,CAbQ,CADX;;MAgBa2vB,yBAAwB;EAOnClxB,YAAoBC,OAApB,EAAsCwL,SAAkD,EAAxF,EAA0F;IAAtE;IAClB,KAAK0lB,QAAL,GAAgB,IAAIC,eAAJ,CAAmB7oB,gCAC9BsoB,qBAD8B,GAE9BplB,MAF8B,CAAnB,CAAhB;IAIA,KAAK4lB,MAAL,GAAc,KAAKF,QAAL,CAAc5lB,IAAd,CACZ+lB,KAAK,CAAC,6BAAD,CADO,EAEZ9lB,SAAS,CAAE+lB,2BAAD,IAA4B;MACpC,IAAI,CAACA,2BAAL,EAAkC;QAChC,OAAOxuB,IAAI,CAAC,KAAKyuB,8BAAL,EAAD,CAAJ,CAA4CjmB,IAA5C,CACLC,SAAS,CAAEimB,QAAD,IAAS;UACjB,OAAOC,KAAK,CAAC,CAAD,EAAID,QAAJ,CAAZ;QACD,CAFQ,CADJ,CAAP;MAKD,CAND,MAMO;QACL,OAAOC,KAAK,CAAC,CAAD,EAAIH,2BAAJ,CAAZ;MACD;IACF,CAVQ,CAFG,CAAd;IAcA,KAAKI,SAAL,GAAiB,KAAKN,MAAL,CAAY9lB,IAAZ,CACfC,SAAS,CAAC,MAAMwlB,YAAY,CAAC,KAAK/wB,OAAN,CAAnB,CADM,EAEf2xB,uBAAuB,CAAC,MAAD,CAFR,EAGfC,OAAO,EAHQ,EAIf5lB,QAAQ,EAJO,CAAjB;EAMD;;EAES,IAANR,MAAM;IACR,OAAO,KAAK0lB,QAAL,CAAcW,QAAd,EAAP;EACD;;EAEaN,8BAA8B;;MAC1C,IAAI,CAAC,KAAK/lB,MAAL,CAAY8lB,2BAAjB,EAA8C;QAC5C,MAAMQ,8BAA8B,GAAG,IAAvC;QACA,MAAMC,sBAAsB,GAAG,IAA/B;;QACA,IAAI;UACF,MAAM1V,SAAS,GAAG,MAAM,KAAKrc,OAAL,CAAakP,YAAb,CAA0B6O,oBAA1B,CAA+C,MAA/C,CAAxB;UACA,MAAMiU,SAAS,GAAG3V,SAAS,CAACwR,mBAAV,GACdxR,SAAS,CAACwR,mBAAV,CAA8BzqB,YAA9B,CAA2C,IAA3C,CADc,GAEdiZ,SAAS,CAACuR,mBAAV,GACAvR,SAAS,CAACuR,mBAAV,CAA8B,CAA9B,EAAiCxqB,YAAjC,CAA8C,IAA9C,CADA,GAEA,IAAIF,SAAJ,CAAc4uB,8BAAd,CAJJ;UAKA,MAAMG,2BAA2B,GAAGD,SAAS,CAACzuB,SAAV,CAAoB,CAApB,CAApC;UAEA,KAAKiI,MAAL,CAAY8lB,2BAAZ,GACEW,2BAA2B,CAACpV,QAA5B,OAA2C,CAA3C,GACIkV,sBADJ,GAEIE,2BAA2B,CAACpV,QAA5B,EAHN;QAID,CAbD,CAaE,OAAOqV,SAAP,EAAkB;UAClB,OAAOJ,8BAAP;QACD;MACF;;MACD,OAAO,KAAKtmB,MAAL,CAAY8lB,2BAAnB;IACD;EAAA;;EAED3lB,cAAc,CAACwmB,OAAD,EAAgB;IAC5B,OAAO,IAAI5C,sBAAJ,CACL,KAAKmC,SADA,EAEL,KAAKlmB,MAAL,CAAYqlB,iCAFP,EAGL,KAAKrlB,MAAL,CAAYslB,mCAHP,CAAP;EAKD;;EAED1jB,SAAS,CAAC+kB,OAAD,EAAgB;IACvB,OAAO,IAAI5C,sBAAJ,CACL,KAAKmC,SAAL,CAAepmB,IAAf,CAAoB+lB,KAAK,CAAC,MAAD,CAAzB,CADK,EAEL,KAAK7lB,MAAL,CAAYqlB,iCAFP,EAGL,KAAKrlB,MAAL,CAAYslB,mCAHP,CAAP;EAKD;;EAEDsB,kBAAkB,CAAC5lB,MAAD,EAAe;IAC/B,OAAO,IAAI+iB,sBAAJ,CACL,KAAKmC,SAAL,CAAepmB,IAAf,CAAoB0lB,WAAW,CAACxkB,MAAD,CAA/B,CADK,EAEL,KAAKhB,MAAL,CAAYqlB,iCAFP,EAGL,KAAKrlB,MAAL,CAAYslB,mCAHP,CAAP;EAKD;;AApFkC;;MCvCxBuB,mBAAkB;EAC7BtyB,YAAoBC,OAApB,EAAoC;IAAhB;EAAoB;;EAE1BmrB,YAAY;;MACxB,IAAI,CAAC,KAAKnrB,OAAL,CAAaorB,KAAlB,EAAyB;QACvB,MAAMC,SAAS,GAAG,MAAM,KAAKrrB,OAAL,CAAakP,YAAb,CAA0BS,eAA1B,CAA0C,MAA1C,CAAxB;QACA,KAAK3P,OAAL,CAAaorB,KAAb,GAAqBC,SAArB;MACD;;MACD,OAAO,KAAKrrB,OAAL,CAAaorB,KAApB;IACD;EAAA;;EAEKpa,KAAK,CAAC;IAAED,MAAF;IAAU7G;EAAV,CAAD,EAAkC;;MAC3C,MAAMgH,MAAM,GAAG,IAAIohB,WAAJ,CAAgB,MAAM,KAAKnH,YAAL,EAAtB,CAAf;MACA,OAAOja,MAAM,CAACF,KAAP,CAAa;QAAED,MAAF;QAAU7G;MAAV,CAAb,CAAP;IACD;EAAA;;AAd4B;;MC0BlBqoB,yBAAyB,GAAuB;EAC3D7kB,wBAAwB,EAAE,CADiC;EAE3DC,gCAAgC,EAAE;AAFyB;AAK7D;;;;MAGa6kB,QAAO;EAkBlBzyB,YACUsjB,IADV,EAEUoP,UAAkB,IAAIlyB,UAAJ,EAF5B,EAGUmyB,MAHV,EAIkBC,UAAU,IAAIxB,eAAJ,CAAmB7oB,kBACxCiqB,yBADwC,CAAnB,CAJ5B,EAOErhB,MAPF,EAQEsB,QARF,EASEiX,MATF,EAUErR,MAVF,EAWE5E,MAXF,EAYEyZ,uBAZF,EAaE/d,YAbF,EAcExD,MAdF,EAc4B;IAblB;IACA;IACA;IACQ;IAdV,yBAA0D,EAA1D;IAIQ,UAAK,IAAIiO,aAAJ,CAAkB,IAAlB,CAAL;IACA,gBAAW,IAAImC,mBAAJ,CAAwB,IAAxB,CAAX;IACA,gBAAW,IAAIgN,mBAAJ,CAAwB,IAAxB,EAA8B,KAAKtX,QAAnC,CAAX;IACA,aAAQ,IAAI4C,gBAAJ,CAAqB,IAArB,EAA2B,KAAK5C,QAAhC,CAAR;IACA,cAAS,IAAIyP,MAAJ,CAAW,IAAX,CAAT;;;;;;;IA0LhB,sBAAiB;MACf,IAAI2R,aAAa,GAAG,KAAKrhB,KAAL,EAApB;MACA,KAAKshB,iBAAL,CAAuBtoB,OAAvB,CAAgCuoB,SAAD,IAAU;QACvCF,aAAa,GAAGE,SAAS,CAACF,aAAD,CAAzB;MACD,CAFD;MAIA,OAAOA,aAAP;IACD,CAPD;;IAxKE,IAAI,OAAO,KAAKvP,IAAZ,KAAqB,QAAzB,EAAmC;MACjC,KAAK0P,UAAL,GAAkB,IAAIC,SAAJ,CAAc,KAAK3P,IAAnB,CAAlB;IACD,CAFD,MAEO;MACL,KAAK0P,UAAL,GAAkB,KAAK1P,IAAvB;IACD;;IACD,KAAK4P,OAAL,GAAe/hB,MAAM,GAAGA,MAAH,GAAY,IAAImhB,kBAAJ,CAAuB,IAAvB,CAAjC;IACA,KAAKa,SAAL,GAAiB1gB,QAAQ,GAAGA,QAAH,GAAc,IAAI1S,WAAJ,CAAgB,IAAhB,CAAvC;IACA,KAAK6hB,gBAAL,GAAwB,IAAIhJ,gBAAJ,CAAqB,IAArB,CAAxB;IACA,KAAKwa,eAAL,GAAuB/a,MAAM,GAAGA,MAAH,GAAY,IAAIqK,oBAAJ,CAAyB,IAAzB,CAAzC;IACA,KAAK2Q,OAAL,GAAe5f,MAAM,GAAGA,MAAH,GAAY,IAAI0X,iBAAJ,CAAsB,IAAtB,CAAjC;IACA,KAAKmI,OAAL,GAAe5J,MAAM,GAAGA,MAAH,GAAY,IAAI2D,SAAJ,CAAc,IAAd,CAAjC;IACA,KAAKkG,wBAAL,GAAgCrG,uBAAuB,GACnDA,uBADmD,GAEnD,IAAIM,2BAAJ,EAFJ;IAGA,KAAKjK,aAAL,GAAqBpU,YAAY,GAAGA,YAAH,GAAkB,IAAIue,cAAJ,CAAmB,IAAnB,CAAnD;IACA,KAAK8F,OAAL,GAAe7nB,MAAM,GAAGA,MAAH,GAAY,IAAIulB,wBAAJ,CAA6B,IAA7B,CAAjC;EACD;;EAES,IAANzlB,MAAM;IACR,OAAO,KAAKmnB,OAAL,CAAad,QAAb,EAAP;EACD;;EAES,IAANrmB,MAAM,CAACtD,KAAD,EAA0B;IAClC,KAAKyqB,OAAL,CAAavxB,IAAb,CAAiBkH,kBACZJ,KADY,CAAjB;EAGD;;EAEDsrB,gBAAgB,CAACtrB,KAAD,EAAmC;IACjD,KAAKyqB,OAAL,CAAavxB,IAAb,CAAiBkH,gCACZ,KAAKqqB,OAAL,CAAad,QAAb,EADY,GAEZ3pB,KAFY,CAAjB;EAID;;EAEM,IAAH/H,GAAG;IACL,OAAO,KAAK4yB,UAAZ;EACD;;EAEM,IAAH5yB,GAAG,CAAC+H,KAAD,EAA0B;IAC/B,KAAK6qB,UAAL,GAAkB7qB,KAAlB;EACD;;EAEW,IAARsK,QAAQ;IACV,OAAO,KAAK0gB,SAAZ;EACD;;EAEW,IAAR1gB,QAAQ,CAACtK,KAAD,EAAgB;IAC1B,KAAKgrB,SAAL,GAAiBhrB,KAAjB;EACD;;EAES,IAANgJ,MAAM;IACR,OAAO,KAAK+hB,OAAZ;EACD;;EAES,IAAN/hB,MAAM,CAAChJ,KAAD,EAAc;IACtB,KAAK+qB,OAAL,GAAe/qB,KAAf;EACD;;EAES,IAAN2G,MAAM;IACR,OAAO,KAAK4jB,OAAZ;EACD;;EAES,IAAN5jB,MAAM,CAAC3G,KAAD,EAAc;IACtB,KAAKuqB,OAAL,GAAevqB,KAAf;EACD;;EAEiB,IAAdgU,cAAc;IAChB,OAAO,KAAKiX,eAAZ;EACD;;EAEiB,IAAdjX,cAAc,CAAChU,KAAD,EAAsB;IACtC,KAAKirB,eAAL,GAAuBjrB,KAAvB;EACD;;EAEQ,IAALkjB,KAAK,CAACljB,KAAD,EAA6B;IACpC,KAAKwqB,MAAL,GAAcxqB,KAAd;EACD;;EAEQ,IAALkjB,KAAK;IACP,OAAO,KAAKsH,MAAZ;EACD;;EAES,IAANlf,MAAM;IACR,OAAO,KAAK4f,OAAZ;EACD;;EAES,IAAN5f,MAAM,CAACtL,KAAD,EAAsB;IAC9B,KAAKkrB,OAAL,GAAelrB,KAAf;EACD;;EAES,IAANuhB,MAAM;IACR,OAAO,KAAK4J,OAAZ;EACD;;EAES,IAAN5J,MAAM,CAACvhB,KAAD,EAAc;IACtB,KAAKmrB,OAAL,GAAenrB,KAAf;EACD;;EAE0B,IAAvB+kB,uBAAuB;IACzB,OAAO,KAAKqG,wBAAZ;EACD;;EAE0B,IAAvBrG,uBAAuB,CAAC/kB,KAAD,EAA+B;IACxD,KAAKorB,wBAAL,GAAgCprB,KAAhC;EACD;;EAEe,IAAZgH,YAAY;IACd,OAAO,KAAKoU,aAAZ;EACD;;EAEe,IAAZpU,YAAY,CAAChH,KAAD,EAAsB;IACpC,KAAKob,aAAL,GAAqBpb,KAArB;EACD;;EAES,IAANwD,MAAM;IACR,OAAO,KAAK6nB,OAAZ;EACD;;EAES,IAAN7nB,MAAM,CAACxD,KAAD,EAAyB;IACjC,KAAKqrB,OAAL,GAAerrB,KAAf;EACD;;EAEKurB,mBAAmB,CAAC3jB,WAAqB,EAAtB,EAAwB;;MAC/C,IAAI,KAAK4iB,MAAT,EAAiB;QACf,OAAO5iB,QAAQ,CAAC4jB,QAAT,CAAkB,KAAKhB,MAAvB,CAAP;MACD,CAFD,MAEO;QACL,MAAM/E,aAAa,GAAG,MAAM,KAAKze,YAAL,CAAkBS,eAAlB,CAAkC,MAAlC,CAA5B;QACA,OAAOG,QAAQ,CAAC4jB,QAAT,CAAkB/F,aAAlB,CAAP;MACD;IACF;EAAA;;EAED1R,qBAAqB;IACnB,OAAO,EAAE,KAAKpN,MAAL,YAAuBtO,UAAzB,CAAP;EACD;;;;;;EAKDgR,KAAK;IACH,OAAO,IAAIihB,OAAJ,CACL,KAAKryB,GADA,EAEL,KAAK0O,MAFA,EAGL,KAAKuc,KAHA,EAIL,KAAKuH,OAJA,EAKL,KAAKzhB,MALA,EAML,KAAKgiB,SANA,EAOL,KAAKzJ,MAPA,EAQL,KAAK0J,eARA,EASL,KAAKC,OATA,EAUL,KAAKE,wBAVA,EAWL,KAAKhQ,aAXA,EAYL,KAAKiQ,OAZA,CAAP;EAcD;;;;;;EAKDI,yBAAyB,CAACC,EAAD,EAAkC;IACzD,KAAKf,iBAAL,CAAuBzoB,IAAvB,CAA4BwpB,EAA5B;EACD;;AAnMiB,C,CC3CpB;;;AACO,MAAMC,OAAO,GAAG;EACnB,cAAc,0CADK;EAEnB,WAAW;AAFQ,CAAhB;ACAP;;;;;MAIaC,6BAA6BxzB,MAAK;EAE7CP,YAAmB+J,OAAnB,EAAoC;IAClC,MAAM,wBAAN;IADiB;IADnB,YAAO,sBAAP;EAGC;;AAJ4C;AAO/C;;;;;;MAIaiqB,+BAA+BzzB,MAAK;EAE/CP;IACE,MAAM,uCAAN;IAFF,YAAO,wBAAP;EAGC;;AAJ8C;;MAOpCi0B,gBAAe;EAC1Bj0B,YAAoBk0B,OAApB,EAAqC;IAAjB;;IAClB,IAAIA,OAAO,CAACrwB,MAAR,KAAmB,CAAvB,EAA0B;MACxB,MAAM,IAAImwB,sBAAJ,EAAN;IACD;EACF;;EAEK/iB,KAAK,CAAC;IAAED,MAAF;IAAU7G;EAAV,CAAD,EAAkC;;MAC3C,MAAMJ,OAAO,GAAG,MAAM+D,OAAO,CAACmC,GAAR,CACpB,KAAKikB,OAAL,CAAa/nB,GAAb,CAAkBgF,MAAD,IAAO;QACtB,OAAOA,MAAM,CAACF,KAAP,CAAa;UAAED,MAAF;UAAU7G;QAAV,CAAb,CAAP;MACD,CAFD,CADoB,CAAtB;;MAMA,IAAIJ,OAAO,CAAClG,MAAR,KAAmB,CAAvB,EAA0B;QACxB,MAAM,IAAImwB,sBAAJ,EAAN;MACD;;;MAGD,IAAIG,UAAU,GAAWpqB,OAAO,CAACqqB,GAAR,EAAzB,EAAwC;;MACxC,OAAOrqB,OAAO,CAAClG,MAAf,EAAuB;;QAErB,MAAMwwB,aAAa,GAAGtqB,OAAO,CAACqqB,GAAR,EAAtB;;QAEA,IAAIC,aAAa,KAAKF,UAAtB,EAAkC;UAChC,MAAM,IAAIJ,oBAAJ,CAAyB,CAACI,UAAD,EAAaE,aAAb,CAAzB,CAAN;QACD;;QACDF,UAAU,GAAGE,aAAb;MACD;;MAED,OAAOF,UAAP;IACD;EAAA;;AA/ByB;;MCrBfG,UAAS;EACpBt0B,YAAoBC,OAApB,EAAoC;IAAhB;EAAoB;;EAExCgR,KAAK,CAAC;IAAED,MAAF;IAAU7G;EAAV,CAAD,EAAkC;IACrC,OAAO,KAAKlK,OAAL,CAAaG,GAAb,CAAiBm0B,eAAjB,CAAiC;MAAEvjB,MAAF;MAAU7G;IAAV,CAAjC,CAAP;EACD;;AALmB;;MCATqqB,WAAU;EACb9gB,sBAAsB,CAACvF,MAAD,EAAwB;;MAChD,OAAOA,MAAP;IACH;EAAA;;AAHkB;;MCCVsmB,kBAAiB;EAEtB9K,QAAQ,CAACvoB,IAAD,EAAqB;;MACjC,MAAM;QAAE4Y;MAAF,IAAY0a,aAAa,CAACtzB,IAAI,CAACA,IAAN,EAA6BA,IAAI,CAACooB,IAAlC,CAA/B;MACA,OAAO;QAAEC,MAAM,EAAEzP;MAAV,CAAP;IACD;EAAA;;AAL2B;;MCAjB2a,+BAA8B;EAA3C30B;IACU,+BAAsD,EAAtD;EA4BT;;;;;;;EAtBC40B,kBAAkB,CAACC,cAAD,EAA2C;IAC3D,KAAK,MAAM1pB,IAAX,IAAmB0pB,cAAnB,EAAmC;MACjCtsB,MAAM,CAAC6kB,MAAP,CAAc,KAAK0H,uBAAnB,EAA4C;QAC1C,CAAC3pB,IAAD,GAAQ0pB,cAAc,CAAC1pB,IAAD;MADoB,CAA5C;IAGD;EACF;;;;;;;;;;EASKgiB,uBAAuB,CAAChiB,IAAD,EAAyB;;MACpD,MAAMhD,KAAK,GAAG,KAAK2sB,uBAAL,CAA6B3pB,IAA7B,CAAd;;MACA,IAAI,CAAChD,KAAL,EAAY;QACV,MAAM,IAAImlB,sBAAJ,CAA2BniB,IAA3B,CAAN;MACD;;MACD,OAAOhD,KAAP;IACD;EAAA;;AA5BwC;ACO3C;;;;;;;MAKa4sB,sBAAqB;EAEhC/0B,YAA6B+P,QAA7B,EAAgD;IAAnB;IAC3B,KAAKilB,YAAL,GAAoB,GAApB;EACD;;EACDvW,sBAAsB,CAACtQ,MAAD,EAAqC;IACzD,MAAM,IAAI2C,yBAAJ,CAA+B3C,MAAc,CAAClH,IAA9C,CAAN;EACD;;;;;;;;;;;EASK6W,SAAS,CAAC;IACd9X,GAAG,GAAGtE,WAAW,CAACuE,WADJ;IAEdE,YAAY,GAAGxE,qBAAqB,CAACsE,WAFvB;IAGdC,QAAQ,GAAGzE,iBAAiB,CAACwE,WAAlB,GAAgC;EAH7B,CAAD,EAIG;;MAChB,OAAO,IAAIoU,QAAJ,CAAanU,QAAb,EAAuBC,YAAvB,EAAqC,GAArC,EAA0C,KAAK6uB,YAA/C,EAA6DhvB,GAA7D,CAAP;IACD;EAAA;;;;;;;;;;;EAUKqY,QAAQ,CAAC;IACbrY,GAAG,GAAGtE,WAAW,CAAC8F,QADL;IAEbrB,YAAY,GAAGxE,qBAAqB,CAAC6F,QAFxB;IAGbtB,QAAQ,GAAGzE,iBAAiB,CAAC+F,QAAlB,GAA6B;EAH3B,CAAD,EAIG;;MACf,OAAO,IAAI6S,QAAJ,CAAanU,QAAb,EAAuBC,YAAvB,EAAqC,GAArC,EAA0C,KAAK6uB,YAA/C,EAA6DhvB,GAA7D,CAAP;IACD;EAAA;;;;;;;;;;;EAUKsY,WAAW,CAAC;IAChBtY,GAAG,GAAGtE,WAAW,CAACmG,UADF;IAEhB3B,QAAQ,GAAGzE,iBAAiB,CAACoG,UAAlB,GAA+B;EAF1B,CAAD,EAGhB;;MACC,OAAO,IAAIwS,QAAJ,CAAanU,QAAb,EAAuB,CAAvB,EAA0B,GAA1B,EAA+B,KAAK8uB,YAApC,EAAkDhvB,GAAlD,CAAP;IACD;EAAA;;;;;;;;;;;EAUKwY,gBAAgB,CAAC;IACrBxY,GAAG,GAAGtE,WAAW,CAACmG,UADG;IAErB3B,QAAQ,GAAGzE,iBAAiB,CAACoG,UAAlB,GAA+B;EAFrB,CAAD,EAGrB;;MACC,OAAO,IAAIwS,QAAJ,CAAanU,QAAb,EAAuB,CAAvB,EAA0B,GAA1B,EAA+B,KAAK8uB,YAApC,EAAkDhvB,GAAlD,CAAP;IACD;EAAA;;;;;;;;;;;EAUKgO,MAAM;;MACV,OAAO,IAAIqG,QAAJ,CACL5Y,iBAAiB,CAACuG,MAAlB,GAA2B,IADtB,EAELrG,qBAAqB,CAACqG,MAFjB,EAGL,EAHK,EAIL,KAAKgtB,YAJA,EAKLtzB,WAAW,CAACsG,MALP,CAAP;IAOD;EAAA;;EAEK6L,KAAK,CAAC1F,MAAD,EAAyB;;MAClC,MAAMyF,SAAS,GAAe,EAA9B;;MACA,KAAK,MAAMJ,KAAX,IAAoBrF,MAApB,EAA4B;QAC1B,QAAQqF,KAAK,CAACvM,IAAd;UACE,KAAK,aAAL;YACE2M,SAAS,CAACvJ,IAAV,CAAe,MAAM,KAAKgU,QAAL,CAAc7K,KAAd,CAArB;YACA;;UACF,KAAK,aAAL;YACEI,SAAS,CAACvJ,IAAV,CAAe,MAAM,KAAKyT,SAAL,CAAetK,KAAf,CAArB;YACA;;UACF,KAAK,YAAL;YACEI,SAAS,CAACvJ,IAAV,CAAe,MAAM,KAAKiU,WAAL,CAAiB9K,KAAjB,CAArB;YACA;;UACF,KAAK,kBAAL;YACEI,SAAS,CAACvJ,IAAV,CAAe,IAAIgQ,QAAJ,CAAa,CAAb,EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,KAAK2a,YAA3B,EAAyC,CAAzC,CAAf;YACA;;UACF;YACE,MAAM,IAAIlkB,yBAAJ,CAA+B3C,MAAc,CAAClH,IAA9C,CAAN;QAdJ;MAgBD;;MACD,OAAO2M,SAAP;IACD;EAAA;;AA7G+B;AChBlC;;;;;AAsFA;;;;;;;MAKaqhB,aAAY;EAavBj1B,YAAoBsjB,IAApB,EAAqD;IAAjC;IAZZ,gBAA+B,EAA/B;IAUQ,cAASxgB,MAAT;;IAGd,IAAI,OAAO,KAAKwgB,IAAZ,KAAqB,QAAzB,EAAmC;MACjC,KAAK0P,UAAL,GAAkB,IAAIC,SAAJ,CAAc,KAAK3P,IAAnB,CAAlB;IACD,CAFD,MAEO;MACL,KAAK0P,UAAL,GAAkB,KAAK1P,IAAvB;IACD;;IACD,KAAK4R,QAAL,GAAgB,IAAIzC,OAAJ,CAAYnP,IAAZ,CAAhB;IACA,KAAK6R,OAAL,GAAe,IAAIjU,MAAJ,CAAW,KAAKgU,QAAhB,CAAf;IACA,KAAKE,WAAL,CAAiB;MAAEh1B,GAAG,EAAE,KAAK4yB;IAAZ,CAAjB;IACA,KAAKnf,KAAL,GAAa,KAAKqhB,QAAL,CAAcrhB,KAAd,CAAoBA,KAApB,CAA0BiX,IAA1B,CAA+B,KAAKoK,QAAL,CAAcrhB,KAA7C,CAAb;EACD;;;;;;;;;;;;EAYDuhB,WAAW,CAAC;IACVh1B,GADU;IAEVuL,MAFU;IAGVmD,MAHU;IAIViB,QAJU;IAKVtE,MALU;IAMV0F,MANU;IAOVkH,MAPU;IAQVqR,MARU;IASVwD,uBATU;IAUV/d;EAVU,CAAD,EAWU;IACnB,KAAKkmB,cAAL,CAAoBj1B,GAApB;IACA,KAAKk1B,iBAAL,CAAuB3pB,MAAvB;IACA,KAAK4pB,iBAAL,CAAuBzmB,MAAvB;IACA,KAAK0mB,iBAAL,CAAuBrkB,MAAvB;IACA,KAAKskB,iBAAL,CAAuBpd,MAAvB;IACA,KAAKqd,iBAAL,CAAuBhM,MAAvB;IACA,KAAKiM,0BAAL,CAAgCzI,uBAAhC;IACA,KAAK0I,eAAL,CAAqBzmB,YAArB;IAEA,KAAK+lB,QAAL,CAAc7J,KAAd,GAAsBtb,QAAtB;;IACA,IAAItE,MAAJ,EAAY;MACV,KAAKypB,QAAL,CAAczB,gBAAd,CAA+BhoB,MAA/B;IACD;EACF;;;;;;;;;;;EAUD8pB,iBAAiB,CAACzmB,MAAD,EAAsC;IACrD,IAAI,CAAC,KAAK+mB,QAAL,CAAc/mB,MAAf,IAAyB,OAAOA,MAAP,KAAkB,WAA/C,EAA4D;MAC1D,KAAKomB,QAAL,CAAcpmB,MAAd,GAAuB,IAAItO,UAAJ,EAAvB;MACA,KAAKq1B,QAAL,CAAc/mB,MAAd,GAAuBA,MAAvB;IACD,CAHD,MAGO,IAAI,OAAOA,MAAP,KAAkB,WAAtB,EAAmC;MACxC,KAAKomB,QAAL,CAAcpmB,MAAd,GAAuBA,MAAvB;MACA,KAAK+mB,QAAL,CAAc/mB,MAAd,GAAuBA,MAAvB;IACD;EACF;;;;;;;;;;;EAUDumB,cAAc,CAACj1B,GAAD,EAAgC;IAC5C,IAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;MAC3B,KAAK4yB,UAAL,GAAkB,IAAIC,SAAJ,CAAc7yB,GAAd,CAAlB;IACD,CAFD,MAEO,IAAIA,GAAG,KAAKkG,SAAZ,EAAuB,CAAvB,KAEA;MACL,KAAK0sB,UAAL,GAAkB5yB,GAAlB;IACD;;IACD,KAAKy1B,QAAL,CAAcz1B,GAAd,GAAoB,KAAK4yB,UAAzB;IACA,KAAKkC,QAAL,CAAc90B,GAAd,GAAoB,KAAK4yB,UAAzB;EACD;;;;;;;;;;;;EAWDwC,iBAAiB,CAACrkB,MAAD,EAAsC;IACrD,IAAI,OAAOA,MAAP,KAAkB,WAAtB,EAAmC;MACjC,KAAK0kB,QAAL,CAAc1kB,MAAd,GAAuBA,MAAvB;MACA,KAAK+jB,QAAL,CAAc/jB,MAAd,GAAuBA,MAAvB;IACD,CAHD,MAGO,IAAI,KAAK0kB,QAAL,CAAc1kB,MAAd,KAAyB7K,SAA7B,EAAwC;MAC7C,MAAMwvB,CAAC,GAAG,KAAKC,UAAL,CAAgBzD,kBAAhB,GAAV;MACA,KAAKuD,QAAL,CAAc1kB,MAAd,GAAuB2kB,CAAvB;MACA,KAAKZ,QAAL,CAAc/jB,MAAd,GAAuB2kB,CAAvB;IACD;EACF;;;;;;;;;;;EAUDR,iBAAiB,CAAC3pB,MAAD,EAAsC;IACrD,IAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;MAC9B,MAAMqqB,CAAC,GAAG,IAAI9E,wBAAJ,CAA6B,IAAIuB,OAAJ,CAAY,IAAIQ,SAAJ,CAActnB,MAAd,CAAZ,CAA7B,CAAV;MACA,KAAKkqB,QAAL,CAAclqB,MAAd,GAAuBqqB,CAAvB;MACA,KAAKd,QAAL,CAAcvpB,MAAd,GAAuBqqB,CAAvB;IACD,CAJD,MAIO,IAAI,OAAOrqB,MAAP,KAAkB,WAAtB,EAAmC;MACxC,KAAKkqB,QAAL,CAAclqB,MAAd,GAAuBA,MAAvB;MACA,KAAKupB,QAAL,CAAcvpB,MAAd,GAAuBA,MAAvB;IACD,CAHM,MAGA,IAAI,KAAKkqB,QAAL,CAAclqB,MAAd,KAAyBrF,SAA7B,EAAwC;MAC7C,MAAM0vB,CAAC,GAAG,KAAKD,UAAL,CAAgB7E,wBAAhB,GAAV;MACA,KAAK2E,QAAL,CAAclqB,MAAd,GAAuBqqB,CAAvB;MACA,KAAKd,QAAL,CAAcvpB,MAAd,GAAuBqqB,CAAvB;IACD;EACF;;;;;;;;;;;EAUDP,iBAAiB,CAACpd,MAAD,EAAsC;IACrD,IAAI,CAAC,KAAKwd,QAAL,CAAcxd,MAAf,IAAyB,OAAOA,MAAP,KAAkB,WAA/C,EAA4D;MAC1D,MAAM4d,CAAC,GAAG,KAAKF,UAAL,CAAgBrT,oBAAhB,GAAV;MACA,KAAKmT,QAAL,CAAcxd,MAAd,GAAuB4d,CAAvB;MACA,KAAKf,QAAL,CAAc/Y,cAAd,GAA+B8Z,CAA/B;IACD,CAJD,MAIO,IAAI,OAAO5d,MAAP,KAAkB,WAAtB,EAAmC;MACxC,KAAKwd,QAAL,CAAcxd,MAAd,GAAuBA,MAAvB;MACA,KAAK6c,QAAL,CAAc/Y,cAAd,GAA+B9D,MAA/B;IACD;EACF;;;;;;;;;;;EAUDqd,iBAAiB,CAAChM,MAAD,EAAsC;IACrD,IAAI,CAAC,KAAKmM,QAAL,CAAcnM,MAAf,IAAyB,OAAOA,MAAP,KAAkB,WAA/C,EAA4D;MAC1D,MAAMhjB,CAAC,GAAG,KAAKqvB,UAAL,CAAgB1I,SAAhB,GAAV;MACA,KAAK6H,QAAL,CAAcxL,MAAd,GAAuBhjB,CAAvB;MACA,KAAKmvB,QAAL,CAAcnM,MAAd,GAAuBhjB,CAAvB;IACD,CAJD,MAIO,IAAI,OAAOgjB,MAAP,KAAkB,WAAtB,EAAmC;MACxC,KAAKwL,QAAL,CAAcxL,MAAd,GAAuBA,MAAvB;MACA,KAAKmM,QAAL,CAAcnM,MAAd,GAAuBA,MAAvB;IACD;EACF;;;;;;;;;;;;;;;;;;;EAkBDiM,0BAA0B,CACxBzI,uBADwB,EAC+C;IAEvE,IAAI,CAAC,KAAK2I,QAAL,CAAc3I,uBAAf,IAA0C,OAAOA,uBAAP,KAAmC,WAAjF,EAA8F;MAC5F,MAAMgJ,CAAC,GAAG,IAAI1I,2BAAJ,EAAV;MACA,KAAK0H,QAAL,CAAchI,uBAAd,GAAwCgJ,CAAxC;MACA,KAAKL,QAAL,CAAc3I,uBAAd,GAAwCgJ,CAAxC;IACD,CAJD,MAIO,IAAI,OAAOhJ,uBAAP,KAAmC,WAAvC,EAAoD;MACzD,KAAKgI,QAAL,CAAchI,uBAAd,GAAwCA,uBAAxC;MACA,KAAK2I,QAAL,CAAc3I,uBAAd,GAAwCA,uBAAxC;IACD;EACF;;;;;;;;;;EASD0I,eAAe,CAACzmB,YAAD,EAAkD;IAC/D,MAAMgnB,KAAK,GACT,OAAOhnB,YAAP,KAAwB,WAAxB,GAAsC,KAAK4mB,UAAL,CAAgBrI,cAAhB,GAAtC,GAA0Eve,YAD5E;IAEA,KAAK0mB,QAAL,CAAc1mB,YAAd,GAA6BgnB,KAA7B;IACA,KAAKjB,QAAL,CAAc/lB,YAAd,GAA6BgnB,KAA7B;EACD;;;;;;EAKK,IAAFC,EAAE;IACJ,OAAO,KAAKlB,QAAL,CAAckB,EAArB;EACD;;;;;;EAKW,IAARje,QAAQ;IACV,OAAO,KAAK+c,QAAL,CAAc/c,QAArB;EACD;;EAES,IAANE,MAAM;IACR,OAAO,KAAK8c,OAAZ;EACD;;EAEY,IAATnuB,SAAS;IACX,OAAO,KAAKkuB,QAAL,CAActT,gBAArB;EACD;;;;;;EAKW,IAARnQ,QAAQ;IACV,OAAO,KAAKyjB,QAAL,CAAczjB,QAArB;EACD;;;;;;EAKS,IAAN9F,MAAM;IACR,OAAO,KAAKupB,QAAL,CAAcvpB,MAArB;EACD;;;;;;EAKM,IAAHvL,GAAG;IACL,OAAO,KAAK80B,QAAL,CAAc90B,GAArB;EACD;;;;;;EAKS,IAAN0O,MAAM;IACR,OAAO,KAAKomB,QAAL,CAAcpmB,MAArB;EACD;;;;;;EAKkB,IAAfunB,eAAe;IACjB,OAAO,KAAKnB,QAAL,CAAchI,uBAArB;EACD;;;;;;;;;;EASDoJ,YAAY,CAACC,MAAD,EAAgC;IAC1C,IAAItxB,KAAK,CAACC,OAAN,CAAcqxB,MAAd,CAAJ,EAA2B;MACzBA,MAAM,CAAC/rB,OAAP,CAAgBgsB,SAAD,IAAeA,SAAS,CAACC,gBAAV,CAA2B,KAAKvB,QAAhC,CAA9B;IACD,CAFD,MAEO;MACLqB,MAAM,CAACE,gBAAP,CAAwB,KAAKvB,QAA7B;IACD;EACF;;EAEDa,UAAU,CAA0BW,IAA1B,EAAqD;IAC7D,OAAO,CAAC,GAAG9yB,IAAJ,KAAW;MAChB,OAAO,IAAI8yB,IAAJ,CAAS,KAAKxB,QAAd,EAAwB,GAAGtxB,IAA3B,CAAP;IACD,CAFD;EAGD;;;;;;EAKD+yB,cAAc;IACZ,OAAO7C,OAAP;EACD;;AAnTsB","names":["RpcInjector","constructor","context","inject","signedOperationBytes","rpc","injectOperation","UnconfiguredSignerError","Error","NoopSigner","publicKey","publicKeyHash","secretKey","sign","_bytes","_watermark","createObservableFromSubscription","sub","Observable","subscriber","on","data","next","error","complete","close","DEFAULT_GAS_LIMIT","DEFAULT_FEE","DEFAULT_STORAGE_LIMIT","Protocols","protocols","Pt24m4xi","PsBABY5H","PsBabyM1","PsCARTHA","PsDELPH1","PtEdo2Zk","PsFLorena","PtGRANADs","PtHangz2","PsiThaCa","Psithaca2","ProtoALpha","ChainIds","TZ_DECIMALS","MTZ_DECIMALS","getDecimal","format","from","to","amount","bigNum","BigNumber","isNaN","multipliedBy","Math","pow","dividedBy","InvalidParameterError","smartContractMethodName","sigs","args","length","JSON","stringify","InvalidDelegationSource","source","InvalidCodeParameter","message","InvalidInitParameter","InvalidViewParameterError","smartContractViewName","originalError","cause","ViewSimulationError","viewName","failWith","validateAndExtractFailwith","isJsonString","body","parsedError","parse","Array","isArray","with","str","e","InvalidViewSimulationContext","info","RevealOperationError","OriginationParameterError","createOriginationOperation","code","init","balance","delegate","storage","fee","ORIGINATION","gasLimit","storageLimit","mutez","__awaiter","undefined","contractStorage","storageType","find","p","prim","schema","Schema","Encode","script","operation","kind","OpKind","gas_limit","storage_limit","toString","createTransferOperation","parameter","TRANSFER","TRANSACTION","destination","parameters","createSetDelegateOperation","DELEGATION","createRegisterDelegateOperation","createRevealOperation","REVEAL","public_key","createRegisterGlobalConstantOperation","value","REGISTER_GLOBAL_CONSTANT","attachKind","op","Object","findWithKind","arr","found","isKind","isOpWithFee","indexOf","isOpRequireReveal","hasMetadata","hasMetadataWithResult","metadata","hasMetadataWithInternalOperationResult","isErrorWithMessage","TezosOperationError","errors","errorDetails","lastError","id","string","int","TezosPreapplyFailureError","result","flattenOperationResult","response","results","returnedResults","i","j","contents","content","push","operation_result","internal_operation_results","forEach","x","flattenErrors","status","concat","internalResult","OriginationOperationError","InvalidConfirmationCountError","ConfirmationUndefinedError","InvalidFilterExpressionError","Operation","hash","raw","ReplaySubject","_pollingConfig$","pipe","switchMap","config","defer","stream","subscribeBlock","timeoutWith","timeout","throwError","shareReplay","refCount","currentHead$","map","head","operations","_foundAt","header","level","filter","first","Number","POSITIVE_INFINITY","validateOperation","ValidationResult","VALID","InvalidOperationHashError","confirmed$","catchError","of","EMPTY","subscribe","includedInBlock","revealOperation","revealStatus","confirmation","confirmations","defaultConfirmationCount","confirmationPollingTimeoutSecond","conf","Promise","resolve","reject","_","BatchOperation","params","sumProp","prop","reduce","prev","current","BATCH_KINDS","consumedGas","String","storageDiff","OperationEmitter","signer","isRevealOpNeeded","pkh","isAccountRevealRequired","isRevealRequiredForOpType","readProvider","isAccountRevealed","opRequireReveal","prepareOperation","counters","ops","blockHashPromise","getBlockHash","blockProtoPromise","getNextProtocol","counterPromise","getCounter","protocol","headCounter","all","counter","parseInt","getFee","opCounter","getSource","constructOps","cOps","ACTIVATION","cops","toLowerCase","startsWith","DeprecationError","InvalidOperationKindError","opOb","branch","forge","forgedBytes","forger","opbytes","simulate","opResponse","runOperation","clone","estimate","_a","estimator","rest","calculatedFee","calculatedGas","calculatedStorage","estimation","suggestedFeeMutez","signAndInject","signed","Uint8Array","sbytes","signature","prefixSig","preapplyOperations","injector","OperationBatch","withTransfer","validateAddress","InvalidAddressError","withContractCall","toTransferParams","withDelegation","withActivation","secret","validateKeyHash","InvalidKeyHashError","withOrigination","withRegisterGlobalConstant","getRPCOp","param","parser","prepareCodeOrigination","send","estimates","batch","revealNeeded","estimated","reveal","estimatedReveal","unshift","prepared","opBytes","RPCBatchProvider","receiptFromOperation","ALLOCATION_BURN","ORIGINATION_BURN","operationResults","totalGas","totalStorage","totalFee","totalOriginationBurn","totalAllocationBurn","totalPaidStorageDiff","plus","originated_contracts","consumed_gas","paid_storage_size_diff","totalStorageBurn","MissedBlockDuringConfirmationError","MAX_BRANCH_ANCESTORS","WalletOperation","opHash","_newHead$","tap","newHead","_included","lastHead","bufferSize","newHead$","opGroup","_includedInBlock","_operationResult","toPromise","receipt","getCurrentConfirmation","combineLatest","getBlock","foundAtBlock","isInCurrentBranch","tipBlockIdentifier","tipBlockHeaderLevel","getBlockLevel","inclusionBlock","levelDiff","tipBlockLevel","min","blocks","Set","getLiveBlocks","has","confirmationObservable","distinctUntilChanged","previousHead","block","expectedConfirmation","currentConfirmation","completed","takeWhile","BatchWalletOperation","operationResult","DelegationWalletOperation","delegationOperation","OriginationWalletOperation","originationOperation","contract","address","wallet","at","TransactionWalletOperation","transactionOperation","createNewPollingBasedHeadObservable","sharedHeadOb","scheduler","OperationFactory","createNewHeadObservable","sharedHeadObs","createPastBlockWalker","startBlock","count","range","startWith","concatMap","createHeadObservableFromConfig","blockIdentifier","observableSequence","createOperation","createBatchOperation","createTransactionOperation","createDelegationOperation","RpcTzProvider","getBalance","getDelegate","activate","bytes","MINIMAL_FEE_MUTEZ","MINIMAL_FEE_PER_BYTE_MUTEZ","MINIMAL_FEE_PER_GAS_MUTEZ","GAS_BUFFER","Estimate","_milligasLimit","_storageLimit","opSize","minimalFeePerStorageByteMutez","baseFeeMutez","burnFeeMutez","roundUp","limit","max","operationFeeMutez","nanotez","ceil","minimalFeeMutez","usingBaseFeeMutez","totalCost","consumedMilligas","createEstimateInstanceFromProperties","estimateProperties","milligasLimit","createArrayEstimateInstancesFromProperties","RevealEstimateError","mergeLimits","userDefinedLimit","defaultLimits","SIGNATURE_STUB","RPCEstimateProvider","getKeys","isSignerConfigured","isAnySignerConfigured","walletProvider","getPKH","getAccountLimits","constants","numberOfOps","hard_gas_limit_per_operation","hard_gas_limit_per_block","hard_storage_limit_per_operation","cost_per_byte","floor","ajustGasForBatchOperation","toNumber","gasLimitBlock","gaslimitOp","div","getEstimationPropertiesFromOperationContent","size","costPerByte","totalMilligas","ORIGINATION_STORAGE","ALLOCATION_STORAGE","consumed_milligas","storage_size","prepareEstimate","chain_id","getChainId","OP_SIZE_REVEAL","originate","protocolConstants","getProtocolConstants","DEFAULT_PARAMS","isRevealNeeded","addRevealOp","shift","transfer","setDelegate","sourceOrDefault","registerDelegate","registerGlobalConstant","DelegateOperation","delegationOp","isRegisterOperation","OriginationOperation","contractProvider","originatedContracts","contractAddress","originationOp","storageSize","RegisterGlobalConstantOperation","globalConstantHash","global_address","registerGlobalConstantOp","registeredExpression","RevealOperation","revealOp","txResult","TransactionOperation","transactionOp","key","transferImplicit","removeDelegate","transferToContract","MANAGER_LAMBDA","VIEW_LAMBDA","compose","functioncomposer1","functioncomposer2","contractAbstraction","ContractMethod","provider","parameterSchema","name","isMultipleEntrypoint","isAnonymous","validateArgs","ExtractSignatures","ExtractSchema","getSignature","sig","Wallet","fullTransferParams","entrypoint","DEFAULT_SMART_CONTRACT_METHOD_NAME","WalletOperationBatch","mapOperation","mapTransferParamsToWalletParams","mapOriginateParamsToWalletParams","mapDelegateParamsToWalletParams","sendOperations","operationFactory","forceRefetch","_pkh","walletCommand","mappedParams","contractAbstractionComposer","validateContractAddress","InvalidContractAddressError","withExtensions","getScript","entrypoints","getEntrypoints","abs","ContractAbstraction","LegacyWalletProvider","ContractMethodObject","EncodeObject","runCodeHelper","viewArgsType","viewReturnType","contractStorageType","viewInstructions","viewArgs","contractStorageValue","input","OnChainView","_rpc","_readProvider","_contractAddress","_smartContractViewSchema","_contractStorageType","_args","extractArgsSchema","extractResultSchema","executeView","executionContext","verifyContextExecution","chainId","getStorage","executeViewAndDecodeResult","adaptViewCodeToContext","instructions","viewCaller","transformArgsToMichelson","encodeViewArgs","contractBalance","instructionsToReplace","BALANCE","SENDER","SELF_ADDRESS","AMOUNT","inst","viewScript","runCode","decodeViewResult","ContractMethodFactory","createContractMethodFlatParams","smartContractMethodSchema","createContractMethodObjectParam","createContractViewObjectParam","smartContractViewSchema","ContractView","currentContract","callbackParametersSchema","read","validateChain","InvalidChainIdError","arg","runView","Execute","isView","lastElement","storageProvider","contractMethodFactory","fromRPCResponse","ParameterSchema","viewSchema","ViewSchema","_initializeOnChainViews","_initializeMethods","keys","isMultipleEntryPoint","methods","methodsObject","view","entrypointParamWithoutCallback","smartContractMethodSchemaWithoutCallback","parametersCallback","smartContractMethodCallbackSchema","views","anonymousMethods","allContractViews","val","contractViews","bigMap","getBigMapKey","BigMapAbstraction","get","keyToEncode","getBigMapKeyByID","HttpResponseError","STATUS_CODE","NOT_FOUND","getMultipleValues","keysToEncode","batchSize","getBigMapKeysByID","toJSON","SaplingStateAbstraction","getSaplingDiff","getSaplingDiffByID","getId","smartContractAbstractionSemantic","big_map","sapling_state","RpcContractProvider","Symbol","for","contractSchema","isSchema","getContract","encodedKey","EncodeBigMapKey","ExecuteOnBigMapValue","type","packed","packer","packData","encodedExpr","encodeExpr","bigMapValue","getBigMapValue","expr","getBlockForRequest","bigMapValues","MichelsonMap","position","keysBatch","slice","getBigMapValueOrUndefined","set","ex","saplingState","getSaplingDiffById","addRevealOperationIfNeeded","estimateReveal","bind","preparedOrigination","forgedOrigination","test","publickKeyHash","MichelCodecParser","getNextProto","proto","nextProto","parseScript","src","Parser","parseMichelineExpression","parseJSON","parsedParams","formatCodeParam","formatInitParam","globalconstantsHashAndValue","findGlobalConstantsHashAndValue","expandGlobalConstant","storageTypeNoGlobalConst","schemaNoGlobalConst","parsedCode","c","order","sort","a","b","parsedInit","globalConstantTokens","findToken","globalConstantsHashAndValue","token","tokenArgs","tokenVal","michelineValue","globalConstantsProvider","getGlobalConstantByHash","assign","RpcPacker","GlobalConstantNotFound","UnconfiguredGlobalConstantsProviderError","NoopGlobalConstantsProvider","_hash","RpcReadAdapter","getProtocols","next_protocol","time_between_blocks","minimal_block_delay","getConstants","getBlockHeader","getBlockTimestamp","timestamp","bigMapQuery","getBigMapExpr","saplingStateQuery","manager","getManagerKey","haveManager","opHashFilter","sourceFilter","kindFilter","destinationFilter","some","evaluateOpFilter","evaluateExpression","exp","and","every","evaluateFilter","or","filters","filterOrExp","UnsupportedEventError","ObservableSubscription","obs","shouldRetry","operatorFunction","retry","Subject","takeUntil","completed$","call","messageListeners","errorListeners","closeListeners","NEVER","listeners","l","console","remove","idx","splice","cb","off","defaultConfigStreamer","shouldObservableSubscriptionRetry","observableSubscriptionRetryFunction","getLastBlock","applyFilter","PollingSubscribeProvider","_config$","BehaviorSubject","timer$","pluck","pollingIntervalMilliseconds","getConfirmationPollingInterval","interval","timer","newBlock$","distinctUntilKeyChanged","publish","getValue","defaultIntervalTestnetsMainnet","defaultIntervalSandbox","blockTime","confirmationPollingInterval","exception","_filter","subscribeOperation","TaquitoLocalForger","LocalForger","defaultConfigConfirmation","Context","_signer","_proto","_config","clonedContext","providerDecorator","decorator","_rpcClient","RpcClient","_forger","_injector","_walletProvider","_parser","_packer","_globalConstantsProvider","_stream","setPartialConfig","isAnyProtocolActive","includes","registerProviderDecorator","fx","VERSION","ForgingMismatchError","UnspecifiedForgerError","CompositeForger","forgers","lastResult","pop","currentResult","RpcForger","forgeOperations","NoopParser","MichelCodecPacker","packDataBytes","DefaultGlobalConstantsProvider","loadGlobalConstant","globalConstant","_globalConstantsLibrary","NaiveEstimateProvider","_costPerByte","TezosToolkit","_context","_wallet","setProvider","setRpcProvider","setStreamProvider","setSignerProvider","setForgerProvider","setWalletProvider","setPackerProvider","setGlobalConstantsProvider","setReadProvider","_options","f","getFactory","s","w","g","readP","tz","globalConstants","addExtension","module","extension","configureContext","ctor","getVersionInfo"],"sources":["../src/injector/rpc-injector.ts","../src/signer/noop.ts","../src/subscribe/create-observable-from-subscription.ts","../src/constants.ts","../src/format.ts","../src/contract/errors.ts","../src/contract/prepare.ts","../src/operations/types.ts","../src/operations/operation-errors.ts","../src/error.ts","../src/operations/operations.ts","../src/operations/batch-operation.ts","../src/operations/operation-emitter.ts","../src/batch/rpc-batch-provider.ts","../src/wallet/receipt.ts","../src/wallet/operation.ts","../src/wallet/batch-operation.ts","../src/wallet/delegation-operation.ts","../src/wallet/origination-operation.ts","../src/wallet/transaction-operation.ts","../src/wallet/operation-factory.ts","../src/tz/rpc-tz-provider.ts","../src/estimate/estimate.ts","../src/estimate/error.ts","../src/estimate/rpc-estimate-provider.ts","../src/operations/delegate-operation.ts","../src/operations/origination-operation.ts","../src/operations/register-global-constant-operation.ts","../src/operations/reveal-operation.ts","../src/operations/transaction-operation.ts","../src/contract/manager-lambda.ts","../src/contract/view_lambda.ts","../src/contract/compose.ts","../src/contract/contract-methods/contract-method-flat-param.ts","../src/wallet/wallet.ts","../src/wallet/legacy.ts","../src/contract/contract-methods/contract-method-object-param.ts","../src/contract/contract-methods/contract-on-chain-view.ts","../src/contract/contract-methods/contract-method-factory.ts","../src/contract/contract.ts","../src/contract/big-map.ts","../src/contract/sapling-state-abstraction.ts","../src/contract/semantic.ts","../src/contract/rpc-contract-provider.ts","../src/parser/michel-codec-parser.ts","../src/packer/rpc-packer.ts","../src/global-constants/error.ts","../src/global-constants/noop-global-constants-provider.ts","../src/read-provider/rpc-read-adapter.ts","../src/subscribe/filters.ts","../src/subscribe/observable-subscription.ts","../src/subscribe/polling-subcribe-provider.ts","../src/forger/taquito-local-forger.ts","../src/context.ts","../src/version.ts","../src/forger/composite-forger.ts","../src/forger/rpc-forger.ts","../src/parser/noop-parser.ts","../src/packer/michel-codec-packer.ts","../src/global-constants/default-global-constants-provider.ts","../src/estimate/naive-estimate-provider.ts","../src/taquito.ts"],"sourcesContent":["import { Injector } from './interface';\nimport { Context } from '../context';\n\nexport class RpcInjector implements Injector {\n  constructor(private context: Context) {}\n  inject(signedOperationBytes: string): Promise<string> {\n    return this.context.rpc.injectOperation(signedOperationBytes);\n  }\n}\n","import { Signer } from './interface';\n\n/**\n *  @category Error\n *  @description Error that indicates the signer has been unconfigured in the TezosToolkit instance\n */\nexport class UnconfiguredSignerError extends Error {\n  name = 'UnconfiguredSignerError';\n\n  constructor() {\n    super(\n      'No signer has been configured. Please configure one by calling setProvider({signer}) on your TezosToolkit instance.'\n    );\n  }\n}\n\n/**\n * @description Default signer implementation which does nothing and produce invalid signature\n */\nexport class NoopSigner implements Signer {\n  async publicKey(): Promise<string> {\n    throw new UnconfiguredSignerError();\n  }\n  async publicKeyHash(): Promise<string> {\n    throw new UnconfiguredSignerError();\n  }\n  async secretKey(): Promise<string> {\n    throw new UnconfiguredSignerError();\n  }\n  async sign(_bytes: string, _watermark?: Uint8Array): Promise<any> {\n    throw new UnconfiguredSignerError();\n  }\n}\n","import { BlockResponse } from '@taquito/rpc';\nimport { Observable } from 'rxjs';\nimport { OperationContent, Subscription } from './interface';\n\nexport function createObservableFromSubscription<\n  T extends BlockResponse | string | OperationContent\n>(sub: Subscription<T>) {\n  return new Observable<T>((subscriber) => {\n    sub.on('data', (data: T) => {\n      subscriber.next(data);\n    });\n\n    sub.on('error', (error: Error) => {\n      subscriber.error(error);\n    });\n\n    sub.on('close', () => {\n      subscriber.complete();\n    });\n\n    return () => {\n      sub.close();\n    };\n  });\n}\n","export enum DEFAULT_GAS_LIMIT {\n  DELEGATION = 10600,\n  ORIGINATION = 10600,\n  TRANSFER = 10600,\n  REVEAL = 1100,\n}\nexport enum DEFAULT_FEE {\n  DELEGATION = 1257,\n  ORIGINATION = 10000,\n  TRANSFER = 10000,\n  REVEAL = 374,\n}\nexport enum DEFAULT_STORAGE_LIMIT {\n  DELEGATION = 0,\n  ORIGINATION = 257,\n  TRANSFER = 257,\n  REVEAL = 0,\n}\n\nexport enum Protocols {\n  Pt24m4xi = 'Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd',\n  PsBABY5H = 'PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU',\n  PsBabyM1 = 'PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS',\n  PsCARTHA = 'PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb',\n  PsDELPH1 = 'PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo',\n  PtEdo2Zk = 'PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA',\n  PsFLorena = 'PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i',\n  PtGRANADs = 'PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV',\n  PtHangz2 = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx',\n  PsiThaCa = 'PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP',\n  Psithaca2 = 'Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A',\n  ProtoALpha = 'ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK', // temporary protocol hash\n}\n\nexport const protocols = {\n  '004': [Protocols.Pt24m4xi],\n  '005': [Protocols.PsBABY5H, Protocols.PsBabyM1],\n  '006': [Protocols.PsCARTHA],\n  '007': [Protocols.PsDELPH1],\n  '008': [Protocols.PtEdo2Zk], // edonet v2\n  '009': [Protocols.PsFLorena],\n  '010': [Protocols.PtGRANADs],\n  '011': [Protocols.PtHangz2], // hangzhou v2,\n  '012': [Protocols.PsiThaCa], //Ithaca\n  '013': [Protocols.Psithaca2], //Ithaca2\n  '014': [Protocols.ProtoALpha],\n};\n\nexport enum ChainIds {\n  MAINNET = 'NetXdQprcVkpaWU',\n  CARTHAGENET = 'NetXjD3HPJJjmcd',\n  DELPHINET = 'NetXm8tYqnMWky1',\n  EDONET = 'NetXSgo1ZT2DRUG',\n  FLORENCENET = 'NetXxkAx4woPLyu',\n  GRANADANET = 'NetXz969SFaFn8k',\n  HANGZHOUNET = 'NetXZSsxBpMQeAT',\n  ITHACANET = 'NetXbhmtAbMukLc',\n  ITHACANET2 = 'NetXnHfVqm9iesp',\n}\n","import BigNumber from 'bignumber.js';\n\nconst TZ_DECIMALS = 6;\nconst MTZ_DECIMALS = 3;\n\ntype Format = 'tz' | 'mtz' | 'mutez';\n\nfunction getDecimal(format: Format) {\n  switch (format) {\n    case 'tz':\n      return TZ_DECIMALS;\n    case 'mtz':\n      return MTZ_DECIMALS;\n    case 'mutez':\n    default:\n      return 0;\n  }\n}\n\nexport function format(\n  from: Format = 'mutez',\n  to: Format = 'mutez',\n  amount: number | string | BigNumber\n) {\n  const bigNum = new BigNumber(amount);\n  if (bigNum.isNaN()) {\n    return amount;\n  }\n\n  return bigNum\n    .multipliedBy(Math.pow(10, getDecimal(from)))\n    .dividedBy(Math.pow(10, getDecimal(to)));\n}\n","import { HttpResponseError } from '@taquito/http-utils';\nimport { MichelsonV1Expression } from '@taquito/rpc';\n\n/**\n *  @category Error\n *  @description Error that indicates invalid smart contract parameters being passed or used\n */\nexport class InvalidParameterError extends Error {\n  name = 'Invalid parameters error';\n  constructor(public smartContractMethodName: string, public sigs: any[], public args: any[]) {\n    super(\n      `${smartContractMethodName} Received ${\n        args.length\n      } arguments while expecting one of the following signatures (${JSON.stringify(sigs)})`\n    );\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid delegation source contract address being passed or used\n */\nexport class InvalidDelegationSource extends Error {\n  name = 'Invalid delegation source error';\n\n  constructor(public source: string) {\n    super(\n      `Since Babylon delegation source can no longer be a contract address ${source}. Please use the smart contract abstraction to set your delegate.`\n    );\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid smart contract code parameter being passed or used\n */\nexport class InvalidCodeParameter extends Error {\n  public name = 'InvalidCodeParameter';\n  constructor(public message: string, public readonly data: any) {\n    super(message);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates invalid smart contract init parameter being passed or used\n */\nexport class InvalidInitParameter extends Error {\n  public name = 'InvalidInitParameter';\n  constructor(public message: string, public readonly data: any) {\n    super(message);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates invalid view parameter of a smart contract\n */\nexport class InvalidViewParameterError extends Error {\n  name = 'Invalid view parameters error';\n  cause: any;\n  constructor(\n    public smartContractViewName: string,\n    public sigs: any,\n    public args: any,\n    public originalError: any\n  ) {\n    super(\n      `Unable to encode the parameter of the view: ${smartContractViewName}. Received ${args} as parameter while expecting one of the following signatures (${JSON.stringify(\n        sigs\n      )})`\n    );\n    this.cause = originalError;\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates a failure when conducting a view simulation\n */\nexport class ViewSimulationError extends Error {\n  name = 'ViewSimulationError';\n  constructor(\n    public message: string,\n    public viewName: string,\n    public failWith?: MichelsonV1Expression,\n    public originalError?: any\n  ) {\n    super(message);\n  }\n}\n\nexport const validateAndExtractFailwith = (\n  error: HttpResponseError\n): MichelsonV1Expression | undefined => {\n  if (isJsonString(error.body)) {\n    const parsedError = JSON.parse(error.body);\n    if (Array.isArray(parsedError) && 'with' in parsedError[parsedError.length - 1]) {\n      return parsedError[parsedError.length - 1].with;\n    }\n  }\n};\n\nconst isJsonString = (str: string) => {\n  try {\n    JSON.parse(str);\n  } catch (e) {\n    return false;\n  }\n  return true;\n};\n\n/**\n *  @category Error\n *  @description Error that indicates invalid or unconfigured context when executing a view\n */\nexport class InvalidViewSimulationContext extends Error {\n  public name = 'InvalidViewSimulationContext';\n  constructor(public info: string) {\n    super(`${info} Please configure the context of the view execution in the executeView method.`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates a mistake happening during the reveal operation\n */\nexport class RevealOperationError extends Error {\n  public name = 'RevealOperationError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates a mistake in the parameters in the preparation of an Origination operation\n */\nexport class OriginationParameterError extends Error {\n  public name = 'OriginationParameterError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n","import { Schema } from '@taquito/michelson-encoder';\nimport { OpKind, MichelsonV1Expression } from '@taquito/rpc';\nimport { Prim, Expr } from '@taquito/michel-codec';\nimport {\n  OriginateParams,\n  RPCOriginationOperation,\n  TransferParams,\n  RPCTransferOperation,\n  DelegateParams,\n  RPCDelegateOperation,\n  RegisterDelegateParams,\n  RPCRevealOperation,\n  RevealParams,\n  RegisterGlobalConstantParams,\n  RPCRegisterGlobalConstantOperation,\n} from '../operations/types';\nimport { DEFAULT_FEE, DEFAULT_GAS_LIMIT, DEFAULT_STORAGE_LIMIT } from '../constants';\nimport { format } from '../format';\nimport { InvalidCodeParameter, InvalidInitParameter, OriginationParameterError } from './errors';\n\nexport const createOriginationOperation = async ({\n  code,\n  init,\n  balance = '0',\n  delegate,\n  storage,\n  fee = DEFAULT_FEE.ORIGINATION,\n  gasLimit = DEFAULT_GAS_LIMIT.ORIGINATION,\n  storageLimit = DEFAULT_STORAGE_LIMIT.ORIGINATION,\n  mutez = false,\n}: OriginateParams) => {\n  if (storage !== undefined && init !== undefined) {\n    throw new OriginationParameterError(\n      'Storage and Init cannot be set a the same time. Please either use storage or init but not both.'\n    );\n  }\n\n  if (!Array.isArray(code)) {\n    throw new InvalidCodeParameter('Wrong code parameter type, expected an array', code);\n  }\n\n  let contractStorage: Expr | undefined;\n  if (storage !== undefined) {\n    const storageType = (code as Expr[]).find(\n      (p): p is Prim => 'prim' in p && p.prim === 'storage'\n    );\n    if (storageType?.args === undefined) {\n      throw new InvalidCodeParameter('The storage section is missing from the script', code);\n    }\n    const schema = new Schema(storageType.args[0] as MichelsonV1Expression); // TODO\n    contractStorage = schema.Encode(storage);\n  } else if (init !== undefined && typeof init === 'object') {\n    contractStorage = init as Expr;\n  } else {\n    throw new InvalidInitParameter('Wrong init parameter type, expected JSON Michelson', init);\n  }\n\n  const script = {\n    code,\n    storage: contractStorage,\n  };\n\n  const operation: RPCOriginationOperation = {\n    kind: OpKind.ORIGINATION,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    balance: mutez ? balance.toString() : format('tz', 'mutez', balance).toString(),\n    script,\n  };\n\n  if (delegate) {\n    operation.delegate = delegate;\n  }\n  return operation;\n};\n\nexport const createTransferOperation = async ({\n  to,\n  amount,\n  parameter,\n  fee = DEFAULT_FEE.TRANSFER,\n  gasLimit = DEFAULT_GAS_LIMIT.TRANSFER,\n  storageLimit = DEFAULT_STORAGE_LIMIT.TRANSFER,\n  mutez = false,\n}: TransferParams) => {\n  const operation: RPCTransferOperation = {\n    kind: OpKind.TRANSACTION,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    amount: mutez ? amount.toString() : format('tz', 'mutez', amount).toString(),\n    destination: to,\n    parameters: parameter,\n  };\n  return operation;\n};\n\nexport const createSetDelegateOperation = async ({\n  delegate,\n  source,\n  fee = DEFAULT_FEE.DELEGATION,\n  gasLimit = DEFAULT_GAS_LIMIT.DELEGATION,\n  storageLimit = DEFAULT_STORAGE_LIMIT.DELEGATION,\n}: DelegateParams) => {\n  const operation: RPCDelegateOperation = {\n    kind: OpKind.DELEGATION,\n    source,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    delegate,\n  };\n  return operation;\n};\n\nexport const createRegisterDelegateOperation = async (\n  {\n    fee = DEFAULT_FEE.DELEGATION,\n    gasLimit = DEFAULT_GAS_LIMIT.DELEGATION,\n    storageLimit = DEFAULT_STORAGE_LIMIT.DELEGATION,\n  }: RegisterDelegateParams,\n  source: string\n) => {\n  return {\n    kind: OpKind.DELEGATION,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    delegate: source,\n  } as RPCDelegateOperation;\n};\n\nexport const createRevealOperation = async (\n  {\n    fee = DEFAULT_FEE.REVEAL,\n    gasLimit = DEFAULT_GAS_LIMIT.REVEAL,\n    storageLimit = DEFAULT_STORAGE_LIMIT.REVEAL,\n  }: RevealParams,\n  source: string,\n  publicKey: string\n) => {\n  return {\n    kind: OpKind.REVEAL,\n    fee,\n    public_key: publicKey,\n    source,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n  } as RPCRevealOperation;\n};\n\nexport const createRegisterGlobalConstantOperation = async ({\n  value,\n  source,\n  fee,\n  gasLimit,\n  storageLimit,\n}: RegisterGlobalConstantParams) => {\n  return {\n    kind: OpKind.REGISTER_GLOBAL_CONSTANT,\n    value,\n    fee,\n    gas_limit: gasLimit,\n    storage_limit: storageLimit,\n    source,\n  } as RPCRegisterGlobalConstantOperation;\n};\n","import {\n  OperationObject,\n  InternalOperationResultKindEnum,\n  OpKind,\n  TransactionOperationParameter,\n  MichelsonV1Expression,\n} from '@taquito/rpc';\n\nexport { OpKind } from '@taquito/rpc';\n\nexport type withKind<T, K extends OpKind> = T & { kind: K };\n\nexport type ParamsWithKind =\n  | withKind<OriginateParams, OpKind.ORIGINATION>\n  | withKind<DelegateParams, OpKind.DELEGATION>\n  | withKind<TransferParams, OpKind.TRANSACTION>\n  | withKind<ActivationParams, OpKind.ACTIVATION>\n  | withKind<RegisterGlobalConstantParams, OpKind.REGISTER_GLOBAL_CONSTANT>;\n\nexport type ParamsWithKindExtended =\n  | ParamsWithKind\n  | withKind<RevealParams, OpKind.REVEAL>\n\nexport const attachKind = <T, K extends OpKind>(op: T, kind: K) => {\n  return { ...op, kind } as withKind<T, K>;\n};\n\nexport const findWithKind = <T extends { kind: OpKind }, K extends OpKind>(\n  arr: T[],\n  kind: K\n): (T & { kind: K }) | undefined => {\n  if (Array.isArray(arr)) {\n    const found = arr.find(op => op.kind === kind);\n\n    if (found && isKind(found, kind)) {\n      return found;\n    }\n  }\n};\n\nexport const isKind = <T extends { kind: OpKind }, K extends OpKind>(\n  op: T,\n  kind: K\n): op is withKind<T, K> => {\n  return op.kind === kind;\n};\n\nexport type RPCOpWithFee =\n  | RPCTransferOperation\n  | RPCOriginationOperation\n  | RPCDelegateOperation\n  | RPCRevealOperation\n  | RPCRegisterGlobalConstantOperation;\nexport type RPCOpWithSource =\n  | RPCTransferOperation\n  | RPCOriginationOperation\n  | RPCDelegateOperation\n  | RPCRevealOperation\n  | RPCRegisterGlobalConstantOperation;\n\nexport const isOpWithFee = <T extends { kind: OpKind }>(\n  op: T\n): op is withKind<T, InternalOperationResultKindEnum> => {\n  return ['transaction', 'delegation', 'origination', 'reveal', 'register_global_constant'].indexOf(op.kind) !== -1;\n};\n\nexport const isOpRequireReveal = <T extends { kind: OpKind }>(\n  op: T\n): op is withKind<T, Exclude<InternalOperationResultKindEnum, OpKind.REVEAL>> => {\n  return ['transaction', 'delegation', 'origination', 'register_global_constant'].indexOf(op.kind) !== -1;\n};\n\nexport type SourceKinds = InternalOperationResultKindEnum;\n\nexport const isSourceOp = <T extends { kind: OpKind }>(op: T): op is withKind<T, SourceKinds> => {\n  return ['transaction', 'delegation', 'origination', 'reveal', 'ballot'].indexOf(op.kind) !== -1;\n};\n\nexport const hasMetadata = <T extends { kind: OpKind }, K>(\n  op: T\n): op is T & {\n  metadata: K;\n} => {\n  return 'metadata' in op;\n};\n\nexport const hasMetadataWithResult = <T extends { kind: OpKind }, K>(\n  op: T\n): op is T & {\n  metadata: {\n    operation_result: K;\n  };\n} => {\n  return hasMetadata<T, any>(op) && 'operation_result' in op.metadata;\n};\n\nexport const hasMetadataWithInternalOperationResult = <T extends { kind: OpKind }, K>(\n  op: T\n): op is T & {\n  metadata: {\n    internal_operation_results?: K;\n  };\n} => {\n  return hasMetadata<T, any>(op) && 'internal_operation_results' in op.metadata;\n};\n\nexport interface GasConsumingOperation {\n  consumedGas?: string;\n  gasLimit: number;\n}\n\nexport interface StorageConsumingOperation {\n  storageDiff?: string;\n  storageSize?: string;\n  storageLimit: number;\n}\n\nexport interface FeeConsumingOperation {\n  fee: number;\n}\n\nexport type OriginateParamsBase = {\n  balance?: string;\n  code: string | object[];\n  delegate?: string;\n  fee?: number;\n  gasLimit?: number;\n  storageLimit?: number;\n  mutez?: boolean;\n};\n\n/**\n * @description Parameters for originate method\n */\nexport type OriginateParams<TStorage = any> = OriginateParamsBase &\n  (\n    | {\n      init?: never;\n      /** JS representation of a storage object */\n      storage: TStorage;\n    }\n    | {\n      /** Initial storage object value. Either Micheline or JSON encoded */\n      init: string | object;\n      storage?: never;\n    }\n  );\n\nexport interface ActivationParams {\n  pkh: string;\n  secret: string;\n}\n\n/**\n * @description RPC origination operation\n */\nexport interface RPCOriginationOperation {\n  kind: OpKind.ORIGINATION;\n  fee: number;\n  gas_limit: number;\n  storage_limit: number;\n  balance: string;\n  delegate?: string;\n  source?: string;\n  script: {\n    code: any;\n    storage: any;\n  };\n}\n\n/**\n * @description RPC reveal operation\n */\nexport interface RPCRevealOperation {\n  kind: OpKind.REVEAL;\n  fee: number;\n  public_key: string;\n  source?: string;\n  gas_limit: number;\n  storage_limit: number;\n}\n\nexport interface RevealParams {\n  fee?: number;\n  gasLimit?: number;\n  storageLimit?: number;\n}\n\n\n/**\n * @description Result of a forge operation contains the operation plus its encoded version\n */\nexport interface ForgedBytes {\n  opbytes: string;\n  opOb: OperationObject;\n  counter: number;\n}\n\n/**\n * @description Parameters for setDelegate method\n */\nexport interface DelegateParams {\n  source: string;\n  delegate?: string;\n  fee?: number;\n  gasLimit?: number;\n  storageLimit?: number;\n}\n\n/**\n * @description Parameters for registerDelegate method\n */\nexport interface RegisterDelegateParams {\n  fee?: number;\n  gasLimit?: number;\n  storageLimit?: number;\n}\n\n/**\n * @description RPC delegation operation\n */\nexport interface RPCDelegateOperation {\n  kind: OpKind.DELEGATION;\n  source?: string;\n  fee: number;\n  gas_limit: number;\n  storage_limit: number;\n  delegate?: string;\n}\n\n/**\n * @description Parameters for transfer method\n */\nexport interface TransferParams {\n  to: string;\n  source?: string;\n  amount: number;\n  fee?: number;\n  parameter?: TransactionOperationParameter;\n  gasLimit?: number;\n  storageLimit?: number;\n  mutez?: boolean;\n}\n\n/**\n * @description RPC register global constant operation\n */\n export interface RPCRegisterGlobalConstantOperation {\n  kind: OpKind.REGISTER_GLOBAL_CONSTANT;\n  fee: number;\n  gas_limit: number;\n  storage_limit: number;\n  source: string;\n  value: MichelsonV1Expression;\n}\n\n/**\n * @description Parameters for the `registerGlobalConstant` method\n */\nexport interface RegisterGlobalConstantParams {\n  value: MichelsonV1Expression;\n  source?: string;\n  fee?: number;\n  gasLimit?: number;\n  storageLimit?: number;\n}\n\n/**\n * @description RPC transfer operation\n */\nexport interface RPCTransferOperation {\n  kind: OpKind.TRANSACTION;\n  fee: number;\n  gas_limit: number;\n  storage_limit: number;\n  amount: string;\n  source?: string;\n  destination: string;\n  parameters?: TransactionOperationParameter;\n}\n\n/**\n * @description RPC activate account operation\n */\nexport interface RPCActivateOperation {\n  kind: OpKind.ACTIVATION;\n  pkh: string;\n  secret: string;\n}\n\nexport type RPCOperation =\n  | RPCOriginationOperation\n  | RPCTransferOperation\n  | RPCDelegateOperation\n  | RPCRevealOperation\n  | RPCActivateOperation\n  | RPCRegisterGlobalConstantOperation;\n\nexport type PrepareOperationParams = {\n  operation: RPCOperation | RPCOperation[];\n  source?: string;\n};\n","import {\n  MichelsonV1ExpressionBase,\n  OperationResultDelegation,\n  OperationResultOrigination,\n  OperationResultRegisterGlobalConstant,\n  OperationResultReveal,\n  OperationResultTransaction,\n  PreapplyResponse,\n  TezosGenericOperationError,\n} from '@taquito/rpc';\nimport {\n  hasMetadata,\n  hasMetadataWithInternalOperationResult,\n  hasMetadataWithResult,\n} from './types';\n\nexport interface TezosOperationErrorWithMessage extends TezosGenericOperationError {\n  with: MichelsonV1ExpressionBase;\n}\n\nconst isErrorWithMessage = (error: any): error is TezosOperationErrorWithMessage => {\n  return 'with' in error;\n};\n\n/**\n *  @category Error\n *  @description Generic tezos error that will be thrown when a mistake occurs when doing an operation; more details here https://tezos.gitlab.io/api/errors.html\n */\nexport class TezosOperationError extends Error {\n  name = 'TezosOperationError';\n  id: string;\n  kind: string;\n\n  constructor(public errors: TezosGenericOperationError[], public errorDetails?: string) {\n    super();\n    // Last error is 'often' the one with more detail\n    const lastError = errors[errors.length - 1];\n    this.id = lastError.id;\n    this.kind = lastError.kind;\n\n    this.message = `(${this.kind}) ${this.id}`;\n\n    if (isErrorWithMessage(lastError)) {\n      if (lastError.with.string) {\n        this.message = lastError.with.string;\n      } else if (lastError.with.int) {\n        this.message = lastError.with.int;\n      } else {\n        this.message = JSON.stringify(lastError.with);\n      }\n    }\n  }\n}\n\n/**\n *  @category Error\n *  @description Tezos error that will be thrown when a mistake happens during the preapply stage\n */\nexport class TezosPreapplyFailureError extends Error {\n  name = 'TezosPreapplyFailureError';\n\n  constructor(public result: any) {\n    super('Preapply returned an unexpected result');\n  }\n}\n\nexport type MergedOperationResult = OperationResultDelegation &\n  OperationResultOrigination &\n  OperationResultTransaction &\n  OperationResultRegisterGlobalConstant &\n  OperationResultReveal & {\n    fee?: string;\n  };\n\n// Flatten all operation content results and internal operation results into a single array\n// Some cases where we can have multiple operation results or internal operation results are:\n// - When an operation includes a reveal operation\n// - When an operation is made using the batch API\n// - Smart contract call can contains internal operation results when they call other smart contract internally or originate contracts\nexport const flattenOperationResult = (response: PreapplyResponse | PreapplyResponse[]) => {\n  const results = Array.isArray(response) ? response : [response];\n\n  const returnedResults: MergedOperationResult[] = [];\n  for (let i = 0; i < results.length; i++) {\n    for (let j = 0; j < results[i].contents.length; j++) {\n      const content = results[i].contents[j];\n      if (hasMetadataWithResult(content)) {\n        returnedResults.push({\n          fee: content.fee,\n          ...content.metadata.operation_result,\n        });\n\n        if (Array.isArray(content.metadata.internal_operation_results)) {\n          content.metadata.internal_operation_results.forEach((x) =>\n            returnedResults.push(x.result)\n          );\n        }\n      }\n    }\n  }\n\n  return returnedResults;\n};\n\n/***\n * @description Flatten all error from preapply response (including internal error)\n */\nexport const flattenErrors = (\n  response: PreapplyResponse | PreapplyResponse[],\n  status = 'failed'\n) => {\n  const results = Array.isArray(response) ? response : [response];\n\n  let errors: TezosGenericOperationError[] = [];\n  // Transaction that do not fail will be backtracked in case one failure occur\n  for (let i = 0; i < results.length; i++) {\n    for (let j = 0; j < results[i].contents.length; j++) {\n      const content = results[i].contents[j];\n      if (hasMetadata(content)) {\n        if (hasMetadataWithResult(content) && content.metadata.operation_result.status === status) {\n          errors = errors.concat(content.metadata.operation_result.errors || []);\n        }\n        if (\n          hasMetadataWithInternalOperationResult(content) &&\n          Array.isArray(content.metadata.internal_operation_results)\n        ) {\n          for (const internalResult of content.metadata.internal_operation_results) {\n            if ('result' in internalResult && internalResult.result.status === status) {\n              errors = errors.concat(internalResult.result.errors || []);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return errors;\n};\n\n/**\n *  @category Error\n *  @description Error that indicates a general failure happening during an origination operation\n */\nexport class OriginationOperationError extends Error {\n  public name = 'OriginationOperationError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n","/**\n *  @category Error\n *  @description Error that indicates invalid confirmation count has been passed or configured\n */\nexport class InvalidConfirmationCountError extends Error {\n  public name = 'InvalidConfirmationCountError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates undefined confirmation has not been specified or configured\n */\nexport class ConfirmationUndefinedError extends Error {\n  public name = 'ConfirmationUndefinedError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid filter expression being passed or used\n */\nexport class InvalidFilterExpressionError extends Error {\n  public name = 'InvalidFilterExpressionError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n","import { OperationContentsAndResult, OperationContentsAndResultReveal } from '@taquito/rpc';\nimport { defer, EMPTY, of, ReplaySubject, throwError } from 'rxjs';\nimport {\n  catchError,\n  filter,\n  first,\n  map,\n  shareReplay,\n  switchMap,\n  timeoutWith,\n} from 'rxjs/operators';\nimport { Context } from '../context';\nimport { ForgedBytes, hasMetadataWithResult } from './types';\nimport { validateOperation, ValidationResult, InvalidOperationHashError } from '@taquito/utils';\nimport { createObservableFromSubscription } from '../subscribe/create-observable-from-subscription';\nimport { InvalidConfirmationCountError } from '../error';\n\ninterface PollingConfig {\n  timeout: number;\n  interval: number;\n}\n\n/**\n * @description Utility class to interact with Tezos operations\n */\nexport class Operation {\n  private _pollingConfig$ = new ReplaySubject<PollingConfig>(1);\n\n  private currentHead$ = this._pollingConfig$.pipe(\n    switchMap((config) => {\n      return defer(() =>\n        createObservableFromSubscription(this.context.stream.subscribeBlock('head'))\n      ).pipe(\n        timeoutWith(config.timeout * 1000, throwError(new Error('Confirmation polling timed out')))\n      );\n    }),\n    shareReplay({ refCount: true })\n  );\n\n  // Observable that emit once operation is seen in a block\n  private confirmed$ = this.currentHead$.pipe(\n    map((head) => {\n      for (let i = 3; i >= 0; i--) {\n        head.operations[i].forEach((op) => {\n          if (op.hash === this.hash) {\n            this._foundAt = head.header.level;\n          }\n        });\n      }\n\n      if (head.header.level - this._foundAt >= 0) {\n        return this._foundAt;\n      }\n    }),\n    filter((x) => x !== undefined),\n    first(),\n    shareReplay()\n  );\n\n  protected _foundAt = Number.POSITIVE_INFINITY;\n  get includedInBlock() {\n    return this._foundAt;\n  }\n  /**\n   *\n   * @param hash Operation hash\n   * @param raw Raw operation that was injected\n   * @param context Taquito context allowing access to rpc and signer\n   */\n  constructor(\n    public readonly hash: string,\n    public readonly raw: ForgedBytes,\n    public readonly results: OperationContentsAndResult[],\n    protected readonly context: Context\n  ) {\n    if (validateOperation(this.hash) !== ValidationResult.VALID) {\n      throw new InvalidOperationHashError(this.hash);\n    }\n\n    this.confirmed$\n      .pipe(\n        first(),\n        catchError(() => {\n          return of(EMPTY);\n        })\n      )\n      .subscribe();\n  }\n\n  get revealOperation() {\n    return (\n      Array.isArray(this.results) &&\n      (this.results.find((op) => op.kind === 'reveal') as\n        | OperationContentsAndResultReveal\n        | undefined)\n    );\n  }\n\n  public get revealStatus() {\n    if (this.revealOperation) {\n      return this.revealOperation.metadata.operation_result.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  public get status() {\n    return (\n      this.results.map((result) => {\n        if (hasMetadataWithResult(result)) {\n          return result.metadata.operation_result.status;\n        } else {\n          return 'unknown';\n        }\n      })[0] || 'unknown'\n    );\n  }\n\n  /**\n   *\n   * @param confirmations [0] Number of confirmation to wait for\n   * @param timeout [180] Timeout\n   */\n  async confirmation(confirmations?: number, timeout?: number) {\n    if (typeof confirmations !== 'undefined' && confirmations < 1) {\n      throw new InvalidConfirmationCountError('Confirmation count must be at least 1');\n    }\n\n    const { defaultConfirmationCount, confirmationPollingTimeoutSecond } = this.context.config;\n    this._pollingConfig$.next({\n      timeout: timeout || confirmationPollingTimeoutSecond,\n    } as Required<PollingConfig>);\n\n    const conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;\n\n    return new Promise<number>((resolve, reject) => {\n      this.confirmed$\n        .pipe(\n          switchMap(() => this.currentHead$),\n          filter((head) => head.header.level - this._foundAt >= conf - 1),\n          first()\n        )\n        .subscribe((_) => {\n          resolve(this._foundAt + (conf - 1));\n        }, reject);\n    });\n  }\n}\n","import { OperationContentsAndResult } from '@taquito/rpc';\nimport { BATCH_KINDS } from '../batch/rpc-batch-provider';\nimport { Context } from '../context';\nimport { flattenErrors, flattenOperationResult } from './operation-errors';\nimport { Operation } from './operations';\nimport {\n  FeeConsumingOperation,\n  ForgedBytes,\n  GasConsumingOperation,\n  RPCOperation,\n  StorageConsumingOperation,\n  hasMetadataWithResult,\n} from './types';\n\nexport class BatchOperation\n  extends Operation\n  implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation\n{\n  constructor(\n    hash: string,\n    private readonly params: RPCOperation[],\n    public readonly source: string,\n    raw: ForgedBytes,\n    results: OperationContentsAndResult[],\n    context: Context\n  ) {\n    super(hash, raw, results, context);\n  }\n\n  private sumProp(arr: any[], prop: string) {\n    return arr.reduce((prev, current) => {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  }\n\n  public get status() {\n    return (\n      this.results\n        .filter((result) => BATCH_KINDS.indexOf(result.kind) !== -1)\n        .map((result) => {\n          if (hasMetadataWithResult(result)) {\n            return result.metadata.operation_result.status;\n          } else {\n            return 'unknown';\n          }\n        })[0] || 'unknown'\n    );\n  }\n\n  get fee() {\n    return this.sumProp(this.params, 'fee');\n  }\n\n  get gasLimit() {\n    return this.sumProp(this.params, 'gas_limit');\n  }\n\n  get storageLimit() {\n    return this.sumProp(this.params, 'storage_limit');\n  }\n\n  get consumedGas() {\n    return String(this.sumProp(flattenOperationResult({ contents: this.results }), 'consumed_gas'));\n  }\n\n  get storageDiff() {\n    return String(\n      this.sumProp(flattenOperationResult({ contents: this.results }), 'paid_storage_size_diff')\n    );\n  }\n\n  get errors() {\n    return flattenErrors({ contents: this.results });\n  }\n}\n","import {\n  OperationContents,\n  OperationContentsAndResult,\n  OpKind,\n  RpcClientInterface,\n  RPCRunOperationParam,\n} from '@taquito/rpc';\nimport { Protocols } from '../constants';\nimport { Context } from '../context';\nimport { Estimate } from '../estimate/estimate';\nimport { flattenErrors, TezosOperationError, TezosPreapplyFailureError } from './operation-errors';\nimport { InvalidOperationKindError, DeprecationError } from '@taquito/utils';\nimport {\n  ForgedBytes,\n  isOpRequireReveal,\n  ParamsWithKind,\n  PrepareOperationParams,\n  RPCOperation,\n  RPCOpWithFee,\n  RPCOpWithSource,\n} from './types';\n\nexport interface PreparedOperation {\n  opOb: {\n    branch: string;\n    contents: OperationContents[];\n    protocol: string;\n  };\n  counter: number;\n}\n\nexport abstract class OperationEmitter {\n  get rpc(): RpcClientInterface {\n    return this.context.rpc;\n  }\n\n  get signer() {\n    return this.context.signer;\n  }\n\n  constructor(protected context: Context) {}\n\n  protected async isRevealOpNeeded(op: RPCOperation[] | ParamsWithKind[], pkh: string) {\n    return !(await this.isAccountRevealRequired(pkh)) || !this.isRevealRequiredForOpType(op)\n      ? false\n      : true;\n  }\n\n  protected async isAccountRevealRequired(publicKeyHash: string) {\n    return !(await this.context.readProvider.isAccountRevealed(publicKeyHash, 'head'));\n  }\n\n  protected isRevealRequiredForOpType(op: RPCOperation[] | ParamsWithKind[]) {\n    let opRequireReveal = false;\n    for (const operation of op) {\n      if (isOpRequireReveal(operation)) {\n        opRequireReveal = true;\n      }\n    }\n    return opRequireReveal;\n  }\n\n  // Originally from sotez (Copyright (c) 2018 Andrew Kishino)\n  protected async prepareOperation(\n    { operation, source }: PrepareOperationParams,\n    pkh?: string\n  ): Promise<PreparedOperation> {\n    const counters: { [key: string]: number } = {};\n    let ops: RPCOperation[] = [];\n\n    const blockHashPromise = this.context.readProvider.getBlockHash('head~2');\n    const blockProtoPromise = this.context.readProvider.getNextProtocol('head');\n\n    if (Array.isArray(operation)) {\n      ops = [...operation];\n    } else {\n      ops = [operation];\n    }\n\n    // Implicit account who emit the operation\n    const publicKeyHash = pkh ? pkh : await this.signer.publicKeyHash();\n    let counterPromise: Promise<string | undefined> = Promise.resolve(undefined);\n\n    for (let i = 0; i < ops.length; i++) {\n      if (isOpRequireReveal(ops[i]) || ops[i].kind === 'reveal') {\n        counterPromise = this.context.readProvider.getCounter(publicKeyHash, 'head');\n        break;\n      }\n    }\n\n    const [hash, protocol, headCounter] = await Promise.all([\n      blockHashPromise,\n      blockProtoPromise,\n      counterPromise,\n    ]);\n\n    const counter = parseInt(headCounter || '0', 10);\n    if (!counters[publicKeyHash] || counters[publicKeyHash] < counter) {\n      counters[publicKeyHash] = counter;\n    }\n\n    const getFee = (op: RPCOpWithFee) => {\n      const opCounter = ++counters[publicKeyHash];\n      return {\n        counter: `${opCounter}`,\n        fee: typeof op.fee === 'undefined' ? '0' : `${op.fee}`,\n        gas_limit: typeof op.gas_limit === 'undefined' ? '0' : `${op.gas_limit}`,\n        storage_limit: typeof op.storage_limit === 'undefined' ? '0' : `${op.storage_limit}`,\n      };\n    };\n\n    const getSource = (op: RPCOpWithSource) => {\n      return {\n        source: typeof op.source === 'undefined' ? source || publicKeyHash : op.source,\n      };\n    };\n\n    const constructOps = (cOps: RPCOperation[]): OperationContents[] =>\n      cOps.map((op: RPCOperation) => {\n        switch (op.kind) {\n          case OpKind.ACTIVATION:\n            return {\n              ...op,\n            };\n          case OpKind.REVEAL:\n            return {\n              ...op,\n              ...getSource(op),\n              ...getFee(op),\n            };\n          case OpKind.ORIGINATION:\n            return {\n              ...op,\n              balance: typeof op.balance !== 'undefined' ? `${op.balance}` : '0',\n              ...getSource(op),\n              ...getFee(op),\n            };\n          case OpKind.TRANSACTION: {\n            const cops = {\n              ...op,\n              amount: typeof op.amount !== 'undefined' ? `${op.amount}` : '0',\n              ...getSource(op),\n              ...getFee(op),\n            };\n            if (cops.source.toLowerCase().startsWith('kt1')) {\n              throw new DeprecationError(\n                `KT1 addresses are not supported as source since ${Protocols.PsBabyM1}`\n              );\n            }\n            return cops;\n          }\n          case OpKind.DELEGATION:\n            return {\n              ...op,\n              ...getSource(op),\n              ...getFee(op),\n            };\n          case OpKind.REGISTER_GLOBAL_CONSTANT:\n            return {\n              ...op,\n              ...getSource(op),\n              ...getFee(op),\n            };\n          default:\n            throw new InvalidOperationKindError((op as any).kind);\n        }\n      });\n\n    const contents = constructOps(ops);\n\n    return {\n      opOb: {\n        branch: hash,\n        contents,\n        protocol,\n      },\n      counter,\n    };\n  }\n\n  protected async forge({ opOb: { branch, contents, protocol }, counter }: PreparedOperation) {\n    const forgedBytes = await this.context.forger.forge({ branch, contents });\n\n    return {\n      opbytes: forgedBytes,\n      opOb: {\n        branch,\n        contents,\n        protocol,\n      },\n      counter,\n    };\n  }\n\n  protected async simulate(op: RPCRunOperationParam) {\n    return {\n      opResponse: await this.rpc.runOperation(op),\n      op,\n      context: this.context.clone(),\n    };\n  }\n\n  protected async estimate<T extends { fee?: number; gasLimit?: number; storageLimit?: number }>(\n    { fee, gasLimit, storageLimit, ...rest }: T,\n    estimator: (param: T) => Promise<Estimate>\n  ) {\n    let calculatedFee = fee;\n    let calculatedGas = gasLimit;\n    let calculatedStorage = storageLimit;\n\n    if (fee === undefined || gasLimit === undefined || storageLimit === undefined) {\n      const estimation = await estimator({ fee, gasLimit, storageLimit, ...(rest as any) });\n\n      if (calculatedFee === undefined) {\n        calculatedFee = estimation.suggestedFeeMutez;\n      }\n\n      if (calculatedGas === undefined) {\n        calculatedGas = estimation.gasLimit;\n      }\n\n      if (calculatedStorage === undefined) {\n        calculatedStorage = estimation.storageLimit;\n      }\n    }\n\n    return {\n      fee: calculatedFee,\n      gasLimit: calculatedGas,\n      storageLimit: calculatedStorage,\n    };\n  }\n\n  protected async signAndInject(forgedBytes: ForgedBytes) {\n    const signed = await this.signer.sign(forgedBytes.opbytes, new Uint8Array([3]));\n    forgedBytes.opbytes = signed.sbytes;\n    forgedBytes.opOb.signature = signed.prefixSig;\n\n    const opResponse: OperationContentsAndResult[] = [];\n    const results = await this.rpc.preapplyOperations([forgedBytes.opOb]);\n\n    if (!Array.isArray(results)) {\n      throw new TezosPreapplyFailureError(results);\n    }\n\n    for (let i = 0; i < results.length; i++) {\n      for (let j = 0; j < results[i].contents.length; j++) {\n        opResponse.push(results[i].contents[j]);\n      }\n    }\n\n    const errors = flattenErrors(results);\n\n    if (errors.length) {\n      throw new TezosOperationError(\n        errors,\n        'Error occurred during validation simulation of operation'\n      );\n    }\n\n    return {\n      hash: await this.context.injector.inject(forgedBytes.opbytes),\n      forgedBytes,\n      opResponse,\n      context: this.context.clone(),\n    };\n  }\n}\n","import { Context } from '../context';\nimport { ContractStorageType, DefaultContractType } from '../contract/contract';\nimport { ContractMethod } from '../contract/contract-methods/contract-method-flat-param';\nimport { ContractProvider } from '../contract/interface';\nimport {\n  createOriginationOperation,\n  createRegisterGlobalConstantOperation,\n  createRevealOperation,\n  createSetDelegateOperation,\n  createTransferOperation,\n} from '../contract/prepare';\nimport { BatchOperation } from '../operations/batch-operation';\nimport { OperationEmitter } from '../operations/operation-emitter';\nimport {\n  ActivationParams,\n  DelegateParams,\n  OriginateParams,\n  RPCOperation,\n  TransferParams,\n  ParamsWithKind,\n  isOpWithFee,\n  withKind,\n  RevealParams,\n  RegisterGlobalConstantParams,\n} from '../operations/types';\nimport { OpKind } from '@taquito/rpc';\nimport { ContractMethodObject } from '../contract/contract-methods/contract-method-object-param';\nimport {\n  validateAddress,\n  validateKeyHash,\n  InvalidAddressError,\n  InvalidKeyHashError,\n  ValidationResult,\n  InvalidOperationKindError,\n} from '@taquito/utils';\nimport { EstimationProvider } from '../estimate/estimate-provider-interface';\n\nexport const BATCH_KINDS = [\n  OpKind.ACTIVATION,\n  OpKind.ORIGINATION,\n  OpKind.TRANSACTION,\n  OpKind.DELEGATION,\n];\nexport type BatchKinds =\n  | OpKind.ACTIVATION\n  | OpKind.ORIGINATION\n  | OpKind.TRANSACTION\n  | OpKind.DELEGATION;\n\nexport class OperationBatch extends OperationEmitter {\n  private operations: ParamsWithKind[] = [];\n\n  constructor(context: Context, private estimator: EstimationProvider) {\n    super(context);\n  }\n\n  /**\n   *\n   * @description Add a transaction operation to the batch\n   *\n   * @param params Transfer operation parameter\n   */\n  withTransfer(params: TransferParams) {\n    if (validateAddress(params.to) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(params.to);\n    }\n    this.operations.push({ kind: OpKind.TRANSACTION, ...params });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add a transaction operation to the batch\n   *\n   * @param params Transfer operation parameter\n   */\n  withContractCall(\n    params: ContractMethod<ContractProvider> | ContractMethodObject<ContractProvider>\n  ) {\n    return this.withTransfer(params.toTransferParams());\n  }\n\n  /**\n   *\n   * @description Add a delegation operation to the batch\n   *\n   * @param params Delegation operation parameter\n   */\n  withDelegation(params: DelegateParams) {\n    if (params.source && validateAddress(params.source) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(params.source);\n    }\n    if (params.delegate && validateAddress(params.delegate) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(params.delegate);\n    }\n    this.operations.push({ kind: OpKind.DELEGATION, ...params });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add an activation operation to the batch\n   *\n   * @param params Activation operation parameter\n   */\n  withActivation({ pkh, secret }: ActivationParams) {\n    if (validateKeyHash(pkh) !== ValidationResult.VALID) {\n      throw new InvalidKeyHashError(pkh);\n    }\n    this.operations.push({ kind: OpKind.ACTIVATION, pkh, secret });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add an origination operation to the batch\n   *\n   * @param params Origination operation parameter\n   */\n  withOrigination<TContract extends DefaultContractType = DefaultContractType>(\n    params: OriginateParams<ContractStorageType<TContract>>\n  ) {\n    this.operations.push({ kind: OpKind.ORIGINATION, ...params });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add an operation to register a global constant to the batch\n   *\n   * @param params RegisterGlobalConstant operation parameter\n   */\n  withRegisterGlobalConstant(params: RegisterGlobalConstantParams) {\n    this.operations.push({ kind: OpKind.REGISTER_GLOBAL_CONSTANT, ...params });\n    return this;\n  }\n\n  private async getRPCOp(param: ParamsWithKind) {\n    switch (param.kind) {\n      case OpKind.TRANSACTION:\n        return createTransferOperation({\n          ...param,\n        });\n      case OpKind.ORIGINATION:\n        return createOriginationOperation(\n          await this.context.parser.prepareCodeOrigination({\n            ...param,\n          })\n        );\n      case OpKind.DELEGATION:\n        return createSetDelegateOperation({\n          ...param,\n        });\n      case OpKind.ACTIVATION:\n        return {\n          ...param,\n        };\n      case OpKind.REGISTER_GLOBAL_CONSTANT:\n        return createRegisterGlobalConstantOperation({\n          ...param,\n        });\n      default:\n        throw new InvalidOperationKindError((param as any).kind);\n    }\n  }\n\n  /**\n   *\n   * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\n   *\n   * @param params Operations parameter\n   */\n  with(params: ParamsWithKind[]) {\n    for (const param of params) {\n      switch (param.kind) {\n        case OpKind.TRANSACTION:\n          this.withTransfer(param);\n          break;\n        case OpKind.ORIGINATION:\n          this.withOrigination(param);\n          break;\n        case OpKind.DELEGATION:\n          this.withDelegation(param);\n          break;\n        case OpKind.ACTIVATION:\n          this.withActivation(param);\n          break;\n        case OpKind.REGISTER_GLOBAL_CONSTANT:\n          this.withRegisterGlobalConstant(param);\n          break;\n        default:\n          throw new InvalidOperationKindError((param as any).kind);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   *\n   * @description Forge and Inject the operation batch\n   *\n   * @param params Optionally specify the source of the operation\n   */\n  async send(params?: { source?: string }) {\n    const publicKeyHash = await this.signer.publicKeyHash();\n    const publicKey = await this.signer.publicKey();\n    const estimates = await this.estimator.batch(this.operations);\n\n    const revealNeeded = await this.isRevealOpNeeded(this.operations, publicKeyHash);\n    let i = revealNeeded ? 1 : 0;\n\n    const ops: RPCOperation[] = [];\n    for (const op of this.operations) {\n      if (isOpWithFee(op)) {\n        const estimated = await this.estimate(op, async () => estimates[i]);\n        ops.push(await this.getRPCOp({ ...op, ...estimated }));\n      } else {\n        ops.push({ ...op });\n      }\n      i++;\n    }\n    if (revealNeeded) {\n      const reveal: withKind<RevealParams, OpKind.REVEAL> = { kind: OpKind.REVEAL };\n      const estimatedReveal = await this.estimate(reveal, async () => estimates[0]);\n      ops.unshift(await createRevealOperation({ ...estimatedReveal }, publicKeyHash, publicKey));\n    }\n\n    const source = (params && params.source) || publicKeyHash;\n    const prepared = await this.prepareOperation({\n      operation: ops,\n      source,\n    });\n    const opBytes = await this.forge(prepared);\n    const { hash, context, forgedBytes, opResponse } = await this.signAndInject(opBytes);\n    return new BatchOperation(hash, ops, source, forgedBytes, opResponse, context);\n  }\n}\n\nexport class RPCBatchProvider {\n  constructor(private context: Context, private estimator: EstimationProvider) {}\n\n  /***\n   *\n   * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\n   *\n   * @param params List of operation to batch together\n   */\n  batch(params?: ParamsWithKind[]) {\n    const batch = new OperationBatch(this.context, this.estimator);\n\n    if (Array.isArray(params)) {\n      batch.with(params);\n    }\n\n    return batch;\n  }\n}\n","import { OperationContentsAndResult } from '@taquito/rpc';\nimport BigNumber from 'bignumber.js';\nimport { flattenOperationResult } from '../operations/operation-errors';\n\nexport interface Receipt {\n  totalFee: BigNumber;\n  totalGas: BigNumber;\n  totalStorage: BigNumber;\n  totalAllocationBurn: BigNumber;\n  totalOriginationBurn: BigNumber;\n  totalPaidStorageDiff: BigNumber;\n  totalStorageBurn: BigNumber;\n}\n\nexport const receiptFromOperation = (\n  op: OperationContentsAndResult[],\n  { ALLOCATION_BURN, ORIGINATION_BURN } = {\n    ALLOCATION_BURN: 257,\n    ORIGINATION_BURN: 257,\n  }\n): Receipt => {\n  const operationResults = flattenOperationResult({ contents: op });\n  let totalGas = new BigNumber(0);\n  let totalStorage = new BigNumber(0);\n  let totalFee = new BigNumber(0);\n  let totalOriginationBurn = new BigNumber(0);\n  let totalAllocationBurn = new BigNumber(0);\n  let totalPaidStorageDiff = new BigNumber(0);\n  operationResults.forEach(result => {\n    totalFee = totalFee.plus(result.fee || 0);\n    totalOriginationBurn = totalOriginationBurn.plus(\n      Array.isArray(result.originated_contracts)\n        ? result.originated_contracts.length * ORIGINATION_BURN\n        : 0\n    );\n    totalAllocationBurn = totalAllocationBurn.plus(\n      'allocated_destination_contract' in result ? ALLOCATION_BURN : 0\n    );\n    totalGas = totalGas.plus(result.consumed_gas || 0);\n    totalPaidStorageDiff = totalPaidStorageDiff.plus(\n      'paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0\n    );\n  });\n\n  totalStorage = totalStorage\n    .plus(totalAllocationBurn)\n    .plus(totalOriginationBurn)\n    .plus(totalPaidStorageDiff);\n\n  return {\n    totalFee,\n    totalGas,\n    totalStorage,\n    totalAllocationBurn,\n    totalOriginationBurn,\n    totalPaidStorageDiff,\n    totalStorageBurn: new BigNumber(totalStorage.multipliedBy(1000)),\n  };\n};\n","import { BlockResponse, OperationContentsAndResult, OperationResultStatusEnum } from '@taquito/rpc';\nimport { combineLatest, from, Observable, of, ReplaySubject } from 'rxjs';\nimport {\n  catchError,\n  distinctUntilChanged,\n  filter,\n  first,\n  map,\n  shareReplay,\n  takeWhile,\n  tap,\n} from 'rxjs/operators';\nimport { Context } from '../context';\nimport { Receipt, receiptFromOperation } from './receipt';\nimport { validateOperation, ValidationResult, InvalidOperationHashError } from '@taquito/utils';\nimport { BlockIdentifier } from '../read-provider/interface';\nimport { InvalidConfirmationCountError, ConfirmationUndefinedError } from '../error';\n\nexport type OperationStatus = 'pending' | 'unknown' | OperationResultStatusEnum;\n\n/**\n *  @category Error\n *  @description Error that indicates a missed block when polling to retrieve new head block. This may happen when the polling interval is greater than the time between blocks.\n */\nexport class MissedBlockDuringConfirmationError extends Error {\n  name = 'MissedBlockDuringConfirmationError';\n\n  constructor() {\n    super(\n      'Taquito missed a block while waiting for operation confirmation and was not able to find the operation'\n    );\n  }\n}\n\nconst MAX_BRANCH_ANCESTORS = 60;\n\n/**\n * @description WalletOperation allows to monitor operation inclusion on chains and surface information related to the operation\n */\nexport class WalletOperation {\n  protected _operationResult = new ReplaySubject<OperationContentsAndResult[]>(1);\n  protected _includedInBlock = new ReplaySubject<BlockResponse>(1);\n  protected _included = false;\n\n  private lastHead: BlockResponse | undefined;\n  protected newHead$: Observable<BlockResponse> = this._newHead$.pipe(\n    tap((newHead) => {\n      if (\n        !this._included &&\n        this.lastHead &&\n        newHead.header.level - this.lastHead.header.level > 1\n      ) {\n        throw new MissedBlockDuringConfirmationError();\n      }\n\n      this.lastHead = newHead;\n    }),\n    shareReplay({ bufferSize: 1, refCount: true })\n  );\n\n  // Observable that emit once operation is seen in a block\n  private confirmed$ = this.newHead$.pipe(\n    map((head) => {\n      for (const opGroup of head.operations) {\n        for (const op of opGroup) {\n          if (op.hash === this.opHash) {\n            this._included = true;\n            this._includedInBlock.next(head);\n            this._operationResult.next(op.contents as OperationContentsAndResult[]);\n\n            // Return the block where the operation was found\n            return head;\n          }\n        }\n      }\n    }),\n    filter<BlockResponse | undefined, BlockResponse>((x): x is BlockResponse => {\n      return typeof x !== 'undefined';\n    }),\n    first(),\n    shareReplay({ bufferSize: 1, refCount: true })\n  );\n\n  async operationResults() {\n    return this._operationResult.pipe(first()).toPromise();\n  }\n\n  /**\n   * @description Receipt expose the total amount of tezos token burn and spent on fees\n   * The promise returned by receipt will resolve only once the transaction is included\n   */\n  async receipt(): Promise<Receipt> {\n    return receiptFromOperation(await this.operationResults());\n  }\n\n  /**\n   *\n   * @param opHash Operation hash\n   * @param raw Raw operation that was injected\n   * @param context Taquito context allowing access to rpc and signer\n   */\n  constructor(\n    public readonly opHash: string,\n    protected readonly context: Context,\n    private _newHead$: Observable<BlockResponse>\n  ) {\n    if (validateOperation(this.opHash) !== ValidationResult.VALID) {\n      throw new InvalidOperationHashError(this.opHash);\n    }\n    this.confirmed$\n      .pipe(\n        first(),\n        catchError(() => of(undefined))\n      )\n      .subscribe();\n  }\n\n  async getCurrentConfirmation() {\n    if (!this._included) {\n      return 0;\n    }\n\n    return combineLatest([this._includedInBlock, from(this.context.readProvider.getBlock('head'))])\n      .pipe(\n        map(([foundAtBlock, head]) => {\n          return head.header.level - foundAtBlock.header.level + 1;\n        }),\n        first()\n      )\n      .toPromise();\n  }\n\n  async isInCurrentBranch(tipBlockIdentifier: BlockIdentifier = 'head') {\n    // By default it is assumed that the operation is in the current branch\n    if (!this._included) {\n      return true;\n    }\n\n    const tipBlockHeaderLevel = await this.context.readProvider.getBlockLevel(tipBlockIdentifier);\n    const inclusionBlock = await this._includedInBlock.pipe(first()).toPromise();\n\n    const levelDiff = tipBlockHeaderLevel - inclusionBlock.header.level;\n\n    // Block produced before the operation is included are assumed to be part of the current branch\n    if (levelDiff <= 0) {\n      return true;\n    }\n\n    const tipBlockLevel = Math.min(\n      inclusionBlock.header.level + levelDiff,\n      inclusionBlock.header.level + MAX_BRANCH_ANCESTORS\n    );\n\n    const blocks = new Set(await this.context.readProvider.getLiveBlocks(tipBlockLevel));\n    return blocks.has(inclusionBlock.hash);\n  }\n\n  confirmationObservable(confirmations?: number) {\n    if (typeof confirmations !== 'undefined' && confirmations < 1) {\n      throw new InvalidConfirmationCountError('Confirmation count must be at least 1');\n    }\n\n    const { defaultConfirmationCount } = this.context.config;\n\n    const conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;\n\n    if (conf === undefined) {\n      throw new ConfirmationUndefinedError('Default confirmation count can not be undefined!');\n    }\n\n    return combineLatest([this._includedInBlock, this.newHead$]).pipe(\n      distinctUntilChanged(([, previousHead], [, newHead]) => {\n        return previousHead.hash === newHead.hash;\n      }),\n      map(([foundAtBlock, head]) => {\n        return {\n          block: head,\n          expectedConfirmation: conf,\n          currentConfirmation: head.header.level - foundAtBlock.header.level + 1,\n          completed: head.header.level - foundAtBlock.header.level >= conf - 1,\n          isInCurrentBranch: () => this.isInCurrentBranch(head.hash as BlockIdentifier),\n        };\n      }),\n      takeWhile(({ completed }) => !completed, true)\n    );\n  }\n\n  /**\n   *\n   * @param confirmations [0] Number of confirmation to wait for\n   */\n  confirmation(confirmations?: number) {\n    return this.confirmationObservable(confirmations).toPromise();\n  }\n}\n","import { BlockResponse, OperationContentsAndResultReveal, OpKind } from '@taquito/rpc';\nimport { Observable } from 'rxjs';\nimport { BATCH_KINDS } from '../batch/rpc-batch-provider';\nimport { Context } from '../context';\nimport { hasMetadataWithResult } from '../operations/types';\nimport { WalletOperation, OperationStatus } from './operation';\n\nexport class BatchWalletOperation extends WalletOperation {\n  constructor(\n    public readonly opHash: string,\n    protected readonly context: Context,\n    newHead$: Observable<BlockResponse>\n  ) {\n    super(opHash, context, newHead$);\n  }\n\n  public async revealOperation() {\n    const operationResult = await this.operationResults();\n    return operationResult.find(x => x.kind === OpKind.REVEAL) as\n      | OperationContentsAndResultReveal\n      | undefined;\n  }\n\n  async status(): Promise<OperationStatus> {\n    if (!this._included) {\n      return 'pending';\n    }\n\n    const op = await this.operationResults();\n\n    return (\n      op\n        .filter((result) => BATCH_KINDS.indexOf(result.kind) !== -1)\n        .map((result) => {\n          if (hasMetadataWithResult(result)) {\n            return result.metadata.operation_result.status;\n          } else {\n            return 'unknown';\n          }\n        })[0] || 'unknown'\n    );\n  }\n}\n","import {\n  BlockResponse,\n  OperationContentsAndResultDelegation,\n  OperationContentsAndResultReveal,\n  OpKind,\n} from '@taquito/rpc';\nimport { Observable } from 'rxjs';\nimport { Context } from '../context';\nimport { WalletOperation, OperationStatus } from './operation';\n\nexport class DelegationWalletOperation extends WalletOperation {\n  constructor(\n    public readonly opHash: string,\n    protected readonly context: Context,\n    newHead$: Observable<BlockResponse>\n  ) {\n    super(opHash, context, newHead$);\n  }\n\n  public async revealOperation() {\n    const operationResult = await this.operationResults();\n    return operationResult.find((x) => x.kind === OpKind.REVEAL) as\n      | OperationContentsAndResultReveal\n      | undefined;\n  }\n\n  public async delegationOperation() {\n    const operationResult = await this.operationResults();\n    return operationResult.find((x) => x.kind === OpKind.DELEGATION) as\n      | OperationContentsAndResultDelegation\n      | undefined;\n  }\n\n  public async status(): Promise<OperationStatus> {\n    if (!this._included) {\n      return 'pending';\n    }\n\n    const op = await this.delegationOperation();\n    if (!op) {\n      return 'unknown';\n    }\n\n    return op.metadata.operation_result.status;\n  }\n}\n","import {\n  BlockResponse,\n  OperationContentsAndResultOrigination,\n  OperationContentsAndResultReveal,\n  OpKind,\n} from '@taquito/rpc';\nimport { Observable } from 'rxjs';\nimport { Context } from '../context';\nimport { DefaultWalletType } from '../contract/contract';\nimport { findWithKind } from '../operations/types';\nimport { WalletOperation, OperationStatus } from './operation';\n\nexport class OriginationWalletOperation<TWallet extends DefaultWalletType = DefaultWalletType> extends WalletOperation {\n  constructor(\n    public readonly opHash: string,\n    protected readonly context: Context,\n    newHead$: Observable<BlockResponse>\n  ) {\n    super(opHash, context, newHead$);\n  }\n\n  public async originationOperation() {\n    const operationResult = await this.operationResults();\n    return findWithKind(operationResult, OpKind.ORIGINATION) as\n      | OperationContentsAndResultOrigination\n      | undefined;\n  }\n\n  public async revealOperation() {\n    const operationResult = await this.operationResults();\n    return findWithKind(operationResult, OpKind.REVEAL) as\n      | OperationContentsAndResultReveal\n      | undefined;\n  }\n\n  public async status(): Promise<OperationStatus> {\n    if (!this._included) {\n      return 'pending';\n    }\n\n    const op = await this.originationOperation();\n    if (!op) {\n      return 'unknown';\n    }\n\n    return op.metadata.operation_result.status;\n  }\n\n  public async contract() {\n    const op = await this.originationOperation();\n    const address = (op?.metadata.operation_result.originated_contracts || [])[0];\n    return this.context.wallet.at<TWallet>(address);\n  }\n}\n","import { WalletOperation, OperationStatus } from './operation';\nimport { Context } from '../context';\nimport { Observable } from 'rxjs';\nimport {\n  BlockResponse,\n  OpKind,\n  OperationContentsAndResultReveal,\n  OperationContentsAndResultTransaction,\n} from '@taquito/rpc';\n\nexport class TransactionWalletOperation extends WalletOperation {\n  constructor(\n    public readonly opHash: string,\n    protected readonly context: Context,\n    newHead$: Observable<BlockResponse>\n  ) {\n    super(opHash, context, newHead$);\n  }\n\n  public async revealOperation() {\n    const operationResult = await this.operationResults();\n    return operationResult.find(x => x.kind === OpKind.REVEAL) as\n      | OperationContentsAndResultReveal\n      | undefined;\n  }\n\n  public async transactionOperation() {\n    const operationResult = await this.operationResults();\n    return operationResult.find(x => x.kind === OpKind.TRANSACTION) as\n      | OperationContentsAndResultTransaction\n      | undefined;\n  }\n\n  public async status(): Promise<OperationStatus> {\n    if (!this._included) {\n      return 'pending';\n    }\n\n    const op = await this.transactionOperation();\n    if (!op) {\n      return 'unknown';\n    }\n\n    return op.metadata.operation_result.status;\n  }\n}\n","import { BlockResponse } from '@taquito/rpc';\nimport { concat, defer, from, Observable, of, range, SchedulerLike, throwError } from 'rxjs';\nimport { concatMap, shareReplay, startWith, switchMap, timeoutWith } from 'rxjs/operators';\nimport { Context } from '../context';\nimport { BlockIdentifier } from '../read-provider/interface';\nimport { createObservableFromSubscription } from '../subscribe/create-observable-from-subscription';\nimport { BatchWalletOperation } from './batch-operation';\nimport { DelegationWalletOperation } from './delegation-operation';\nimport { WalletOperation } from './operation';\nimport { OriginationWalletOperation } from './origination-operation';\nimport { TransactionWalletOperation } from './transaction-operation';\n\nexport const createNewPollingBasedHeadObservable = (\n  sharedHeadOb: Observable<BlockResponse>,\n  context: Context,\n  scheduler?: SchedulerLike\n): Observable<BlockResponse> => {\n  return sharedHeadOb.pipe(\n    timeoutWith(\n      context.config.confirmationPollingTimeoutSecond * 1000,\n      throwError(new Error('Confirmation polling timed out')),\n      scheduler\n    ),\n    shareReplay({\n      refCount: true,\n      scheduler,\n    })\n  );\n};\n\nexport interface OperationFactoryConfig {\n  blockIdentifier?: string;\n}\n\nexport class OperationFactory {\n  constructor(private context: Context) {}\n\n  // Cache the last block for one second across all operations\n  private sharedHeadObs = defer(() => {\n    return createObservableFromSubscription(this.context.stream.subscribeBlock('head'));\n  });\n\n  private async createNewHeadObservable() {\n    return createNewPollingBasedHeadObservable(this.sharedHeadObs, this.context);\n  }\n\n  private createPastBlockWalker(startBlock: string, count = 1) {\n    return from(this.context.readProvider.getBlock(startBlock as BlockIdentifier)).pipe(\n      switchMap((block) => {\n        if (count === 1) {\n          return of(block);\n        }\n\n        return range(block.header.level, count - 1).pipe(\n          startWith(block),\n          concatMap(async (level) => {\n            return this.context.readProvider.getBlock(\n              typeof level === 'number' ? level : level.header.level\n            );\n          })\n        );\n      })\n    );\n  }\n\n  private async createHeadObservableFromConfig({ blockIdentifier }: OperationFactoryConfig) {\n    const observableSequence: Observable<BlockResponse>[] = [];\n\n    if (blockIdentifier) {\n      observableSequence.push(this.createPastBlockWalker(blockIdentifier));\n    }\n\n    observableSequence.push(await this.createNewHeadObservable());\n\n    return concat(...observableSequence);\n  }\n\n  async createOperation(\n    hash: string,\n    config: OperationFactoryConfig = {}\n  ): Promise<WalletOperation> {\n    return new WalletOperation(\n      hash,\n      this.context.clone(),\n      await this.createHeadObservableFromConfig(config)\n    );\n  }\n\n  async createBatchOperation(\n    hash: string,\n    config: OperationFactoryConfig = {}\n  ): Promise<BatchWalletOperation> {\n    return new BatchWalletOperation(\n      hash,\n      this.context.clone(),\n      await this.createHeadObservableFromConfig(config)\n    );\n  }\n\n  async createTransactionOperation(\n    hash: string,\n    config: OperationFactoryConfig = {}\n  ): Promise<TransactionWalletOperation> {\n    return new TransactionWalletOperation(\n      hash,\n      this.context.clone(),\n      await this.createHeadObservableFromConfig(config)\n    );\n  }\n\n  async createDelegationOperation(\n    hash: string,\n    config: OperationFactoryConfig = {}\n  ): Promise<DelegationWalletOperation> {\n    return new DelegationWalletOperation(\n      hash,\n      this.context.clone(),\n      await this.createHeadObservableFromConfig(config)\n    );\n  }\n\n  async createOriginationOperation(\n    hash: string,\n    config: OperationFactoryConfig = {}\n  ): Promise<OriginationWalletOperation> {\n    return new OriginationWalletOperation(\n      hash,\n      this.context.clone(),\n      await this.createHeadObservableFromConfig(config)\n    );\n  }\n}\n","import BigNumber from 'bignumber.js';\nimport { Context } from '../context';\nimport { OperationEmitter } from '../operations/operation-emitter';\nimport { Operation } from '../operations/operations';\nimport { RPCActivateOperation } from '../operations/types';\nimport { TzProvider } from './interface';\nimport { OpKind } from '@taquito/rpc';\nimport {\n  validateAddress,\n  ValidationResult,\n  validateKeyHash,\n  InvalidAddressError,\n  InvalidKeyHashError,\n} from '@taquito/utils';\n\nexport class RpcTzProvider extends OperationEmitter implements TzProvider {\n  constructor(context: Context) {\n    super(context);\n  }\n\n  async getBalance(address: string): Promise<BigNumber> {\n    if (validateAddress(address) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(address);\n    }\n    return this.context.readProvider.getBalance(address, 'head');\n  }\n\n  async getDelegate(address: string): Promise<string | null> {\n    if (validateAddress(address) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(address);\n    }\n    return this.context.readProvider.getDelegate(address, 'head');\n  }\n\n  async activate(pkh: string, secret: string) {\n    if (validateKeyHash(pkh) !== ValidationResult.VALID) {\n      throw new InvalidKeyHashError(pkh);\n    }\n    const operation: RPCActivateOperation = {\n      kind: OpKind.ACTIVATION,\n      pkh,\n      secret,\n    };\n\n    const prepared = await this.prepareOperation({ operation: [operation], source: pkh });\n    const forgedBytes = await this.forge(prepared);\n    const bytes = `${forgedBytes.opbytes}00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`;\n    return new Operation(\n      await this.rpc.injectOperation(bytes),\n      { ...forgedBytes, opbytes: bytes },\n      [],\n      this.context.clone()\n    );\n  }\n}\n","const MINIMAL_FEE_MUTEZ = 100;\nconst MINIMAL_FEE_PER_BYTE_MUTEZ = 1;\nconst MINIMAL_FEE_PER_GAS_MUTEZ = 0.1;\n\nconst GAS_BUFFER = 100;\n\nexport interface EstimateProperties {\n  milligasLimit: number;\n  storageLimit: number;\n  opSize: number;\n  minimalFeePerStorageByteMutez: number;\n  baseFeeMutez?: number;\n}\n\n/**\n * Examples of use :\n *\n *  Estimate a transfer operation :\n * ```\n * // Assuming that provider and signer are already configured...\n *\n * const amount = 2;\n * const address = 'tz1h3rQ8wBxFd8L9B3d7Jhaawu6Z568XU3xY';\n *\n * // Estimate gasLimit, storageLimit and fees for a transfer operation\n * const est = await Tezos.estimate.transfer({ to: address, amount: amount })\n * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,\n *  est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)\n *\n * ```\n *\n * Estimate a contract origination :\n * ```\n * // generic.json is referring to a Michelson Smart Contract\n *\n * const genericMultisigJSON = require('./generic.json')\n * const est = await Tezos.estimate.originate({\n *   code: genericMultisigJSON,\n *   storage: {\n *     stored_counter: 0,\n *     threshold: 1,\n *     keys: ['edpkuLxx9PQD8fZ45eUzrK3BhfDZJHhBuK4Zi49DcEGANwd2rpX82t']\n *   }\n * })\n * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,\n *   est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)\n *\n * ```\n */\n\nexport class Estimate {\n  constructor(\n    private readonly _milligasLimit: number | string,\n    private readonly _storageLimit: number | string,\n    public readonly opSize: number | string,\n    private readonly minimalFeePerStorageByteMutez: number | string,\n    /**\n     * @description Base fee in mutez (1 mutez = 1e106 tez)\n     */\n    private readonly baseFeeMutez: number | string = MINIMAL_FEE_MUTEZ\n  ) {}\n\n  /**\n   * @description The number of Mutez that will be burned for the storage of the [operation](https://tezos.gitlab.io/user/glossary.html#operations). (Storage + Allocation fees)\n   */\n  get burnFeeMutez() {\n    return this.roundUp(Number(this.storageLimit) * Number(this.minimalFeePerStorageByteMutez));\n  }\n\n  /**\n   * @description  The limit on the amount of storage an [operation](https://tezos.gitlab.io/user/glossary.html#operations) can use.\n   */\n  get storageLimit() {\n    const limit = Math.max(Number(this._storageLimit), 0);\n    return limit > 0 ? limit : 0;\n  }\n\n  /**\n   * @description The limit on the amount of [gas](https://tezos.gitlab.io/user/glossary.html#gas) a given operation can consume.\n   */\n  get gasLimit() {\n    return this.roundUp(Number(this._milligasLimit) / 1000 + GAS_BUFFER);\n  }\n\n  private get operationFeeMutez() {\n    return (\n      (Number(this._milligasLimit) / 1000 + GAS_BUFFER) * MINIMAL_FEE_PER_GAS_MUTEZ +\n      Number(this.opSize) * MINIMAL_FEE_PER_BYTE_MUTEZ\n    );\n  }\n\n  private roundUp(nanotez: number) {\n    return Math.ceil(Number(nanotez));\n  }\n\n  /**\n   * @description Minimum fees for the [operation](https://tezos.gitlab.io/user/glossary.html#operations) according to [baker](https://tezos.gitlab.io/user/glossary.html#baker) defaults.\n   */\n  get minimalFeeMutez() {\n    return this.roundUp(MINIMAL_FEE_MUTEZ + this.operationFeeMutez);\n  }\n\n  /**\n   * @description The suggested fee for the operation which includes minimal fees and a small buffer.\n   */\n  get suggestedFeeMutez() {\n    return this.roundUp(this.operationFeeMutez + MINIMAL_FEE_MUTEZ * 2);\n  }\n\n  /**\n   * @description Fees according to your specified base fee will ensure that at least minimum fees are used.\n   */\n  get usingBaseFeeMutez() {\n    return (\n      Math.max(Number(this.baseFeeMutez), MINIMAL_FEE_MUTEZ) + this.roundUp(this.operationFeeMutez)\n    );\n  }\n\n  /**\n   * @description The sum of `minimalFeeMutez` + `burnFeeMutez`.\n   */\n  get totalCost() {\n    return this.minimalFeeMutez + this.burnFeeMutez;\n  }\n\n  /**\n   * @description Since Delphinet, consumed gas is provided in milligas for more precision.\n   * This function returns an estimation of the gas that operation will consume in milligas.\n   */\n  get consumedMilligas() {\n    return Number(this._milligasLimit);\n  }\n\n  static createEstimateInstanceFromProperties(estimateProperties: EstimateProperties[]) {\n    let milligasLimit = 0;\n    let storageLimit = 0;\n    let opSize = 0;\n    let minimalFeePerStorageByteMutez = 0;\n    let baseFeeMutez: number | undefined;\n\n    estimateProperties.forEach((estimate) => {\n      milligasLimit += estimate.milligasLimit;\n      storageLimit += estimate.storageLimit;\n      opSize += estimate.opSize;\n      minimalFeePerStorageByteMutez = Math.max(\n        estimate.minimalFeePerStorageByteMutez,\n        minimalFeePerStorageByteMutez\n      );\n      if (estimate.baseFeeMutez) {\n        baseFeeMutez = baseFeeMutez ? baseFeeMutez + estimate.baseFeeMutez : estimate.baseFeeMutez;\n      }\n    });\n    return new Estimate(\n      milligasLimit,\n      storageLimit,\n      opSize,\n      minimalFeePerStorageByteMutez,\n      baseFeeMutez\n    );\n  }\n\n  static createArrayEstimateInstancesFromProperties(estimateProperties: EstimateProperties[]) {\n    return estimateProperties.map(\n      (x) =>\n        new Estimate(\n          x.milligasLimit,\n          x.storageLimit,\n          x.opSize,\n          x.minimalFeePerStorageByteMutez,\n          x.baseFeeMutez\n        )\n    );\n  }\n}\n","/**\n *  @category Error\n *  @description Error that indicates invalid public key being passed when doing a reveal operation estimate\n */\nexport class RevealEstimateError extends Error {\n  name = 'Reveal Estimate Error';\n  constructor() {\n    super('Unable to estimate the reveal operation, the public key is unknown');\n  }\n}\n","import { PreapplyResponse, RPCRunOperationParam, OpKind, ConstantsResponse } from '@taquito/rpc';\nimport BigNumber from 'bignumber.js';\nimport { DEFAULT_FEE, DEFAULT_GAS_LIMIT, DEFAULT_STORAGE_LIMIT } from '../constants';\nimport { OperationEmitter } from '../operations/operation-emitter';\nimport {\n  flattenErrors,\n  flattenOperationResult,\n  TezosOperationError,\n} from '../operations/operation-errors';\nimport {\n  DelegateParams,\n  isOpWithFee,\n  OriginateParams,\n  ParamsWithKind,\n  PrepareOperationParams,\n  RegisterDelegateParams,\n  RPCOperation,\n  TransferParams,\n  RevealParams,\n  RegisterGlobalConstantParams,\n} from '../operations/types';\nimport { Estimate, EstimateProperties } from './estimate';\nimport { EstimationProvider } from '../estimate/estimate-provider-interface';\nimport {\n  createOriginationOperation,\n  createRegisterDelegateOperation,\n  createRevealOperation,\n  createSetDelegateOperation,\n  createTransferOperation,\n  createRegisterGlobalConstantOperation,\n} from '../contract/prepare';\nimport {\n  validateAddress,\n  InvalidAddressError,\n  ValidationResult,\n  InvalidOperationKindError,\n} from '@taquito/utils';\nimport { RevealEstimateError } from './error';\n\ninterface Limits {\n  fee?: number;\n  storageLimit?: number;\n  gasLimit?: number;\n}\n\nconst mergeLimits = (\n  userDefinedLimit: Limits,\n  defaultLimits: Required<Limits>\n): Required<Limits> => {\n  return {\n    fee: typeof userDefinedLimit.fee === 'undefined' ? defaultLimits.fee : userDefinedLimit.fee,\n    gasLimit:\n      typeof userDefinedLimit.gasLimit === 'undefined'\n        ? defaultLimits.gasLimit\n        : userDefinedLimit.gasLimit,\n    storageLimit:\n      typeof userDefinedLimit.storageLimit === 'undefined'\n        ? defaultLimits.storageLimit\n        : userDefinedLimit.storageLimit,\n  };\n};\n\n// RPC requires a signature but does not verify it\nconst SIGNATURE_STUB =\n  'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg';\n\nexport class RPCEstimateProvider extends OperationEmitter implements EstimationProvider {\n  private readonly ALLOCATION_STORAGE = 257;\n  private readonly ORIGINATION_STORAGE = 257;\n  private readonly OP_SIZE_REVEAL = 128;\n\n  private async getKeys(): Promise<{\n    publicKeyHash: string;\n    publicKey?: string;\n  }> {\n    const isSignerConfigured = this.context.isAnySignerConfigured();\n    return {\n      publicKeyHash: isSignerConfigured\n        ? await this.signer.publicKeyHash()\n        : await this.context.walletProvider.getPKH(),\n      publicKey: isSignerConfigured ? await this.signer.publicKey() : undefined,\n    };\n  }\n\n  // Maximum values defined by the protocol\n  private async getAccountLimits(\n    pkh: string,\n    constants: Pick<\n      ConstantsResponse,\n      | 'hard_gas_limit_per_operation'\n      | 'hard_gas_limit_per_block'\n      | 'hard_storage_limit_per_operation'\n      | 'cost_per_byte'\n    >,\n    numberOfOps?: number\n  ) {\n    const balance = await this.context.readProvider.getBalance(pkh, 'head');\n    const {\n      hard_gas_limit_per_operation,\n      hard_gas_limit_per_block,\n      hard_storage_limit_per_operation,\n      cost_per_byte,\n    } = constants;\n    return {\n      fee: 0,\n      gasLimit: numberOfOps\n        ? Math.floor(\n            this.ajustGasForBatchOperation(\n              hard_gas_limit_per_block,\n              hard_gas_limit_per_operation,\n              numberOfOps\n            ).toNumber()\n          )\n        : hard_gas_limit_per_operation.toNumber(),\n      storageLimit: Math.floor(\n        BigNumber.min(balance.dividedBy(cost_per_byte), hard_storage_limit_per_operation).toNumber()\n      ),\n    };\n  }\n\n  // Fix for Granada where the total gasLimit of a batch can not exceed the hard_gas_limit_per_block.\n  // If the total gasLimit of the batch is higher than the hard_gas_limit_per_block,\n  // the gasLimit is calculated by dividing the hard_gas_limit_per_block by the number of operation in the batch (numberOfOps).\n  // numberOfOps is incremented by 1 for safety in case a reveal operation is needed\n  private ajustGasForBatchOperation(\n    gasLimitBlock: BigNumber,\n    gaslimitOp: BigNumber,\n    numberOfOps: number\n  ) {\n    return BigNumber.min(gaslimitOp, gasLimitBlock.div(numberOfOps + 1));\n  }\n\n  private getEstimationPropertiesFromOperationContent(\n    content: PreapplyResponse['contents'][0],\n    size: number,\n    costPerByte: BigNumber\n  ): EstimateProperties {\n    const operationResults = flattenOperationResult({ contents: [content] });\n    let totalGas = 0;\n    let totalMilligas = 0;\n    let totalStorage = 0;\n    operationResults.forEach((result) => {\n      totalStorage +=\n        'originated_contracts' in result && typeof result.originated_contracts !== 'undefined'\n          ? result.originated_contracts.length * this.ORIGINATION_STORAGE\n          : 0;\n      totalStorage += 'allocated_destination_contract' in result ? this.ALLOCATION_STORAGE : 0;\n      totalGas += Number(result.consumed_gas) || 0;\n      totalMilligas += Number(result.consumed_milligas) || 0;\n      totalStorage +=\n        'paid_storage_size_diff' in result ? Number(result.paid_storage_size_diff) || 0 : 0;\n      totalStorage +=\n        'storage_size' in result && 'global_address' in result\n          ? Number(result.storage_size) || 0\n          : 0;\n    });\n\n    if (totalGas !== 0 && totalMilligas === 0) {\n      // This will convert gas to milligas for Carthagenet where result does not contain consumed gas in milligas.\n      totalMilligas = totalGas * 1000;\n    }\n\n    if (isOpWithFee(content)) {\n      return {\n        milligasLimit: totalMilligas || 0,\n        storageLimit: Number(totalStorage || 0),\n        opSize: size,\n        minimalFeePerStorageByteMutez: costPerByte.toNumber(),\n      };\n    } else {\n      return {\n        milligasLimit: 0,\n        storageLimit: 0,\n        opSize: size,\n        minimalFeePerStorageByteMutez: costPerByte.toNumber(),\n        baseFeeMutez: 0,\n      };\n    }\n  }\n\n  private async prepareEstimate(\n    params: PrepareOperationParams,\n    constants: Pick<ConstantsResponse, 'cost_per_byte'>,\n    pkh: string\n  ) {\n    const prepared = await this.prepareOperation(params, pkh);\n    const {\n      opbytes,\n      opOb: { branch, contents },\n    } = await this.forge(prepared);\n    const operation: RPCRunOperationParam = {\n      operation: { branch, contents, signature: SIGNATURE_STUB },\n      chain_id: await this.context.readProvider.getChainId(),\n    };\n\n    const { opResponse } = await this.simulate(operation);\n    const { cost_per_byte } = constants;\n    const errors = [...flattenErrors(opResponse, 'backtracked'), ...flattenErrors(opResponse)];\n\n    // Fail early in case of errors\n    if (errors.length) {\n      throw new TezosOperationError(errors, 'Error occurred during estimation');\n    }\n\n    let numberOfOps = 1;\n    if (Array.isArray(params.operation) && params.operation.length > 1) {\n      numberOfOps =\n        opResponse.contents[0].kind === 'reveal'\n          ? params.operation.length - 1\n          : params.operation.length;\n    }\n\n    return opResponse.contents.map((x) => {\n      return this.getEstimationPropertiesFromOperationContent(\n        x,\n        // TODO: Calculate a specific opSize for each operation.\n        x.kind === 'reveal' ? this.OP_SIZE_REVEAL / 2 : opbytes.length / 2 / numberOfOps,\n        cost_per_byte\n      );\n    });\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for an origination operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param OriginationOperation Originate operation parameter\n   */\n  async originate({ fee, storageLimit, gasLimit, ...rest }: OriginateParams) {\n    const { publicKeyHash } = await this.getKeys();\n    const protocolConstants = await this.context.readProvider.getProtocolConstants('head');\n    const DEFAULT_PARAMS = await this.getAccountLimits(publicKeyHash, protocolConstants);\n    const op = await createOriginationOperation(\n      await this.context.parser.prepareCodeOrigination({\n        ...rest,\n        ...mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS),\n      })\n    );\n    const isRevealNeeded = await this.isRevealOpNeeded([op], publicKeyHash);\n    const ops = isRevealNeeded ? await this.addRevealOp([op], publicKeyHash) : op;\n    const estimateProperties = await this.prepareEstimate(\n      { operation: ops, source: publicKeyHash },\n      protocolConstants,\n      publicKeyHash\n    );\n    if (isRevealNeeded) {\n      estimateProperties.shift();\n    }\n    return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n  }\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for an transfer operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param TransferOperation Originate operation parameter\n   */\n  async transfer({ fee, storageLimit, gasLimit, ...rest }: TransferParams) {\n    if (validateAddress(rest.to) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(rest.to);\n    }\n    if (rest.source && validateAddress(rest.source) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(rest.source);\n    }\n    const pkh = (await this.getKeys()).publicKeyHash;\n    const protocolConstants = await this.context.readProvider.getProtocolConstants('head');\n    const DEFAULT_PARAMS = await this.getAccountLimits(pkh, protocolConstants);\n    const op = await createTransferOperation({\n      ...rest,\n      ...mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS),\n    });\n    const isRevealNeeded = await this.isRevealOpNeeded([op], pkh);\n    const ops = isRevealNeeded ? await this.addRevealOp([op], pkh) : op;\n    const estimateProperties = await this.prepareEstimate(\n      { operation: ops, source: pkh },\n      protocolConstants,\n      pkh\n    );\n    if (isRevealNeeded) {\n      estimateProperties.shift();\n    }\n    return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param Estimate\n   */\n  async setDelegate({ fee, gasLimit, storageLimit, ...rest }: DelegateParams) {\n    if (rest.source && validateAddress(rest.source) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(rest.source);\n    }\n    if (rest.delegate && validateAddress(rest.delegate) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(rest.delegate);\n    }\n\n    const pkh = (await this.getKeys()).publicKeyHash;\n    const sourceOrDefault = rest.source || pkh;\n    const protocolConstants = await this.context.readProvider.getProtocolConstants('head');\n    const DEFAULT_PARAMS = await this.getAccountLimits(sourceOrDefault, protocolConstants);\n    const op = await createSetDelegateOperation({\n      ...rest,\n      ...mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS),\n    });\n    const isRevealNeeded = await this.isRevealOpNeeded([op], pkh);\n    const ops = isRevealNeeded ? await this.addRevealOp([op], pkh) : op;\n    const estimateProperties = await this.prepareEstimate(\n      { operation: ops, source: pkh },\n      protocolConstants,\n      pkh\n    );\n    if (isRevealNeeded) {\n      estimateProperties.shift();\n    }\n    return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for a each operation in the batch\n   *\n   * @returns An array of Estimate objects. If a reveal operation is needed, the first element of the array is the Estimate for the reveal operation.\n   */\n  async batch(params: ParamsWithKind[]) {\n    const { publicKeyHash } = await this.getKeys();\n    let operations: RPCOperation[] = [];\n    const protocolConstants = await this.context.readProvider.getProtocolConstants('head');\n    const DEFAULT_PARAMS = await this.getAccountLimits(\n      publicKeyHash,\n      protocolConstants,\n      params.length\n    );\n    for (const param of params) {\n      switch (param.kind) {\n        case OpKind.TRANSACTION:\n          operations.push(\n            await createTransferOperation({\n              ...param,\n              ...mergeLimits(param, DEFAULT_PARAMS),\n            })\n          );\n          break;\n        case OpKind.ORIGINATION:\n          operations.push(\n            await createOriginationOperation(\n              await this.context.parser.prepareCodeOrigination({\n                ...param,\n                ...mergeLimits(param, DEFAULT_PARAMS),\n              })\n            )\n          );\n          break;\n        case OpKind.DELEGATION:\n          operations.push(\n            await createSetDelegateOperation({\n              ...param,\n              ...mergeLimits(param, DEFAULT_PARAMS),\n            })\n          );\n          break;\n        case OpKind.ACTIVATION:\n          operations.push({\n            ...param,\n            ...DEFAULT_PARAMS,\n          });\n          break;\n        case OpKind.REGISTER_GLOBAL_CONSTANT:\n          operations.push(\n            await createRegisterGlobalConstantOperation({\n              ...param,\n              ...mergeLimits(param, DEFAULT_PARAMS),\n            })\n          );\n          break;\n        default:\n          throw new InvalidOperationKindError((params as any).kind);\n      }\n    }\n    const isRevealNeeded = await this.isRevealOpNeeded(operations, publicKeyHash);\n    operations = isRevealNeeded ? await this.addRevealOp(operations, publicKeyHash) : operations;\n    const estimateProperties = await this.prepareEstimate(\n      { operation: operations, source: publicKeyHash },\n      protocolConstants,\n      publicKeyHash\n    );\n\n    return Estimate.createArrayEstimateInstancesFromProperties(estimateProperties);\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param Estimate\n   */\n  async registerDelegate(params: RegisterDelegateParams) {\n    const pkh = (await this.getKeys()).publicKeyHash;\n    const protocolConstants = await this.context.readProvider.getProtocolConstants('head');\n    const DEFAULT_PARAMS = await this.getAccountLimits(pkh, protocolConstants);\n    const op = await createRegisterDelegateOperation({ ...params, ...DEFAULT_PARAMS }, pkh);\n    const isRevealNeeded = await this.isRevealOpNeeded([op], pkh);\n    const ops = isRevealNeeded ? await this.addRevealOp([op], pkh) : op;\n    const estimateProperties = await this.prepareEstimate(\n      { operation: ops, source: pkh },\n      protocolConstants,\n      pkh\n    );\n    if (isRevealNeeded) {\n      estimateProperties.shift();\n    }\n    return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees to reveal the current account\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation or undefined if the account is already revealed\n   *\n   * @param Estimate\n   */\n  async reveal(params?: RevealParams) {\n    const { publicKeyHash, publicKey } = await this.getKeys();\n    if (!publicKey) {\n      throw new RevealEstimateError();\n    }\n    if (await this.isAccountRevealRequired(publicKeyHash)) {\n      const protocolConstants = await this.context.readProvider.getProtocolConstants('head');\n      const DEFAULT_PARAMS = await this.getAccountLimits(publicKeyHash, protocolConstants);\n      const op = await createRevealOperation(\n        {\n          ...params,\n          ...DEFAULT_PARAMS,\n        },\n        publicKeyHash,\n        publicKey\n      );\n      const estimateProperties = await this.prepareEstimate(\n        { operation: op, source: publicKeyHash },\n        protocolConstants,\n        publicKeyHash\n      );\n      return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n    }\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for an registerGlobalConstant operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param params registerGlobalConstant operation parameter\n   */\n  async registerGlobalConstant({\n    fee,\n    storageLimit,\n    gasLimit,\n    ...rest\n  }: RegisterGlobalConstantParams) {\n    const pkh = (await this.getKeys()).publicKeyHash;\n    const protocolConstants = await this.context.readProvider.getProtocolConstants('head');\n    const DEFAULT_PARAMS = await this.getAccountLimits(pkh, protocolConstants);\n    const op = await createRegisterGlobalConstantOperation({\n      ...rest,\n      ...mergeLimits({ fee, storageLimit, gasLimit }, DEFAULT_PARAMS),\n    });\n    const isRevealNeeded = await this.isRevealOpNeeded([op], pkh);\n    const ops = isRevealNeeded ? await this.addRevealOp([op], pkh) : op;\n    const estimateProperties = await this.prepareEstimate(\n      { operation: ops, source: pkh },\n      protocolConstants,\n      pkh\n    );\n    if (isRevealNeeded) {\n      estimateProperties.shift();\n    }\n    return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n  }\n\n  private async addRevealOp(op: RPCOperation[], pkh: string) {\n    const { publicKey } = await this.getKeys();\n    if (!publicKey) {\n      throw new RevealEstimateError();\n    }\n    op.unshift(\n      await createRevealOperation(\n        {\n          ...{\n            fee: DEFAULT_FEE.REVEAL,\n            gasLimit: DEFAULT_GAS_LIMIT.REVEAL,\n            storageLimit: DEFAULT_STORAGE_LIMIT.REVEAL,\n          },\n        },\n        pkh,\n        await this.signer.publicKey()\n      )\n    );\n    return op;\n  }\n}\n","import { OperationContentsAndResult, OperationContentsAndResultDelegation } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { Operation } from './operations';\nimport {\n  FeeConsumingOperation,\n  ForgedBytes,\n  GasConsumingOperation,\n  RPCDelegateOperation,\n  StorageConsumingOperation,\n} from './types';\n\n/**\n * @description Delegation operation provide utility function to fetch newly issued delegation\n *\n * @warn Currently support only one delegation per operation\n */\nexport class DelegateOperation extends Operation\n  implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n  constructor(\n    hash: string,\n    private readonly params: RPCDelegateOperation,\n    public readonly source: string,\n    raw: ForgedBytes,\n    results: OperationContentsAndResult[],\n    context: Context\n  ) {\n    super(hash, raw, results, context);\n  }\n\n  get operationResults() {\n    const delegationOp =\n      Array.isArray(this.results) &&\n      (this.results.find(op => op.kind === 'delegation') as OperationContentsAndResultDelegation);\n    const result = delegationOp && delegationOp.metadata && delegationOp.metadata.operation_result;\n    return result ? result : undefined;\n  }\n\n  get status() {\n    const operationResults = this.operationResults;\n    if (operationResults) {\n      return operationResults.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  get delegate(): string {\n    return this.delegate;\n  }\n\n  get isRegisterOperation(): boolean {\n    return this.delegate === this.source;\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  get consumedGas() {\n    const consumedGas = this.operationResults && this.operationResults.consumed_gas;\n    return consumedGas ? consumedGas : undefined;\n  }\n\n  get errors() {\n    return this.operationResults && this.operationResults.errors;\n  }\n}\n","import { OperationContentsAndResult, OperationContentsAndResultOrigination } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { DefaultContractType } from '../contract/contract';\nimport { RpcContractProvider } from '../contract/rpc-contract-provider';\nimport { OriginationOperationError } from './operation-errors';\nimport { Operation } from './operations';\nimport {\n  FeeConsumingOperation,\n  ForgedBytes,\n  GasConsumingOperation,\n  hasMetadataWithResult,\n  RPCOriginationOperation,\n  StorageConsumingOperation,\n} from './types';\n\n/**\n * @description Origination operation provide utility function to fetch newly originated contract\n *\n * @warn Currently support only one origination per operation\n */\nexport class OriginationOperation<TContract extends DefaultContractType = DefaultContractType>\n  extends Operation\n  implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation\n{\n  /**\n   * @description Contract address of the newly originated contract\n   */\n  public readonly contractAddress?: string;\n\n  constructor(\n    hash: string,\n    private readonly params: RPCOriginationOperation,\n    raw: ForgedBytes,\n    results: OperationContentsAndResult[],\n    context: Context,\n    private contractProvider: RpcContractProvider\n  ) {\n    super(hash, raw, results, context);\n\n    const originatedContracts = this.operationResults && this.operationResults.originated_contracts;\n    if (Array.isArray(originatedContracts)) {\n      this.contractAddress = originatedContracts[0];\n    }\n  }\n\n  get status() {\n    const operationResults = this.operationResults;\n    if (operationResults) {\n      return operationResults.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  get operationResults() {\n    const originationOp =\n      Array.isArray(this.results) &&\n      (this.results.find((op) => op.kind === 'origination') as\n        | OperationContentsAndResultOrigination\n        | undefined);\n\n    const result =\n      originationOp &&\n      hasMetadataWithResult(originationOp) &&\n      originationOp.metadata.operation_result;\n    return result ? result : undefined;\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  get consumedGas() {\n    const consumedGas = this.operationResults && this.operationResults.consumed_gas;\n    return consumedGas ? consumedGas : undefined;\n  }\n\n  get storageDiff() {\n    const storageDiff = this.operationResults && this.operationResults.paid_storage_size_diff;\n    return storageDiff ? storageDiff : undefined;\n  }\n\n  get storageSize() {\n    const storageSize = this.operationResults && this.operationResults.storage_size;\n    return storageSize ? storageSize : undefined;\n  }\n\n  get errors() {\n    return this.operationResults && this.operationResults.errors;\n  }\n\n  /**\n   * @description Provide the contract abstract of the newly originated contract\n   */\n  async contract(confirmations?: number, timeout?: number) {\n    if (!this.contractAddress) {\n      throw new OriginationOperationError('No contract was originated in this operation');\n    }\n\n    await this.confirmation(confirmations, timeout);\n    return this.contractProvider.at<TContract>(this.contractAddress);\n  }\n}\n","import { OperationContentsAndResult, OperationContentsAndResultRegisterGlobalConstant } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { Operation } from './operations';\nimport {\n    FeeConsumingOperation,\n    ForgedBytes,\n    GasConsumingOperation,\n    RPCRegisterGlobalConstantOperation,\n    StorageConsumingOperation,\n} from './types';\n\n/**\n * @description RegisterGlobalConstantOperation provides utility functions to fetch a newly issued operation of kind register_global_constant\n */\nexport class RegisterGlobalConstantOperation extends Operation\n    implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n\n    /**\n     * @description Hash (index) of the newly registered constant\n     */\n    public readonly globalConstantHash?: string;\n    constructor(\n        hash: string,\n        private readonly params: RPCRegisterGlobalConstantOperation,\n        public readonly source: string,\n        raw: ForgedBytes,\n        results: OperationContentsAndResult[],\n        context: Context\n    ) {\n        super(hash, raw, results, context);\n\n        this.globalConstantHash = this.operationResults && this.operationResults.global_address;\n    }\n\n    get operationResults() {\n        const registerGlobalConstantOp =\n            Array.isArray(this.results) &&\n            (this.results.find(op => op.kind === 'register_global_constant') as OperationContentsAndResultRegisterGlobalConstant);\n        const result = registerGlobalConstantOp && registerGlobalConstantOp.metadata && registerGlobalConstantOp.metadata.operation_result;\n        return result ? result : undefined;\n    }\n\n    get status() {\n        const operationResults = this.operationResults;\n        if (operationResults) {\n            return operationResults.status;\n        } else {\n            return 'unknown';\n        }\n    }\n\n    get registeredExpression() {\n        return this.params.value;\n    }\n\n    get fee() {\n        return this.params.fee;\n    }\n\n    get gasLimit() {\n        return this.params.gas_limit;\n    }\n\n    get storageLimit() {\n        return this.params.storage_limit;\n    }\n\n    get errors() {\n        return this.operationResults && this.operationResults.errors;\n    }\n}\n","import { OperationContentsAndResult, OperationContentsAndResultReveal } from '@taquito/rpc';\nimport { Context } from '../context';\nimport { flattenErrors, flattenOperationResult } from './operation-errors';\nimport { Operation } from './operations';\nimport {\n  FeeConsumingOperation,\n  ForgedBytes,\n  GasConsumingOperation,\n  RPCRevealOperation,\n  StorageConsumingOperation,\n} from './types';\n\n/**\n * @description Reveal operation provides utility functions to fetch a newly issued revelation\n */\nexport class RevealOperation extends Operation\n  implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n  constructor(\n    hash: string,\n    private readonly params: RPCRevealOperation,\n    public readonly source: string,\n    raw: ForgedBytes,\n    results: OperationContentsAndResult[],\n    context: Context\n  ) {\n    super(hash, raw, results, context);\n  }\n\n  get operationResults() {\n    const revealOp =\n      Array.isArray(this.results) &&\n      (this.results.find(op => op.kind === 'reveal') as OperationContentsAndResultReveal);\n    return revealOp ? [revealOp] : [];\n  }\n\n  get status() {\n    const operationResults = this.operationResults;\n    const txResult = operationResults[0];\n    if (txResult) {\n      return txResult.metadata.operation_result.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  get publicKey() {\n    return this.params.public_key;\n  }\n\n  private sumProp(arr: any[], prop: string) {\n    return arr.reduce((prev, current) => {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  }\n\n  get consumedGas() {\n    return String(\n      this.sumProp(flattenOperationResult({ contents: this.operationResults }), 'consumed_gas')\n    );\n  }\n\n  get storageDiff() {\n    return String(\n      this.sumProp(\n        flattenOperationResult({ contents: this.operationResults }),\n        'paid_storage_size_diff'\n      )\n    );\n  }\n\n  get storageSize() {\n    return String(\n      this.sumProp(flattenOperationResult({ contents: this.operationResults }), 'storage_size')\n    );\n  }\n\n  get errors() {\n    return flattenErrors({ contents: this.operationResults });\n  }\n}\n","import { OperationContentsAndResult, OperationContentsAndResultTransaction } from '@taquito/rpc';\nimport BigNumber from 'bignumber.js';\nimport { Context } from '../context';\nimport { flattenErrors, flattenOperationResult } from './operation-errors';\nimport { Operation } from './operations';\nimport {\n  FeeConsumingOperation,\n  ForgedBytes,\n  GasConsumingOperation,\n  RPCTransferOperation,\n  StorageConsumingOperation,\n} from './types';\n\n/**\n * @description Transaction operation provides utility functions to fetch a newly issued transaction\n *\n * @warn Currently supports one transaction per operation\n */\nexport class TransactionOperation extends Operation\n  implements GasConsumingOperation, StorageConsumingOperation, FeeConsumingOperation {\n  constructor(\n    hash: string,\n    private readonly params: RPCTransferOperation,\n    public readonly source: string,\n    raw: ForgedBytes,\n    results: OperationContentsAndResult[],\n    context: Context\n  ) {\n    super(hash, raw, results, context);\n  }\n\n  get operationResults() {\n    const transactionOp =\n      Array.isArray(this.results) &&\n      (this.results.find(op => op.kind === 'transaction') as OperationContentsAndResultTransaction);\n    return transactionOp ? [transactionOp] : [];\n  }\n\n  get status() {\n    const operationResults = this.operationResults;\n    const txResult = operationResults[0];\n    if (txResult) {\n      return txResult.metadata.operation_result.status;\n    } else {\n      return 'unknown';\n    }\n  }\n\n  get amount() {\n    return new BigNumber(this.params.amount);\n  }\n\n  get destination() {\n    return this.params.destination;\n  }\n\n  get fee() {\n    return this.params.fee;\n  }\n\n  get gasLimit() {\n    return this.params.gas_limit;\n  }\n\n  get storageLimit() {\n    return this.params.storage_limit;\n  }\n\n  private sumProp(arr: any[], prop: string) {\n    return arr.reduce((prev, current) => {\n      return prop in current ? Number(current[prop]) + prev : prev;\n    }, 0);\n  }\n\n  get consumedGas() {\n    return String(\n      this.sumProp(flattenOperationResult({ contents: this.operationResults }), 'consumed_gas')\n    );\n  }\n\n  get storageDiff() {\n    return String(\n      this.sumProp(\n        flattenOperationResult({ contents: this.operationResults }),\n        'paid_storage_size_diff'\n      )\n    );\n  }\n\n  get storageSize() {\n    return String(\n      this.sumProp(flattenOperationResult({ contents: this.operationResults }), 'storage_size')\n    );\n  }\n\n  get errors() {\n    return flattenErrors({ contents: this.operationResults });\n  }\n}\n","const setDelegate = (key: string) => {\n  return [\n    { prim: 'DROP' },\n    { prim: 'NIL', args: [{ prim: 'operation' }] },\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'key_hash' }, { string: key }],\n    },\n    { prim: 'SOME' },\n    { prim: 'SET_DELEGATE' },\n    { prim: 'CONS' },\n  ];\n};\n\nconst transferImplicit = (key: string, mutez: number) => {\n  return [\n    { prim: 'DROP' },\n    { prim: 'NIL', args: [{ prim: 'operation' }] },\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'key_hash' }, { string: key }],\n    },\n    { prim: 'IMPLICIT_ACCOUNT' },\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'mutez' }, { int: `${mutez}` }],\n    },\n    { prim: 'UNIT' },\n    { prim: 'TRANSFER_TOKENS' },\n    { prim: 'CONS' },\n  ];\n};\n\nconst removeDelegate = () => {\n  return [\n    { prim: 'DROP' },\n    { prim: 'NIL', args: [{ prim: 'operation' }] },\n    { prim: 'NONE', args: [{ prim: 'key_hash' }] },\n    { prim: 'SET_DELEGATE' },\n    { prim: 'CONS' },\n  ];\n};\n\nconst transferToContract = (key: string, amount: number) => {\n  return [\n    { prim: 'DROP' },\n    { prim: 'NIL', args: [{ prim: 'operation' }] },\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'address' }, { string: key }],\n    },\n    { prim: 'CONTRACT', args: [{ prim: 'unit' }] },\n    [\n      {\n        prim: 'IF_NONE',\n        args: [[[{ prim: 'UNIT' }, { prim: 'FAILWITH' }]], []],\n      },\n    ],\n    {\n      prim: 'PUSH',\n      args: [{ prim: 'mutez' }, { int: `${amount}` }],\n    },\n    { prim: 'UNIT' },\n    { prim: 'TRANSFER_TOKENS' },\n    { prim: 'CONS' },\n  ];\n};\n\nexport const MANAGER_LAMBDA = {\n  setDelegate,\n  removeDelegate,\n  transferImplicit,\n  transferToContract,\n};\n","const code = [\n  {\n    prim: 'parameter',\n    args: [\n      {\n        prim: 'lambda',\n        args: [\n          { prim: 'unit' },\n          {\n            prim: 'pair',\n            args: [{ prim: 'list', args: [{ prim: 'operation' }] }, { prim: 'unit' }],\n          },\n        ],\n      },\n    ],\n  },\n  { prim: 'storage', args: [{ prim: 'unit' }] },\n  { prim: 'code', args: [[{ prim: 'CAR' }, { prim: 'UNIT' }, { prim: 'EXEC' }]] },\n];\n\nconst storage = 'Unit';\n\nexport const VIEW_LAMBDA = {\n  code,\n  storage\n}\n","import { Wallet } from '../wallet/wallet';\nimport { Context } from '../context';\nimport { ContractAbstraction } from './contract';\nimport { ContractProvider } from './interface';\n\nexport function compose<\n    ContractAbsComposer1 extends ContractAbstraction<ContractProvider | Wallet>,\n    ContractAbsComposer2 extends ContractAbstraction<ContractProvider | Wallet>,\n    ContractAbstractionComposed\n>(\n    functioncomposer1: (abs: ContractAbsComposer1, context: Context) => ContractAbsComposer2,\n    functioncomposer2: (abs: ContractAbsComposer2, context: Context) => ContractAbstractionComposed\n): (abs: ContractAbsComposer1, context: Context) => ContractAbstractionComposed {\n    return (contractAbstraction, context) =>\n        functioncomposer2(functioncomposer1(contractAbstraction, context), context);\n}\n","import { TransactionOperation } from '../../operations/transaction-operation';\nimport { TransferParams } from '../../operations/types';\nimport { ContractProvider } from '../interface';\nimport { TransactionWalletOperation, Wallet } from '../../wallet';\nimport { ParameterSchema } from '@taquito/michelson-encoder';\nimport {\n  ContractMethodInterface,\n  ExplicitTransferParams,\n  SendParams,\n} from './contract-method-interface';\nimport { DEFAULT_SMART_CONTRACT_METHOD_NAME } from '../contract';\nimport { InvalidParameterError } from '../errors';\n\n/**\n * @description Utility class to send smart contract operation\n * The format for the arguments is the flattened representation\n */\nexport class ContractMethod<T extends ContractProvider | Wallet>\n  implements ContractMethodInterface\n{\n  constructor(\n    private provider: T,\n    private address: string,\n    private parameterSchema: ParameterSchema,\n    private name: string,\n    private args: any[],\n    private isMultipleEntrypoint = true,\n    private isAnonymous = false\n  ) {}\n\n  private validateArgs(args: any[], schema: ParameterSchema, name: string) {\n    const sigs = schema.ExtractSignatures();\n\n    if (!sigs.find((x: any[]) => x.length === args.length)) {\n      throw new InvalidParameterError(name, sigs, args);\n    }\n  }\n\n  /**\n   * @description Get the schema of the smart contract method\n   */\n  get schema() {\n    return this.isAnonymous\n      ? this.parameterSchema.ExtractSchema()[this.name]\n      : this.parameterSchema.ExtractSchema();\n  }\n\n  /**\n   * @description Get the signature of the smart contract method\n   */\n  getSignature() {\n    if (this.isAnonymous) {\n      const sig = this.parameterSchema.ExtractSignatures().find((x: any[]) => x[0] === this.name);\n      if (sig) {\n        sig.shift();\n        return sig;\n      }\n    } else {\n      const sig = this.parameterSchema.ExtractSignatures();\n      return sig.length == 1 ? sig[0] : sig;\n    }\n  }\n\n  /**\n   *\n   * @description Send the smart contract operation\n   *\n   * @param Options generic operation parameter\n   */\n  send(\n    params: Partial<SendParams> = {}\n  ): Promise<T extends Wallet ? TransactionWalletOperation : TransactionOperation> {\n    if (this.provider instanceof Wallet) {\n      return (this.provider as unknown as Wallet)\n        .transfer(this.toTransferParams(params))\n        .send() as any;\n    } else {\n      return this.provider.transfer(this.toTransferParams(params)) as any;\n    }\n  }\n\n  /**\n   *\n   * @description Create transfer params to be used with TezosToolkit.contract.transfer methods\n   *\n   * @param Options generic transfer operation parameters\n   */\n  toTransferParams({\n    fee,\n    gasLimit,\n    storageLimit,\n    source,\n    amount = 0,\n    mutez = false,\n  }: Partial<SendParams> = {}): TransferParams {\n    const fullTransferParams: ExplicitTransferParams = {\n      to: this.address,\n      amount,\n      fee,\n      mutez,\n      source,\n      gasLimit,\n      storageLimit,\n      parameter: {\n        entrypoint: this.isMultipleEntrypoint ? this.name : DEFAULT_SMART_CONTRACT_METHOD_NAME,\n        value: this.isAnonymous\n          ? this.parameterSchema.Encode(this.name, ...this.args)\n          : this.parameterSchema.Encode(...this.args),\n      },\n    };\n    return fullTransferParams;\n  }\n}\n","import { Protocols } from '../constants';\nimport { Context } from '../context';\nimport { ContractAbstraction, ContractStorageType, DefaultWalletType } from '../contract';\nimport { ContractMethod } from '../contract/contract-methods/contract-method-flat-param';\nimport { ContractMethodObject } from '../contract/contract-methods/contract-method-object-param';\nimport { OpKind, withKind } from '../operations/types';\nimport { OriginationWalletOperation } from './origination-operation';\nimport {\n  WalletDelegateParams,\n  WalletOriginateParams,\n  WalletProvider,\n  WalletTransferParams,\n} from './interface';\n\nimport {\n  validateAddress,\n  validateContractAddress,\n  InvalidContractAddressError,\n  InvalidAddressError,\n  ValidationResult,\n  InvalidOperationKindError,\n} from '@taquito/utils';\n\nexport interface PKHOption {\n  forceRefetch?: boolean;\n}\n\nexport type WalletParamsWithKind =\n  | withKind<WalletTransferParams, OpKind.TRANSACTION>\n  | withKind<WalletOriginateParams, OpKind.ORIGINATION>\n  | withKind<WalletDelegateParams, OpKind.DELEGATION>;\n\nexport class WalletOperationBatch {\n  private operations: WalletParamsWithKind[] = [];\n\n  constructor(private walletProvider: WalletProvider, private context: Context) {}\n\n  /**\n   *\n   * @description Add a transaction operation to the batch\n   *\n   * @param params Transfer operation parameter\n   */\n  withTransfer(params: WalletTransferParams) {\n    if (validateAddress(params.to) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(params.to);\n    }\n    this.operations.push({ kind: OpKind.TRANSACTION, ...params });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add a transaction operation to the batch\n   *\n   * @param params Transfer operation parameter\n   */\n  withContractCall(params: ContractMethod<Wallet> | ContractMethodObject<Wallet>) {\n    return this.withTransfer(params.toTransferParams());\n  }\n\n  /**\n   *\n   * @description Add a delegation operation to the batch\n   *\n   * @param params Delegation operation parameter\n   */\n  withDelegation(params: WalletDelegateParams) {\n    if (params.delegate && validateAddress(params.delegate) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(params.delegate);\n    }\n    this.operations.push({ kind: OpKind.DELEGATION, ...params });\n    return this;\n  }\n\n  /**\n   *\n   * @description Add an origination operation to the batch\n   *\n   * @param params Origination operation parameter\n   */\n  withOrigination<TWallet extends DefaultWalletType = DefaultWalletType>(\n    params: WalletOriginateParams<ContractStorageType<TWallet>>\n  ) {\n    this.operations.push({ kind: OpKind.ORIGINATION, ...params });\n    return this;\n  }\n\n  private async mapOperation(param: WalletParamsWithKind) {\n    switch (param.kind) {\n      case OpKind.TRANSACTION:\n        return this.walletProvider.mapTransferParamsToWalletParams(async () => param);\n      case OpKind.ORIGINATION:\n        return this.walletProvider.mapOriginateParamsToWalletParams(async () =>\n          this.context.parser.prepareCodeOrigination({\n            ...param,\n          })\n        );\n      case OpKind.DELEGATION:\n        return this.walletProvider.mapDelegateParamsToWalletParams(async () => param);\n      default:\n        throw new InvalidOperationKindError((param as any).kind);\n    }\n  }\n\n  /**\n   *\n   * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\n   *\n   * @param params Operations parameter\n   */\n  with(params: WalletParamsWithKind[]) {\n    for (const param of params) {\n      switch (param.kind) {\n        case OpKind.TRANSACTION:\n          this.withTransfer(param);\n          break;\n        case OpKind.ORIGINATION:\n          this.withOrigination(param);\n          break;\n        case OpKind.DELEGATION:\n          this.withDelegation(param);\n          break;\n        default:\n          throw new InvalidOperationKindError((param as any).kind);\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   *\n   * @description Submit batch operation to wallet\n   *\n   */\n  async send() {\n    const ops: WalletParamsWithKind[] = [];\n\n    for (const op of this.operations) {\n      ops.push(await this.mapOperation(op));\n    }\n\n    const opHash = await this.walletProvider.sendOperations(ops);\n\n    return this.context.operationFactory.createBatchOperation(opHash);\n  }\n}\n\nexport class Wallet {\n  constructor(private context: Context) {}\n\n  private get walletProvider() {\n    return this.context.walletProvider;\n  }\n\n  private _pkh?: string;\n\n  /**\n   * @description Retrieve the PKH of the account that is currently in use by the wallet\n   *\n   * @param option Option to use while fetching the PKH.\n   * If forceRefetch is specified the wallet provider implementation will refetch the PKH from the wallet\n   */\n  async pkh({ forceRefetch }: PKHOption = {}) {\n    if (!this._pkh || forceRefetch) {\n      this._pkh = await this.walletProvider.getPKH();\n    }\n\n    return this._pkh;\n  }\n\n  private walletCommand = <T>(send: () => Promise<T>) => {\n    return {\n      send,\n    };\n  };\n\n  /**\n   *\n   * @description Originate a new contract according to the script in parameters.\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param originateParams Originate operation parameter\n   */\n  originate<TWallet extends DefaultWalletType = DefaultWalletType>(\n    params: WalletOriginateParams<ContractStorageType<TWallet>>\n  ): { send: () => Promise<OriginationWalletOperation<TWallet>> } {\n    return this.walletCommand(async () => {\n      const mappedParams = await this.walletProvider.mapOriginateParamsToWalletParams(() =>\n        this.context.parser.prepareCodeOrigination({\n          ...(params as WalletOriginateParams),\n        })\n      );\n      const opHash = await this.walletProvider.sendOperations([mappedParams]);\n      return this.context.operationFactory.createOriginationOperation(opHash) as Promise<\n        OriginationWalletOperation<TWallet>\n      >;\n    });\n  }\n\n  /**\n   *\n   * @description Set the delegate for a contract.\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param delegateParams operation parameter\n   */\n  setDelegate(params: WalletDelegateParams) {\n    if (params.delegate && validateAddress(params.delegate) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(params.delegate);\n    }\n    return this.walletCommand(async () => {\n      const mappedParams = await this.walletProvider.mapDelegateParamsToWalletParams(\n        async () => params\n      );\n      const opHash = await this.walletProvider.sendOperations([mappedParams]);\n      return this.context.operationFactory.createDelegationOperation(opHash);\n    });\n  }\n\n  /**\n   *\n   * @description Register the current address as delegate.\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   */\n  registerDelegate() {\n    return this.walletCommand(async () => {\n      const mappedParams = await this.walletProvider.mapDelegateParamsToWalletParams(async () => {\n        const delegate = await this.pkh();\n        return { delegate };\n      });\n      const opHash = await this.walletProvider.sendOperations([mappedParams]);\n      return this.context.operationFactory.createDelegationOperation(opHash);\n    });\n  }\n\n  /**\n   *\n   * @description Transfer tezos tokens from current address to a specific address or call a smart contract.\n   *\n   * @returns A wallet command from which we can send the operation to the wallet\n   *\n   * @param params operation parameter\n   */\n  transfer(params: WalletTransferParams) {\n    if (validateAddress(params.to) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(params.to);\n    }\n    return this.walletCommand(async () => {\n      const mappedParams = await this.walletProvider.mapTransferParamsToWalletParams(\n        async () => params\n      );\n      const opHash = await this.walletProvider.sendOperations([mappedParams]);\n      return this.context.operationFactory.createTransactionOperation(opHash);\n    });\n  }\n\n  /**\n   *\n   * @description Create a batch of operation\n   *\n   * @returns A batch object from which we can add more operation or send a command to the wallet to execute the batch\n   *\n   * @param params List of operation to initialize the batch with\n   */\n  batch(params?: Parameters<WalletOperationBatch['with']>[0]) {\n    const batch = new WalletOperationBatch(this.walletProvider, this.context);\n\n    if (Array.isArray(params)) {\n      batch.with(params);\n    }\n\n    return batch;\n  }\n\n  /**\n   *\n   * @description Create an smart contract abstraction for the address specified. Calling entrypoints with the returned\n   * smart contract abstraction will leverage the wallet provider to make smart contract calls\n   *\n   * @param address Smart contract address\n   */\n  async at<T extends ContractAbstraction<Wallet>>(\n    address: string,\n    contractAbstractionComposer: (abs: ContractAbstraction<Wallet>, context: Context) => T = (x) =>\n      x as any\n  ): Promise<T> {\n    if (validateContractAddress(address) !== ValidationResult.VALID) {\n      throw new InvalidContractAddressError(address);\n    }\n    const rpc = this.context.withExtensions().rpc;\n    const readProvider = this.context.withExtensions().readProvider;\n    const script = await readProvider.getScript(address, 'head');\n    const entrypoints = await readProvider.getEntrypoints(address);\n    const abs = new ContractAbstraction(\n      address,\n      script,\n      this,\n      this.context.contract,\n      entrypoints,\n      rpc,\n      readProvider\n    );\n    return contractAbstractionComposer(abs, this.context);\n  }\n}\n","import { Context } from '../context';\nimport { attachKind, OpKind } from '../operations/types';\nimport {\n  WalletDelegateParams,\n  WalletOriginateParams,\n  WalletProvider,\n  WalletTransferParams,\n} from './interface';\nimport { WalletParamsWithKind } from './wallet';\n\nexport class LegacyWalletProvider implements WalletProvider {\n  constructor(private context: Context) {}\n\n  async getPKH(): Promise<string> {\n    return this.context.signer.publicKeyHash();\n  }\n\n  async mapTransferParamsToWalletParams(params: () => Promise<WalletTransferParams>) {\n    return attachKind(await params(), OpKind.TRANSACTION);\n  }\n\n  async mapOriginateParamsToWalletParams(params: () => Promise<WalletOriginateParams>) {\n    return attachKind(await params(), OpKind.ORIGINATION);\n  }\n\n  async mapDelegateParamsToWalletParams(params: () => Promise<WalletDelegateParams>) {\n    return attachKind(await params(), OpKind.DELEGATION);\n  }\n\n  async sendOperations(params: WalletParamsWithKind[]) {\n    const op = await this.context.batch.batch(params as any).send();\n    return op.hash;\n  }\n}\n","import { TransactionOperation } from '../../operations/transaction-operation';\nimport { TransferParams } from '../../operations/types';\nimport { ContractProvider } from '../interface';\nimport { TransactionWalletOperation, Wallet } from '../../wallet';\nimport { ParameterSchema } from \"@taquito/michelson-encoder\";\nimport { ContractMethodInterface, ExplicitTransferParams, SendParams } from './contract-method-interface';\nimport { DEFAULT_SMART_CONTRACT_METHOD_NAME } from '../contract';\n\n/**\n * @description Utility class to send smart contract operation\n * The format for the arguments is the object representation\n */\nexport class ContractMethodObject<T extends ContractProvider | Wallet> implements ContractMethodInterface {\n    constructor(\n        private provider: T,\n        private address: string,\n        private parameterSchema: ParameterSchema,\n        private name: string,\n        private args: any = 'unit',\n        private isMultipleEntrypoint = true,\n        private isAnonymous = false\n    ) { }\n\n    /**\n     * @description Get the signature of the smart contract method\n     */\n    getSignature() {\n        return this.isAnonymous\n            ? this.parameterSchema.ExtractSchema()[this.name]\n            : this.parameterSchema.ExtractSchema();\n    }\n\n    /**\n     *\n     * @description Send the smart contract operation\n     *\n     * @param Options generic operation parameter\n     */\n    send(\n        params: Partial<SendParams> = {}\n    ): Promise<T extends Wallet ? TransactionWalletOperation : TransactionOperation> {\n        if (this.provider instanceof Wallet) {\n            return (this.provider as unknown as Wallet).transfer(this.toTransferParams(params)).send() as any;\n        } else {\n            return this.provider.transfer(this.toTransferParams(params)) as any;\n        }\n    }\n\n    /**\n     *\n     * @description Create transfer params to be used with TezosToolkit.contract.transfer methods\n     *\n     * @param Options generic transfer operation parameters\n     */\n    toTransferParams({\n        fee,\n        gasLimit,\n        storageLimit,\n        source,\n        amount = 0,\n        mutez = false,\n    }: Partial<SendParams> = {}): TransferParams {\n        const fullTransferParams: ExplicitTransferParams = {\n            to: this.address,\n            amount,\n            fee,\n            mutez,\n            source,\n            gasLimit,\n            storageLimit,\n            parameter: {\n                entrypoint: this.isMultipleEntrypoint ? this.name : DEFAULT_SMART_CONTRACT_METHOD_NAME,\n                value: this.isAnonymous\n                    ? this.parameterSchema.EncodeObject({ [this.name]: this.args })\n                    : this.parameterSchema.EncodeObject(this.args),\n            },\n        };\n        return fullTransferParams;\n    }\n}","import { ViewSchema } from '@taquito/michelson-encoder';\nimport {\n  MichelsonV1Expression,\n  MichelsonV1ExpressionExtended,\n  RpcClientInterface,\n  RPCRunCodeParam,\n} from '@taquito/rpc';\nimport { validateAddress, ValidationResult } from '@taquito/utils';\nimport { TzReadProvider } from '../../read-provider/interface';\nimport {\n  InvalidViewSimulationContext,\n  InvalidViewParameterError,\n  ViewSimulationError,\n  validateAndExtractFailwith,\n} from '../errors';\n\nconst runCodeHelper = (\n  viewArgsType: MichelsonV1ExpressionExtended,\n  viewReturnType: MichelsonV1ExpressionExtended,\n  contractStorageType: MichelsonV1Expression,\n  viewInstructions: MichelsonV1ExpressionExtended[],\n  viewArgs: MichelsonV1Expression,\n  contractStorageValue: MichelsonV1Expression,\n  balance: string,\n  chain_id: string,\n  source?: string,\n  amount = '0'\n): RPCRunCodeParam => {\n  return {\n    script: [\n      { prim: 'parameter', args: [{ prim: 'pair', args: [viewArgsType, contractStorageType] }] },\n      { prim: 'storage', args: [{ prim: 'option', args: [viewReturnType] }] },\n      {\n        prim: 'code',\n        args: [\n          [\n            { prim: 'CAR' },\n            viewInstructions,\n            { prim: 'SOME' },\n            { prim: 'NIL', args: [{ prim: 'operation' }] },\n            { prim: 'PAIR' },\n          ],\n        ],\n      },\n    ],\n    storage: { prim: 'None' },\n    input: { prim: 'Pair', args: [viewArgs, contractStorageValue] },\n    amount,\n    balance,\n    chain_id,\n    source,\n  };\n};\n\nexport interface ExecutionContextParams {\n  source?: string;\n  viewCaller: string;\n}\n\nexport class OnChainView {\n  constructor(\n    private _rpc: RpcClientInterface,\n    private _readProvider: TzReadProvider,\n    private _contractAddress: string,\n    private _smartContractViewSchema: ViewSchema,\n    private _contractStorageType: MichelsonV1Expression,\n    private _args: any = 'Unit'\n  ) {}\n\n  /**\n   * @description Get the signature of the smart contract view\n   */\n  getSignature() {\n    return {\n      parameter: this._smartContractViewSchema.extractArgsSchema(),\n      result: this._smartContractViewSchema.extractResultSchema(),\n    };\n  }\n\n  /**\n   * @description Get the result of the view simulation\n   * @param executionContext.source the public key hash of the account who initialized this view execution.\n   * @param executionContext.viewCaller the contract address which is the caller of view.\n   */\n  async executeView(executionContext: ExecutionContextParams) {\n    this.verifyContextExecution(executionContext);\n    const balance = (await this._readProvider.getBalance(this._contractAddress, 'head')).toString();\n    const chainId = await this._readProvider.getChainId();\n    const storage = await this._readProvider.getStorage(this._contractAddress, 'head');\n    return this.executeViewAndDecodeResult(\n      runCodeHelper(\n        this._smartContractViewSchema.viewArgsType,\n        this._smartContractViewSchema.viewReturnType,\n        this._contractStorageType,\n        this.adaptViewCodeToContext(\n          this._smartContractViewSchema.instructions,\n          executionContext.viewCaller,\n          balance\n        ),\n        this.transformArgsToMichelson(),\n        storage,\n        balance,\n        chainId,\n        executionContext.source\n      )\n    );\n  }\n\n  private verifyContextExecution(executionContext: ExecutionContextParams) {\n    if (\n      executionContext.source &&\n      validateAddress(executionContext.source) !== ValidationResult.VALID\n    ) {\n      throw new InvalidViewSimulationContext(\n        `The source account who initialized the view execution is invalid: ${executionContext.source}.`\n      );\n    }\n    if (\n      !executionContext.viewCaller ||\n      validateAddress(executionContext.viewCaller) !== ValidationResult.VALID\n    ) {\n      throw new InvalidViewSimulationContext(\n        `The contract which is the caller of view is invalid: ${executionContext.viewCaller}.`\n      );\n    }\n  }\n\n  private transformArgsToMichelson() {\n    try {\n      return this._smartContractViewSchema.encodeViewArgs(this._args);\n    } catch (error) {\n      throw new InvalidViewParameterError(\n        this._smartContractViewSchema.viewName,\n        this.getSignature(),\n        this._args,\n        error\n      );\n    }\n  }\n  /**\n   * @description Loops through the view's instructions and replace BALANCE, SENDER, SELF_ADDRESS and AMOUNT with Michelson expressions that match the current context, if applicable.\n   *\n   * Certain specific instructions have different semantics in view:\n   * BALANCE represents the current amount of mutez held by the contract where view is;\n   * SENDER represents the contract which is the caller of view;\n   * SELF_ADDRESS represents the contract where view is;\n   * AMOUNT is always 0 mutez.\n   *\n   */\n  private adaptViewCodeToContext(\n    instructions: MichelsonV1ExpressionExtended[],\n    viewCaller: string,\n    contractBalance: string\n  ) {\n    const instructionsToReplace = {\n      BALANCE: [{ prim: 'PUSH', args: [{ prim: 'mutez' }, { int: contractBalance }] }],\n      SENDER: [{ prim: 'PUSH', args: [{ prim: 'address' }, { string: viewCaller }] }],\n      SELF_ADDRESS: [\n        { prim: 'PUSH', args: [{ prim: 'address' }, { string: this._contractAddress }] },\n      ],\n      AMOUNT: [{ prim: 'PUSH', args: [{ prim: 'mutez' }, { int: '0' }] }],\n    };\n\n    instructions.forEach((inst: any, i: number) => {\n      if (inst.prim in instructionsToReplace) {\n        instructions[i] = Object(instructionsToReplace)[inst.prim];\n      }\n      if (inst.args && inst.args.length !== 0) {\n        this.adaptViewCodeToContext(inst.args, viewCaller, contractBalance);\n      } else if (Array.isArray(inst)) {\n        this.adaptViewCodeToContext(inst, viewCaller, contractBalance);\n      }\n    });\n    return instructions;\n  }\n\n  private async executeViewAndDecodeResult(viewScript: RPCRunCodeParam) {\n    let storage: MichelsonV1ExpressionExtended;\n    try {\n      storage = (await this._rpc.runCode(viewScript)).storage as MichelsonV1ExpressionExtended;\n    } catch (error: any) {\n      const failWith = validateAndExtractFailwith(error);\n      throw failWith\n        ? new ViewSimulationError(\n            `The simulation of the on-chain view named ${\n              this._smartContractViewSchema.viewName\n            } failed with: ${JSON.stringify(failWith)}`,\n            this._smartContractViewSchema.viewName,\n            failWith,\n            error\n          )\n        : error;\n    }\n    if (!storage.args) {\n      throw new ViewSimulationError(\n        `View simulation failed with an invalid result: ${storage}`,\n        this._smartContractViewSchema.viewName\n      );\n    }\n    return this._smartContractViewSchema.decodeViewResult(storage.args[0]);\n  }\n}\n","import { Wallet } from '../../wallet';\nimport { ContractProvider } from '../../contract';\nimport { ContractMethodObject } from './contract-method-object-param';\nimport { ContractMethod } from './contract-method-flat-param';\nimport { ParameterSchema, ViewSchema } from '@taquito/michelson-encoder';\nimport { RpcClientInterface, MichelsonV1Expression } from '@taquito/rpc';\nimport { OnChainView } from './contract-on-chain-view';\nimport { TzReadProvider } from '../../read-provider/interface';\n\nexport class ContractMethodFactory<T extends ContractProvider | Wallet> {\n  constructor(private provider: T, private contractAddress: string) {}\n\n  createContractMethodFlatParams(\n    smartContractMethodSchema: ParameterSchema,\n    smartContractMethodName: string,\n    args: any[],\n    isMultipleEntrypoint = true,\n    isAnonymous = false\n  ) {\n    return new ContractMethod<T>(\n      this.provider,\n      this.contractAddress,\n      smartContractMethodSchema,\n      smartContractMethodName,\n      args,\n      isMultipleEntrypoint,\n      isAnonymous\n    );\n  }\n\n  createContractMethodObjectParam(\n    smartContractMethodSchema: ParameterSchema,\n    smartContractMethodName: string,\n    args: any[],\n    isMultipleEntrypoint = true,\n    isAnonymous = false\n  ) {\n    return new ContractMethodObject<T>(\n      this.provider,\n      this.contractAddress,\n      smartContractMethodSchema,\n      smartContractMethodName,\n      args,\n      isMultipleEntrypoint,\n      isAnonymous\n    );\n  }\n\n  createContractViewObjectParam(\n    rpc: RpcClientInterface,\n    readProvider: TzReadProvider,\n    smartContractViewSchema: ViewSchema,\n    contractStorageType: MichelsonV1Expression,\n    viewArgs: any\n  ) {\n    return new OnChainView(\n      rpc,\n      readProvider,\n      this.contractAddress,\n      smartContractViewSchema,\n      contractStorageType,\n      viewArgs\n    );\n  }\n}\n","import { ParameterSchema, Schema, ViewSchema } from '@taquito/michelson-encoder';\nimport {\n  EntrypointsResponse,\n  MichelsonV1Expression,\n  RpcClientInterface,\n  ScriptResponse,\n} from '@taquito/rpc';\nimport {\n  validateChain,\n  validateContractAddress,\n  ValidationResult,\n  InvalidChainIdError,\n  DeprecationError,\n} from '@taquito/utils';\nimport { ChainIds } from '../constants';\nimport { TzReadProvider } from '../read-provider/interface';\nimport { Wallet } from '../wallet';\nimport { ContractMethodFactory } from './contract-methods/contract-method-factory';\nimport { ContractMethod } from './contract-methods/contract-method-flat-param';\nimport { ContractMethodObject } from './contract-methods/contract-method-object-param';\nimport { OnChainView } from './contract-methods/contract-on-chain-view';\nimport { InvalidParameterError } from './errors';\nimport { ContractProvider, StorageProvider } from './interface';\n\nexport const DEFAULT_SMART_CONTRACT_METHOD_NAME = 'default';\n\n/**\n * @description Utility class to retrieve data from a smart contract's storage without incurring fees via a contract's view method\n */\nexport class ContractView {\n  constructor(\n    private currentContract: ContractAbstraction<ContractProvider | Wallet>,\n    private name: string,\n    private callbackParametersSchema: ParameterSchema,\n    private parameterSchema: ParameterSchema,\n    private args: any[],\n    private rpc: RpcClientInterface,\n    private readProvider: TzReadProvider\n  ) {}\n\n  async read(chainId?: ChainIds) {\n    if (validateContractAddress(chainId) == ValidationResult.VALID) {\n      throw new DeprecationError(\n        `Since version 12, the lambda view no longer depends on a lambda contract. The read method no longer accepts a contract address as a parameter.`\n      );\n    } else if (chainId && validateChain(chainId) !== ValidationResult.VALID) {\n      throw new InvalidChainIdError(chainId);\n    }\n    const arg = this.parameterSchema.Encode(...this.args);\n    const result = await this.rpc.runView({\n      contract: this.currentContract.address,\n      entrypoint: this.name,\n      input: arg,\n      chain_id: chainId ? chainId : await this.readProvider.getChainId(),\n    });\n    return this.callbackParametersSchema.Execute(result.data);\n  }\n}\n\nconst validateArgs = (args: any[], schema: ParameterSchema, name: string) => {\n  const sigs = schema.ExtractSignatures();\n\n  if (!sigs.find((x: any[]) => x.length === args.length)) {\n    throw new InvalidParameterError(name, sigs, args);\n  }\n};\n\n// lambda view tzip4\nconst isView = (entrypoint: MichelsonV1Expression): boolean => {\n  let isView = false;\n  if ('prim' in entrypoint && entrypoint.prim === 'pair' && entrypoint.args) {\n    const lastElement = entrypoint.args[entrypoint.args.length - 1];\n    if ('prim' in lastElement && lastElement.prim === 'contract') {\n      isView = true;\n    }\n  }\n  return isView;\n};\n\nexport type Contract = ContractAbstraction<ContractProvider>;\nexport type WalletContract = ContractAbstraction<Wallet>;\n\nconst isContractProvider = (variableToCheck: any): variableToCheck is ContractProvider =>\n  variableToCheck.contractProviderTypeSymbol !== undefined;\n\ntype DefaultMethods<T extends ContractProvider | Wallet> = Record<\n  string,\n  (...args: any[]) => ContractMethod<T>\n>;\ntype DefaultMethodsObject<T extends ContractProvider | Wallet> = Record<\n  string,\n  (args?: any) => ContractMethodObject<T>\n>;\ntype DefaultViews = Record<string, (...args: any[]) => ContractView>;\ntype DefaultContractViews = Record<string, (args?: any) => OnChainView>;\ntype DefaultStorage = unknown; // Record<string, unknown>;\n\ntype PromiseReturnType<T extends (...args: any) => any> = T extends (\n  ...args: any\n) => Promise<infer R>\n  ? R\n  : any;\nexport type ContractStorageType<T extends ContractAbstraction<ContractProvider | Wallet>> =\n  PromiseReturnType<T['storage']>;\nexport type DefaultContractType = ContractAbstraction<ContractProvider>;\nexport type DefaultWalletType = ContractAbstraction<Wallet>;\n\n/**\n * @description Smart contract abstraction\n */\nexport class ContractAbstraction<\n  T extends ContractProvider | Wallet,\n  TMethods extends DefaultMethods<T> = DefaultMethods<T>,\n  TMethodsObject extends DefaultMethodsObject<T> = DefaultMethodsObject<T>,\n  TViews extends DefaultViews = DefaultViews,\n  TContractViews extends DefaultContractViews = DefaultContractViews,\n  TStorage extends DefaultStorage = DefaultStorage\n> {\n  private contractMethodFactory: ContractMethodFactory<T>;\n  /**\n   * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.\n   * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.\n   *\n   */\n  public methods: TMethods = {} as TMethods;\n  /**\n   * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.\n   * `methodsObject` serves the exact same purpose as the `methods` member. The difference is that it allows passing the parameter in an object format when calling the smart contract method (instead of the flattened representation)\n   * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.\n   *\n   */\n  public methodsObject: TMethodsObject = {} as TMethodsObject;\n  /**\n   * @description Contains lamda views (tzip4) that are implemented by the target Tezos Smart Contract, and offers the user to call the lambda views as if they were native TS/JS methods.\n   * NB: These are the view defined in the tzip4 standard, not the views introduced by the Hangzhou protocol.\n   */\n  public views: TViews = {} as TViews;\n  /**\n   * @description Contains on-chain views that are defined by the target Tezos Smart Contract, and offers the user to simulate the views execution as if they were native TS/JS methods.\n   * NB: the expected format for the parameter when calling a smart contract view is the object format (same format as for the storage) and not the flattened representation.\n   *\n   */\n  public contractViews: TContractViews = {} as TContractViews;\n\n  public readonly schema: Schema;\n\n  public readonly parameterSchema: ParameterSchema;\n  public readonly viewSchema: ViewSchema[];\n\n  constructor(\n    public readonly address: string,\n    public readonly script: ScriptResponse,\n    provider: T,\n    private storageProvider: StorageProvider,\n    public readonly entrypoints: EntrypointsResponse,\n    private rpc: RpcClientInterface,\n    private readProvider: TzReadProvider\n  ) {\n    this.contractMethodFactory = new ContractMethodFactory(provider, address);\n    this.schema = Schema.fromRPCResponse({ script: this.script });\n    this.parameterSchema = ParameterSchema.fromRPCResponse({ script: this.script });\n\n    this.viewSchema = ViewSchema.fromRPCResponse({ script: this.script });\n    if (this.viewSchema.length !== 0) {\n      this._initializeOnChainViews(this, rpc, this.readProvider, this.viewSchema);\n    }\n    this._initializeMethods(this, this.entrypoints.entrypoints, this.rpc, this.readProvider);\n  }\n\n  private _initializeMethods(\n    currentContract: ContractAbstraction<T>,\n    entrypoints: {\n      [key: string]: object;\n    },\n    rpc: RpcClientInterface,\n    readProvider: TzReadProvider\n  ) {\n    const parameterSchema = this.parameterSchema;\n    const keys = Object.keys(entrypoints);\n    if (parameterSchema.isMultipleEntryPoint) {\n      keys.forEach((smartContractMethodName) => {\n        const smartContractMethodSchema = new ParameterSchema(entrypoints[smartContractMethodName]);\n\n        (this.methods as DefaultMethods<T>)[smartContractMethodName] = function (...args: any[]) {\n          return currentContract.contractMethodFactory.createContractMethodFlatParams(\n            smartContractMethodSchema,\n            smartContractMethodName,\n            args\n          );\n        };\n\n        (this.methodsObject as DefaultMethodsObject<T>)[smartContractMethodName] = function (\n          args: any\n        ) {\n          return currentContract.contractMethodFactory.createContractMethodObjectParam(\n            smartContractMethodSchema,\n            smartContractMethodName,\n            args\n          );\n        };\n\n        if (isView(entrypoints[smartContractMethodName])) {\n          const view = function (...args: any[]) {\n            const entrypointParamWithoutCallback = (entrypoints[smartContractMethodName] as any)\n              .args[0];\n            const smartContractMethodSchemaWithoutCallback = new ParameterSchema(\n              entrypointParamWithoutCallback\n            );\n            const parametersCallback = (entrypoints[smartContractMethodName] as any).args[1]\n              .args[0];\n            const smartContractMethodCallbackSchema = new ParameterSchema(parametersCallback);\n\n            validateArgs(args, smartContractMethodSchemaWithoutCallback, smartContractMethodName);\n            return new ContractView(\n              currentContract,\n              smartContractMethodName,\n              smartContractMethodCallbackSchema,\n              smartContractMethodSchemaWithoutCallback,\n              args,\n              rpc,\n              readProvider\n            );\n          };\n          (this.views as DefaultViews)[smartContractMethodName] = view;\n        }\n      });\n\n      // Deal with methods with no annotations which were not discovered by the RPC endpoint\n      // Methods with no annotations are discovered using parameter schema\n      const anonymousMethods = Object.keys(parameterSchema.ExtractSchema()).filter(\n        (key) => Object.keys(entrypoints).indexOf(key) === -1\n      );\n\n      anonymousMethods.forEach((smartContractMethodName) => {\n        (this.methods as DefaultMethods<T>)[smartContractMethodName] = function (...args: any[]) {\n          return currentContract.contractMethodFactory.createContractMethodFlatParams(\n            parameterSchema,\n            smartContractMethodName,\n            args,\n            false,\n            true\n          );\n        };\n\n        (this.methodsObject as DefaultMethodsObject<T>)[smartContractMethodName] = function (\n          args: any\n        ) {\n          return currentContract.contractMethodFactory.createContractMethodObjectParam(\n            parameterSchema,\n            smartContractMethodName,\n            args,\n            false,\n            true\n          );\n        };\n      });\n    } else {\n      const smartContractMethodSchema = this.parameterSchema;\n      (this.methods as DefaultMethods<T>)[DEFAULT_SMART_CONTRACT_METHOD_NAME] = function (\n        ...args: any[]\n      ) {\n        return currentContract.contractMethodFactory.createContractMethodFlatParams(\n          smartContractMethodSchema,\n          DEFAULT_SMART_CONTRACT_METHOD_NAME,\n          args,\n          false\n        );\n      };\n\n      (this.methodsObject as DefaultMethodsObject<T>)[DEFAULT_SMART_CONTRACT_METHOD_NAME] =\n        function (args: any) {\n          return currentContract.contractMethodFactory.createContractMethodObjectParam(\n            smartContractMethodSchema,\n            DEFAULT_SMART_CONTRACT_METHOD_NAME,\n            args,\n            false\n          );\n        };\n    }\n  }\n\n  private _initializeOnChainViews(\n    currentContract: ContractAbstraction<T>,\n    rpc: RpcClientInterface,\n    readProvider: TzReadProvider,\n    allContractViews: ViewSchema[]\n  ) {\n    const storageType = this.schema.val;\n\n    allContractViews.forEach((viewSchema) => {\n      (this.contractViews as DefaultContractViews)[viewSchema.viewName] = function (args: any) {\n        return currentContract.contractMethodFactory.createContractViewObjectParam(\n          rpc,\n          readProvider,\n          viewSchema,\n          storageType,\n          args\n        );\n      };\n    });\n  }\n\n  /**\n   * @description Return a friendly representation of the smart contract storage\n   */\n  public storage<T extends TStorage = TStorage>() {\n    return this.storageProvider.getStorage<T>(this.address, this.schema);\n  }\n\n  /**\n   *\n   * @description Return a friendly representation of the smart contract big map value\n   *\n   * @param key BigMap key to fetch\n   *\n   * @deprecated getBigMapKey has been deprecated in favor of getBigMapKeyByID\n   *\n   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get\n   */\n  public bigMap(key: string) {\n    return this.storageProvider.getBigMapKey(this.address, key, this.schema);\n  }\n}\n","import { Schema, BigMapKeyType } from '@taquito/michelson-encoder';\nimport BigNumber from 'bignumber.js';\nimport { ContractProvider } from './interface';\nimport { HttpResponseError, STATUS_CODE } from '@taquito/http-utils';\n\nexport class BigMapAbstraction {\n  constructor(private id: BigNumber, private schema: Schema, private provider: ContractProvider) {}\n\n  /**\n   *\n   * @description Fetch one value in a big map\n   *\n   * @param keysToEncode Key to query (will be encoded properly according to the schema)\n   * @param block optional block level to fetch the values from (head will be use by default)\n   * @returns Return a well formatted json object of a big map value or undefined if the key is not found in the big map\n   *\n   */\n  async get<T>(keyToEncode: BigMapKeyType, block?: number) {\n    try {\n      const id = await this.provider.getBigMapKeyByID<T>(\n        this.id.toString(),\n        keyToEncode,\n        this.schema,\n        block\n      );\n      return id;\n    } catch (e) {\n      if (e instanceof HttpResponseError && e.status === STATUS_CODE.NOT_FOUND) {\n        return undefined;\n      } else {\n        throw e;\n      }\n    }\n  }\n\n  /**\n   *\n   * @description Fetch multiple values in a big map\n   * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.\n   * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.\n   * If one of the keys does not exist in the big map, its value will be set to undefined.\n   *\n   * @param keysToEncode Array of keys to query (will be encoded properly according to the schema)\n   * @param block optional block level to fetch the values from\n   * @param batchSize optional batch size representing the number of requests to execute in parallel\n   * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format\n   *\n   */\n  async getMultipleValues<T>(keysToEncode: Array<BigMapKeyType>, block?: number, batchSize = 5) {\n    return this.provider.getBigMapKeysByID<T>(\n      this.id.toString(),\n      keysToEncode,\n      this.schema,\n      block,\n      batchSize\n    );\n  }\n\n  toJSON() {\n    return this.id.toString();\n  }\n\n  toString() {\n    return this.id.toString();\n  }\n}\n","import BigNumber from 'bignumber.js';\nimport { ContractProvider } from './interface';\n\nexport class SaplingStateAbstraction {\n    constructor(private id: BigNumber, private provider: ContractProvider) { }\n\n    /**\n     *\n     * @description Fetch the sapling state\n     * \n     * @param block optional block level to fetch the values from (head will be use by default)\n     * @returns Return a json object of the sapling_state\n     *\n     */\n    async getSaplingDiff(block?: number) {\n        return this.provider.getSaplingDiffByID(this.id.toString(), block);\n    }\n\n    getId() {\n        return this.id.toString();\n    }\n}\n","import { Schema, Semantic } from '@taquito/michelson-encoder';\nimport { BigMapAbstraction } from './big-map';\nimport { ContractProvider } from './interface';\nimport BigNumber from 'bignumber.js';\nimport { MichelsonV1Expression } from '@taquito/rpc';\nimport { SaplingStateAbstraction } from './sapling-state-abstraction';\n\n// Override the default michelson encoder semantic to provide richer abstraction over storage properties\nexport const smartContractAbstractionSemantic: (p: ContractProvider) => Semantic = (\n  provider: ContractProvider\n) => ({\n  // Provide a specific abstraction for BigMaps\n  big_map: (val: MichelsonV1Expression, code: MichelsonV1Expression) => {\n    if (!val || !('int' in val) || val.int === undefined) {\n      // Return an empty object in case of missing big map ID\n      return {};\n    } else {\n      const schema = new Schema(code);\n      return new BigMapAbstraction(new BigNumber(val.int), schema, provider);\n    }\n  },\n  sapling_state: (val: MichelsonV1Expression) => {\n    if (!val || !('int' in val) || val.int === undefined) {\n      // Return an empty object in case of missing sapling state ID\n      return {};\n    } else {\n      return new SaplingStateAbstraction(new BigNumber(val.int), provider);\n    }\n  }\n  /*\n  // TODO: embed useful other abstractions\n  'contract':  () => {},\n  'address':  () => {}\n  */\n});\n","import { HttpResponseError, STATUS_CODE } from '@taquito/http-utils';\nimport { BigMapKeyType, MichelsonMap, MichelsonMapKey, Schema } from '@taquito/michelson-encoder';\nimport { OpKind, ScriptResponse } from '@taquito/rpc';\nimport { encodeExpr } from '@taquito/utils';\nimport { OperationBatch } from '../batch/rpc-batch-provider';\nimport { Context } from '../context';\nimport { DelegateOperation } from '../operations/delegate-operation';\nimport { OperationEmitter } from '../operations/operation-emitter';\nimport { OriginationOperation } from '../operations/origination-operation';\nimport { RegisterGlobalConstantOperation } from '../operations/register-global-constant-operation';\nimport { RevealOperation } from '../operations/reveal-operation';\nimport { TransactionOperation } from '../operations/transaction-operation';\nimport {\n  DelegateParams,\n  isOpRequireReveal,\n  OriginateParams,\n  ParamsWithKind,\n  RegisterDelegateParams,\n  RegisterGlobalConstantParams,\n  RevealParams,\n  RPCOperation,\n  TransferParams,\n  withKind,\n} from '../operations/types';\nimport { DefaultContractType, ContractStorageType, ContractAbstraction } from './contract';\nimport { InvalidDelegationSource, RevealOperationError } from './errors';\nimport { ContractProvider, ContractSchema, StorageProvider } from './interface';\nimport {\n  createOriginationOperation,\n  createRegisterDelegateOperation,\n  createRegisterGlobalConstantOperation,\n  createRevealOperation,\n  createSetDelegateOperation,\n  createTransferOperation,\n} from './prepare';\nimport { smartContractAbstractionSemantic } from './semantic';\nimport {\n  validateAddress,\n  validateContractAddress,\n  InvalidContractAddressError,\n  InvalidAddressError,\n  ValidationResult,\n} from '@taquito/utils';\nimport { EstimationProvider } from '../estimate/estimate-provider-interface';\nexport class RpcContractProvider\n  extends OperationEmitter\n  implements ContractProvider, StorageProvider\n{\n  constructor(context: Context, private estimator: EstimationProvider) {\n    super(context);\n  }\n  contractProviderTypeSymbol = Symbol.for('taquito--provider-type-symbol');\n\n  /**\n   *\n   * @description Return a well formatted json object of the contract storage\n   *\n   * @param contract contract address you want to get the storage from\n   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\n   *\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\n   */\n  async getStorage<T>(contract: string, schema?: ContractSchema): Promise<T> {\n    if (validateContractAddress(contract) !== ValidationResult.VALID) {\n      throw new InvalidContractAddressError(contract);\n    }\n    const script = await this.context.readProvider.getScript(contract, 'head');\n    if (!schema) {\n      schema = script;\n    }\n\n    let contractSchema: Schema;\n    if (Schema.isSchema(schema)) {\n      contractSchema = schema;\n    } else {\n      contractSchema = Schema.fromRPCResponse({ script: schema as ScriptResponse });\n    }\n\n    return contractSchema.Execute(script.storage, smartContractAbstractionSemantic(this)) as T; // Cast into T because only the caller can know the true type of the storage\n  }\n\n  /**\n   *\n   * @description Return a well formatted json object of the contract big map storage\n   *\n   * @param contract contract address you want to get the storage from\n   * @param key contract big map key to fetch value from\n   * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\n   *\n   * @deprecated Deprecated in favor of getBigMapKeyByID\n   *\n   * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get\n   */\n  async getBigMapKey<T>(contract: string, key: string, schema?: ContractSchema): Promise<T> {\n    if (validateContractAddress(contract) !== ValidationResult.VALID) {\n      throw new InvalidContractAddressError(contract);\n    }\n    if (!schema) {\n      schema = (await this.rpc.getContract(contract)).script;\n    }\n\n    let contractSchema: Schema;\n    if (Schema.isSchema(schema)) {\n      contractSchema = schema;\n    } else {\n      contractSchema = Schema.fromRPCResponse({ script: schema as ScriptResponse });\n    }\n\n    const encodedKey = contractSchema.EncodeBigMapKey(key);\n\n    const val = await this.rpc.getBigMapKey(contract, encodedKey);\n\n    return contractSchema.ExecuteOnBigMapValue(val) as T; // Cast into T because only the caller can know the true type of the storage\n  }\n\n  /**\n   *\n   * @description Return a well formatted json object of a big map value\n   *\n   * @param id Big Map ID\n   * @param keyToEncode key to query (will be encoded properly according to the schema)\n   * @param schema Big Map schema (can be determined using your contract type)\n   * @param block optional block level to fetch the values from\n   *\n   * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr\n   */\n  async getBigMapKeyByID<T>(\n    id: string,\n    keyToEncode: BigMapKeyType,\n    schema: Schema,\n    block?: number\n  ): Promise<T> {\n    const { key, type } = schema.EncodeBigMapKey(keyToEncode);\n    const { packed } = await this.context.packer.packData({ data: key, type });\n\n    const encodedExpr = encodeExpr(packed);\n\n    const bigMapValue = block\n      ? await this.context.readProvider.getBigMapValue(\n          { id: id.toString(), expr: encodedExpr },\n          block\n        )\n      : await this.context.readProvider.getBigMapValue(\n          { id: id.toString(), expr: encodedExpr },\n          'head'\n        );\n\n    return schema.ExecuteOnBigMapValue(bigMapValue, smartContractAbstractionSemantic(this)) as T;\n  }\n\n  /**\n   *\n   * @description Fetch multiple values in a big map\n   * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.\n   * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.\n   * If one of the keys does not exist in the big map, its value will be set to undefined.\n   *\n   * @param id Big Map ID\n   * @param keys Array of keys to query (will be encoded properly according to the schema)\n   * @param schema Big Map schema (can be determined using your contract type)\n   * @param block optional block level to fetch the values from\n   * @param batchSize optional batch size representing the number of requests to execute in parallel\n   * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format\n   *\n   */\n  async getBigMapKeysByID<T>(\n    id: string,\n    keys: Array<BigMapKeyType>,\n    schema: Schema,\n    block?: number,\n    batchSize = 5\n  ): Promise<MichelsonMap<MichelsonMapKey, T | undefined>> {\n    const level = await this.getBlockForRequest(keys, block);\n    const bigMapValues = new MichelsonMap<MichelsonMapKey, T | undefined>();\n\n    // Execute batch of promises in series\n    let position = 0;\n    let results: Array<T | undefined> = [];\n\n    while (position < keys.length) {\n      const keysBatch = keys.slice(position, position + batchSize);\n      const batch = keysBatch.map((keyToEncode) =>\n        this.getBigMapValueOrUndefined<T>(keyToEncode, id, schema, level)\n      );\n      results = [...results, ...(await Promise.all(batch))];\n      position += batchSize;\n    }\n\n    for (let i = 0; i < results.length; i++) {\n      bigMapValues.set(keys[i], results[i]);\n    }\n\n    return bigMapValues;\n  }\n\n  private async getBlockForRequest(keys: Array<BigMapKeyType>, block?: number) {\n    return keys.length === 1 || typeof block !== 'undefined'\n      ? block\n      : await this.context.readProvider.getBlockLevel('head');\n  }\n\n  private async getBigMapValueOrUndefined<T>(\n    keyToEncode: BigMapKeyType,\n    id: string,\n    schema: Schema,\n    level?: number\n  ) {\n    try {\n      return await this.getBigMapKeyByID<T>(id, keyToEncode, schema, level);\n    } catch (ex) {\n      if (ex instanceof HttpResponseError && ex.status === STATUS_CODE.NOT_FOUND) {\n        return;\n      } else {\n        throw ex;\n      }\n    }\n  }\n\n  /**\n   *\n   * @description Return a well formatted json object of a sapling state\n   *\n   * @param id Sapling state ID\n   * @param block optional block level to fetch the value from\n   *\n   */\n  async getSaplingDiffByID(id: string, block?: number) {\n    const saplingState = block\n      ? await this.context.readProvider.getSaplingDiffById({ id: id.toString() }, block)\n      : await this.context.readProvider.getSaplingDiffById({ id: id.toString() }, 'head');\n    return saplingState;\n  }\n\n  private async addRevealOperationIfNeeded(operation: RPCOperation, publicKeyHash: string) {\n    if (isOpRequireReveal(operation)) {\n      const ops: RPCOperation[] = [operation];\n      const publicKey = await this.signer.publicKey();\n      const estimateReveal = await this.estimator.reveal();\n      if (estimateReveal) {\n        const reveal: withKind<RevealParams, OpKind.REVEAL> = { kind: OpKind.REVEAL };\n        const estimatedReveal = await this.estimate(reveal, async () => estimateReveal);\n        ops.unshift(await createRevealOperation({ ...estimatedReveal }, publicKeyHash, publicKey));\n        return ops;\n      }\n    }\n    return operation;\n  }\n\n  /**\n   *\n   * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @warn You cannot specify storage and init at the same time (use init to pass the raw michelson representation of storage)\n   *\n   * @param OriginationOperation Originate operation parameter\n   */\n  async originate<TContract extends DefaultContractType = DefaultContractType>(\n    params: OriginateParams<ContractStorageType<TContract>>\n  ) {\n    const estimate = await this.estimate(params, this.estimator.originate.bind(this.estimator));\n\n    const publicKeyHash = await this.signer.publicKeyHash();\n    const operation = await createOriginationOperation(\n      await this.context.parser.prepareCodeOrigination({\n        ...params,\n        ...estimate,\n      })\n    );\n    const ops = await this.addRevealOperationIfNeeded(operation, publicKeyHash);\n    const preparedOrigination = await this.prepareOperation({\n      operation: ops,\n      source: publicKeyHash,\n    });\n    const forgedOrigination = await this.forge(preparedOrigination);\n    const { hash, context, forgedBytes, opResponse } = await this.signAndInject(forgedOrigination);\n    return new OriginationOperation<TContract>(\n      hash,\n      operation,\n      forgedBytes,\n      opResponse,\n      context,\n      this\n    );\n  }\n\n  /**\n   *\n   * @description Set the delegate for a contract. Will sign and inject an operation using the current context\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param SetDelegate operation parameter\n   */\n  async setDelegate(params: DelegateParams) {\n    if (params.source && validateAddress(params.source) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(params.source);\n    }\n    if (params.delegate && validateAddress(params.delegate) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(params.delegate);\n    }\n\n    // Since babylon delegation source cannot smart contract\n    if (/kt1/i.test(params.source)) {\n      throw new InvalidDelegationSource(params.source);\n    }\n\n    const estimate = await this.estimate(params, this.estimator.setDelegate.bind(this.estimator));\n    const publicKeyHash = await this.signer.publicKeyHash();\n    const operation = await createSetDelegateOperation({ ...params, ...estimate });\n    const sourceOrDefault = params.source || publicKeyHash;\n    const ops = await this.addRevealOperationIfNeeded(operation, publicKeyHash);\n    const prepared = await this.prepareOperation({\n      operation: ops,\n      source: sourceOrDefault,\n    });\n    const opBytes = await this.forge(prepared);\n    const { hash, context, forgedBytes, opResponse } = await this.signAndInject(opBytes);\n    return new DelegateOperation(\n      hash,\n      operation,\n      sourceOrDefault,\n      forgedBytes,\n      opResponse,\n      context\n    );\n  }\n\n  /**\n   *\n   * @description Register the current address as delegate. Will sign and inject an operation using the current context\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param RegisterDelegate operation parameter\n   */\n  async registerDelegate(params: RegisterDelegateParams) {\n    const estimate = await this.estimate(\n      params,\n      this.estimator.registerDelegate.bind(this.estimator)\n    );\n    const source = await this.signer.publicKeyHash();\n    const operation = await createRegisterDelegateOperation({ ...params, ...estimate }, source);\n    const ops = await this.addRevealOperationIfNeeded(operation, source);\n    const prepared = await this.prepareOperation({ operation: ops });\n    const opBytes = await this.forge(prepared);\n    const { hash, context, forgedBytes, opResponse } = await this.signAndInject(opBytes);\n    return new DelegateOperation(hash, operation, source, forgedBytes, opResponse, context);\n  }\n\n  /**\n   *\n   * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param Transfer operation parameter\n   */\n  async transfer(params: TransferParams) {\n    if (validateAddress(params.to) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(params.to);\n    }\n    if (params.source && validateAddress(params.source) !== ValidationResult.VALID) {\n      throw new InvalidAddressError(params.source);\n    }\n\n    const publickKeyHash = await this.signer.publicKeyHash();\n    const estimate = await this.estimate(params, this.estimator.transfer.bind(this.estimator));\n    const operation = await createTransferOperation({\n      ...params,\n      ...estimate,\n    });\n    const source = params.source || publickKeyHash;\n    const ops = await this.addRevealOperationIfNeeded(operation, publickKeyHash);\n    const prepared = await this.prepareOperation({ operation: ops, source: params.source });\n    const opBytes = await this.forge(prepared);\n    const { hash, context, forgedBytes, opResponse } = await this.signAndInject(opBytes);\n    return new TransactionOperation(hash, operation, source, forgedBytes, opResponse, context);\n  }\n\n  /**\n   *\n   * @description Reveal the current address. Will throw an error if the address is already revealed.\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param RevealParams operation parameter\n   */\n  async reveal(params: RevealParams) {\n    const publicKeyHash = await this.signer.publicKeyHash();\n    const estimateReveal = await this.estimator.reveal(params);\n    if (estimateReveal) {\n      const estimated = await this.estimate(params, async () => estimateReveal);\n      const operation = await createRevealOperation(\n        {\n          ...estimated,\n        },\n        publicKeyHash,\n        await this.signer.publicKey()\n      );\n      const prepared = await this.prepareOperation({ operation, source: publicKeyHash });\n      const opBytes = await this.forge(prepared);\n      const { hash, context, forgedBytes, opResponse } = await this.signAndInject(opBytes);\n      return new RevealOperation(hash, operation, publicKeyHash, forgedBytes, opResponse, context);\n    } else {\n      throw new RevealOperationError(\n        `The publicKeyHash '${publicKeyHash}' has already been revealed.`\n      );\n    }\n  }\n\n  /**\n   *\n   * @description Register a Micheline expression in a global table of constants. Will sign and inject an operation using the current context\n   *\n   * @returns An operation handle with the result from the rpc node\n   *\n   * @param params registerGlobalConstant operation parameter\n   */\n  async registerGlobalConstant(params: RegisterGlobalConstantParams) {\n    const publickKeyHash = await this.signer.publicKeyHash();\n    const estimate = await this.estimate(\n      params,\n      this.estimator.registerGlobalConstant.bind(this.estimator)\n    );\n    const operation = await createRegisterGlobalConstantOperation({\n      ...params,\n      ...estimate,\n    });\n    const ops = await this.addRevealOperationIfNeeded(operation, publickKeyHash);\n    const prepared = await this.prepareOperation({ operation: ops, source: publickKeyHash });\n    const opBytes = await this.forge(prepared);\n    const { hash, context, forgedBytes, opResponse } = await this.signAndInject(opBytes);\n    return new RegisterGlobalConstantOperation(\n      hash,\n      operation,\n      publickKeyHash,\n      forgedBytes,\n      opResponse,\n      context\n    );\n  }\n\n  async at<T extends DefaultContractType = DefaultContractType>(\n    address: string,\n    contractAbstractionComposer: ContractAbstractionComposer<T> = (x) => x as any\n  ): Promise<T> {\n    if (validateContractAddress(address) !== ValidationResult.VALID) {\n      throw new InvalidContractAddressError(address);\n    }\n    const rpc = this.context.withExtensions().rpc;\n    const readProvider = this.context.withExtensions().readProvider;\n    const script = await readProvider.getScript(address, 'head');\n    const entrypoints = await readProvider.getEntrypoints(address);\n    const abs = new ContractAbstraction(\n      address,\n      script,\n      this,\n      this,\n      entrypoints,\n      rpc,\n      readProvider\n    );\n    return contractAbstractionComposer(abs, this.context);\n  }\n\n  /**\n   *\n   * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\n   *\n   * @returns A batch object from which we can add more operation or send a command to execute the batch\n   *\n   * @param params List of operation to batch together\n   */\n  batch(params?: ParamsWithKind[]) {\n    const batch = new OperationBatch(this.context, this.estimator);\n\n    if (Array.isArray(params)) {\n      batch.with(params);\n    }\n\n    return batch;\n  }\n}\n\ntype ContractAbstractionComposer<T> = (\n  abs: ContractAbstraction<ContractProvider>,\n  context: Context\n) => T;\n","import { Context } from '../context';\nimport { ParserProvider } from './interface';\nimport { Expr, GlobalConstantHashAndValue, Parser, Prim, ProtocolID } from '@taquito/michel-codec';\nimport { OriginateParams } from '../operations/types';\nimport { InvalidInitParameter, InvalidCodeParameter } from '../contract/errors';\nimport { Schema } from '@taquito/michelson-encoder';\nimport { MichelsonV1Expression } from '@taquito/rpc';\nimport { Protocols } from '../constants';\n\nexport class MichelCodecParser implements ParserProvider {\n  constructor(private context: Context) {}\n\n  private async getNextProto(): Promise<ProtocolID> {\n    if (!this.context.proto) {\n      const nextProto = await this.context.readProvider.getNextProtocol('head');\n      this.context.proto = nextProto as Protocols;\n    }\n    return this.context.proto as ProtocolID;\n  }\n\n  async parseScript(src: string): Promise<Expr[] | null> {\n    const parser = new Parser({ protocol: await this.getNextProto() });\n    return parser.parseScript(src);\n  }\n\n  async parseMichelineExpression(src: string): Promise<Expr | null> {\n    const parser = new Parser({ protocol: await this.getNextProto() });\n    return parser.parseMichelineExpression(src);\n  }\n\n  async parseJSON(src: object): Promise<Expr> {\n    const parser = new Parser({ protocol: await this.getNextProto() });\n    return parser.parseJSON(src);\n  }\n\n  async prepareCodeOrigination(params: OriginateParams): Promise<OriginateParams> {\n    const parsedParams = params;\n    parsedParams.code = await this.formatCodeParam(params.code);\n    if (params.init) {\n      parsedParams.init = await this.formatInitParam(params.init);\n    } else if (params.storage) {\n      const storageType = (parsedParams.code as Expr[]).find(\n        (p): p is Prim => 'prim' in p && p.prim === 'storage'\n      );\n      if (!storageType?.args) {\n        throw new InvalidCodeParameter(\n          'The storage section is missing from the script',\n          params.code\n        );\n      }\n      const schema = new Schema(storageType.args[0] as MichelsonV1Expression);\n      const globalconstantsHashAndValue = await this.findGlobalConstantsHashAndValue(schema);\n\n      if (Object.keys(globalconstantsHashAndValue).length !== 0) {\n        // If there are global constants in the storage part of the contract code,\n        // they need to be locally expanded in order to encode the storage arguments\n        const p = new Parser({ expandGlobalConstant: globalconstantsHashAndValue });\n        const storageTypeNoGlobalConst = p.parseJSON(storageType.args[0]);\n        const schemaNoGlobalConst = new Schema(storageTypeNoGlobalConst);\n        parsedParams.init = schemaNoGlobalConst.Encode(params.storage);\n      } else {\n        parsedParams.init = schema.Encode(params.storage);\n      }\n      delete parsedParams.storage;\n    }\n    return parsedParams;\n  }\n\n  private async formatCodeParam(code: string | object[]) {\n    let parsedCode: Expr[];\n    if (typeof code === 'string') {\n      const c = await this.parseScript(code);\n      if (c === null) {\n        throw new InvalidCodeParameter('Invalid code parameter', code);\n      }\n      parsedCode = c;\n    } else {\n      const c = await this.parseJSON(code);\n      const order = ['parameter', 'storage', 'code'];\n      // Ensure correct ordering for RPC\n      parsedCode = (c as Prim[]).sort((a, b) => order.indexOf(a.prim) - order.indexOf(b.prim));\n    }\n    return parsedCode;\n  }\n\n  private async formatInitParam(init: string | object) {\n    let parsedInit: Expr;\n    if (typeof init === 'string') {\n      const c = await this.parseMichelineExpression(init);\n      if (c === null) {\n        throw new InvalidInitParameter('Invalid init parameter', init);\n      }\n      parsedInit = c;\n    } else {\n      parsedInit = await this.parseJSON(init);\n    }\n    return parsedInit;\n  }\n\n  private async findGlobalConstantsHashAndValue(schema: Schema) {\n    const globalConstantTokens = schema.findToken('constant');\n    const globalConstantsHashAndValue: GlobalConstantHashAndValue = {};\n\n    if (globalConstantTokens.length !== 0) {\n      for (const token of globalConstantTokens) {\n        const tokenArgs = token.tokenVal.args;\n        if (tokenArgs) {\n          const hash: string = tokenArgs[0]['string'];\n          const michelineValue = await this.context.globalConstantsProvider.getGlobalConstantByHash(\n            hash\n          );\n          Object.assign(globalConstantsHashAndValue, {\n            [hash]: michelineValue,\n          });\n        }\n      }\n    }\n    return globalConstantsHashAndValue;\n  }\n}\n","import { Packer } from './interface';\nimport { Context } from '../context';\nimport { PackDataParams, PackDataResponse } from '@taquito/rpc';\n\nexport class RpcPacker implements Packer {\n  constructor(private context: Context) {}\n  \n  async packData(data: PackDataParams): Promise<PackDataResponse> {\n    return this.context.rpc.packData(data);\n  }\n}\n","/**\n *  @category Error\n *  @description Error that indicates that a global constant does not exist\n */\nexport class GlobalConstantNotFound extends Error {\n  name = 'GlobalConstantNotFound';\n\n  constructor(public hash: string) {\n    super(\n      `Please load the value associated with the constant ${hash} using the loadGlobalConstant method of the DefaultGlobalConstantsProvider.`\n    );\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates the global constant provider not being configured under TezosToolkit\n */\nexport class UnconfiguredGlobalConstantsProviderError extends Error {\n  name = 'UnconfiguredGlobalConstantsProviderError';\n\n  constructor() {\n    super(\n      'No global constants provider has been configured. Please configure one by calling setGlobalConstantsProvider({globalConstantsProvider}) on your TezosToolkit instance.'\n    );\n  }\n}\n","import { Expr } from \"@taquito/michel-codec\";\nimport { UnconfiguredGlobalConstantsProviderError } from \"./error\";\nimport { GlobalConstantHash, GlobalConstantsProvider } from \"./interface-global-constants-provider\";\n\nexport class NoopGlobalConstantsProvider implements GlobalConstantsProvider {\n    async getGlobalConstantByHash(_hash: GlobalConstantHash): Promise<Expr> {\n        throw new UnconfiguredGlobalConstantsProviderError();\n    }\n}","import {\n  BlockResponse,\n  EntrypointsResponse,\n  MichelsonV1Expression,\n  SaplingDiffResponse,\n  ScriptedContracts,\n} from '@taquito/rpc';\nimport BigNumber from 'bignumber.js';\nimport { Context } from '../context';\nimport { BigMapQuery, BlockIdentifier, SaplingStateQuery, TzReadProvider } from './interface';\n\n/**\n * @description Converts calls from TzReadProvider into calls to the wrapped RpcClient in a format it can understand.\n */\nexport class RpcReadAdapter implements TzReadProvider {\n  constructor(private context: Context) {}\n\n  /**\n   * @description Access the balance of a contract.\n   * @param address address from which we want to retrieve the balance\n   * @param block from which we want to retrieve the balance\n   * @returns the balance in mutez\n   */\n  async getBalance(address: string, block: BlockIdentifier): Promise<BigNumber> {\n    return this.context.rpc.getBalance(address, { block: String(block) });\n  }\n\n  /**\n   * @description Access the delegate of a contract, if any.\n   * @param address contract address from which we want to retrieve the delegate (baker)\n   * @param block from which we want to retrieve the delegate\n   * @returns the public key hash of the delegate or null if no delegate\n   */\n  async getDelegate(address: string, block: BlockIdentifier): Promise<string | null> {\n    return this.context.rpc.getDelegate(address, { block: String(block) });\n  }\n\n  /**\n   * @description Access the next protocol hash\n   * @param block from which we want to retrieve the next protocol hash\n   */\n  async getNextProtocol(block: BlockIdentifier): Promise<string> {\n    const protocols = await this.context.rpc.getProtocols({ block: String(block) });\n    return protocols.next_protocol;\n  }\n\n  /**\n   * @description Access protocol constants used in Taquito\n   * @param block from which we want to retrieve the constants\n   */\n  async getProtocolConstants(block: BlockIdentifier): Promise<{\n    time_between_blocks?: BigNumber[];\n    minimal_block_delay?: BigNumber | undefined;\n    hard_gas_limit_per_operation: BigNumber;\n    hard_gas_limit_per_block: BigNumber;\n    hard_storage_limit_per_operation: BigNumber;\n    cost_per_byte: BigNumber;\n  }> {\n    const {\n      time_between_blocks,\n      minimal_block_delay,\n      hard_gas_limit_per_operation,\n      hard_gas_limit_per_block,\n      hard_storage_limit_per_operation,\n      cost_per_byte,\n    } = await this.context.rpc.getConstants({ block: String(block) });\n    return {\n      time_between_blocks,\n      minimal_block_delay,\n      hard_gas_limit_per_operation,\n      hard_gas_limit_per_block,\n      hard_storage_limit_per_operation,\n      cost_per_byte,\n    };\n  }\n\n  /**\n   * @description Access the script (code and storage) of a smart contract\n   * @param contract contract address from which we want to retrieve the script\n   * @param block from which we want to retrieve the storage value\n   * @returns Note: The code must be in the JSON format and not contain global constant\n   */\n  async getScript(contract: string, block: BlockIdentifier): Promise<ScriptedContracts> {\n    const { script } = await this.context.rpc.getContract(contract, { block: String(block) });\n    return script;\n  }\n\n  /**\n   * @description Access the storage value of a contract\n   * @param contract contract address from which we want to retrieve the storage\n   * @param block from which we want to retrieve the storage value\n   */\n  async getStorage(contract: string, block: BlockIdentifier): Promise<MichelsonV1Expression> {\n    return this.context.rpc.getStorage(contract, { block: String(block) });\n  }\n\n  /**\n   * @description Access the block hash\n   */\n  async getBlockHash(block: BlockIdentifier): Promise<string> {\n    const { hash } = await this.context.rpc.getBlockHeader({ block: String(block) });\n    return hash;\n  }\n\n  /**\n   * @description Access the block level\n   */\n  async getBlockLevel(block: BlockIdentifier): Promise<number> {\n    const { level } = await this.context.rpc.getBlockHeader({ block: String(block) });\n    return level;\n  }\n\n  /**\n   * @description Access the counter of an address\n   * @param pkh from which we want to retrieve the counter\n   * @param block from which we want to retrieve the counter\n   */\n  async getCounter(pkh: string, block: BlockIdentifier): Promise<string> {\n    const { counter } = await this.context.rpc.getContract(pkh, { block: String(block) });\n    return counter || '0';\n  }\n\n  /**\n   * @description Access the timestamp of a block\n   * @param block from which we want to retrieve the timestamp\n   * @returns date ISO format zero UTC offset (\"2022-01-19T22:37:07Z\")\n   */\n  async getBlockTimestamp(block: BlockIdentifier): Promise<string> {\n    const { timestamp } = await this.context.rpc.getBlockHeader({ block: String(block) });\n    return timestamp;\n  }\n\n  /**\n   * @description Access the value associated with a key in a big map.\n   * @param bigMapQuery Big Map ID and Expression hash to query (A b58check encoded Blake2b hash of the expression)\n   * @param block from which we want to retrieve the big map value\n   */\n  async getBigMapValue(\n    bigMapQuery: BigMapQuery,\n    block: BlockIdentifier\n  ): Promise<MichelsonV1Expression> {\n    return this.context.rpc.getBigMapExpr(bigMapQuery.id, bigMapQuery.expr, {\n      block: String(block),\n    });\n  }\n\n  /**\n   * @description Access the value associated with a sapling state ID.\n   * @param id Sapling state ID\n   * @param block from which we want to retrieve the sapling state\n   */\n  async getSaplingDiffById(\n    saplingStateQuery: SaplingStateQuery,\n    block: BlockIdentifier\n  ): Promise<SaplingDiffResponse> {\n    return this.context.rpc.getSaplingDiffById(saplingStateQuery.id, { block: String(block) });\n  }\n\n  /**\n   * @description Return the list of entrypoints of the contract\n   * @param contract address of the contract we want to get the entrypoints of\n   */\n  async getEntrypoints(contract: string): Promise<EntrypointsResponse> {\n    return this.context.rpc.getEntrypoints(contract);\n  }\n\n  /**\n   * @description Access the chain id\n   */\n  async getChainId(): Promise<string> {\n    return this.context.rpc.getChainId();\n  }\n\n  /**\n   * @description Indicate if an account is revealed\n   * @param publicKeyHash of the account\n   * @param block from which we want to know if the account is revealed\n   */\n  async isAccountRevealed(publicKeyHash: string, block: BlockIdentifier): Promise<boolean> {\n    const manager = await this.context.rpc.getManagerKey(publicKeyHash, { block: String(block) });\n    const haveManager = manager && typeof manager === 'object' ? !!manager.key : !!manager;\n    return haveManager;\n  }\n\n  /**\n   * @description Return all the information about a block\n   * @param block from which we want to retrieve the information\n   */\n  async getBlock(block: BlockIdentifier): Promise<BlockResponse> {\n    return this.context.rpc.getBlock({ block: String(block) });\n  }\n\n  /**\n   * @description Return a list of the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.\n   * @param block from which we want to retrieve the information\n   */\n  getLiveBlocks(block: BlockIdentifier): Promise<string[]> {\n    return this.context.rpc.getLiveBlocks({ block: String(block) });\n  }\n}\n","import {\n  OpFilter,\n  FilterExpression,\n  Filter,\n  OpHashFilter,\n  SourceFilter,\n  KindFilter,\n  DestinationFilter,\n  OperationContent,\n} from './interface';\n\nimport { InvalidFilterExpressionError } from '../error';\n\nconst opHashFilter = (op: OperationContent, filter: OpHashFilter) => op.hash === filter.opHash;\n\nconst sourceFilter = (x: OperationContent, filter: SourceFilter) => {\n  switch (x.kind) {\n    case 'endorsement':\n      return 'metadata' in x && x.metadata.delegate === filter.source;\n    case 'activate_account':\n      return 'metadata' in x && x.pkh === filter.source;\n    default:\n      return 'source' in x && x.source === filter.source;\n  }\n};\n\nconst kindFilter = (x: OperationContent, filter: KindFilter) =>\n  'kind' in x && x.kind === filter.kind;\n\nconst destinationFilter = (x: OperationContent, filter: DestinationFilter) => {\n  switch (x.kind) {\n    case 'delegation':\n      return x.delegate === filter.destination;\n    case 'origination':\n      if (\n        'metadata' in x &&\n        'operation_result' in x.metadata &&\n        'originated_contracts' in x.metadata.operation_result &&\n        Array.isArray(x.metadata.operation_result.originated_contracts)\n      ) {\n        return x.metadata.operation_result.originated_contracts.some(\n          (contract) => contract === filter.destination\n        );\n      }\n      break;\n    case 'transaction':\n      return x.destination === filter.destination;\n    default:\n      return false;\n  }\n};\n\nexport const evaluateOpFilter = (op: OperationContent, filter: OpFilter) => {\n  if ('opHash' in filter) {\n    return opHashFilter(op, filter);\n  } else if ('source' in filter) {\n    return sourceFilter(op, filter);\n  } else if ('kind' in filter) {\n    return kindFilter(op, filter);\n  } else if ('destination' in filter) {\n    return destinationFilter(op, filter);\n  }\n\n  return false;\n};\n\nexport const evaluateExpression = (op: OperationContent, exp: FilterExpression): boolean => {\n  if (Array.isArray(exp.and)) {\n    return exp.and.every((x: OpFilter | FilterExpression) => evaluateFilter(op, x));\n  } else if (Array.isArray(exp.or)) {\n    return exp.or.some((x: OpFilter | FilterExpression) => evaluateFilter(op, x));\n  } else {\n    throw new InvalidFilterExpressionError('Filter expression must contain either and/or property');\n  }\n};\n\nexport const evaluateFilter = (op: OperationContent, filter: Filter): boolean => {\n  const filters: OpFilter[] | FilterExpression[] = [];\n  if (!Array.isArray(filter)) {\n    filters.push(filter as any);\n  } else {\n    filters.push(...(filter as any));\n  }\n\n  return (filters as any[]).every((filterOrExp: OpFilter | FilterExpression) => {\n    if ('and' in filterOrExp || 'or' in filterOrExp) {\n      return evaluateExpression(op, filterOrExp);\n    } else {\n      return evaluateOpFilter(op, filterOrExp as OpFilter);\n    }\n  });\n};\n","/* eslint-disable no-dupe-class-members */\nimport { Observable, Subject, NEVER, OperatorFunction } from 'rxjs';\nimport { Subscription } from './interface';\nimport { takeUntil, tap, catchError, retry } from 'rxjs/operators';\n\n/**\n *  @category Error\n *  @description Error that indicates an unsupported event being passed or used\n */\nexport class UnsupportedEventError extends Error {\n  public name = 'UnsupportedEventError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\nexport class ObservableSubscription<T> implements Subscription<T> {\n  private errorListeners: Array<(error: Error) => void> = [];\n  private messageListeners: Array<(data: T) => void> = [];\n  private closeListeners: Array<() => void> = [];\n  private completed$ = new Subject();\n\n  constructor(\n    obs: Observable<T>,\n    private shouldRetry: boolean = false,\n    private operatorFunction: OperatorFunction<T, T> = retry<T>()\n  ) {\n    obs\n      .pipe(\n        takeUntil(this.completed$),\n        tap(\n          (data: T) => {\n            this.call(this.messageListeners, data);\n          },\n          (error) => {\n            this.call(this.errorListeners, error);\n          },\n          () => {\n            this.call(this.closeListeners);\n          }\n        ),\n        this.shouldRetry ? operatorFunction : tap(),\n        catchError(() => NEVER)\n      )\n      .subscribe();\n  }\n\n  private call<K>(listeners: Array<(val: K) => void>, value?: K) {\n    for (const l of listeners) {\n      try {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        l(value!);\n      } catch (ex) {\n        console.error(ex);\n      }\n    }\n  }\n\n  private remove(listeners: Array<any>, value: any) {\n    const idx = listeners.indexOf(value);\n    if (idx !== -1) {\n      listeners.splice(idx, 1);\n    }\n  }\n\n  public on(type: 'error', cb: (error: Error) => void): void;\n  public on(type: 'data', cb: (data: T) => void): void;\n  public on(type: 'close', cb: () => void): void;\n\n  public on(type: 'data' | 'error' | 'close', cb: any): void {\n    switch (type) {\n      case 'data':\n        this.messageListeners.push(cb);\n        break;\n      case 'error':\n        this.errorListeners.push(cb);\n        break;\n      case 'close':\n        this.closeListeners.push(cb);\n        break;\n      default:\n        throw new UnsupportedEventError(`Trying to register on an unsupported event: ${type}`);\n    }\n  }\n\n  public off(type: 'error', cb: (error: Error) => void): void;\n  public off(type: 'data', cb: (data: T) => void): void;\n  public off(type: 'close', cb: () => void): void;\n\n  public off(type: 'data' | 'error' | 'close', cb: any): void {\n    switch (type) {\n      case 'data':\n        this.remove(this.messageListeners, cb);\n        break;\n      case 'error':\n        this.remove(this.errorListeners, cb);\n        break;\n      case 'close':\n        this.remove(this.closeListeners, cb);\n        break;\n      default:\n        throw new UnsupportedEventError(`Trying to unregister on an unsupported event: ${type}`);\n    }\n  }\n\n  public close() {\n    this.completed$.next();\n  }\n}\n","import { BlockResponse } from '@taquito/rpc';\nimport { BehaviorSubject, from, Observable, ObservableInput, OperatorFunction, timer } from 'rxjs';\nimport {\n  concatMap,\n  distinctUntilKeyChanged,\n  first,\n  pluck,\n  publish,\n  refCount,\n  retry,\n  switchMap,\n} from 'rxjs/operators';\nimport { Context } from '../context';\nimport { evaluateFilter } from './filters';\nimport { Filter, SubscribeProvider, Subscription, OperationContent } from './interface';\nimport { ObservableSubscription } from './observable-subscription';\nimport BigNumber from 'bignumber.js';\n\nexport interface PollingSubscribeProviderConfig {\n  pollingIntervalMilliseconds?: number;\n  shouldObservableSubscriptionRetry: boolean;\n  observableSubscriptionRetryFunction: OperatorFunction<any, any>;\n}\n\nexport const defaultConfigStreamer: PollingSubscribeProviderConfig = {\n  shouldObservableSubscriptionRetry: false,\n  observableSubscriptionRetryFunction: retry(),\n};\n\nconst getLastBlock = (context: Context) => {\n  return from(context.rpc.getBlock()).pipe(first());\n};\n\nconst applyFilter = (filter: Filter) =>\n  concatMap<BlockResponse, ObservableInput<OperationContent>>((block) => {\n    return new Observable<OperationContent>((sub) => {\n      for (const ops of block.operations) {\n        for (const op of ops) {\n          for (const content of op.contents) {\n            if (evaluateFilter({ hash: op.hash, ...content }, filter)) {\n              sub.next({ hash: op.hash, ...content });\n            }\n          }\n        }\n      }\n      sub.complete();\n    });\n  });\n\nexport class PollingSubscribeProvider implements SubscribeProvider {\n  private _config$: BehaviorSubject<PollingSubscribeProviderConfig>;\n  // Map the changing polling interval to a timer, which will automatically terminate the previous timer when the next one starts.\n  private timer$: Observable<number>;\n\n  private newBlock$: Observable<BlockResponse>;\n\n  constructor(private context: Context, config: Partial<PollingSubscribeProviderConfig> = {}) {\n    this._config$ = new BehaviorSubject({\n      ...defaultConfigStreamer,\n      ...config,\n    });\n    this.timer$ = this._config$.pipe(\n      pluck('pollingIntervalMilliseconds'),\n      switchMap((pollingIntervalMilliseconds) => {\n        if (!pollingIntervalMilliseconds) {\n          return from(this.getConfirmationPollingInterval()).pipe(\n            switchMap((interval) => {\n              return timer(0, interval);\n            })\n          );\n        } else {\n          return timer(0, pollingIntervalMilliseconds);\n        }\n      })\n    );\n    this.newBlock$ = this.timer$.pipe(\n      switchMap(() => getLastBlock(this.context)),\n      distinctUntilKeyChanged('hash'),\n      publish(),\n      refCount()\n    );\n  }\n\n  get config() {\n    return this._config$.getValue();\n  }\n\n  private async getConfirmationPollingInterval() {\n    if (!this.config.pollingIntervalMilliseconds) {\n      const defaultIntervalTestnetsMainnet = 5000;\n      const defaultIntervalSandbox = 1000;\n      try {\n        const constants = await this.context.readProvider.getProtocolConstants('head');\n        const blockTime = constants.minimal_block_delay\n          ? constants.minimal_block_delay.multipliedBy(1000)\n          : constants.time_between_blocks\n          ? constants.time_between_blocks[0].multipliedBy(1000)\n          : new BigNumber(defaultIntervalTestnetsMainnet);\n        const confirmationPollingInterval = blockTime.dividedBy(3);\n\n        this.config.pollingIntervalMilliseconds =\n          confirmationPollingInterval.toNumber() === 0\n            ? defaultIntervalSandbox\n            : confirmationPollingInterval.toNumber();\n      } catch (exception) {\n        return defaultIntervalTestnetsMainnet;\n      }\n    }\n    return this.config.pollingIntervalMilliseconds;\n  }\n\n  subscribeBlock(_filter: 'head'): Subscription<BlockResponse> {\n    return new ObservableSubscription(\n      this.newBlock$,\n      this.config.shouldObservableSubscriptionRetry,\n      this.config.observableSubscriptionRetryFunction\n    );\n  }\n\n  subscribe(_filter: 'head'): Subscription<string> {\n    return new ObservableSubscription(\n      this.newBlock$.pipe(pluck('hash')),\n      this.config.shouldObservableSubscriptionRetry,\n      this.config.observableSubscriptionRetryFunction\n    );\n  }\n\n  subscribeOperation(filter: Filter): Subscription<OperationContent> {\n    return new ObservableSubscription(\n      this.newBlock$.pipe(applyFilter(filter)),\n      this.config.shouldObservableSubscriptionRetry,\n      this.config.observableSubscriptionRetryFunction\n    );\n  }\n}\n","import {\n  LocalForger,\n  Forger,\n  ForgeParams,\n  ForgeResponse,\n  ProtocolsHash,\n} from '@taquito/local-forging';\nimport { Protocols } from '../constants';\nimport { Context } from '../context';\n\nexport class TaquitoLocalForger implements Forger {\n  constructor(private context: Context) {}\n\n  private async getNextProto(): Promise<ProtocolsHash> {\n    if (!this.context.proto) {\n      const nextProto = await this.context.readProvider.getNextProtocol('head');\n      this.context.proto = nextProto as Protocols;\n    }\n    return this.context.proto as unknown as ProtocolsHash;\n  }\n\n  async forge({ branch, contents }: ForgeParams): Promise<ForgeResponse> {\n    const forger = new LocalForger(await this.getNextProto());\n    return forger.forge({ branch, contents });\n  }\n}\n","import { RpcClient, RpcClientInterface } from '@taquito/rpc';\nimport { Protocols } from './constants';\nimport { Forger } from '@taquito/local-forging';\nimport { Injector } from './injector/interface';\nimport { RpcInjector } from './injector/rpc-injector';\nimport { Signer } from './signer/interface';\nimport { NoopSigner } from './signer/noop';\nimport { OperationFactory } from './wallet/operation-factory';\nimport { RpcTzProvider } from './tz/rpc-tz-provider';\nimport { RPCEstimateProvider } from './estimate/rpc-estimate-provider';\nimport { RpcContractProvider } from './contract/rpc-contract-provider';\nimport { RPCBatchProvider } from './batch/rpc-batch-provider';\n\nimport { Wallet, LegacyWalletProvider, WalletProvider } from './wallet';\nimport { ParserProvider } from './parser/interface';\nimport { MichelCodecParser } from './parser/michel-codec-parser';\nimport { Packer } from './packer/interface';\nimport { RpcPacker } from './packer/rpc-packer';\nimport { BehaviorSubject } from 'rxjs';\nimport { GlobalConstantsProvider } from './global-constants/interface-global-constants-provider';\nimport { NoopGlobalConstantsProvider } from './global-constants/noop-global-constants-provider';\nimport { TzReadProvider } from './read-provider/interface';\nimport { RpcReadAdapter } from './read-provider/rpc-read-adapter';\nimport { SubscribeProvider } from './subscribe/interface';\nimport { PollingSubscribeProvider } from './subscribe/polling-subcribe-provider';\nimport { TaquitoLocalForger } from './forger/taquito-local-forger';\n\nexport interface TaquitoProvider<T, K extends Array<any>> {\n  new (context: Context, ...rest: K): T;\n}\n\nexport interface ConfigConfirmation {\n  confirmationPollingTimeoutSecond: number;\n  defaultConfirmationCount: number;\n}\n\nexport const defaultConfigConfirmation: ConfigConfirmation = {\n  defaultConfirmationCount: 1,\n  confirmationPollingTimeoutSecond: 180,\n};\n\n/**\n * @description Encapsulate common service used throughout different part of the library\n */\nexport class Context {\n  private _rpcClient: RpcClientInterface;\n  private _forger: Forger;\n  private _parser: ParserProvider;\n  private _injector: Injector;\n  private _walletProvider: WalletProvider;\n  public readonly operationFactory: OperationFactory;\n  private _packer: Packer;\n  private providerDecorator: Array<(context: Context) => Context> = [];\n  private _globalConstantsProvider: GlobalConstantsProvider;\n  private _readProvider: TzReadProvider;\n  private _stream: SubscribeProvider;\n  public readonly tz = new RpcTzProvider(this);\n  public readonly estimate = new RPCEstimateProvider(this);\n  public readonly contract = new RpcContractProvider(this, this.estimate);\n  public readonly batch = new RPCBatchProvider(this, this.estimate);\n  public readonly wallet = new Wallet(this);\n\n  constructor(\n    private _rpc: RpcClientInterface | string,\n    private _signer: Signer = new NoopSigner(),\n    private _proto?: Protocols,\n    public readonly _config = new BehaviorSubject({\n      ...defaultConfigConfirmation,\n    }),\n    forger?: Forger,\n    injector?: Injector,\n    packer?: Packer,\n    wallet?: WalletProvider,\n    parser?: ParserProvider,\n    globalConstantsProvider?: GlobalConstantsProvider,\n    readProvider?: TzReadProvider,\n    stream?: SubscribeProvider\n  ) {\n    if (typeof this._rpc === 'string') {\n      this._rpcClient = new RpcClient(this._rpc);\n    } else {\n      this._rpcClient = this._rpc;\n    }\n    this._forger = forger ? forger : new TaquitoLocalForger(this);\n    this._injector = injector ? injector : new RpcInjector(this);\n    this.operationFactory = new OperationFactory(this);\n    this._walletProvider = wallet ? wallet : new LegacyWalletProvider(this);\n    this._parser = parser ? parser : new MichelCodecParser(this);\n    this._packer = packer ? packer : new RpcPacker(this);\n    this._globalConstantsProvider = globalConstantsProvider\n      ? globalConstantsProvider\n      : new NoopGlobalConstantsProvider();\n    this._readProvider = readProvider ? readProvider : new RpcReadAdapter(this);\n    this._stream = stream ? stream : new PollingSubscribeProvider(this);\n  }\n\n  get config(): ConfigConfirmation {\n    return this._config.getValue();\n  }\n\n  set config(value: ConfigConfirmation) {\n    this._config.next({\n      ...value,\n    });\n  }\n\n  setPartialConfig(value: Partial<ConfigConfirmation>) {\n    this._config.next({\n      ...this._config.getValue(),\n      ...value,\n    });\n  }\n\n  get rpc(): RpcClientInterface {\n    return this._rpcClient;\n  }\n\n  set rpc(value: RpcClientInterface) {\n    this._rpcClient = value;\n  }\n\n  get injector() {\n    return this._injector;\n  }\n\n  set injector(value: Injector) {\n    this._injector = value;\n  }\n\n  get forger() {\n    return this._forger;\n  }\n\n  set forger(value: Forger) {\n    this._forger = value;\n  }\n\n  get signer() {\n    return this._signer;\n  }\n\n  set signer(value: Signer) {\n    this._signer = value;\n  }\n\n  get walletProvider() {\n    return this._walletProvider;\n  }\n\n  set walletProvider(value: WalletProvider) {\n    this._walletProvider = value;\n  }\n\n  set proto(value: Protocols | undefined) {\n    this._proto = value;\n  }\n\n  get proto() {\n    return this._proto;\n  }\n\n  get parser() {\n    return this._parser;\n  }\n\n  set parser(value: ParserProvider) {\n    this._parser = value;\n  }\n\n  get packer() {\n    return this._packer;\n  }\n\n  set packer(value: Packer) {\n    this._packer = value;\n  }\n\n  get globalConstantsProvider() {\n    return this._globalConstantsProvider;\n  }\n\n  set globalConstantsProvider(value: GlobalConstantsProvider) {\n    this._globalConstantsProvider = value;\n  }\n\n  get readProvider() {\n    return this._readProvider;\n  }\n\n  set readProvider(value: TzReadProvider) {\n    this._readProvider = value;\n  }\n\n  get stream() {\n    return this._stream;\n  }\n\n  set stream(value: SubscribeProvider) {\n    this._stream = value;\n  }\n\n  async isAnyProtocolActive(protocol: string[] = []) {\n    if (this._proto) {\n      return protocol.includes(this._proto);\n    } else {\n      const next_protocol = await this.readProvider.getNextProtocol('head');\n      return protocol.includes(next_protocol);\n    }\n  }\n\n  isAnySignerConfigured() {\n    return !(this.signer instanceof NoopSigner);\n  }\n\n  /**\n   * @description Create a copy of the current context. Useful when you have long running operation and you do not want a context change to affect the operation\n   */\n  clone(): Context {\n    return new Context(\n      this.rpc,\n      this.signer,\n      this.proto,\n      this._config,\n      this.forger,\n      this._injector,\n      this.packer,\n      this._walletProvider,\n      this._parser,\n      this._globalConstantsProvider,\n      this._readProvider,\n      this._stream\n    );\n  }\n\n  /**\n   * @description Allows extensions set on the TezosToolkit to inject logic into the context\n   */\n  registerProviderDecorator(fx: (context: Context) => Context) {\n    this.providerDecorator.push(fx);\n  }\n\n  /**\n   * @description Applies the decorators on a cloned instance of the context and returned this cloned instance.\n   * The decorators are functions that inject logic into the context.\n   * They are provided by the extensions set on the TezosToolkit by calling the registerProviderDecorator method.\n   */\n  withExtensions = (): Context => {\n    let clonedContext = this.clone();\n    this.providerDecorator.forEach((decorator) => {\n      clonedContext = decorator(clonedContext);\n    });\n\n    return clonedContext;\n  };\n}\n","\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\nexport const VERSION = {\n    \"commitHash\": \"cbdd0af87e400489076259d065e2d328feb8e1b4\",\n    \"version\": \"12.1.0\"\n};\n","import { Forger, ForgeParams, ForgeResponse } from '@taquito/local-forging';\n\n/**\n *  @category Error\n *  @description Error that indicates a value mismatch when forging\n */\nexport class ForgingMismatchError extends Error {\n  name = 'ForgingMismatchError';\n  constructor(public results: string[]) {\n    super('Forging mismatch error');\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates a forger not being specified in TezosToolkit\n */\nexport class UnspecifiedForgerError extends Error {\n  name = 'UnspecifiedForgerError';\n  constructor() {\n    super('At least one forger must be specified');\n  }\n}\n\nexport class CompositeForger implements Forger {\n  constructor(private forgers: Forger[]) {\n    if (forgers.length === 0) {\n      throw new UnspecifiedForgerError();\n    }\n  }\n\n  async forge({ branch, contents }: ForgeParams): Promise<ForgeResponse> {\n    const results = await Promise.all(\n      this.forgers.map((forger) => {\n        return forger.forge({ branch, contents });\n      })\n    );\n\n    if (results.length === 0) {\n      throw new UnspecifiedForgerError();\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    let lastResult: string = results.pop()!; // Assumed to be more than one since we\n    while (results.length) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      const currentResult = results.pop()!;\n\n      if (currentResult !== lastResult) {\n        throw new ForgingMismatchError([lastResult, currentResult]);\n      }\n      lastResult = currentResult;\n    }\n\n    return lastResult;\n  }\n}\n","import { Forger, ForgeParams, ForgeResponse } from '@taquito/local-forging';\nimport { Context } from '../context';\n\nexport class RpcForger implements Forger {\n  constructor(private context: Context) {}\n\n  forge({ branch, contents }: ForgeParams): Promise<ForgeResponse> {\n    return this.context.rpc.forgeOperations({ branch, contents });\n  }\n}\n","import { OriginateParams } from \"../operations/types\";\nimport { ParserProvider } from \"./interface\";\n\nexport class NoopParser implements ParserProvider {\n    async prepareCodeOrigination(params: OriginateParams): Promise<OriginateParams> {\n        return params;\n    }\n}","import { Packer } from './interface';\nimport { packDataBytes, MichelsonData, MichelsonType } from '@taquito/michel-codec'\nimport { PackDataResponse, PackDataParams } from '@taquito/rpc';\n\nexport class MichelCodecPacker implements Packer {\n\n  async packData(data: PackDataParams): Promise<PackDataResponse> {\n    const { bytes } = packDataBytes(data.data as MichelsonData, data.type as MichelsonType);\n    return { packed: bytes }\n  }\n}\n","import { GlobalConstantHashAndValue } from '@taquito/michel-codec';\nimport { GlobalConstantNotFound } from './error';\nimport { GlobalConstantHash, GlobalConstantsProvider } from './interface-global-constants-provider';\n\nexport class DefaultGlobalConstantsProvider implements GlobalConstantsProvider {\n  private _globalConstantsLibrary: GlobalConstantHashAndValue = {};\n\n  /**\n   *\n   * @description Allows to load global constant hashes and their corresponding Michelson JSON values\n   */\n  loadGlobalConstant(globalConstant: GlobalConstantHashAndValue) {\n    for (const hash in globalConstant) {\n      Object.assign(this._globalConstantsLibrary, {\n        [hash]: globalConstant[hash],\n      });\n    }\n  }\n\n  /**\n   *\n   * @description Retrieve the Michelson value of a global constant based on its hash\n   *\n   * @param hash a string representing the global constant hash\n   * @returns Expr, the JSON Michelson value\n   */\n  async getGlobalConstantByHash(hash: GlobalConstantHash) {\n    const value = this._globalConstantsLibrary[hash];\n    if (!value) {\n      throw new GlobalConstantNotFound(hash);\n    }\n    return value;\n  }\n}\n","import { DEFAULT_FEE, DEFAULT_GAS_LIMIT, DEFAULT_STORAGE_LIMIT, Protocols } from '../constants';\nimport {\n  OriginateParams,\n  TransferParams,\n  ParamsWithKind,\n  RegisterGlobalConstantParams,\n} from '../operations/types';\nimport { Estimate } from './estimate';\nimport { EstimationProvider } from '../estimate/estimate-provider-interface';\nimport { InvalidOperationKindError } from '@taquito/utils';\n\n/**\n * @description Nave implementation of an estimate provider. Will work for basic transaction but your operation risk to fail if they are more complex (smart contract interaction)\n *\n * @deprecated Deprecated in favor of RPCEstimateProvider\n */\nexport class NaiveEstimateProvider implements EstimationProvider {\n  private _costPerByte: number;\n  constructor(private readonly protocol: Protocols) {\n    this._costPerByte = 250;\n  }\n  registerGlobalConstant(params: RegisterGlobalConstantParams): Promise<Estimate> {\n    throw new InvalidOperationKindError((params as any).kind);\n  }\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for an origination operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param OriginationOperation Originate operation parameter\n   */\n  async originate({\n    fee = DEFAULT_FEE.ORIGINATION,\n    storageLimit = DEFAULT_STORAGE_LIMIT.ORIGINATION,\n    gasLimit = DEFAULT_GAS_LIMIT.ORIGINATION * 1000,\n  }: OriginateParams) {\n    return new Estimate(gasLimit, storageLimit, 185, this._costPerByte, fee);\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for an transfer operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param TransferOperation Originate operation parameter\n   */\n  async transfer({\n    fee = DEFAULT_FEE.TRANSFER,\n    storageLimit = DEFAULT_STORAGE_LIMIT.TRANSFER,\n    gasLimit = DEFAULT_GAS_LIMIT.TRANSFER * 1000,\n  }: TransferParams) {\n    return new Estimate(gasLimit, storageLimit, 162, this._costPerByte, fee);\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param Estimate\n   */\n  async setDelegate({\n    fee = DEFAULT_FEE.DELEGATION,\n    gasLimit = DEFAULT_GAS_LIMIT.DELEGATION * 1000,\n  }): Promise<Estimate> {\n    return new Estimate(gasLimit, 0, 157, this._costPerByte, fee);\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for a delegate operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param Estimate\n   */\n  async registerDelegate({\n    fee = DEFAULT_FEE.DELEGATION,\n    gasLimit = DEFAULT_GAS_LIMIT.DELEGATION * 1000,\n  }): Promise<Estimate> {\n    return new Estimate(gasLimit, 0, 157, this._costPerByte, fee);\n  }\n\n  /**\n   *\n   * @description Estimate gasLimit, storageLimit and fees for a reveal operation\n   *\n   * @returns An estimation of gasLimit, storageLimit and fees for the operation\n   *\n   * @param Estimate\n   */\n  async reveal() {\n    return new Estimate(\n      DEFAULT_GAS_LIMIT.REVEAL * 1000,\n      DEFAULT_STORAGE_LIMIT.REVEAL,\n      64,\n      this._costPerByte,\n      DEFAULT_FEE.REVEAL\n    );\n  }\n\n  async batch(params: ParamsWithKind[]) {\n    const estimates: Estimate[] = [];\n    for (const param of params) {\n      switch (param.kind) {\n        case 'transaction':\n          estimates.push(await this.transfer(param));\n          break;\n        case 'origination':\n          estimates.push(await this.originate(param));\n          break;\n        case 'delegation':\n          estimates.push(await this.setDelegate(param));\n          break;\n        case 'activate_account':\n          estimates.push(new Estimate(0, 0, 0, this._costPerByte, 0));\n          break;\n        default:\n          throw new InvalidOperationKindError((params as any).kind);\n      }\n    }\n    return estimates;\n  }\n}\n","/**\n * @packageDocumentation\n * @module @taquito/taquito\n */\n\nimport { RpcClient, RpcClientInterface } from '@taquito/rpc';\nimport { Forger } from '@taquito/local-forging';\nimport { RPCBatchProvider } from './batch/rpc-batch-provider';\nimport { Protocols } from './constants';\nimport { ConfigConfirmation, Context, TaquitoProvider } from './context';\nimport { ContractProvider } from './contract/interface';\nimport { Extension } from './extension/extension';\nimport { format } from './format';\nimport { GlobalConstantsProvider } from './global-constants/interface-global-constants-provider';\nimport { NoopGlobalConstantsProvider } from './global-constants/noop-global-constants-provider';\nimport { Packer } from './packer/interface';\nimport { RpcPacker } from './packer/rpc-packer';\nimport { TzReadProvider } from './read-provider/interface';\nimport { RpcReadAdapter } from './read-provider/rpc-read-adapter';\nimport { Signer } from './signer/interface';\nimport { NoopSigner } from './signer/noop';\nimport { SubscribeProvider } from './subscribe/interface';\nimport { PollingSubscribeProvider } from './subscribe/polling-subcribe-provider';\nimport { TzProvider } from './tz/interface';\nimport { VERSION } from './version';\nimport { LegacyWalletProvider, Wallet, WalletProvider } from './wallet';\nimport { OperationFactory } from './wallet/operation-factory';\nimport { TaquitoLocalForger } from './forger/taquito-local-forger';\nimport { EstimationProvider } from './estimate/estimate-provider-interface';\n\nexport { MichelsonMap, UnitValue } from '@taquito/michelson-encoder';\nexport { Forger, ForgeParams, ForgeResponse } from '@taquito/local-forging';\nexport * from './constants';\nexport * from './context';\nexport { TaquitoProvider } from './context';\nexport * from './contract';\nexport * from './contract/big-map';\nexport { CompositeForger } from './forger/composite-forger';\nexport { RpcForger } from './forger/rpc-forger';\nexport * from './operations';\nexport { OperationBatch } from './batch/rpc-batch-provider';\nexport * from './signer/interface';\nexport * from './subscribe/interface';\nexport { SubscribeProvider } from './subscribe/interface';\nexport { PollingSubscribeProvider } from './subscribe/polling-subcribe-provider';\nexport { ObservableSubscription } from './subscribe/observable-subscription';\nexport * from './tz/interface';\nexport * from './wallet';\nexport { Extension } from './extension/extension';\nexport * from './parser/interface';\nexport * from './parser/michel-codec-parser';\nexport * from './parser/noop-parser';\nexport * from './packer/interface';\nexport * from './packer/michel-codec-packer';\nexport * from './packer/rpc-packer';\nexport * from './global-constants/default-global-constants-provider';\nexport * from './global-constants/error';\nexport * from './global-constants/interface-global-constants-provider';\nexport {\n  BigMapQuery,\n  SaplingStateQuery,\n  BlockIdentifier,\n  TzReadProvider,\n} from './read-provider/interface';\nexport { RpcReadAdapter } from './read-provider/rpc-read-adapter';\nexport * from './estimate';\nexport { TaquitoLocalForger } from './forger/taquito-local-forger';\n\nexport interface SetProviderOptions {\n  forger?: Forger;\n  wallet?: WalletProvider;\n  rpc?: string | RpcClientInterface;\n  readProvider?: TzReadProvider;\n  stream?: string | SubscribeProvider;\n  signer?: Signer;\n  protocol?: Protocols;\n  config?: Partial<ConfigConfirmation>;\n  packer?: Packer;\n  globalConstantsProvider?: GlobalConstantsProvider;\n}\n\nexport interface VersionInfo {\n  commitHash: string;\n  version: string;\n}\n\n/**\n * @description Facade class that surfaces all of the libraries capability and allow it's configuration\n *\n * @param _rpc The RPC server to use\n */\nexport class TezosToolkit {\n  private _options: SetProviderOptions = {};\n  private _rpcClient: RpcClientInterface;\n  private _wallet: Wallet;\n  private _context: Context;\n  /**\n   * @deprecated TezosToolkit.batch has been deprecated in favor of TezosToolkit.contract.batch\n   *\n   */\n  public batch: RPCBatchProvider['batch'];\n\n  public readonly format = format;\n\n  constructor(private _rpc: RpcClientInterface | string) {\n    if (typeof this._rpc === 'string') {\n      this._rpcClient = new RpcClient(this._rpc);\n    } else {\n      this._rpcClient = this._rpc;\n    }\n    this._context = new Context(_rpc);\n    this._wallet = new Wallet(this._context);\n    this.setProvider({ rpc: this._rpcClient });\n    this.batch = this._context.batch.batch.bind(this._context.batch);\n  }\n\n  /**\n   * @description Sets configuration on the Tezos Taquito instance. Allows user to choose which signer, rpc client, rpc url, forger and so forth\n   *\n   * @param options rpc url or rpcClient to use to interact with the Tezos network\n   *\n   * @example Tezos.setProvider({rpc: 'https://mainnet.api.tez.ie/', signer: new InMemorySigner.fromSecretKey(edsk...)})\n   * @example Tezos.setProvider({ config: { confirmationPollingTimeoutSecond: 300 }})\n   *\n   */\n\n  setProvider({\n    rpc,\n    stream,\n    signer,\n    protocol,\n    config,\n    forger,\n    wallet,\n    packer,\n    globalConstantsProvider,\n    readProvider,\n  }: SetProviderOptions) {\n    this.setRpcProvider(rpc);\n    this.setStreamProvider(stream);\n    this.setSignerProvider(signer);\n    this.setForgerProvider(forger);\n    this.setWalletProvider(wallet);\n    this.setPackerProvider(packer);\n    this.setGlobalConstantsProvider(globalConstantsProvider);\n    this.setReadProvider(readProvider);\n\n    this._context.proto = protocol;\n    if (config) {\n      this._context.setPartialConfig(config);\n    }\n  }\n\n  /**\n   * @description Sets signer provider on the Tezos Taquito instance.\n   *\n   * @param options signer to use to interact with the Tezos network\n   *\n   * @example Tezos.setSignerProvider(new InMemorySigner.fromSecretKey('edsk...'))\n   *\n   */\n  setSignerProvider(signer?: SetProviderOptions['signer']) {\n    if (!this._options.signer && typeof signer === 'undefined') {\n      this._context.signer = new NoopSigner();\n      this._options.signer = signer;\n    } else if (typeof signer !== 'undefined') {\n      this._context.signer = signer;\n      this._options.signer = signer;\n    }\n  }\n\n  /**\n   * @description Sets rpc provider on the Tezos Taquito instance\n   *\n   * @param options rpc url or rpcClient to use to interact with the Tezos network\n   *\n   * @example Tezos.setRpcProvider('https://mainnet.api.tez.ie/')\n   *\n   */\n  setRpcProvider(rpc?: SetProviderOptions['rpc']) {\n    if (typeof rpc === 'string') {\n      this._rpcClient = new RpcClient(rpc);\n    } else if (rpc === undefined) {\n      // do nothing, RPC is required in the constructor, do not override it\n    } else {\n      this._rpcClient = rpc;\n    }\n    this._options.rpc = this._rpcClient;\n    this._context.rpc = this._rpcClient;\n  }\n\n  /**\n   * @description Sets forger provider on the Tezos Taquito instance\n   * The `LocalForger` from `@taquito/local-forging` is set by default.\n   *\n   * @param options forger to use to interact with the Tezos network\n   *\n   * @example Tezos.setForgerProvider(this.getFactory(RpcForger)())\n   *\n   */\n  setForgerProvider(forger?: SetProviderOptions['forger']) {\n    if (typeof forger !== 'undefined') {\n      this._options.forger = forger;\n      this._context.forger = forger;\n    } else if (this._options.forger === undefined) {\n      const f = this.getFactory(TaquitoLocalForger)();\n      this._options.forger = f;\n      this._context.forger = f;\n    }\n  }\n\n  /**\n   * @description Sets stream provider on the Tezos Taquito instance\n   *\n   * @param options stream to use to interact with the Tezos network\n   *\n   * @example Tezos.setStreamProvider(...)\n   *\n   */\n  setStreamProvider(stream?: SetProviderOptions['stream']) {\n    if (typeof stream === 'string') {\n      const s = new PollingSubscribeProvider(new Context(new RpcClient(stream)));\n      this._options.stream = s;\n      this._context.stream = s;\n    } else if (typeof stream !== 'undefined') {\n      this._options.stream = stream;\n      this._context.stream = stream;\n    } else if (this._options.stream === undefined) {\n      const s = this.getFactory(PollingSubscribeProvider)();\n      this._options.stream = s;\n      this._context.stream = s;\n    }\n  }\n\n  /**\n   * @description Sets wallet provider on the Tezos Taquito instance\n   *\n   * @param options wallet to use to interact with the Tezos network\n   *\n   * @example Tezos.setWalletProvider(...)\n   *\n   */\n  setWalletProvider(wallet?: SetProviderOptions['wallet']) {\n    if (!this._options.wallet && typeof wallet === 'undefined') {\n      const w = this.getFactory(LegacyWalletProvider)();\n      this._options.wallet = w;\n      this._context.walletProvider = w;\n    } else if (typeof wallet !== 'undefined') {\n      this._options.wallet = wallet;\n      this._context.walletProvider = wallet;\n    }\n  }\n\n  /**\n   * @description Sets Packer provider on the Tezos Taquito instance\n   *\n   * @param options packer to use to interact with the Tezos network\n   *\n   * @example Tezos.setPackerProvider(new MichelCodecPacker())\n   *\n   */\n  setPackerProvider(packer?: SetProviderOptions['packer']) {\n    if (!this._options.packer && typeof packer === 'undefined') {\n      const p = this.getFactory(RpcPacker)();\n      this._context.packer = p;\n      this._options.packer = p;\n    } else if (typeof packer !== 'undefined') {\n      this._context.packer = packer;\n      this._options.packer = packer;\n    }\n  }\n\n  /**\n   * @description Sets global constants provider on the Tezos Taquito instance\n   *\n   * @param options globalConstantsProvider to use to interact with the Tezos network\n   *\n   * @example\n   * ```\n   * const globalConst = new DefaultGlobalConstantsProvider();\n   * globalConst.loadGlobalConstant({\n   *  \"expruu5BTdW7ajqJ9XPTF3kgcV78pRiaBW3Gq31mgp3WSYjjUBYxre\": { prim: \"int\" },\n   *  // ...\n   * })\n   * Tezos.setGlobalConstantsProvider(globalConst);\n   * ```\n   *\n   */\n  setGlobalConstantsProvider(\n    globalConstantsProvider?: SetProviderOptions['globalConstantsProvider']\n  ) {\n    if (!this._options.globalConstantsProvider && typeof globalConstantsProvider === 'undefined') {\n      const g = new NoopGlobalConstantsProvider();\n      this._context.globalConstantsProvider = g;\n      this._options.globalConstantsProvider = g;\n    } else if (typeof globalConstantsProvider !== 'undefined') {\n      this._context.globalConstantsProvider = globalConstantsProvider;\n      this._options.globalConstantsProvider = globalConstantsProvider;\n    }\n  }\n\n  /**\n   * @description Sets read provider on the Tezos Taquito instance\n   * By default reads are done from the RPC usign the RpcReadAdapter class, this can be overridden to read from an indexer that implements the TzReadProvider interface\n   *\n   * @param options TzReadProvider to use to interact with the Tezos network\n   *\n   */\n  setReadProvider(readProvider?: SetProviderOptions['readProvider']) {\n    const readP =\n      typeof readProvider === 'undefined' ? this.getFactory(RpcReadAdapter)() : readProvider;\n    this._options.readProvider = readP;\n    this._context.readProvider = readP;\n  }\n\n  /**\n   * @description Provide access to tezos account management\n   */\n  get tz(): TzProvider {\n    return this._context.tz;\n  }\n\n  /**\n   * @description Provide access to smart contract utilities\n   */\n  get contract(): ContractProvider {\n    return this._context.contract;\n  }\n\n  get wallet(): Wallet {\n    return this._wallet;\n  }\n\n  get operation(): OperationFactory {\n    return this._context.operationFactory;\n  }\n\n  /**\n   * @description Provide access to operation estimation utilities\n   */\n  get estimate(): EstimationProvider {\n    return this._context.estimate;\n  }\n\n  /**\n   * @description Provide access to streaming utilities backed by an streamer implementation\n   */\n  get stream(): SubscribeProvider {\n    return this._context.stream;\n  }\n\n  /**\n   * @description Provide access to the currently used rpc client\n   */\n  get rpc(): RpcClientInterface {\n    return this._context.rpc;\n  }\n\n  /**\n   * @description Provide access to the currently used signer\n   */\n  get signer() {\n    return this._context.signer;\n  }\n\n  /**\n   * @description Provide access to the currently used globalConstantsProvider\n   */\n  get globalConstants() {\n    return this._context.globalConstantsProvider;\n  }\n\n  /**\n   * @description Allow to add a module to the TezosToolkit instance. This method adds the appropriate Providers(s) required by the module to the internal context.\n   *\n   * @param module extension to add to the TezosToolkit instance\n   *\n   * @example Tezos.addExtension(new Tzip16Module());\n   */\n  addExtension(module: Extension | Extension[]) {\n    if (Array.isArray(module)) {\n      module.forEach((extension) => extension.configureContext(this._context));\n    } else {\n      module.configureContext(this._context);\n    }\n  }\n\n  getFactory<T, K extends Array<any>>(ctor: TaquitoProvider<T, K>) {\n    return (...args: K) => {\n      return new ctor(this._context, ...args);\n    };\n  }\n\n  /**\n   * @description Gets an object containing the version of Taquito library and git sha of the commit this library is compiled from\n   */\n  getVersionInfo(): VersionInfo {\n    return VERSION;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}