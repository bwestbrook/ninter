{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport \"core-js/modules/es.error.cause.js\";\nimport { Buffer } from 'buffer';\nimport { verify } from '@stablelib/ed25519';\nimport { hash } from '@stablelib/blake2b';\nimport blake from 'blakejs';\nimport bs58check from 'bs58check';\nimport elliptic from 'elliptic';\nimport toBuffer from 'typedarray-to-buffer';\nvar Prefix;\n\n(function (Prefix) {\n  Prefix[\"TZ1\"] = \"tz1\";\n  Prefix[\"TZ2\"] = \"tz2\";\n  Prefix[\"TZ3\"] = \"tz3\";\n  Prefix[\"TZ4\"] = \"tz4\";\n  Prefix[\"KT\"] = \"KT\";\n  Prefix[\"KT1\"] = \"KT1\";\n  Prefix[\"EDSK2\"] = \"edsk2\";\n  Prefix[\"SPSK\"] = \"spsk\";\n  Prefix[\"P2SK\"] = \"p2sk\";\n  Prefix[\"EDPK\"] = \"edpk\";\n  Prefix[\"SPPK\"] = \"sppk\";\n  Prefix[\"P2PK\"] = \"p2pk\";\n  Prefix[\"EDESK\"] = \"edesk\";\n  Prefix[\"SPESK\"] = \"spesk\";\n  Prefix[\"P2ESK\"] = \"p2esk\";\n  Prefix[\"EDSK\"] = \"edsk\";\n  Prefix[\"EDSIG\"] = \"edsig\";\n  Prefix[\"SPSIG\"] = \"spsig\";\n  Prefix[\"P2SIG\"] = \"p2sig\";\n  Prefix[\"SIG\"] = \"sig\";\n  Prefix[\"NET\"] = \"Net\";\n  Prefix[\"NCE\"] = \"nce\";\n  Prefix[\"B\"] = \"B\";\n  Prefix[\"O\"] = \"o\";\n  Prefix[\"LO\"] = \"Lo\";\n  Prefix[\"LLO\"] = \"LLo\";\n  Prefix[\"P\"] = \"P\";\n  Prefix[\"CO\"] = \"Co\";\n  Prefix[\"ID\"] = \"id\";\n  Prefix[\"EXPR\"] = \"expr\";\n  Prefix[\"TZ\"] = \"TZ\";\n  Prefix[\"VH\"] = \"vh\"; //rollups\n\n  Prefix[\"TXR1\"] = \"txr1\";\n  Prefix[\"TXI\"] = \"txi\";\n  Prefix[\"TXM\"] = \"txm\";\n  Prefix[\"TXC\"] = \"txc\";\n  Prefix[\"TXMR\"] = \"txmr\";\n  Prefix[\"TXRL\"] = \"txM\";\n  Prefix[\"TXW\"] = \"txw\";\n})(Prefix || (Prefix = {}));\n\nconst prefix = {\n  [Prefix.TZ1]: new Uint8Array([6, 161, 159]),\n  [Prefix.TZ2]: new Uint8Array([6, 161, 161]),\n  [Prefix.TZ3]: new Uint8Array([6, 161, 164]),\n  [Prefix.TZ4]: new Uint8Array([6, 161, 166]),\n  [Prefix.KT]: new Uint8Array([2, 90, 121]),\n  [Prefix.KT1]: new Uint8Array([2, 90, 121]),\n  [Prefix.EDSK]: new Uint8Array([43, 246, 78, 7]),\n  [Prefix.EDSK2]: new Uint8Array([13, 15, 58, 7]),\n  [Prefix.SPSK]: new Uint8Array([17, 162, 224, 201]),\n  [Prefix.P2SK]: new Uint8Array([16, 81, 238, 189]),\n  [Prefix.EDPK]: new Uint8Array([13, 15, 37, 217]),\n  [Prefix.SPPK]: new Uint8Array([3, 254, 226, 86]),\n  [Prefix.P2PK]: new Uint8Array([3, 178, 139, 127]),\n  [Prefix.EDESK]: new Uint8Array([7, 90, 60, 179, 41]),\n  [Prefix.SPESK]: new Uint8Array([0x09, 0xed, 0xf1, 0xae, 0x96]),\n  [Prefix.P2ESK]: new Uint8Array([0x09, 0x30, 0x39, 0x73, 0xab]),\n  [Prefix.EDSIG]: new Uint8Array([9, 245, 205, 134, 18]),\n  [Prefix.SPSIG]: new Uint8Array([13, 115, 101, 19, 63]),\n  [Prefix.P2SIG]: new Uint8Array([54, 240, 44, 52]),\n  [Prefix.SIG]: new Uint8Array([4, 130, 43]),\n  [Prefix.NET]: new Uint8Array([87, 82, 0]),\n  [Prefix.NCE]: new Uint8Array([69, 220, 169]),\n  [Prefix.B]: new Uint8Array([1, 52]),\n  [Prefix.O]: new Uint8Array([5, 116]),\n  [Prefix.LO]: new Uint8Array([133, 233]),\n  [Prefix.LLO]: new Uint8Array([29, 159, 109]),\n  [Prefix.P]: new Uint8Array([2, 170]),\n  [Prefix.CO]: new Uint8Array([79, 179]),\n  [Prefix.ID]: new Uint8Array([153, 103]),\n  [Prefix.EXPR]: new Uint8Array([13, 44, 64, 27]),\n  // Legacy prefix\n  [Prefix.TZ]: new Uint8Array([2, 90, 121]),\n  [Prefix.VH]: new Uint8Array([1, 106, 242]),\n  [Prefix.TXR1]: new Uint8Array([1, 128, 120, 31]),\n  [Prefix.TXI]: new Uint8Array([79, 148, 196]),\n  [Prefix.TXM]: new Uint8Array([79, 149, 30]),\n  [Prefix.TXC]: new Uint8Array([79, 148, 17]),\n  [Prefix.TXMR]: new Uint8Array([18, 7, 206, 87]),\n  [Prefix.TXRL]: new Uint8Array([79, 146, 82]),\n  [Prefix.TXW]: new Uint8Array([79, 150, 72])\n};\nconst prefixLength = {\n  [Prefix.TZ1]: 20,\n  [Prefix.TZ2]: 20,\n  [Prefix.TZ3]: 20,\n  [Prefix.TZ4]: 20,\n  [Prefix.KT]: 20,\n  [Prefix.KT1]: 20,\n  [Prefix.EDPK]: 32,\n  [Prefix.SPPK]: 33,\n  [Prefix.P2PK]: 33,\n  [Prefix.EDSIG]: 64,\n  [Prefix.SPSIG]: 64,\n  [Prefix.P2SIG]: 64,\n  [Prefix.SIG]: 64,\n  [Prefix.NET]: 4,\n  [Prefix.B]: 32,\n  [Prefix.P]: 32,\n  [Prefix.O]: 32,\n  [Prefix.VH]: 32,\n  [Prefix.TXR1]: 20,\n  [Prefix.TXI]: 32,\n  [Prefix.TXM]: 32,\n  [Prefix.TXC]: 32,\n  [Prefix.TXMR]: 32,\n  [Prefix.TXRL]: 32,\n  [Prefix.TXW]: 32\n};\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid key being passed or used\r\n */\n\nclass InvalidKeyError extends Error {\n  constructor(key, errorDetail) {\n    super(`The key ${key} is invalid. ${errorDetail}`);\n    this.key = key;\n    this.errorDetail = errorDetail;\n    this.name = 'InvalidKeyError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an Invalid Public Key being passed or used\r\n */\n\n\nclass InvalidPublicKeyError extends Error {\n  constructor(publicKey, errorDetail) {\n    super(`The public key '${publicKey}' is invalid. ${errorDetail}`);\n    this.publicKey = publicKey;\n    this.name = 'InvalidPublicKeyError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid signature being passed or used\r\n */\n\n\nclass InvalidSignatureError extends Error {\n  constructor(signature, errorDetail) {\n    super(`The signature '${signature}' is invalid (${errorDetail})`);\n    this.signature = signature;\n    this.name = 'InvalidSignatureError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid message being passed or used\r\n */\n\n\nclass InvalidMessageError extends Error {\n  constructor(msg, errorDetail) {\n    super(`The message '${msg}' is invalid. ${errorDetail}`);\n    this.msg = msg;\n    this.errorDetail = errorDetail;\n    this.name = 'InvalidMessageError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid contract address being passed or used\r\n */\n\n\nclass InvalidContractAddressError extends Error {\n  constructor(contractAddress) {\n    super(`The contract address '${contractAddress}' is invalid`);\n    this.contractAddress = contractAddress;\n    this.name = 'InvalidContractAddressError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid address being passed or used (both contract and implicit)\r\n */\n\n\nclass InvalidAddressError extends Error {\n  constructor(address) {\n    super(`The address '${address}' is invalid`);\n    this.address = address;\n    this.name = 'InvalidAddressError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid chain id being passed or used\r\n */\n\n\nclass InvalidChainIdError extends Error {\n  constructor(chainId) {\n    super(`The chain id '${chainId}' is invalid`);\n    this.chainId = chainId;\n    this.name = 'InvalidChainIdError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid key hash being passed or used\r\n */\n\n\nclass InvalidKeyHashError extends Error {\n  constructor(keyHash) {\n    super(`The public key hash '${keyHash}' is invalid`);\n    this.keyHash = keyHash;\n    this.name = 'InvalidKeyHashError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid block hash being passed or used\r\n */\n\n\nclass InvalidBlockHashError extends Error {\n  constructor(blockHash) {\n    super(`The block hash '${blockHash}' is invalid`);\n    this.blockHash = blockHash;\n    this.name = 'InvalidBlockHashError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates invalid protocol hash being passed or used\r\n */\n\n\nclass InvalidProtocolHashError extends Error {\n  constructor(protocolHash) {\n    super(`The protocol hash '${protocolHash}' is invalid`);\n    this.protocolHash = protocolHash;\n    this.name = 'InvalidProtocolHashError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid operation hash being passed or used\r\n */\n\n\nclass InvalidOperationHashError extends Error {\n  constructor(operationHash) {\n    super(`The operation hash '${operationHash}' is invalid`);\n    this.operationHash = operationHash;\n    this.name = 'InvalidOperationHashError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid operation kind being passed or used\r\n */\n\n\nclass InvalidOperationKindError extends Error {\n  constructor(operationKind) {\n    super(`The operation kind '${operationKind}' is unsupported`);\n    this.operationKind = operationKind;\n    this.name = 'InvalidOperationKindError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description General error that indicates something is no longer supported and/or deprecated\r\n */\n\n\nclass DeprecationError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'DeprecationError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description General error that indicates an action is prohibited or not allowed\r\n */\n\n\nclass ProhibitedActionError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'ProhibitedActionError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description General error that indicates a failure when trying to convert data from one type to another\r\n */\n\n\nclass ValueConversionError extends Error {\n  constructor(value, desiredType) {\n    super(`Unable to convert ${value} to a ${desiredType}`);\n    this.value = value;\n    this.desiredType = desiredType;\n    this.name = 'ValueConversionError';\n  }\n\n}\n/**\r\n * @description Verify signature of a payload\r\n *\r\n * @param messageBytes The forged message including the magic byte (11 for block,\r\n *        12 for preendorsement, 13 for endorsement, 3 for generic, 5 for the PACK format of michelson)\r\n * @param publicKey The public key to verify the signature against\r\n * @param signature The signature to verify\r\n * @returns A boolean indicating if the signature matches\r\n *\r\n * @example\r\n * ```\r\n * const message = '03d0c10e3ed11d7c6e3357f6ef335bab9e8f2bd54d0ce20c482e241191a6e4b8ce6c01be917311d9ac46959750e405d57e268e2ed9e174a80794fbd504e12a4a000141eb3781afed2f69679ff2bbe1c5375950b0e40d00ff000000005e05050505050507070100000024747a32526773486e74516b72794670707352466261313652546656503539684b72654a4d07070100000024747a315a6672455263414c42776d4171776f6e525859565142445439426a4e6a42484a750001';\r\n * const pk = 'sppk7c7hkPj47yjYFEHX85q46sFJGw6RBrqoVSHwAJAT4e14KJwzoey';\r\n * const sig = 'spsig1cdLkp1RLgUHAp13aRFkZ6MQDPp7xCnjAExGL3MBSdMDmT6JgQSX8cufyDgJRM3sinFtiCzLbsyP6d365EHoNevxhT47nx'\r\n *\r\n * const response = verifySignature(message, pk, sig);\r\n * ```\r\n *\r\n */\n\n\nfunction verifySignature(messageBytes, publicKey, signature) {\n  const pkPrefix = validatePkAndExtractPrefix(publicKey);\n  const sigPrefix = validateSigAndExtractPrefix(signature);\n  const decodedPublicKey = b58cdecode(publicKey, prefix[pkPrefix]);\n  const decodedSig = b58cdecode(signature, prefix[sigPrefix]);\n  const bytesHash = hash(hex2buf(validateMessageNotEmpty(messageBytes)), 32);\n\n  if (pkPrefix === Prefix.EDPK) {\n    return verifyEdSignature(decodedSig, bytesHash, decodedPublicKey);\n  } else if (pkPrefix === Prefix.SPPK) {\n    return verifySpSignature(decodedSig, bytesHash, decodedPublicKey);\n  } else if (pkPrefix === Prefix.P2PK) {\n    return verifyP2Signature(decodedSig, bytesHash, decodedPublicKey);\n  } else {\n    return false;\n  }\n}\n\nfunction validateMessageNotEmpty(message) {\n  if (message === '') {\n    throw new InvalidMessageError(message, 'The message provided for verifying signature cannot be empty.');\n  }\n\n  return message;\n}\n\nfunction validatePkAndExtractPrefix(publicKey) {\n  if (publicKey === '') {\n    throw new InvalidPublicKeyError(publicKey, 'Public key cannot be empty');\n  }\n\n  const pkPrefix = publicKey.substring(0, 4);\n  const validation = validatePublicKey(publicKey);\n\n  if (validation !== ValidationResult.VALID) {\n    if (validation === ValidationResult.INVALID_CHECKSUM) {\n      throw new InvalidPublicKeyError(publicKey, 'The public key provided has an invalid checksum');\n    } else if (validation === ValidationResult.INVALID_LENGTH) {\n      throw new InvalidPublicKeyError(publicKey, 'The public key provided has an invalid length');\n    } else if (validation === ValidationResult.NO_PREFIX_MATCHED) {\n      throw new InvalidPublicKeyError(publicKey, `The public key provided has an unsupported prefix: ${pkPrefix}`);\n    }\n  }\n\n  return pkPrefix;\n}\n\nfunction validateSigAndExtractPrefix(signature) {\n  const signaturePrefix = signature.startsWith('sig') ? signature.substr(0, 3) : signature.substr(0, 5);\n  const validation = validateSignature(signature);\n\n  if (validation !== ValidationResult.VALID) {\n    if (validation === ValidationResult.INVALID_CHECKSUM) {\n      throw new InvalidSignatureError(signature, `invalid checksum`);\n    } else if (validation === ValidationResult.INVALID_LENGTH) {\n      throw new InvalidSignatureError(signature, 'invalid length');\n    } else if (validation === ValidationResult.NO_PREFIX_MATCHED) {\n      throw new InvalidSignatureError(signaturePrefix, 'unsupported prefix');\n    }\n  }\n\n  return signaturePrefix;\n}\n\nfunction verifyEdSignature(decodedSig, bytesHash, decodedPublicKey) {\n  try {\n    return verify(decodedPublicKey, bytesHash, decodedSig);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction verifySpSignature(decodedSig, bytesHash, decodedPublicKey) {\n  const key = new elliptic.ec('secp256k1').keyFromPublic(decodedPublicKey);\n  return verifySpOrP2Sig(decodedSig, bytesHash, key);\n}\n\nfunction verifyP2Signature(decodedSig, bytesHash, decodedPublicKey) {\n  const key = new elliptic.ec('p256').keyFromPublic(decodedPublicKey);\n  return verifySpOrP2Sig(decodedSig, bytesHash, key);\n}\n\nfunction verifySpOrP2Sig(decodedSig, bytesHash, key) {\n  const hexSig = buf2hex(toBuffer(decodedSig));\n  const match = hexSig.match(/([a-f\\d]{64})/gi);\n\n  if (match) {\n    try {\n      const [r, s] = match;\n      return key.verify(bytesHash, {\n        r,\n        s\n      });\n    } catch (e) {\n      return false;\n    }\n  }\n\n  return false;\n}\n\nvar ValidationResult;\n\n(function (ValidationResult) {\n  ValidationResult[ValidationResult[\"NO_PREFIX_MATCHED\"] = 0] = \"NO_PREFIX_MATCHED\";\n  ValidationResult[ValidationResult[\"INVALID_CHECKSUM\"] = 1] = \"INVALID_CHECKSUM\";\n  ValidationResult[ValidationResult[\"INVALID_LENGTH\"] = 2] = \"INVALID_LENGTH\";\n  ValidationResult[ValidationResult[\"VALID\"] = 3] = \"VALID\";\n})(ValidationResult || (ValidationResult = {}));\n\nfunction isValidPrefix(value) {\n  if (typeof value !== 'string') {\n    return false;\n  }\n\n  return value in prefix;\n}\n/**\r\n * @description This function is called by the validation functions ([[validateAddress]], [[validateChain]], [[validateContractAddress]], [[validateKeyHash]], [[validateSignature]], [[validatePublicKey]]).\r\n * Verify if the value has the right prefix or return `NO_PREFIX_MATCHED`,\r\n * decode the value using base58 and return `INVALID_CHECKSUM` if it fails,\r\n * check if the length of the value matches the prefix type or return `INVALID_LENGTH`.\r\n * If all checks pass, return `VALID`.\r\n *\r\n * @param value Value to validate\r\n * @param prefixes prefix the value should have\r\n */\n\n\nfunction validatePrefixedValue(value, prefixes) {\n  const match = new RegExp(`^(${prefixes.join('|')})`).exec(value);\n\n  if (!match || match.length === 0) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  }\n\n  const prefixKey = match[0];\n\n  if (!isValidPrefix(prefixKey)) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  } // Remove annotation from contract address before doing the validation\n\n\n  const contractAddress = /^(KT1\\w{33})(%(.*))?/.exec(value);\n\n  if (contractAddress) {\n    value = contractAddress[1];\n  } // decodeUnsafe return undefined if decoding fail\n\n\n  let decoded = bs58check.decodeUnsafe(value);\n\n  if (!decoded) {\n    return ValidationResult.INVALID_CHECKSUM;\n  }\n\n  decoded = decoded.slice(prefix[prefixKey].length);\n\n  if (decoded.length !== prefixLength[prefixKey]) {\n    return ValidationResult.INVALID_LENGTH;\n  }\n\n  return ValidationResult.VALID;\n}\n\nconst implicitPrefix = [Prefix.TZ1, Prefix.TZ2, Prefix.TZ3, Prefix.TZ4];\nconst contractPrefix = [Prefix.KT1, Prefix.TXR1];\nconst signaturePrefix = [Prefix.EDSIG, Prefix.P2SIG, Prefix.SPSIG, Prefix.SIG];\nconst pkPrefix = [Prefix.EDPK, Prefix.SPPK, Prefix.P2PK];\nconst operationPrefix = [Prefix.O];\nconst protocolPrefix = [Prefix.P];\nconst blockPrefix = [Prefix.B];\n/**\r\n * @description Used to check if an address or a contract address is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateAddress } from '@taquito/utils';\r\n * const pkh = 'tz1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\r\n * const validation = validateAddress(pkh)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\nfunction validateAddress(value) {\n  return validatePrefixedValue(value, [...implicitPrefix, ...contractPrefix]);\n}\n/**\r\n * @description Used to check if a chain id is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateChain } from '@taquito/utils';\r\n * const chainId = 'NetXdQprcVkpaWU'\r\n * const validation = validateChain(chainId)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateChain(value) {\n  return validatePrefixedValue(value, [Prefix.NET]);\n}\n/**\r\n * @description Used to check if a contract address is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateContractAddress } from '@taquito/utils';\r\n * const contractAddress = 'KT1JVErLYTgtY8uGGZ4mso2npTSxqVLDRVbC'\r\n * const validation = validateContractAddress(contractAddress)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateContractAddress(value) {\n  return validatePrefixedValue(value, contractPrefix);\n}\n/**\r\n * @description Used to check if a key hash is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateKeyHash } from '@taquito/utils';\r\n * const keyHashWithoutPrefix = '1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\r\n * const validation = validateKeyHash(keyHashWithoutPrefix)\r\n * console.log(validation)\r\n * // This example return 0 which correspond to NO_PREFIX_MATCHED\r\n * ```\r\n */\n\n\nfunction validateKeyHash(value) {\n  return validatePrefixedValue(value, implicitPrefix);\n}\n/**\r\n * @description Used to check if a signature is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateSignature } from '@taquito/utils';\r\n * const signature = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\r\n * const validation = validateSignature(signature)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateSignature(value) {\n  return validatePrefixedValue(value, signaturePrefix);\n}\n/**\r\n * @description Used to check if a public key is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validatePublicKey } from '@taquito/utils';\r\n * const publicKey = 'edpkvS5QFv7KRGfa3b87gg9DBpxSm3NpSwnjhUjNBQrRUUR66F7C9g'\r\n * const validation = validatePublicKey(publicKey)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validatePublicKey(value) {\n  return validatePrefixedValue(value, pkPrefix);\n}\n/**\r\n * @description Used to check if an operation hash is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateOperation } from '@taquito/utils';\r\n * const operationHash = 'oo6JPEAy8VuMRGaFuMmLNFFGdJgiaKfnmT1CpHJfKP3Ye5ZahiP'\r\n * const validation = validateOperation(operationHash)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateOperation(value) {\n  return validatePrefixedValue(value, operationPrefix);\n}\n/**\r\n * @description Used to check if a protocol hash is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateProtocol } from '@taquito/utils';\r\n * const protocolHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\r\n * const validation = validateProtocol(protocolHash)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateProtocol(value) {\n  return validatePrefixedValue(value, protocolPrefix);\n}\n/**\r\n * @description Used to check if a block hash is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateBlock } from '@taquito/utils';\r\n * const blockHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\r\n * const validation = validateBlock(blockHash)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateBlock(value) {\n  return validatePrefixedValue(value, blockPrefix);\n} // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\n\n\nconst VERSION = {\n  \"commitHash\": \"cbdd0af87e400489076259d065e2d328feb8e1b4\",\n  \"version\": \"12.1.0\"\n};\n/**\r\n * @packageDocumentation\r\n * @module @taquito/utils\r\n */\n\n/**\r\n *\r\n * @description Hash a string using the BLAKE2b algorithm, base58 encode the hash obtained and appends the prefix 'expr' to it\r\n *\r\n * @param value Value in hex\r\n */\n\nfunction encodeExpr(value) {\n  const blakeHash = blake.blake2b(hex2buf(value), undefined, 32);\n  return b58cencode(blakeHash, prefix['expr']);\n}\n/**\r\n *\r\n * @description Return the operation hash of a signed operation\r\n * @param value Value in hex of a signed operation\r\n */\n\n\nfunction encodeOpHash(value) {\n  const blakeHash = blake.blake2b(hex2buf(value), undefined, 32);\n  return b58cencode(blakeHash, prefix.o);\n}\n/**\r\n *\r\n * @description Base58 encode a string or a Uint8Array and append a prefix to it\r\n *\r\n * @param value Value to base58 encode\r\n * @param prefix prefix to append to the encoded string\r\n */\n\n\nfunction b58cencode(value, prefix) {\n  const payloadAr = typeof value === 'string' ? Uint8Array.from(Buffer.from(value, 'hex')) : value;\n  const n = new Uint8Array(prefix.length + payloadAr.length);\n  n.set(prefix);\n  n.set(payloadAr, prefix.length);\n  return bs58check.encode(Buffer.from(n.buffer));\n}\n/**\r\n *\r\n * @description Base58 decode a string and remove the prefix from it\r\n *\r\n * @param value Value to base58 decode\r\n * @param prefix prefix to remove from the decoded string\r\n */\n\n\nconst b58cdecode = (enc, prefixArg) => bs58check.decode(enc).slice(prefixArg.length);\n/**\r\n *\r\n * @description Base58 decode a string with predefined prefix\r\n *\r\n * @param value Value to base58 decode\r\n */\n\n\nfunction b58decode(payload) {\n  const buf = bs58check.decode(payload);\n  const prefixMap = {\n    [prefix.tz1.toString()]: '0000',\n    [prefix.tz2.toString()]: '0001',\n    [prefix.tz3.toString()]: '0002'\n  };\n  const pref = prefixMap[new Uint8Array(buf.slice(0, 3)).toString()];\n\n  if (pref) {\n    // tz addresses\n    const hex = buf2hex(buf.slice(3));\n    return pref + hex;\n  } else {\n    // other (kt addresses)\n    return '01' + buf2hex(buf.slice(3, 42)) + '00';\n  }\n}\n/**\r\n *\r\n * @description Base58 encode an address using predefined prefix\r\n *\r\n * @param value Address to base58 encode (tz1, tz2, tz3 or KT1)\r\n */\n\n\nfunction encodePubKey(value) {\n  if (value.substring(0, 2) === '00') {\n    const pref = {\n      '0000': prefix.tz1,\n      '0001': prefix.tz2,\n      '0002': prefix.tz3\n    };\n    return b58cencode(value.substring(4), pref[value.substring(0, 4)]);\n  }\n\n  return b58cencode(value.substring(2, 42), prefix.KT);\n}\n/**\r\n *\r\n * @description Base58 encode a key according to its prefix\r\n *\r\n * @param value Key to base58 encode\r\n */\n\n\nfunction encodeKey(value) {\n  if (value[0] === '0') {\n    const pref = {\n      '00': new Uint8Array([13, 15, 37, 217]),\n      '01': new Uint8Array([3, 254, 226, 86]),\n      '02': new Uint8Array([3, 178, 139, 127])\n    };\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n/**\r\n *\r\n * @description Base58 encode a key hash according to its prefix\r\n *\r\n * @param value Key hash to base58 encode\r\n */\n\n\nfunction encodeKeyHash(value) {\n  if (value[0] === '0') {\n    const pref = {\n      '00': new Uint8Array([6, 161, 159]),\n      '01': new Uint8Array([6, 161, 161]),\n      '02': new Uint8Array([6, 161, 164])\n    };\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n/**\r\n *\r\n * @description Convert an hex string to a Uint8Array\r\n *\r\n * @param hex Hex string to convert\r\n */\n\n\nconst hex2buf = hex => {\n  const match = hex.match(/[\\da-f]{2}/gi);\n\n  if (match) {\n    return new Uint8Array(match.map(h => parseInt(h, 16)));\n  } else {\n    throw new ValueConversionError(hex, 'Uint8Array');\n  }\n};\n/**\r\n *\r\n * @description Merge 2 buffers together\r\n *\r\n * @param b1 First buffer\r\n * @param b2 Second buffer\r\n */\n\n\nconst mergebuf = (b1, b2) => {\n  const r = new Uint8Array(b1.length + b2.length);\n  r.set(b1);\n  r.set(b2, b1.length);\n  return r;\n};\n/**\r\n *\r\n * @description Flatten a michelson json representation to an array\r\n *\r\n * @param s michelson json\r\n */\n\n\nconst mic2arr = function me2(s) {\n  let ret = [];\n\n  if (Object.prototype.hasOwnProperty.call(s, 'prim')) {\n    if (s.prim === 'Pair') {\n      ret.push(me2(s.args[0]));\n      ret = ret.concat(me2(s.args[1]));\n    } else if (s.prim === 'Elt') {\n      ret = {\n        key: me2(s.args[0]),\n        val: me2(s.args[1])\n      };\n    } else if (s.prim === 'True') {\n      ret = true;\n    } else if (s.prim === 'False') {\n      ret = false;\n    }\n  } else if (Array.isArray(s)) {\n    const sc = s.length;\n\n    for (let i = 0; i < sc; i++) {\n      const n = me2(s[i]);\n\n      if (typeof n.key !== 'undefined') {\n        if (Array.isArray(ret)) {\n          ret = {\n            keys: [],\n            vals: []\n          };\n        }\n\n        ret.keys.push(n.key);\n        ret.vals.push(n.val);\n      } else {\n        ret.push(n);\n      }\n    }\n  } else if (Object.prototype.hasOwnProperty.call(s, 'string')) {\n    ret = s.string;\n  } else if (Object.prototype.hasOwnProperty.call(s, 'int')) {\n    ret = parseInt(s.int, 10);\n  } else {\n    ret = s;\n  }\n\n  return ret;\n};\n/**\r\n *\r\n * @description Convert a buffer to an hex string\r\n *\r\n * @param buffer Buffer to convert\r\n */\n\n\nconst buf2hex = buffer => {\n  const byteArray = new Uint8Array(buffer);\n  const hexParts = [];\n  byteArray.forEach(byte => {\n    const hex = byte.toString(16);\n    const paddedHex = `00${hex}`.slice(-2);\n    hexParts.push(paddedHex);\n  });\n  return hexParts.join('');\n};\n/**\r\n *\r\n *  @description Gets Tezos address (PKH) from Public Key\r\n *\r\n *  @param publicKey Public Key\r\n *  @returns A string of the Tezos address (PKH) that was derived from the given Public Key\r\n */\n\n\nconst getPkhfromPk = publicKey => {\n  let encodingPrefix;\n  let prefixLen;\n  const keyPrefix = validatePkAndExtractPrefix(publicKey);\n  const decoded = b58cdecode(publicKey, prefix[keyPrefix]);\n\n  switch (keyPrefix) {\n    case Prefix.EDPK:\n      encodingPrefix = prefix[Prefix.TZ1];\n      prefixLen = prefixLength[Prefix.TZ1];\n      break;\n\n    case Prefix.SPPK:\n      encodingPrefix = prefix[Prefix.TZ2];\n      prefixLen = prefixLength[Prefix.TZ2];\n      break;\n\n    case Prefix.P2PK:\n      encodingPrefix = prefix[Prefix.TZ3];\n      prefixLen = prefixLength[Prefix.TZ3];\n      break;\n  }\n\n  const hashed = hash(decoded, prefixLen);\n  const result = b58cencode(hashed, encodingPrefix);\n  return result;\n};\n/**\r\n *\r\n * @description Convert a string to bytes\r\n *\r\n * @param str String to convert\r\n */\n\n\nfunction char2Bytes(str) {\n  return Buffer.from(str, 'utf8').toString('hex');\n}\n/**\r\n *\r\n * @description Convert bytes to a string\r\n *\r\n * @param str Bytes to convert\r\n */\n\n\nfunction bytes2Char(hex) {\n  return Buffer.from(hex2buf(hex)).toString('utf8');\n}\n\nexport { DeprecationError, InvalidAddressError, InvalidBlockHashError, InvalidChainIdError, InvalidContractAddressError, InvalidKeyError, InvalidKeyHashError, InvalidMessageError, InvalidOperationHashError, InvalidOperationKindError, InvalidProtocolHashError, InvalidPublicKeyError, InvalidSignatureError, Prefix, ProhibitedActionError, VERSION, ValidationResult, ValueConversionError, b58cdecode, b58cencode, b58decode, buf2hex, bytes2Char, char2Bytes, encodeExpr, encodeKey, encodeKeyHash, encodeOpHash, encodePubKey, getPkhfromPk, hex2buf, isValidPrefix, mergebuf, mic2arr, prefix, prefixLength, validateAddress, validateBlock, validateChain, validateContractAddress, validateKeyHash, validateOperation, validatePkAndExtractPrefix, validateProtocol, validatePublicKey, validateSignature, verifySignature };","map":{"version":3,"mappings":"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","names":["Prefix","prefix","TZ1","Uint8Array","TZ2","TZ3","TZ4","KT","KT1","EDSK","EDSK2","SPSK","P2SK","EDPK","SPPK","P2PK","EDESK","SPESK","P2ESK","EDSIG","SPSIG","P2SIG","SIG","NET","NCE","B","O","LO","LLO","P","CO","ID","EXPR","TZ","VH","TXR1","TXI","TXM","TXC","TXMR","TXRL","TXW","prefixLength","InvalidKeyError","Error","constructor","key","errorDetail","InvalidPublicKeyError","publicKey","InvalidSignatureError","signature","InvalidMessageError","msg","InvalidContractAddressError","contractAddress","InvalidAddressError","address","InvalidChainIdError","chainId","InvalidKeyHashError","keyHash","InvalidBlockHashError","blockHash","InvalidProtocolHashError","protocolHash","InvalidOperationHashError","operationHash","InvalidOperationKindError","operationKind","DeprecationError","message","ProhibitedActionError","ValueConversionError","value","desiredType","verifySignature","messageBytes","pkPrefix","validatePkAndExtractPrefix","sigPrefix","validateSigAndExtractPrefix","decodedPublicKey","b58cdecode","decodedSig","bytesHash","hash","hex2buf","validateMessageNotEmpty","verifyEdSignature","verifySpSignature","verifyP2Signature","substring","validation","validatePublicKey","ValidationResult","VALID","INVALID_CHECKSUM","INVALID_LENGTH","NO_PREFIX_MATCHED","signaturePrefix","startsWith","substr","validateSignature","verify","e","elliptic","ec","keyFromPublic","verifySpOrP2Sig","hexSig","buf2hex","toBuffer","match","r","s","isValidPrefix","validatePrefixedValue","prefixes","RegExp","join","exec","length","prefixKey","decoded","bs58check","decodeUnsafe","slice","implicitPrefix","contractPrefix","operationPrefix","protocolPrefix","blockPrefix","validateAddress","validateChain","validateContractAddress","validateKeyHash","validateOperation","validateProtocol","validateBlock","VERSION","encodeExpr","blakeHash","blake","blake2b","undefined","b58cencode","encodeOpHash","o","payloadAr","from","Buffer","n","set","encode","buffer","enc","prefixArg","decode","b58decode","payload","buf","prefixMap","tz1","toString","tz2","tz3","pref","hex","encodePubKey","encodeKey","encodeKeyHash","map","h","parseInt","mergebuf","b1","b2","mic2arr","me2","ret","Object","prototype","hasOwnProperty","call","prim","push","args","concat","val","Array","isArray","sc","i","keys","vals","string","int","byteArray","hexParts","forEach","byte","paddedHex","getPkhfromPk","encodingPrefix","prefixLen","keyPrefix","hashed","result","char2Bytes","str","bytes2Char"],"sources":["../src/constants.ts","../src/errors.ts","../src/verify-signature.ts","../src/validators.ts","../src/version.ts","../src/taquito-utils.ts"],"sourcesContent":["export enum Prefix {\n  TZ1 = 'tz1',\n  TZ2 = 'tz2',\n  TZ3 = 'tz3',\n  TZ4 = 'tz4',\n  KT = 'KT',\n  KT1 = 'KT1',\n\n  EDSK2 = 'edsk2',\n  SPSK = 'spsk',\n  P2SK = 'p2sk',\n\n  EDPK = 'edpk',\n  SPPK = 'sppk',\n  P2PK = 'p2pk',\n\n  EDESK = 'edesk',\n  SPESK = 'spesk',\n  P2ESK = 'p2esk',\n\n  EDSK = 'edsk',\n  EDSIG = 'edsig',\n  SPSIG = 'spsig',\n  P2SIG = 'p2sig',\n  SIG = 'sig',\n\n  NET = 'Net',\n  NCE = 'nce',\n  B = 'B',\n  O = 'o',\n  LO = 'Lo',\n  LLO = 'LLo',\n  P = 'P',\n  CO = 'Co',\n  ID = 'id',\n\n  EXPR = 'expr',\n  TZ = 'TZ',\n\n  VH = 'vh', // block_payload_hash\n\n  //rollups\n  TXR1 = 'txr1',\n  TXI = 'txi',\n  TXM = 'txm',\n  TXC = 'txc',\n  TXMR = 'txmr',\n  TXRL = 'txM',\n  TXW = 'txw',\n\n}\n\nexport const prefix = {\n  [Prefix.TZ1]: new Uint8Array([6, 161, 159]),\n  [Prefix.TZ2]: new Uint8Array([6, 161, 161]),\n  [Prefix.TZ3]: new Uint8Array([6, 161, 164]),\n  [Prefix.TZ4]: new Uint8Array([6, 161, 166]),\n  [Prefix.KT]: new Uint8Array([2, 90, 121]),\n  [Prefix.KT1]: new Uint8Array([2, 90, 121]),\n\n  [Prefix.EDSK]: new Uint8Array([43, 246, 78, 7]),\n  [Prefix.EDSK2]: new Uint8Array([13, 15, 58, 7]),\n  [Prefix.SPSK]: new Uint8Array([17, 162, 224, 201]),\n  [Prefix.P2SK]: new Uint8Array([16, 81, 238, 189]),\n\n  [Prefix.EDPK]: new Uint8Array([13, 15, 37, 217]),\n  [Prefix.SPPK]: new Uint8Array([3, 254, 226, 86]),\n  [Prefix.P2PK]: new Uint8Array([3, 178, 139, 127]),\n\n  [Prefix.EDESK]: new Uint8Array([7, 90, 60, 179, 41]),\n  [Prefix.SPESK]: new Uint8Array([0x09, 0xed, 0xf1, 0xae, 0x96]),\n  [Prefix.P2ESK]: new Uint8Array([0x09, 0x30, 0x39, 0x73, 0xab]),\n\n  [Prefix.EDSIG]: new Uint8Array([9, 245, 205, 134, 18]),\n  [Prefix.SPSIG]: new Uint8Array([13, 115, 101, 19, 63]),\n  [Prefix.P2SIG]: new Uint8Array([54, 240, 44, 52]),\n  [Prefix.SIG]: new Uint8Array([4, 130, 43]),\n\n  [Prefix.NET]: new Uint8Array([87, 82, 0]),\n  [Prefix.NCE]: new Uint8Array([69, 220, 169]),\n  [Prefix.B]: new Uint8Array([1, 52]),\n  [Prefix.O]: new Uint8Array([5, 116]),\n  [Prefix.LO]: new Uint8Array([133, 233]),\n  [Prefix.LLO]: new Uint8Array([29, 159, 109]),\n  [Prefix.P]: new Uint8Array([2, 170]),\n  [Prefix.CO]: new Uint8Array([79, 179]),\n  [Prefix.ID]: new Uint8Array([153, 103]),\n\n  [Prefix.EXPR]: new Uint8Array([13, 44, 64, 27]),\n  // Legacy prefix\n  [Prefix.TZ]: new Uint8Array([2, 90, 121]),\n\n  [Prefix.VH]: new Uint8Array([1, 106, 242]),\n\n  [Prefix.TXR1]: new Uint8Array([1, 128, 120, 31]),\n  [Prefix.TXI]: new Uint8Array([79, 148, 196]),\n  [Prefix.TXM]: new Uint8Array([79, 149, 30]),\n  [Prefix.TXC]: new Uint8Array([79, 148, 17]),\n  [Prefix.TXMR]: new Uint8Array([18, 7, 206, 87]),\n  [Prefix.TXRL]: new Uint8Array([79, 146, 82]),\n  [Prefix.TXW]: new Uint8Array([79, 150, 72]),\n   \n};\n\nexport const prefixLength: { [key: string]: number } = {\n  [Prefix.TZ1]: 20,\n  [Prefix.TZ2]: 20,\n  [Prefix.TZ3]: 20,\n  [Prefix.TZ4]: 20,\n  [Prefix.KT]: 20,\n  [Prefix.KT1]: 20,\n\n  [Prefix.EDPK]: 32,\n  [Prefix.SPPK]: 33,\n  [Prefix.P2PK]: 33,\n  [Prefix.EDSIG]: 64,\n  [Prefix.SPSIG]: 64,\n  [Prefix.P2SIG]: 64,\n  [Prefix.SIG]: 64,\n  [Prefix.NET]: 4,\n  [Prefix.B]: 32,\n  [Prefix.P]: 32,\n  [Prefix.O]: 32,\n  [Prefix.VH]: 32,\n  [Prefix.TXR1]: 20,\n  [Prefix.TXI]: 32,\n  [Prefix.TXM]: 32,\n  [Prefix.TXC]: 32,\n  [Prefix.TXMR]: 32,\n  [Prefix.TXRL]: 32,\n  [Prefix.TXW]: 32,\n\n};\n","/**\n *  @category Error\n *  @description Error that indicates an invalid key being passed or used\n */\nexport class InvalidKeyError extends Error {\n  public name = 'InvalidKeyError';\n  constructor(public key: string, public errorDetail?: string) {\n    super(`The key ${key} is invalid. ${errorDetail}`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an Invalid Public Key being passed or used\n */\nexport class InvalidPublicKeyError extends Error {\n  public name = 'InvalidPublicKeyError';\n  constructor(public publicKey: string, errorDetail?: string) {\n    super(`The public key '${publicKey}' is invalid. ${errorDetail}`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid signature being passed or used\n */\nexport class InvalidSignatureError extends Error {\n  public name = 'InvalidSignatureError';\n  constructor(public signature: string, errorDetail?: string) {\n    super(`The signature '${signature}' is invalid (${errorDetail})`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid message being passed or used\n */\nexport class InvalidMessageError extends Error {\n  public name = 'InvalidMessageError';\n  constructor(public msg: string, public errorDetail?: string) {\n    super(`The message '${msg}' is invalid. ${errorDetail}`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid contract address being passed or used\n */\nexport class InvalidContractAddressError extends Error {\n  public name = 'InvalidContractAddressError';\n  constructor(public contractAddress: string) {\n    super(`The contract address '${contractAddress}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid address being passed or used (both contract and implicit)\n */\nexport class InvalidAddressError extends Error {\n  public name = 'InvalidAddressError';\n  constructor(public address: string) {\n    super(`The address '${address}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid chain id being passed or used\n */\nexport class InvalidChainIdError extends Error {\n  public name = 'InvalidChainIdError';\n  constructor(public chainId: string) {\n    super(`The chain id '${chainId}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid key hash being passed or used\n */\nexport class InvalidKeyHashError extends Error {\n  public name = 'InvalidKeyHashError';\n  constructor(public keyHash: string) {\n    super(`The public key hash '${keyHash}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid block hash being passed or used\n */ export class InvalidBlockHashError extends Error {\n  public name = 'InvalidBlockHashError';\n  constructor(public blockHash: string) {\n    super(`The block hash '${blockHash}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates invalid protocol hash being passed or used\n */\nexport class InvalidProtocolHashError extends Error {\n  public name = 'InvalidProtocolHashError';\n  constructor(public protocolHash: string) {\n    super(`The protocol hash '${protocolHash}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid operation hash being passed or used\n */ export class InvalidOperationHashError extends Error {\n  public name = 'InvalidOperationHashError';\n  constructor(public operationHash: string) {\n    super(`The operation hash '${operationHash}' is invalid`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid operation kind being passed or used\n */\nexport class InvalidOperationKindError extends Error {\n  public name = 'InvalidOperationKindError';\n  constructor(public operationKind: string) {\n    super(`The operation kind '${operationKind}' is unsupported`);\n  }\n}\n\n/**\n *  @category Error\n *  @description General error that indicates something is no longer supported and/or deprecated\n */\nexport class DeprecationError extends Error {\n  public name = 'DeprecationError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n\n/**\n *  @category Error\n *  @description General error that indicates an action is prohibited or not allowed\n */\nexport class ProhibitedActionError extends Error {\n  public name = 'ProhibitedActionError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n\n/**\n *  @category Error\n *  @description General error that indicates a failure when trying to convert data from one type to another\n */\nexport class ValueConversionError extends Error {\n  public name = 'ValueConversionError';\n  constructor(public value: string, public desiredType: string) {\n    super(`Unable to convert ${value} to a ${desiredType}`);\n  }\n}\n","import { verify } from '@stablelib/ed25519';\nimport { hash } from '@stablelib/blake2b';\nimport {\n  b58cdecode,\n  buf2hex,\n  hex2buf,\n  Prefix,\n  prefix,\n  validatePublicKey,\n  validateSignature,\n  ValidationResult,\n} from './taquito-utils';\nimport elliptic from 'elliptic';\nimport toBuffer from 'typedarray-to-buffer';\nimport { InvalidMessageError, InvalidPublicKeyError, InvalidSignatureError } from './errors';\n\ntype PkPrefix = Prefix.EDPK | Prefix.SPPK | Prefix.P2PK;\ntype SigPrefix = Prefix.EDSIG | Prefix.SPSIG | Prefix.P2SIG | Prefix.SIG;\n\n/**\n * @description Verify signature of a payload\n *\n * @param messageBytes The forged message including the magic byte (11 for block,\n *        12 for preendorsement, 13 for endorsement, 3 for generic, 5 for the PACK format of michelson)\n * @param publicKey The public key to verify the signature against\n * @param signature The signature to verify\n * @returns A boolean indicating if the signature matches\n *\n * @example\n * ```\n * const message = '03d0c10e3ed11d7c6e3357f6ef335bab9e8f2bd54d0ce20c482e241191a6e4b8ce6c01be917311d9ac46959750e405d57e268e2ed9e174a80794fbd504e12a4a000141eb3781afed2f69679ff2bbe1c5375950b0e40d00ff000000005e05050505050507070100000024747a32526773486e74516b72794670707352466261313652546656503539684b72654a4d07070100000024747a315a6672455263414c42776d4171776f6e525859565142445439426a4e6a42484a750001';\n * const pk = 'sppk7c7hkPj47yjYFEHX85q46sFJGw6RBrqoVSHwAJAT4e14KJwzoey';\n * const sig = 'spsig1cdLkp1RLgUHAp13aRFkZ6MQDPp7xCnjAExGL3MBSdMDmT6JgQSX8cufyDgJRM3sinFtiCzLbsyP6d365EHoNevxhT47nx'\n *\n * const response = verifySignature(message, pk, sig);\n * ```\n *\n */\nexport function verifySignature(\n  messageBytes: string,\n  publicKey: string,\n  signature: string\n): boolean {\n  const pkPrefix = validatePkAndExtractPrefix(publicKey);\n  const sigPrefix = validateSigAndExtractPrefix(signature);\n\n  const decodedPublicKey = b58cdecode(publicKey, prefix[pkPrefix]);\n  const decodedSig = b58cdecode(signature, prefix[sigPrefix]);\n  const bytesHash = hash(hex2buf(validateMessageNotEmpty(messageBytes)), 32);\n\n  if (pkPrefix === Prefix.EDPK) {\n    return verifyEdSignature(decodedSig, bytesHash, decodedPublicKey);\n  } else if (pkPrefix === Prefix.SPPK) {\n    return verifySpSignature(decodedSig, bytesHash, decodedPublicKey);\n  } else if (pkPrefix === Prefix.P2PK) {\n    return verifyP2Signature(decodedSig, bytesHash, decodedPublicKey);\n  } else {\n    return false;\n  }\n}\n\nfunction validateMessageNotEmpty(message: string) {\n  if (message === '') {\n    throw new InvalidMessageError(\n      message,\n      'The message provided for verifying signature cannot be empty.'\n    );\n  }\n  return message;\n}\n\nexport function validatePkAndExtractPrefix(publicKey: string): PkPrefix {\n  if (publicKey === '') {\n    throw new InvalidPublicKeyError(publicKey, 'Public key cannot be empty');\n  }\n  const pkPrefix = publicKey.substring(0, 4);\n  const validation = validatePublicKey(publicKey);\n  if (validation !== ValidationResult.VALID) {\n    if (validation === ValidationResult.INVALID_CHECKSUM) {\n      throw new InvalidPublicKeyError(publicKey, 'The public key provided has an invalid checksum');\n    } else if (validation === ValidationResult.INVALID_LENGTH) {\n      throw new InvalidPublicKeyError(publicKey, 'The public key provided has an invalid length');\n    } else if (validation === ValidationResult.NO_PREFIX_MATCHED) {\n      throw new InvalidPublicKeyError(\n        publicKey,\n        `The public key provided has an unsupported prefix: ${pkPrefix}`\n      );\n    }\n  }\n  return pkPrefix as PkPrefix;\n}\n\nfunction validateSigAndExtractPrefix(signature: string): SigPrefix {\n  const signaturePrefix = signature.startsWith('sig')\n    ? signature.substr(0, 3)\n    : signature.substr(0, 5);\n  const validation = validateSignature(signature);\n  if (validation !== ValidationResult.VALID) {\n    if (validation === ValidationResult.INVALID_CHECKSUM) {\n      throw new InvalidSignatureError(signature, `invalid checksum`);\n    } else if (validation === ValidationResult.INVALID_LENGTH) {\n      throw new InvalidSignatureError(signature, 'invalid length');\n    } else if (validation === ValidationResult.NO_PREFIX_MATCHED) {\n      throw new InvalidSignatureError(signaturePrefix, 'unsupported prefix');\n    }\n  }\n  return signaturePrefix as SigPrefix;\n}\n\nfunction verifyEdSignature(\n  decodedSig: Uint8Array,\n  bytesHash: Uint8Array,\n  decodedPublicKey: Uint8Array\n) {\n  try {\n    return verify(decodedPublicKey, bytesHash, decodedSig);\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction verifySpSignature(\n  decodedSig: Uint8Array,\n  bytesHash: Uint8Array,\n  decodedPublicKey: Uint8Array\n) {\n  const key = new elliptic.ec('secp256k1').keyFromPublic(decodedPublicKey);\n  return verifySpOrP2Sig(decodedSig, bytesHash, key);\n}\n\nfunction verifyP2Signature(\n  decodedSig: Uint8Array,\n  bytesHash: Uint8Array,\n  decodedPublicKey: Uint8Array\n) {\n  const key = new elliptic.ec('p256').keyFromPublic(decodedPublicKey);\n  return verifySpOrP2Sig(decodedSig, bytesHash, key);\n}\n\nfunction verifySpOrP2Sig(decodedSig: Uint8Array, bytesHash: Uint8Array, key: elliptic.ec.KeyPair) {\n  const hexSig = buf2hex(toBuffer(decodedSig));\n  const match = hexSig.match(/([a-f\\d]{64})/gi);\n  if (match) {\n    try {\n      const [r, s] = match;\n      return key.verify(bytesHash, { r, s });\n    } catch (e) {\n      return false;\n    }\n  }\n  return false;\n}\n","import { prefix, prefixLength, Prefix } from './constants';\n\nimport bs58check from 'bs58check';\n\nexport enum ValidationResult {\n  NO_PREFIX_MATCHED,\n  INVALID_CHECKSUM,\n  INVALID_LENGTH,\n  VALID,\n}\n\nexport function isValidPrefix(value: any): value is Prefix {\n  if (typeof value !== 'string') {\n    return false;\n  }\n\n  return value in prefix;\n}\n/**\n * @description This function is called by the validation functions ([[validateAddress]], [[validateChain]], [[validateContractAddress]], [[validateKeyHash]], [[validateSignature]], [[validatePublicKey]]).\n * Verify if the value has the right prefix or return `NO_PREFIX_MATCHED`,\n * decode the value using base58 and return `INVALID_CHECKSUM` if it fails,\n * check if the length of the value matches the prefix type or return `INVALID_LENGTH`.\n * If all checks pass, return `VALID`.\n *\n * @param value Value to validate\n * @param prefixes prefix the value should have\n */\nfunction validatePrefixedValue(value: any, prefixes: Prefix[]) {\n  const match = new RegExp(`^(${prefixes.join('|')})`).exec(value);\n  if (!match || match.length === 0) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  }\n\n  const prefixKey = match[0];\n\n  if (!isValidPrefix(prefixKey)) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  }\n\n  // Remove annotation from contract address before doing the validation\n  const contractAddress = /^(KT1\\w{33})(%(.*))?/.exec(value);\n  if (contractAddress) {\n    value = contractAddress[1];\n  }\n\n  // decodeUnsafe return undefined if decoding fail\n  let decoded = bs58check.decodeUnsafe(value);\n  if (!decoded) {\n    return ValidationResult.INVALID_CHECKSUM;\n  }\n\n  decoded = decoded.slice(prefix[prefixKey].length);\n  if (decoded.length !== prefixLength[prefixKey]) {\n    return ValidationResult.INVALID_LENGTH;\n  }\n\n  return ValidationResult.VALID;\n}\n\nconst implicitPrefix = [Prefix.TZ1, Prefix.TZ2, Prefix.TZ3,Prefix.TZ4];\nconst contractPrefix = [Prefix.KT1,Prefix.TXR1];\nconst signaturePrefix = [Prefix.EDSIG, Prefix.P2SIG, Prefix.SPSIG, Prefix.SIG];\nconst pkPrefix = [Prefix.EDPK, Prefix.SPPK, Prefix.P2PK];\nconst operationPrefix = [Prefix.O];\nconst protocolPrefix = [Prefix.P];\nconst blockPrefix = [Prefix.B]\n\n/**\n * @description Used to check if an address or a contract address is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateAddress } from '@taquito/utils';\n * const pkh = 'tz1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n * const validation = validateAddress(pkh)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateAddress(value: any): ValidationResult {\n  return validatePrefixedValue(value, [...implicitPrefix, ...contractPrefix]);\n}\n\n/**\n * @description Used to check if a chain id is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateChain } from '@taquito/utils';\n * const chainId = 'NetXdQprcVkpaWU'\n * const validation = validateChain(chainId)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateChain(value: any): ValidationResult {\n  return validatePrefixedValue(value, [Prefix.NET]);\n}\n\n/**\n * @description Used to check if a contract address is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateContractAddress } from '@taquito/utils';\n * const contractAddress = 'KT1JVErLYTgtY8uGGZ4mso2npTSxqVLDRVbC'\n * const validation = validateContractAddress(contractAddress)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateContractAddress(value: any): ValidationResult {\n  return validatePrefixedValue(value, contractPrefix);\n}\n\n/**\n * @description Used to check if a key hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateKeyHash } from '@taquito/utils';\n * const keyHashWithoutPrefix = '1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n * const validation = validateKeyHash(keyHashWithoutPrefix)\n * console.log(validation)\n * // This example return 0 which correspond to NO_PREFIX_MATCHED\n * ```\n */\nexport function validateKeyHash(value: any): ValidationResult {\n  return validatePrefixedValue(value, implicitPrefix);\n}\n\n/**\n * @description Used to check if a signature is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateSignature } from '@taquito/utils';\n * const signature = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\n * const validation = validateSignature(signature)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateSignature(value: any): ValidationResult {\n  return validatePrefixedValue(value, signaturePrefix);\n}\n\n/**\n * @description Used to check if a public key is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validatePublicKey } from '@taquito/utils';\n * const publicKey = 'edpkvS5QFv7KRGfa3b87gg9DBpxSm3NpSwnjhUjNBQrRUUR66F7C9g'\n * const validation = validatePublicKey(publicKey)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validatePublicKey(value: any): ValidationResult {\n  return validatePrefixedValue(value, pkPrefix);\n}\n\n/**\n * @description Used to check if an operation hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateOperation } from '@taquito/utils';\n * const operationHash = 'oo6JPEAy8VuMRGaFuMmLNFFGdJgiaKfnmT1CpHJfKP3Ye5ZahiP'\n * const validation = validateOperation(operationHash)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateOperation(value: any): ValidationResult {\n  return validatePrefixedValue(value, operationPrefix);\n}\n\n/**\n * @description Used to check if a protocol hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateProtocol } from '@taquito/utils';\n * const protocolHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\n * const validation = validateProtocol(protocolHash)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateProtocol(value: any): ValidationResult {\n  return validatePrefixedValue(value, protocolPrefix);\n}\n\n/**\n * @description Used to check if a block hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateBlock } from '@taquito/utils';\n * const blockHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\n * const validation = validateBlock(blockHash)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */\nexport function validateBlock(value: any): ValidationResult {\n  return validatePrefixedValue(value, blockPrefix);\n}\n","\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\nexport const VERSION = {\n    \"commitHash\": \"cbdd0af87e400489076259d065e2d328feb8e1b4\",\n    \"version\": \"12.1.0\"\n};\n","/**\n * @packageDocumentation\n * @module @taquito/utils\n */\n\n/*\n * Some code in this file is originally from sotez and eztz\n * Copyright (c) 2018 Andrew Kishino\n * Copyright (c) 2017 Stephen Andrews\n */\n\nimport { Buffer } from 'buffer';\nimport { Prefix, prefix, prefixLength } from './constants';\nimport { validatePkAndExtractPrefix } from './verify-signature';\nimport { hash } from '@stablelib/blake2b';\nimport blake from 'blakejs';\nimport bs58check from 'bs58check';\nimport { ValueConversionError } from './errors';\n\nexport * from './validators';\nexport { VERSION } from './version';\n\nexport { prefix, Prefix, prefixLength } from './constants';\n\nexport { verifySignature, validatePkAndExtractPrefix } from './verify-signature';\nexport * from './errors';\n\n/**\n *\n * @description Hash a string using the BLAKE2b algorithm, base58 encode the hash obtained and appends the prefix 'expr' to it\n *\n * @param value Value in hex\n */\nexport function encodeExpr(value: string) {\n  const blakeHash = blake.blake2b(hex2buf(value), undefined, 32);\n  return b58cencode(blakeHash, prefix['expr']);\n}\n\n/**\n *\n * @description Return the operation hash of a signed operation\n * @param value Value in hex of a signed operation\n */\nexport function encodeOpHash(value: string) {\n  const blakeHash = blake.blake2b(hex2buf(value), undefined, 32);\n  return b58cencode(blakeHash, prefix.o);\n}\n\n/**\n *\n * @description Base58 encode a string or a Uint8Array and append a prefix to it\n *\n * @param value Value to base58 encode\n * @param prefix prefix to append to the encoded string\n */\nexport function b58cencode(value: string | Uint8Array, prefix: Uint8Array) {\n  const payloadAr = typeof value === 'string' ? Uint8Array.from(Buffer.from(value, 'hex')) : value;\n\n  const n = new Uint8Array(prefix.length + payloadAr.length);\n  n.set(prefix);\n  n.set(payloadAr, prefix.length);\n\n  return bs58check.encode(Buffer.from(n.buffer));\n}\n\n/**\n *\n * @description Base58 decode a string and remove the prefix from it\n *\n * @param value Value to base58 decode\n * @param prefix prefix to remove from the decoded string\n */\nexport const b58cdecode = (enc: string, prefixArg: Uint8Array): Uint8Array =>\n  bs58check.decode(enc).slice(prefixArg.length);\n\n/**\n *\n * @description Base58 decode a string with predefined prefix\n *\n * @param value Value to base58 decode\n */\nexport function b58decode(payload: string) {\n  const buf: Buffer = bs58check.decode(payload);\n\n  const prefixMap = {\n    [prefix.tz1.toString()]: '0000',\n    [prefix.tz2.toString()]: '0001',\n    [prefix.tz3.toString()]: '0002',\n  };\n\n  const pref = prefixMap[new Uint8Array(buf.slice(0, 3)).toString()];\n  if (pref) {\n    // tz addresses\n    const hex = buf2hex(buf.slice(3));\n    return pref + hex;\n  } else {\n    // other (kt addresses)\n    return '01' + buf2hex(buf.slice(3, 42)) + '00';\n  }\n}\n\n/**\n *\n * @description Base58 encode an address using predefined prefix\n *\n * @param value Address to base58 encode (tz1, tz2, tz3 or KT1)\n */\nexport function encodePubKey(value: string) {\n  if (value.substring(0, 2) === '00') {\n    const pref: { [key: string]: Uint8Array } = {\n      '0000': prefix.tz1,\n      '0001': prefix.tz2,\n      '0002': prefix.tz3,\n    };\n\n    return b58cencode(value.substring(4), pref[value.substring(0, 4)]);\n  }\n\n  return b58cencode(value.substring(2, 42), prefix.KT);\n}\n\n/**\n *\n * @description Base58 encode a key according to its prefix\n *\n * @param value Key to base58 encode\n */\nexport function encodeKey(value: string) {\n  if (value[0] === '0') {\n    const pref: { [key: string]: Uint8Array } = {\n      '00': new Uint8Array([13, 15, 37, 217]),\n      '01': new Uint8Array([3, 254, 226, 86]),\n      '02': new Uint8Array([3, 178, 139, 127]),\n    };\n\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n\n/**\n *\n * @description Base58 encode a key hash according to its prefix\n *\n * @param value Key hash to base58 encode\n */\nexport function encodeKeyHash(value: string) {\n  if (value[0] === '0') {\n    const pref: { [key: string]: Uint8Array } = {\n      '00': new Uint8Array([6, 161, 159]),\n      '01': new Uint8Array([6, 161, 161]),\n      '02': new Uint8Array([6, 161, 164]),\n    };\n\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n\n/**\n *\n * @description Convert an hex string to a Uint8Array\n *\n * @param hex Hex string to convert\n */\nexport const hex2buf = (hex: string): Uint8Array => {\n  const match = hex.match(/[\\da-f]{2}/gi);\n  if (match) {\n    return new Uint8Array(match.map((h) => parseInt(h, 16)));\n  } else {\n    throw new ValueConversionError(hex, 'Uint8Array');\n  }\n};\n\n/**\n *\n * @description Merge 2 buffers together\n *\n * @param b1 First buffer\n * @param b2 Second buffer\n */\nexport const mergebuf = (b1: Uint8Array, b2: Uint8Array): Uint8Array => {\n  const r = new Uint8Array(b1.length + b2.length);\n  r.set(b1);\n  r.set(b2, b1.length);\n  return r;\n};\n\n/**\n *\n * @description Flatten a michelson json representation to an array\n *\n * @param s michelson json\n */\nexport const mic2arr = function me2(s: any): any {\n  let ret: any = [];\n  if (Object.prototype.hasOwnProperty.call(s, 'prim')) {\n    if (s.prim === 'Pair') {\n      ret.push(me2(s.args[0]));\n      ret = ret.concat(me2(s.args[1]));\n    } else if (s.prim === 'Elt') {\n      ret = {\n        key: me2(s.args[0]),\n        val: me2(s.args[1]),\n      };\n    } else if (s.prim === 'True') {\n      ret = true;\n    } else if (s.prim === 'False') {\n      ret = false;\n    }\n  } else if (Array.isArray(s)) {\n    const sc = s.length;\n    for (let i = 0; i < sc; i++) {\n      const n = me2(s[i]);\n      if (typeof n.key !== 'undefined') {\n        if (Array.isArray(ret)) {\n          ret = {\n            keys: [],\n            vals: [],\n          };\n        }\n        ret.keys.push(n.key);\n        ret.vals.push(n.val);\n      } else {\n        ret.push(n);\n      }\n    }\n  } else if (Object.prototype.hasOwnProperty.call(s, 'string')) {\n    ret = s.string;\n  } else if (Object.prototype.hasOwnProperty.call(s, 'int')) {\n    ret = parseInt(s.int, 10);\n  } else {\n    ret = s;\n  }\n  return ret;\n};\n\n/**\n *\n * @description Convert a buffer to an hex string\n *\n * @param buffer Buffer to convert\n */\nexport const buf2hex = (buffer: Buffer): string => {\n  const byteArray = new Uint8Array(buffer);\n  const hexParts: string[] = [];\n  byteArray.forEach((byte: any) => {\n    const hex = byte.toString(16);\n    const paddedHex = `00${hex}`.slice(-2);\n    hexParts.push(paddedHex);\n  });\n  return hexParts.join('');\n};\n\n/**\n *\n *  @description Gets Tezos address (PKH) from Public Key\n *\n *  @param publicKey Public Key\n *  @returns A string of the Tezos address (PKH) that was derived from the given Public Key\n */\nexport const getPkhfromPk = (publicKey: string): string => {\n  let encodingPrefix;\n  let prefixLen;\n\n  const keyPrefix = validatePkAndExtractPrefix(publicKey);\n  const decoded = b58cdecode(publicKey, prefix[keyPrefix]);\n\n  switch (keyPrefix) {\n    case Prefix.EDPK:\n      encodingPrefix = prefix[Prefix.TZ1];\n      prefixLen = prefixLength[Prefix.TZ1];\n      break;\n    case Prefix.SPPK:\n      encodingPrefix = prefix[Prefix.TZ2];\n      prefixLen = prefixLength[Prefix.TZ2];\n      break;\n    case Prefix.P2PK:\n      encodingPrefix = prefix[Prefix.TZ3];\n      prefixLen = prefixLength[Prefix.TZ3];\n      break;\n  }\n\n  const hashed = hash(decoded, prefixLen);\n  const result = b58cencode(hashed, encodingPrefix);\n\n  return result;\n};\n\n/**\n *\n * @description Convert a string to bytes\n *\n * @param str String to convert\n */\nexport function char2Bytes(str: string) {\n  return Buffer.from(str, 'utf8').toString('hex');\n}\n\n/**\n *\n * @description Convert bytes to a string\n *\n * @param str Bytes to convert\n */\nexport function bytes2Char(hex: string): string {\n  return Buffer.from(hex2buf(hex)).toString('utf8');\n}\n"]},"metadata":{},"sourceType":"module"}