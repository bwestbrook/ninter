{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { crypto_sign_ed25519_sk_to_curve25519, crypto_sign_ed25519_pk_to_curve25519, crypto_kx_server_session_keys, crypto_kx_client_session_keys } from 'libsodium-wrappers';\nimport { toHex, getHexHash, sealCryptobox } from '@airgap/beacon-utils';\n/**\n * @internalapi\n *\n *\n */\n\nexport class CommunicationClient {\n  constructor(keyPair) {\n    this.keyPair = keyPair;\n  }\n  /**\n   * Get the public key\n   */\n\n\n  getPublicKey() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return toHex(this.keyPair.publicKey);\n    });\n  }\n  /**\n   * get the public key hash\n   */\n\n\n  getPublicKeyHash() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return getHexHash(this.keyPair.publicKey);\n    });\n  }\n  /**\n   * Create a cryptobox shared key\n   *\n   * @param otherPublicKey\n   * @param selfPrivateKey\n   */\n\n\n  createCryptoBox(otherPublicKey, selfPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // TODO: Don't calculate it every time?\n      const kxSelfPrivateKey = crypto_sign_ed25519_sk_to_curve25519(Buffer.from(selfPrivateKey)); // Secret bytes to scalar bytes\n\n      const kxSelfPublicKey = crypto_sign_ed25519_pk_to_curve25519(Buffer.from(selfPrivateKey).slice(32, 64)); // Secret bytes to scalar bytes\n\n      const kxOtherPublicKey = crypto_sign_ed25519_pk_to_curve25519(Buffer.from(otherPublicKey, 'hex')); // Secret bytes to scalar bytes\n\n      return [Buffer.from(kxSelfPublicKey), Buffer.from(kxSelfPrivateKey), Buffer.from(kxOtherPublicKey)];\n    });\n  }\n  /**\n   * Create a cryptobox server\n   *\n   * @param otherPublicKey\n   * @param selfPrivateKey\n   */\n\n\n  createCryptoBoxServer(otherPublicKey, selfPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keys = yield this.createCryptoBox(otherPublicKey, selfPrivateKey);\n      return crypto_kx_server_session_keys(...keys);\n    });\n  }\n  /**\n   * Create a cryptobox client\n   *\n   * @param otherPublicKey\n   * @param selfPrivateKey\n   */\n\n\n  createCryptoBoxClient(otherPublicKey, selfPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keys = yield this.createCryptoBox(otherPublicKey, selfPrivateKey);\n      return crypto_kx_client_session_keys(...keys);\n    });\n  }\n  /**\n   * Encrypt a message for a specific publicKey (receiver, asymmetric)\n   *\n   * @param recipientPublicKey\n   * @param message\n   */\n\n\n  encryptMessageAsymmetric(recipientPublicKey, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return sealCryptobox(message, Buffer.from(recipientPublicKey, 'hex'));\n    });\n  }\n\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAGEA,oCAHF,EAIEC,oCAJF,EAKEC,6BALF,EAMEC,6BANF,QAOO,oBAPP;AAcA,SAASC,KAAT,EAAgBC,UAAhB,EAA4BC,aAA5B,QAAiD,sBAAjD;AAEA;;;;;;AAKA,OAAM,MAAgBC,mBAAhB,CAAmC;EACvCC,YAA+BC,OAA/B,EAA+C;IAAhB;EAAoB;EAEnD;;;;;EAGaC,YAAY;;MACvB,OAAON,KAAK,CAAC,KAAKK,OAAL,CAAaE,SAAd,CAAZ;IACD;EAAA;EAED;;;;;EAGaC,gBAAgB;;MAC3B,OAAOP,UAAU,CAAC,KAAKI,OAAL,CAAaE,SAAd,CAAjB;IACD;EAAA;EAED;;;;;;;;EAMgBE,eAAe,CAC7BC,cAD6B,EAE7BC,cAF6B,EAEH;;MAE1B;MACA,MAAMC,gBAAgB,GAAGhB,oCAAoC,CAACiB,MAAM,CAACC,IAAP,CAAYH,cAAZ,CAAD,CAA7D,EAA2F;;MAC3F,MAAMI,eAAe,GAAGlB,oCAAoC,CAC1DgB,MAAM,CAACC,IAAP,CAAYH,cAAZ,EAA4BK,KAA5B,CAAkC,EAAlC,EAAsC,EAAtC,CAD0D,CAA5D,EAEE;;MACF,MAAMC,gBAAgB,GAAGpB,oCAAoC,CAC3DgB,MAAM,CAACC,IAAP,CAAYJ,cAAZ,EAA4B,KAA5B,CAD2D,CAA7D,EAEE;;MAEF,OAAO,CACLG,MAAM,CAACC,IAAP,CAAYC,eAAZ,CADK,EAELF,MAAM,CAACC,IAAP,CAAYF,gBAAZ,CAFK,EAGLC,MAAM,CAACC,IAAP,CAAYG,gBAAZ,CAHK,CAAP;IAKD;EAAA;EAED;;;;;;;;EAMgBC,qBAAqB,CACnCR,cADmC,EAEnCC,cAFmC,EAET;;MAE1B,MAAMQ,IAAI,GAAG,MAAM,KAAKV,eAAL,CAAqBC,cAArB,EAAqCC,cAArC,CAAnB;MAEA,OAAOb,6BAA6B,CAAC,GAAGqB,IAAJ,CAApC;IACD;EAAA;EAED;;;;;;;;EAMgBC,qBAAqB,CACnCV,cADmC,EAEnCC,cAFmC,EAET;;MAE1B,MAAMQ,IAAI,GAAG,MAAM,KAAKV,eAAL,CAAqBC,cAArB,EAAqCC,cAArC,CAAnB;MAEA,OAAOZ,6BAA6B,CAAC,GAAGoB,IAAJ,CAApC;IACD;EAAA;EAED;;;;;;;;EAMgBE,wBAAwB,CACtCC,kBADsC,EAEtCC,OAFsC,EAEvB;;MAEf,OAAOrB,aAAa,CAACqB,OAAD,EAAUV,MAAM,CAACC,IAAP,CAAYQ,kBAAZ,EAAgC,KAAhC,CAAV,CAApB;IACD;EAAA;;AApFsC","names":["crypto_sign_ed25519_sk_to_curve25519","crypto_sign_ed25519_pk_to_curve25519","crypto_kx_server_session_keys","crypto_kx_client_session_keys","toHex","getHexHash","sealCryptobox","CommunicationClient","constructor","keyPair","getPublicKey","publicKey","getPublicKeyHash","createCryptoBox","otherPublicKey","selfPrivateKey","kxSelfPrivateKey","Buffer","from","kxSelfPublicKey","slice","kxOtherPublicKey","createCryptoBoxServer","keys","createCryptoBoxClient","encryptMessageAsymmetric","recipientPublicKey","message"],"sourceRoot":"","sources":["../../../../src/transports/clients/CommunicationClient.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}