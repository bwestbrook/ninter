{"ast":null,"code":"import \"core-js/modules/es.array.includes.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { keys } from '@airgap/beacon-utils';\nimport { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';\nimport { StorageKey } from '@airgap/beacon-types';\nconst PRESERVED_FIELDS = ['syncToken', 'rooms'];\n/**\n * The class managing the local state of matrix\n */\n\nexport class MatrixClientStore {\n  constructor(storage) {\n    this.storage = storage;\n    /**\n     * The state of the matrix client\n     */\n\n    this.state = {\n      isRunning: false,\n      userId: undefined,\n      deviceId: undefined,\n      txnNo: 0,\n      accessToken: undefined,\n      syncToken: undefined,\n      pollingTimeout: undefined,\n      pollingRetries: 0,\n      rooms: {}\n    };\n    /**\n     * Listeners that will be called when the state changes\n     */\n\n    this.onStateChangedListeners = new Map();\n    /**\n     * A promise that resolves once the client is ready\n     */\n\n    this.waitReadyPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this.initFromStorage();\n        resolve();\n      } catch (error) {\n        reject(error);\n      }\n    }));\n  }\n  /**\n   * Get an item from the state\n   *\n   * @param key\n   */\n\n\n  get(key) {\n    return this.state[key];\n  }\n  /**\n   * Get the room from an ID or room instance\n   *\n   * @param roomOrId\n   */\n\n\n  getRoom(roomOrId) {\n    const room = MatrixRoom.from(roomOrId, MatrixRoomStatus.UNKNOWN);\n    return this.state.rooms[room.id] || room;\n  }\n  /**\n   * Update the state with a partial state\n   *\n   * @param stateUpdate\n   */\n\n\n  update(stateUpdate) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.waitReady();\n      const oldState = Object.assign({}, this.state);\n      this.setState(stateUpdate);\n      this.updateStorage(stateUpdate);\n      this.notifyListeners(oldState, this.state, stateUpdate);\n    });\n  }\n  /**\n   * Register listeners that are called once the state has changed\n   *\n   * @param listener\n   * @param subscribed\n   */\n\n\n  onStateChanged(listener, ...subscribed) {\n    if (subscribed.length > 0) {\n      subscribed.forEach(key => {\n        this.onStateChangedListeners.set(key, listener);\n      });\n    } else {\n      this.onStateChangedListeners.set('all', listener);\n    }\n  }\n  /**\n   * A promise that resolves once the client is ready\n   */\n\n\n  waitReady() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.waitReadyPromise;\n    });\n  }\n  /**\n   * Read state from storage\n   */\n\n\n  initFromStorage() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const preserved = yield this.storage.get(StorageKey.MATRIX_PRESERVED_STATE);\n      this.setState(preserved);\n    });\n  }\n  /**\n   * Prepare data before persisting it in storage\n   *\n   * @param toStore\n   */\n\n\n  prepareData(toStore) {\n    const requiresPreparation = ['rooms'];\n    const toStoreCopy = requiresPreparation.some(key => toStore[key] !== undefined) ? JSON.parse(JSON.stringify(toStore)) : toStore; // there is no need for saving messages in a persistent storage\n\n    Object.values(toStoreCopy.rooms || {}).forEach(room => {\n      room.messages = [];\n    });\n    return toStoreCopy;\n  }\n  /**\n   * Persist state in storage\n   *\n   * @param stateUpdate\n   */\n\n\n  updateStorage(stateUpdate) {\n    const updatedCachedFields = Object.entries(stateUpdate).filter(([key, value]) => PRESERVED_FIELDS.includes(key) && Boolean(value));\n\n    if (updatedCachedFields.length > 0) {\n      const filteredState = {};\n      PRESERVED_FIELDS.forEach(key => {\n        filteredState[key] = this.state[key];\n      });\n      this.storage.set(StorageKey.MATRIX_PRESERVED_STATE, this.prepareData(filteredState));\n    }\n  }\n  /**\n   * Set the state\n   *\n   * @param partialState\n   */\n\n\n  setState(partialState) {\n    this.state = {\n      isRunning: partialState.isRunning || this.state.isRunning,\n      userId: partialState.userId || this.state.userId,\n      deviceId: partialState.deviceId || this.state.deviceId,\n      txnNo: partialState.txnNo || this.state.txnNo,\n      accessToken: partialState.accessToken || this.state.accessToken,\n      syncToken: partialState.syncToken || this.state.syncToken,\n      pollingTimeout: partialState.pollingTimeout || this.state.pollingTimeout,\n      pollingRetries: partialState.pollingRetries || this.state.pollingRetries,\n      rooms: this.mergeRooms(this.state.rooms, partialState.rooms)\n    };\n  }\n  /**\n   * Merge room records and eliminate duplicates\n   *\n   * @param oldRooms\n   * @param _newRooms\n   */\n\n\n  mergeRooms(oldRooms, _newRooms) {\n    if (!_newRooms) {\n      return oldRooms;\n    }\n\n    const newRooms = Array.isArray(_newRooms) ? _newRooms : Object.values(_newRooms);\n    const merged = Object.assign({}, oldRooms);\n    newRooms.forEach(newRoom => {\n      merged[newRoom.id] = MatrixRoom.merge(newRoom, oldRooms[newRoom.id]);\n    });\n    return merged;\n  }\n  /**\n   * Notify listeners of state changes\n   *\n   * @param oldState\n   * @param newState\n   * @param stateChange\n   */\n\n\n  notifyListeners(oldState, newState, stateChange) {\n    const listenForAll = this.onStateChangedListeners.get('all');\n\n    if (listenForAll) {\n      listenForAll(oldState, newState, stateChange);\n    }\n\n    keys(stateChange).filter(key => stateChange[key] !== undefined).forEach(key => {\n      const listener = this.onStateChangedListeners.get(key);\n\n      if (listener) {\n        listener(oldState, newState, stateChange);\n      }\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["keys","MatrixRoom","MatrixRoomStatus","StorageKey","PRESERVED_FIELDS","MatrixClientStore","constructor","storage","isRunning","userId","undefined","deviceId","txnNo","accessToken","syncToken","pollingTimeout","pollingRetries","rooms","Map","Promise","resolve","reject","__awaiter","initFromStorage","error","get","key","state","getRoom","roomOrId","room","from","UNKNOWN","id","update","stateUpdate","waitReady","oldState","Object","assign","setState","updateStorage","notifyListeners","onStateChanged","listener","subscribed","length","forEach","onStateChangedListeners","set","waitReadyPromise","preserved","MATRIX_PRESERVED_STATE","prepareData","toStore","requiresPreparation","toStoreCopy","some","JSON","parse","stringify","values","messages","updatedCachedFields","entries","filter","value","includes","Boolean","filteredState","partialState","mergeRooms","oldRooms","_newRooms","newRooms","Array","isArray","merged","newRoom","merge","newState","stateChange","listenForAll"],"sourceRoot":"","sources":["../../../src/matrix-client/MatrixClientStore.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}