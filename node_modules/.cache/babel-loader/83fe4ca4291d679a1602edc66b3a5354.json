{"ast":null,"code":"import \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport { Buffer } from 'buffer';\n\nvar _a, _b;\n\nvar Prefix;\n\n(function (Prefix) {\n  Prefix[\"TZ1\"] = \"tz1\";\n  Prefix[\"TZ2\"] = \"tz2\";\n  Prefix[\"TZ3\"] = \"tz3\";\n  Prefix[\"KT\"] = \"KT\";\n  Prefix[\"KT1\"] = \"KT1\";\n  Prefix[\"EDSK2\"] = \"edsk2\";\n  Prefix[\"SPSK\"] = \"spsk\";\n  Prefix[\"P2SK\"] = \"p2sk\";\n  Prefix[\"EDPK\"] = \"edpk\";\n  Prefix[\"SPPK\"] = \"sppk\";\n  Prefix[\"P2PK\"] = \"p2pk\";\n  Prefix[\"EDESK\"] = \"edesk\";\n  Prefix[\"SPESK\"] = \"spesk\";\n  Prefix[\"P2ESK\"] = \"p2esk\";\n  Prefix[\"EDSK\"] = \"edsk\";\n  Prefix[\"EDSIG\"] = \"edsig\";\n  Prefix[\"SPSIG\"] = \"spsig\";\n  Prefix[\"P2SIG\"] = \"p2sig\";\n  Prefix[\"SIG\"] = \"sig\";\n  Prefix[\"NET\"] = \"Net\";\n  Prefix[\"NCE\"] = \"nce\";\n  Prefix[\"B\"] = \"b\";\n  Prefix[\"O\"] = \"o\";\n  Prefix[\"LO\"] = \"Lo\";\n  Prefix[\"LLO\"] = \"LLo\";\n  Prefix[\"P\"] = \"P\";\n  Prefix[\"CO\"] = \"Co\";\n  Prefix[\"ID\"] = \"id\";\n  Prefix[\"EXPR\"] = \"expr\";\n  Prefix[\"TZ\"] = \"TZ\";\n})(Prefix || (Prefix = {}));\n\nvar prefix = (_a = {}, _a[Prefix.TZ1] = new Uint8Array([6, 161, 159]), _a[Prefix.TZ2] = new Uint8Array([6, 161, 161]), _a[Prefix.TZ3] = new Uint8Array([6, 161, 164]), _a[Prefix.KT] = new Uint8Array([2, 90, 121]), _a[Prefix.KT1] = new Uint8Array([2, 90, 121]), _a[Prefix.EDSK] = new Uint8Array([43, 246, 78, 7]), _a[Prefix.EDSK2] = new Uint8Array([13, 15, 58, 7]), _a[Prefix.SPSK] = new Uint8Array([17, 162, 224, 201]), _a[Prefix.P2SK] = new Uint8Array([16, 81, 238, 189]), _a[Prefix.EDPK] = new Uint8Array([13, 15, 37, 217]), _a[Prefix.SPPK] = new Uint8Array([3, 254, 226, 86]), _a[Prefix.P2PK] = new Uint8Array([3, 178, 139, 127]), _a[Prefix.EDESK] = new Uint8Array([7, 90, 60, 179, 41]), _a[Prefix.SPESK] = new Uint8Array([0x09, 0xed, 0xf1, 0xae, 0x96]), _a[Prefix.P2ESK] = new Uint8Array([0x09, 0x30, 0x39, 0x73, 0xab]), _a[Prefix.EDSIG] = new Uint8Array([9, 245, 205, 134, 18]), _a[Prefix.SPSIG] = new Uint8Array([13, 115, 101, 19, 63]), _a[Prefix.P2SIG] = new Uint8Array([54, 240, 44, 52]), _a[Prefix.SIG] = new Uint8Array([4, 130, 43]), _a[Prefix.NET] = new Uint8Array([87, 82, 0]), _a[Prefix.NCE] = new Uint8Array([69, 220, 169]), _a[Prefix.B] = new Uint8Array([1, 52]), _a[Prefix.O] = new Uint8Array([5, 116]), _a[Prefix.LO] = new Uint8Array([133, 233]), _a[Prefix.LLO] = new Uint8Array([29, 159, 109]), _a[Prefix.P] = new Uint8Array([2, 170]), _a[Prefix.CO] = new Uint8Array([79, 179]), _a[Prefix.ID] = new Uint8Array([153, 103]), _a[Prefix.EXPR] = new Uint8Array([13, 44, 64, 27]), // Legacy prefix\n_a[Prefix.TZ] = new Uint8Array([2, 90, 121]), _a);\nvar prefixLength = (_b = {}, _b[Prefix.TZ1] = 20, _b[Prefix.TZ2] = 20, _b[Prefix.TZ3] = 20, _b[Prefix.KT] = 20, _b[Prefix.KT1] = 20, _b[Prefix.EDPK] = 32, _b[Prefix.SPPK] = 33, _b[Prefix.P2PK] = 33, _b[Prefix.EDSIG] = 64, _b[Prefix.SPSIG] = 64, _b[Prefix.P2SIG] = 64, _b[Prefix.SIG] = 64, _b[Prefix.NET] = 4, _b[Prefix.B] = 32, _b[Prefix.P] = 32, _b[Prefix.O] = 32, _b);\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spreadArray(to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n}\n\nvar bs58check$1 = require('bs58check');\n\nvar ValidationResult;\n\n(function (ValidationResult) {\n  ValidationResult[ValidationResult[\"NO_PREFIX_MATCHED\"] = 0] = \"NO_PREFIX_MATCHED\";\n  ValidationResult[ValidationResult[\"INVALID_CHECKSUM\"] = 1] = \"INVALID_CHECKSUM\";\n  ValidationResult[ValidationResult[\"INVALID_LENGTH\"] = 2] = \"INVALID_LENGTH\";\n  ValidationResult[ValidationResult[\"VALID\"] = 3] = \"VALID\";\n})(ValidationResult || (ValidationResult = {}));\n\nfunction isValidPrefix(value) {\n  if (typeof value !== 'string') {\n    return false;\n  }\n\n  return value in prefix;\n}\n/**\r\n * @description This function is called by the validation functions ([[validateAddress]], [[validateChain]], [[validateContractAddress]], [[validateKeyHash]], [[validateSignature]], [[validatePublicKey]]).\r\n * Verify if the value has the right prefix or return `NO_PREFIX_MATCHED`,\r\n * decode the value using base58 and return `INVALID_CHECKSUM` if it fails,\r\n * check if the length of the value matches the prefix type or return `INVALID_LENGTH`.\r\n * If all checks pass, return `VALID`.\r\n *\r\n * @param value Value to validate\r\n * @param prefixes prefix the value should have\r\n */\n\n\nfunction validatePrefixedValue(value, prefixes) {\n  var match = new RegExp(\"^(\" + prefixes.join('|') + \")\").exec(value);\n\n  if (!match || match.length === 0) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  }\n\n  var prefixKey = match[0];\n\n  if (!isValidPrefix(prefixKey)) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  } // Remove annotation from contract address before doing the validation\n\n\n  var contractAddress = /^(KT1\\w{33})(\\%(.*))?/.exec(value);\n\n  if (contractAddress) {\n    value = contractAddress[1];\n  } // decodeUnsafe return undefined if decoding fail\n\n\n  var decoded = bs58check$1.decodeUnsafe(value);\n\n  if (!decoded) {\n    return ValidationResult.INVALID_CHECKSUM;\n  }\n\n  decoded = decoded.slice(prefix[prefixKey].length);\n\n  if (decoded.length !== prefixLength[prefixKey]) {\n    return ValidationResult.INVALID_LENGTH;\n  }\n\n  return ValidationResult.VALID;\n}\n\nvar implicitPrefix = [Prefix.TZ1, Prefix.TZ2, Prefix.TZ3];\nvar contractPrefix = [Prefix.KT1];\nvar signaturePrefix = [Prefix.EDSIG, Prefix.P2SIG, Prefix.SPSIG, Prefix.SIG];\nvar pkPrefix = [Prefix.EDPK, Prefix.SPPK, Prefix.P2PK];\n/**\r\n * @description Used to check if an address or a contract address is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateAddress } from '@taquito/utils';\r\n * const pkh = 'tz1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\r\n * const validation = validateAddress(pkh)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\nfunction validateAddress(value) {\n  return validatePrefixedValue(value, __spreadArray(__spreadArray([], __read(implicitPrefix)), __read(contractPrefix)));\n}\n/**\r\n * @description Used to check if a chain id is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateChain } from '@taquito/utils';\r\n * const chainId = 'NetXdQprcVkpaWU'\r\n * const validation = validateChain(chainId)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateChain(value) {\n  return validatePrefixedValue(value, [Prefix.NET]);\n}\n/**\r\n * @description Used to check if a contract address is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateContractAddress } from '@taquito/utils';\r\n * const contractAddress = 'KT1JVErLYTgtY8uGGZ4mso2npTSxqVLDRVbC'\r\n * const validation = validateContractAddress(contractAddress)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateContractAddress(value) {\n  return validatePrefixedValue(value, contractPrefix);\n}\n/**\r\n * @description Used to check if a key hash is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateKeyHash } from '@taquito/utils';\r\n * const keyHashWithoutPrefix = '1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\r\n * const validation = validateKeyHash(keyHashWithoutPrefix)\r\n * console.log(validation)\r\n * // This example return 0 which correspond to NO_PREFIX_MATCHED\r\n * ```\r\n */\n\n\nfunction validateKeyHash(value) {\n  return validatePrefixedValue(value, implicitPrefix);\n}\n/**\r\n * @description Used to check if a signature is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validateSignature } from '@taquito/utils';\r\n * const signature = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\r\n * const validation = validateSignature(signature)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validateSignature(value) {\n  return validatePrefixedValue(value, signaturePrefix);\n}\n/**\r\n * @description Used to check if a signature is valid.\r\n *\r\n * @returns\r\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\r\n *\r\n * @example\r\n * ```\r\n * import { validatePublicKey } from '@taquito/utils';\r\n * const publicKey = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\r\n * const validation = validatePublicKey(publicKey)\r\n * console.log(validation)\r\n * // This example return 3 which correspond to VALID\r\n * ```\r\n */\n\n\nfunction validatePublicKey(value) {\n  return validatePrefixedValue(value, pkPrefix);\n} // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\n\n/* tslint:disable */\n\n\nvar VERSION = {\n  \"commitHash\": \"5711569ffaf481d88ba3251343a1788090b35dd4\",\n  \"version\": \"10.2.1\"\n};\n/* tslint:enable */\n\n/**\r\n * @packageDocumentation\r\n * @module @taquito/utils\r\n */\n\nvar blake = require('blakejs');\n\nvar bs58check = require('bs58check');\n/**\r\n *\r\n * @description Hash a string using the BLAKE2b algorithm, base58 encode the hash obtained and appends the prefix 'expr' to it\r\n *\r\n * @param value Value in hex\r\n */\n\n\nfunction encodeExpr(value) {\n  var blakeHash = blake.blake2b(hex2buf(value), null, 32);\n  return b58cencode(blakeHash, prefix['expr']);\n}\n/**\r\n *\r\n * @description Return the operation hash of a signed operation\r\n * @param value Value in hex of a signed operation\r\n */\n\n\nfunction encodeOpHash(value) {\n  var blakeHash = blake.blake2b(hex2buf(value), null, 32);\n  return b58cencode(blakeHash, prefix.o);\n}\n/**\r\n *\r\n * @description Base58 encode a string or a Uint8Array and append a prefix to it\r\n *\r\n * @param value Value to base58 encode\r\n * @param prefix prefix to append to the encoded string\r\n */\n\n\nfunction b58cencode(value, prefix) {\n  var payloadAr = typeof value === 'string' ? Uint8Array.from(Buffer.from(value, 'hex')) : value;\n  var n = new Uint8Array(prefix.length + payloadAr.length);\n  n.set(prefix);\n  n.set(payloadAr, prefix.length);\n  return bs58check.encode(Buffer.from(n.buffer));\n}\n/**\r\n *\r\n * @description Base58 decode a string and remove the prefix from it\r\n *\r\n * @param value Value to base58 decode\r\n * @param prefix prefix to remove from the decoded string\r\n */\n\n\nvar b58cdecode = function (enc, prefixArg) {\n  return bs58check.decode(enc).slice(prefixArg.length);\n};\n/**\r\n *\r\n * @description Base58 decode a string with predefined prefix\r\n *\r\n * @param value Value to base58 decode\r\n */\n\n\nfunction b58decode(payload) {\n  var _a;\n\n  var buf = bs58check.decode(payload);\n  var prefixMap = (_a = {}, _a[prefix.tz1.toString()] = '0000', _a[prefix.tz2.toString()] = '0001', _a[prefix.tz3.toString()] = '0002', _a);\n  var pref = prefixMap[new Uint8Array(buf.slice(0, 3)).toString()];\n\n  if (pref) {\n    // tz addresses\n    var hex = buf2hex(buf.slice(3));\n    return pref + hex;\n  } else {\n    // other (kt addresses)\n    return '01' + buf2hex(buf.slice(3, 42)) + '00';\n  }\n}\n/**\r\n *\r\n * @description Base58 encode a public key using predefined prefix\r\n *\r\n * @param value Public Key to base58 encode\r\n */\n\n\nfunction encodePubKey(value) {\n  if (value.substring(0, 2) === '00') {\n    var pref = {\n      '0000': prefix.tz1,\n      '0001': prefix.tz2,\n      '0002': prefix.tz3\n    };\n    return b58cencode(value.substring(4), pref[value.substring(0, 4)]);\n  }\n\n  return b58cencode(value.substring(2, 42), prefix.KT);\n}\n/**\r\n *\r\n * @description Base58 encode a key according to its prefix\r\n *\r\n * @param value Key to base58 encode\r\n */\n\n\nfunction encodeKey(value) {\n  if (value[0] === '0') {\n    var pref = {\n      '00': new Uint8Array([13, 15, 37, 217]),\n      '01': new Uint8Array([3, 254, 226, 86]),\n      '02': new Uint8Array([3, 178, 139, 127])\n    };\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n/**\r\n *\r\n * @description Base58 encode a key hash according to its prefix\r\n *\r\n * @param value Key to base58 encode\r\n */\n\n\nfunction encodeKeyHash(value) {\n  if (value[0] === '0') {\n    var pref = {\n      '00': new Uint8Array([6, 161, 159]),\n      '01': new Uint8Array([6, 161, 161]),\n      '02': new Uint8Array([6, 161, 164])\n    };\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n/**\r\n *\r\n * @description Convert an hex string to a Uint8Array\r\n *\r\n * @param hex Hex string to convert\r\n */\n\n\nvar hex2buf = function (hex) {\n  return new Uint8Array(hex.match(/[\\da-f]{2}/gi).map(function (h) {\n    return parseInt(h, 16);\n  }));\n};\n/**\r\n *\r\n * @description Merge 2 buffers together\r\n *\r\n * @param b1 First buffer\r\n * @param b2 Second buffer\r\n */\n\n\nvar mergebuf = function (b1, b2) {\n  var r = new Uint8Array(b1.length + b2.length);\n  r.set(b1);\n  r.set(b2, b1.length);\n  return r;\n};\n/**\r\n *\r\n * @description Flatten a michelson json representation to an array\r\n *\r\n * @param s michelson json\r\n */\n\n\nvar mic2arr = function me2(s) {\n  var ret = [];\n\n  if (Object.prototype.hasOwnProperty.call(s, 'prim')) {\n    if (s.prim === 'Pair') {\n      ret.push(me2(s.args[0]));\n      ret = ret.concat(me2(s.args[1]));\n    } else if (s.prim === 'Elt') {\n      ret = {\n        key: me2(s.args[0]),\n        val: me2(s.args[1])\n      };\n    } else if (s.prim === 'True') {\n      ret = true;\n    } else if (s.prim === 'False') {\n      ret = false;\n    }\n  } else if (Array.isArray(s)) {\n    var sc = s.length;\n\n    for (var i = 0; i < sc; i++) {\n      var n = me2(s[i]);\n\n      if (typeof n.key !== 'undefined') {\n        if (Array.isArray(ret)) {\n          ret = {\n            keys: [],\n            vals: []\n          };\n        }\n\n        ret.keys.push(n.key);\n        ret.vals.push(n.val);\n      } else {\n        ret.push(n);\n      }\n    }\n  } else if (Object.prototype.hasOwnProperty.call(s, 'string')) {\n    ret = s.string;\n  } else if (Object.prototype.hasOwnProperty.call(s, 'int')) {\n    ret = parseInt(s.int, 10);\n  } else {\n    ret = s;\n  }\n\n  return ret;\n};\n/**\r\n *\r\n * @description Convert a buffer to an hex string\r\n *\r\n * @param buffer Buffer to convert\r\n */\n\n\nvar buf2hex = function (buffer) {\n  var byteArray = new Uint8Array(buffer);\n  var hexParts = [];\n  byteArray.forEach(function (byte) {\n    var hex = byte.toString(16);\n    var paddedHex = (\"00\" + hex).slice(-2);\n    hexParts.push(paddedHex);\n  });\n  return hexParts.join('');\n};\n/**\r\n *\r\n * @description Convert a string to bytes\r\n *\r\n * @param str String to convert\r\n */\n\n\nfunction char2Bytes(str) {\n  return Buffer.from(str, 'utf8').toString('hex');\n}\n/**\r\n *\r\n * @description Convert bytes to a string\r\n *\r\n * @param str Bytes to convert\r\n */\n\n\nfunction bytes2Char(hex) {\n  return Buffer.from(hex2buf(hex)).toString('utf8');\n}\n\nexport { Prefix, VERSION, ValidationResult, b58cdecode, b58cencode, b58decode, buf2hex, bytes2Char, char2Bytes, encodeExpr, encodeKey, encodeKeyHash, encodeOpHash, encodePubKey, hex2buf, isValidPrefix, mergebuf, mic2arr, prefix, prefixLength, validateAddress, validateChain, validateContractAddress, validateKeyHash, validatePublicKey, validateSignature };","map":{"version":3,"mappings":"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","names":["Prefix","prefix","_a","TZ1","Uint8Array","TZ2","TZ3","KT","KT1","EDSK","EDSK2","SPSK","P2SK","EDPK","SPPK","P2PK","EDESK","SPESK","P2ESK","EDSIG","SPSIG","P2SIG","SIG","NET","NCE","B","O","LO","LLO","P","CO","ID","EXPR","TZ","prefixLength","_b","bs58check","require","ValidationResult","isValidPrefix","value","validatePrefixedValue","prefixes","match","RegExp","join","exec","length","NO_PREFIX_MATCHED","prefixKey","contractAddress","decoded","decodeUnsafe","INVALID_CHECKSUM","slice","INVALID_LENGTH","VALID","implicitPrefix","contractPrefix","signaturePrefix","pkPrefix","validateAddress","__spreadArray","__read","validateChain","validateContractAddress","validateKeyHash","validateSignature","validatePublicKey","VERSION","blake","encodeExpr","blakeHash","blake2b","hex2buf","b58cencode","encodeOpHash","o","payloadAr","from","Buffer","n","set","encode","buffer","b58cdecode","enc","prefixArg","decode","b58decode","payload","buf","prefixMap","tz1","toString","tz2","tz3","pref","hex","buf2hex","encodePubKey","substring","encodeKey","encodeKeyHash","map","h","mergebuf","b1","b2","r","mic2arr","me2","s","ret","Object","prototype","hasOwnProperty","call","prim","push","args","concat","key","val","Array","isArray","sc","i","keys","vals","string","parseInt","int","byteArray","hexParts","forEach","byte","paddedHex","char2Bytes","str","bytes2Char"],"sources":["../src/constants.ts","../src/validators.ts","../src/version.ts","../src/taquito-utils.ts"],"sourcesContent":["export enum Prefix {\n  TZ1 = 'tz1',\n  TZ2 = 'tz2',\n  TZ3 = 'tz3',\n  KT = 'KT',\n  KT1 = 'KT1',\n\n  EDSK2 = 'edsk2',\n  SPSK = 'spsk',\n  P2SK = 'p2sk',\n\n  EDPK = 'edpk',\n  SPPK = 'sppk',\n  P2PK = 'p2pk',\n\n  EDESK = 'edesk',\n  SPESK = 'spesk',\n  P2ESK = 'p2esk',\n\n  EDSK = 'edsk',\n  EDSIG = 'edsig',\n  SPSIG = 'spsig',\n  P2SIG = 'p2sig',\n  SIG = 'sig',\n\n  NET = 'Net',\n  NCE = 'nce',\n  B = 'b',\n  O = 'o',\n  LO = 'Lo',\n  LLO = 'LLo',\n  P = 'P',\n  CO = 'Co',\n  ID = 'id',\n\n  EXPR = 'expr',\n  TZ = 'TZ',\n}\n\nexport const prefix = {\n  [Prefix.TZ1]: new Uint8Array([6, 161, 159]),\n  [Prefix.TZ2]: new Uint8Array([6, 161, 161]),\n  [Prefix.TZ3]: new Uint8Array([6, 161, 164]),\n  [Prefix.KT]: new Uint8Array([2, 90, 121]),\n  [Prefix.KT1]: new Uint8Array([2, 90, 121]),\n\n  [Prefix.EDSK]: new Uint8Array([43, 246, 78, 7]),\n  [Prefix.EDSK2]: new Uint8Array([13, 15, 58, 7]),\n  [Prefix.SPSK]: new Uint8Array([17, 162, 224, 201]),\n  [Prefix.P2SK]: new Uint8Array([16, 81, 238, 189]),\n\n  [Prefix.EDPK]: new Uint8Array([13, 15, 37, 217]),\n  [Prefix.SPPK]: new Uint8Array([3, 254, 226, 86]),\n  [Prefix.P2PK]: new Uint8Array([3, 178, 139, 127]),\n\n  [Prefix.EDESK]: new Uint8Array([7, 90, 60, 179, 41]),\n  [Prefix.SPESK]: new Uint8Array([0x09, 0xed, 0xf1, 0xae, 0x96]),\n  [Prefix.P2ESK]: new Uint8Array([0x09, 0x30, 0x39, 0x73, 0xab]),\n\n  [Prefix.EDSIG]: new Uint8Array([9, 245, 205, 134, 18]),\n  [Prefix.SPSIG]: new Uint8Array([13, 115, 101, 19, 63]),\n  [Prefix.P2SIG]: new Uint8Array([54, 240, 44, 52]),\n  [Prefix.SIG]: new Uint8Array([4, 130, 43]),\n\n  [Prefix.NET]: new Uint8Array([87, 82, 0]),\n  [Prefix.NCE]: new Uint8Array([69, 220, 169]),\n  [Prefix.B]: new Uint8Array([1, 52]),\n  [Prefix.O]: new Uint8Array([5, 116]),\n  [Prefix.LO]: new Uint8Array([133, 233]),\n  [Prefix.LLO]: new Uint8Array([29, 159, 109]),\n  [Prefix.P]: new Uint8Array([2, 170]),\n  [Prefix.CO]: new Uint8Array([79, 179]),\n  [Prefix.ID]: new Uint8Array([153, 103]),\n\n  [Prefix.EXPR]: new Uint8Array([13, 44, 64, 27]),\n  // Legacy prefix\n  [Prefix.TZ]: new Uint8Array([2, 90, 121]),\n};\n\nexport const prefixLength: { [key: string]: number } = {\n  [Prefix.TZ1]: 20,\n  [Prefix.TZ2]: 20,\n  [Prefix.TZ3]: 20,\n  [Prefix.KT]: 20,\n  [Prefix.KT1]: 20,\n  [Prefix.EDPK]: 32,\n  [Prefix.SPPK]: 33,\n  [Prefix.P2PK]: 33,\n  [Prefix.EDSIG]: 64,\n  [Prefix.SPSIG]: 64,\n  [Prefix.P2SIG]: 64,\n  [Prefix.SIG]: 64,\n  [Prefix.NET]: 4,\n  [Prefix.B]: 32,\n  [Prefix.P]: 32,\n  [Prefix.O]: 32\n};\n","import { prefix, prefixLength, Prefix } from './constants';\n\nconst bs58check = require('bs58check');\n\nexport enum ValidationResult {\n  NO_PREFIX_MATCHED,\n  INVALID_CHECKSUM,\n  INVALID_LENGTH,\n  VALID,\n}\n\nexport function isValidPrefix(value: any): value is Prefix {\n  if (typeof value !== 'string') {\n    return false;\n  }\n\n  return value in prefix;\n}\n  /**\n   * @description This function is called by the validation functions ([[validateAddress]], [[validateChain]], [[validateContractAddress]], [[validateKeyHash]], [[validateSignature]], [[validatePublicKey]]).\n   * Verify if the value has the right prefix or return `NO_PREFIX_MATCHED`,\n   * decode the value using base58 and return `INVALID_CHECKSUM` if it fails,\n   * check if the length of the value matches the prefix type or return `INVALID_LENGTH`.\n   * If all checks pass, return `VALID`.\n   *\n   * @param value Value to validate\n   * @param prefixes prefix the value should have\n   */\nfunction validatePrefixedValue(value: any, prefixes: Prefix[]) {\n  const match = new RegExp(`^(${prefixes.join('|')})`).exec(value);\n  if (!match || match.length === 0) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  }\n\n  const prefixKey = match[0];\n\n  if (!isValidPrefix(prefixKey)) {\n    return ValidationResult.NO_PREFIX_MATCHED;\n  }\n\n  // Remove annotation from contract address before doing the validation\n  const contractAddress = /^(KT1\\w{33})(\\%(.*))?/.exec(value);\n  if (contractAddress) {\n    value = contractAddress[1];\n  }\n\n  // decodeUnsafe return undefined if decoding fail\n  let decoded = bs58check.decodeUnsafe(value);\n  if (!decoded) {\n    return ValidationResult.INVALID_CHECKSUM;\n  }\n\n  decoded = decoded.slice(prefix[prefixKey].length);\n  if (decoded.length !== prefixLength[prefixKey]) {\n    return ValidationResult.INVALID_LENGTH;\n  }\n\n  return ValidationResult.VALID;\n}\n\nconst implicitPrefix = [Prefix.TZ1, Prefix.TZ2, Prefix.TZ3];\nconst contractPrefix = [Prefix.KT1];\nconst signaturePrefix = [Prefix.EDSIG, Prefix.P2SIG, Prefix.SPSIG, Prefix.SIG];\nconst pkPrefix = [Prefix.EDPK, Prefix.SPPK, Prefix.P2PK];\n\n  /**\n   * @description Used to check if an address or a contract address is valid.\n   *\n   * @returns\n   * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n   *\n   * @example\n   * ```\n   * import { validateAddress } from '@taquito/utils';\n   * const pkh = 'tz1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n   * const validation = validateAddress(pkh)\n   * console.log(validation)\n   * // This example return 3 which correspond to VALID\n   * ```\n   */\nexport function validateAddress(value: any): ValidationResult {\n  return validatePrefixedValue(value, [...implicitPrefix, ...contractPrefix]);\n}\n  /**\n   * @description Used to check if a chain id is valid.\n   *\n   * @returns\n   * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n   *\n   * @example\n   * ```\n   * import { validateChain } from '@taquito/utils';\n   * const chainId = 'NetXdQprcVkpaWU'\n   * const validation = validateChain(chainId)\n   * console.log(validation)\n   * // This example return 3 which correspond to VALID\n   * ```\n   */\nexport function validateChain(value: any): ValidationResult {\n  return validatePrefixedValue(value, [Prefix.NET]);\n}\n  /**\n   * @description Used to check if a contract address is valid.\n   *\n   * @returns\n   * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n   *\n   * @example\n   * ```\n   * import { validateContractAddress } from '@taquito/utils';\n   * const contractAddress = 'KT1JVErLYTgtY8uGGZ4mso2npTSxqVLDRVbC'\n   * const validation = validateContractAddress(contractAddress)\n   * console.log(validation)\n   * // This example return 3 which correspond to VALID\n   * ```\n   */\nexport function validateContractAddress(value: any): ValidationResult {\n  return validatePrefixedValue(value, contractPrefix);\n}\n  /**\n   * @description Used to check if a key hash is valid.\n   *\n   * @returns\n   * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n   *\n   * @example\n   * ```\n   * import { validateKeyHash } from '@taquito/utils';\n   * const keyHashWithoutPrefix = '1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n   * const validation = validateKeyHash(keyHashWithoutPrefix)\n   * console.log(validation)\n   * // This example return 0 which correspond to NO_PREFIX_MATCHED\n   * ```\n   */\nexport function validateKeyHash(value: any): ValidationResult {\n  return validatePrefixedValue(value, implicitPrefix);\n}\n  /**\n   * @description Used to check if a signature is valid.\n   *\n   * @returns\n   * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n   *\n   * @example\n   * ```\n   * import { validateSignature } from '@taquito/utils';\n   * const signature = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\n   * const validation = validateSignature(signature)\n   * console.log(validation)\n   * // This example return 3 which correspond to VALID\n   * ```\n   */\nexport function validateSignature(value: any): ValidationResult {\n  return validatePrefixedValue(value, signaturePrefix);\n}\n  /**\n   * @description Used to check if a signature is valid.\n   *\n   * @returns\n   * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n   *\n   * @example\n   * ```\n   * import { validatePublicKey } from '@taquito/utils';\n   * const publicKey = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\n   * const validation = validatePublicKey(publicKey)\n   * console.log(validation)\n   * // This example return 3 which correspond to VALID\n   * ```\n   */\nexport function validatePublicKey(value: any): ValidationResult {\n  return validatePrefixedValue(value, pkPrefix);\n}\n","\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\n/* tslint:disable */\nexport const VERSION = {\n    \"commitHash\": \"5711569ffaf481d88ba3251343a1788090b35dd4\",\n    \"version\": \"10.2.1\"\n};\n/* tslint:enable */\n","/**\n * @packageDocumentation\n * @module @taquito/utils\n */\n\n/*\n * Some code in this file is originally from sotez and eztz\n * Copyright (c) 2018 Andrew Kishino\n * Copyright (c) 2017 Stephen Andrews\n */\n\nimport { Buffer } from 'buffer';\nimport { prefix } from './constants';\nconst blake = require('blakejs');\nconst bs58check = require('bs58check');\n\nexport * from './validators';\nexport { VERSION } from './version';\n\nexport { prefix, Prefix, prefixLength } from './constants';\n\n/**\n *\n * @description Hash a string using the BLAKE2b algorithm, base58 encode the hash obtained and appends the prefix 'expr' to it\n *\n * @param value Value in hex\n */\nexport function encodeExpr(value: string) {\n  const blakeHash = blake.blake2b(hex2buf(value), null, 32);\n  return b58cencode(blakeHash, prefix['expr']);\n}\n\n/**\n *\n * @description Return the operation hash of a signed operation \n * @param value Value in hex of a signed operation\n */\n export function encodeOpHash(value: string) {\n  const blakeHash = blake.blake2b(hex2buf(value), null, 32);\n  return b58cencode(blakeHash, prefix.o);\n}\n\n/**\n *\n * @description Base58 encode a string or a Uint8Array and append a prefix to it\n *\n * @param value Value to base58 encode\n * @param prefix prefix to append to the encoded string\n */\nexport function b58cencode(value: string | Uint8Array, prefix: Uint8Array) {\n  const payloadAr = typeof value === 'string' ? Uint8Array.from(Buffer.from(value, 'hex')) : value;\n\n  const n = new Uint8Array(prefix.length + payloadAr.length);\n  n.set(prefix);\n  n.set(payloadAr, prefix.length);\n\n  return bs58check.encode(Buffer.from(n.buffer));\n}\n\n/**\n *\n * @description Base58 decode a string and remove the prefix from it\n *\n * @param value Value to base58 decode\n * @param prefix prefix to remove from the decoded string\n */\nexport const b58cdecode = (enc: string, prefixArg: Uint8Array): Uint8Array =>\n  bs58check.decode(enc).slice(prefixArg.length);\n\n/**\n *\n * @description Base58 decode a string with predefined prefix\n *\n * @param value Value to base58 decode\n */\nexport function b58decode(payload: string) {\n  const buf: Buffer = bs58check.decode(payload);\n\n  const prefixMap = {\n    [prefix.tz1.toString()]: '0000',\n    [prefix.tz2.toString()]: '0001',\n    [prefix.tz3.toString()]: '0002',\n  };\n\n  let pref = prefixMap[new Uint8Array(buf.slice(0, 3)).toString()];\n  if (pref) {\n    // tz addresses\n    const hex = buf2hex(buf.slice(3));\n    return pref + hex;\n  } else {\n    // other (kt addresses)\n    return '01' + buf2hex(buf.slice(3, 42)) + '00';\n  }\n}\n\n/**\n *\n * @description Base58 encode a public key using predefined prefix\n *\n * @param value Public Key to base58 encode\n */\nexport function encodePubKey(value: string) {\n  if (value.substring(0, 2) === '00') {\n    const pref: { [key: string]: Uint8Array } = {\n      '0000': prefix.tz1,\n      '0001': prefix.tz2,\n      '0002': prefix.tz3,\n    };\n\n    return b58cencode(value.substring(4), pref[value.substring(0, 4)]);\n  }\n\n  return b58cencode(value.substring(2, 42), prefix.KT);\n}\n\n/**\n *\n * @description Base58 encode a key according to its prefix\n *\n * @param value Key to base58 encode\n */\nexport function encodeKey(value: string) {\n  if (value[0] === '0') {\n    const pref: { [key: string]: Uint8Array } = {\n      '00': new Uint8Array([13, 15, 37, 217]),\n      '01': new Uint8Array([3, 254, 226, 86]),\n      '02': new Uint8Array([3, 178, 139, 127]),\n    };\n\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n\n/**\n *\n * @description Base58 encode a key hash according to its prefix\n *\n * @param value Key to base58 encode\n */\nexport function encodeKeyHash(value: string) {\n  if (value[0] === '0') {\n    const pref: { [key: string]: Uint8Array } = {\n      '00': new Uint8Array([6, 161, 159]),\n      '01': new Uint8Array([6, 161, 161]),\n      '02': new Uint8Array([6, 161, 164]),\n    };\n\n    return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n  }\n}\n\n/**\n *\n * @description Convert an hex string to a Uint8Array\n *\n * @param hex Hex string to convert\n */\nexport const hex2buf = (hex: string): Uint8Array => {\n  return new Uint8Array(hex.match(/[\\da-f]{2}/gi)!.map((h) => parseInt(h, 16)));\n};\n\n/**\n *\n * @description Merge 2 buffers together\n *\n * @param b1 First buffer\n * @param b2 Second buffer\n */\nexport const mergebuf = (b1: Uint8Array, b2: Uint8Array): Uint8Array => {\n  const r = new Uint8Array(b1.length + b2.length);\n  r.set(b1);\n  r.set(b2, b1.length);\n  return r;\n};\n\n/**\n *\n * @description Flatten a michelson json representation to an array\n *\n * @param s michelson json\n */\nexport const mic2arr = function me2(s: any): any {\n  let ret: any = [];\n  if (Object.prototype.hasOwnProperty.call(s, 'prim')) {\n    if (s.prim === 'Pair') {\n      ret.push(me2(s.args[0]));\n      ret = ret.concat(me2(s.args[1]));\n    } else if (s.prim === 'Elt') {\n      ret = {\n        key: me2(s.args[0]),\n        val: me2(s.args[1]),\n      };\n    } else if (s.prim === 'True') {\n      ret = true;\n    } else if (s.prim === 'False') {\n      ret = false;\n    }\n  } else if (Array.isArray(s)) {\n    const sc = s.length;\n    for (let i = 0; i < sc; i++) {\n      const n = me2(s[i]);\n      if (typeof n.key !== 'undefined') {\n        if (Array.isArray(ret)) {\n          ret = {\n            keys: [],\n            vals: [],\n          };\n        }\n        ret.keys.push(n.key);\n        ret.vals.push(n.val);\n      } else {\n        ret.push(n);\n      }\n    }\n  } else if (Object.prototype.hasOwnProperty.call(s, 'string')) {\n    ret = s.string;\n  } else if (Object.prototype.hasOwnProperty.call(s, 'int')) {\n    ret = parseInt(s.int, 10);\n  } else {\n    ret = s;\n  }\n  return ret;\n};\n\n/**\n *\n * @description Convert a buffer to an hex string\n *\n * @param buffer Buffer to convert\n */\nexport const buf2hex = (buffer: Buffer): string => {\n  const byteArray = new Uint8Array(buffer);\n  const hexParts: string[] = [];\n  byteArray.forEach((byte: any) => {\n    const hex = byte.toString(16);\n    const paddedHex = `00${hex}`.slice(-2);\n    hexParts.push(paddedHex);\n  });\n  return hexParts.join('');\n};\n\n/**\n *\n * @description Convert a string to bytes\n *\n * @param str String to convert\n */\nexport function char2Bytes(str: string) {\n  return Buffer.from(str, 'utf8').toString('hex');\n}\n\n/**\n *\n * @description Convert bytes to a string\n *\n * @param str Bytes to convert\n */\nexport function bytes2Char(hex: string): string {\n  return Buffer.from(hex2buf(hex)).toString('utf8');\n}\n"]},"metadata":{},"sourceType":"module"}