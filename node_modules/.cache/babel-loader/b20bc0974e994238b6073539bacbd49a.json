{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { StorageKey, TransportStatus } from '@airgap/beacon-types';\nimport { Logger } from '@airgap/beacon-core';\nimport { P2PTransport } from '@airgap/beacon-transport-matrix';\nconst logger = new Logger('DappP2PTransport');\n/**\n * @internalapi\n *\n *\n */\n\nexport class DappP2PTransport extends P2PTransport {\n  constructor(name, keyPair, storage, matrixNodes, iconUrl, appUrl) {\n    super(name, keyPair, storage, matrixNodes, StorageKey.TRANSPORT_P2P_PEERS_DAPP, iconUrl, appUrl);\n  }\n\n  startOpenChannelListener() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.client.listenForChannelOpening(peer => __awaiter(this, void 0, void 0, function* () {\n        logger.log('listenForNewPeer', `new publicKey`, peer.publicKey);\n        yield this.addPeer(peer);\n        this._isConnected = TransportStatus.CONNECTED;\n\n        if (this.newPeerListener) {\n          this.newPeerListener(peer);\n          this.newPeerListener = undefined; // TODO: Remove this once we use the id\n        }\n      }));\n    });\n  }\n\n  listenForNewPeer(newPeerListener) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('listenForNewPeer');\n      this.newPeerListener = newPeerListener;\n    });\n  }\n\n  stopListeningForNewPeers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('stopListeningForNewPeers');\n      this.newPeerListener = undefined;\n    });\n  }\n\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAEEA,UAFF,EAGEC,eAHF,QAKO,sBALP;AAMA,SAASC,MAAT,QAAuB,qBAAvB;AACA,SAASC,YAAT,QAA6B,iCAA7B;AAEA,MAAMC,MAAM,GAAG,IAAIF,MAAJ,CAAW,kBAAX,CAAf;AAEA;;;;;;AAKA,OAAM,MAAOG,gBAAP,SAAgCF,YAAhC,CAGL;EACCG,YACEC,IADF,EAEEC,OAFF,EAGEC,OAHF,EAIEC,WAJF,EAKEC,OALF,EAMEC,MANF,EAMiB;IAEf,MAAML,IAAN,EAAYC,OAAZ,EAAqBC,OAArB,EAA8BC,WAA9B,EAA2CV,UAAU,CAACa,wBAAtD,EAAgFF,OAAhF,EAAyFC,MAAzF;EACD;;EAEYE,wBAAwB;;MACnC,OAAO,KAAKC,MAAL,CAAYC,uBAAZ,CAA2CC,IAAP,IAAeC;QACxDd,MAAM,CAACe,GAAP,CAAW,kBAAX,EAA+B,eAA/B,EAAgDF,IAAI,CAACG,SAArD;QAEA,MAAM,KAAKC,OAAL,CAAaJ,IAAb,CAAN;QAEA,KAAKK,YAAL,GAAoBrB,eAAe,CAACsB,SAApC;;QAEA,IAAI,KAAKC,eAAT,EAA0B;UACxB,KAAKA,eAAL,CAAqBP,IAArB;UACA,KAAKO,eAAL,GAAuBC,SAAvB,CAFwB,CAES;QAClC;MACF,CAXyD,CAAnD,CAAP;IAYD;EAAA;;EAEYC,gBAAgB,CAC3BF,eAD2B,EACgC;;MAE3DpB,MAAM,CAACe,GAAP,CAAW,kBAAX;MACA,KAAKK,eAAL,GAAuBA,eAAvB;IACD;EAAA;;EAEYG,wBAAwB;;MACnCvB,MAAM,CAACe,GAAP,CAAW,0BAAX;MACA,KAAKK,eAAL,GAAuBC,SAAvB;IACD;EAAA;;AArCF","names":["StorageKey","TransportStatus","Logger","P2PTransport","logger","DappP2PTransport","constructor","name","keyPair","storage","matrixNodes","iconUrl","appUrl","TRANSPORT_P2P_PEERS_DAPP","startOpenChannelListener","client","listenForChannelOpening","peer","__awaiter","log","publicKey","addPeer","_isConnected","CONNECTED","newPeerListener","undefined","listenForNewPeer","stopListeningForNewPeers"],"sourceRoot":"","sources":["../../../src/transports/DappP2PTransport.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}