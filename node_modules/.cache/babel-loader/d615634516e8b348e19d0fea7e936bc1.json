{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Logger } from '../utils/Logger';\nimport { TransportType, TransportStatus } from '@airgap/beacon-types';\nconst logger = new Logger('Transport');\n/**\n * @internalapi\n *\n *\n */\n\nexport class Transport {\n  constructor(name, client, peerManager) {\n    /**\n     * The type of the transport\n     */\n    this.type = TransportType.POST_MESSAGE;\n    /**\n     * The status of the transport\n     */\n\n    this._isConnected = TransportStatus.NOT_CONNECTED;\n    /**\n     * The listeners that will be notified when new messages are coming in\n     */\n\n    this.listeners = [];\n    this.name = name;\n    this.client = client;\n    this.peerManager = peerManager;\n  }\n  /**\n   * Return the status of the connection\n   */\n\n\n  get connectionStatus() {\n    return this._isConnected;\n  }\n  /**\n   * Returns a promise that resolves to true if the transport is available, false if it is not\n   */\n\n\n  static isAvailable() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return Promise.resolve(false);\n    });\n  }\n  /**\n   * Connect the transport\n   */\n\n\n  connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('connect');\n      this._isConnected = TransportStatus.CONNECTED;\n      return;\n    });\n  }\n  /**\n   * Disconnect the transport\n   */\n\n\n  disconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('disconnect');\n      this._isConnected = TransportStatus.NOT_CONNECTED;\n      return;\n    });\n  }\n  /**\n   * Send a message through the transport\n   *\n   * @param message The message to send\n   * @param recipient The recipient of the message\n   */\n\n\n  send(message, peer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (peer) {\n        return this.client.sendMessage(message, peer);\n      } else {\n        const knownPeers = yield this.getPeers(); // A broadcast request has to be sent everywhere.\n\n        const promises = knownPeers.map(peerEl => this.client.sendMessage(message, peerEl));\n        return (yield Promise.all(promises))[0];\n      }\n    });\n  }\n  /**\n   * Add a listener to be called when a new message is received\n   *\n   * @param listener The listener that will be registered\n   */\n\n\n  addListener(listener) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.debug('addListener', listener);\n      this.listeners.push(listener);\n      return;\n    });\n  }\n  /**\n   * Remove a listener\n   *\n   * @param listener\n   */\n\n\n  removeListener(listener) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('removeListener');\n      this.listeners = this.listeners.filter(element => element !== listener);\n      return;\n    });\n  }\n\n  getPeers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.peerManager.getPeers(); // TODO: Fix type\n    });\n  }\n\n  addPeer(newPeer, _sendPairingResponse = true) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('addPeer', 'adding peer', newPeer);\n      yield this.peerManager.addPeer(newPeer); // TODO: Fix type\n\n      yield this.listen(newPeer.publicKey);\n    });\n  }\n\n  removePeer(peerToBeRemoved) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('removePeer', 'removing peer', peerToBeRemoved);\n      yield this.peerManager.removePeer(peerToBeRemoved.publicKey);\n\n      if (this.client) {\n        yield this.client.unsubscribeFromEncryptedMessage(peerToBeRemoved.publicKey);\n      }\n    });\n  }\n\n  removeAllPeers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('removeAllPeers');\n      yield this.peerManager.removeAllPeers();\n\n      if (this.client) {\n        yield this.client.unsubscribeFromEncryptedMessages();\n      }\n    });\n  }\n  /**\n   * Notify the listeners when a new message comes in\n   *\n   * @param message Message\n   * @param connectionInfo Context info about the connection\n   */\n\n\n  notifyListeners(message, connectionInfo) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.listeners.length === 0) {\n        logger.warn('notifyListeners', '0 listeners notified!', this);\n      } else {\n        logger.log('notifyListeners', `Notifying ${this.listeners.length} listeners`, this);\n      }\n\n      this.listeners.forEach(listener => {\n        listener(message, connectionInfo);\n      });\n      return;\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["Logger","TransportType","TransportStatus","logger","Transport","constructor","name","client","peerManager","POST_MESSAGE","NOT_CONNECTED","connectionStatus","_isConnected","isAvailable","Promise","resolve","connect","log","CONNECTED","disconnect","send","message","peer","sendMessage","knownPeers","getPeers","promises","map","peerEl","all","addListener","listener","debug","listeners","push","removeListener","filter","element","addPeer","newPeer","_sendPairingResponse","listen","publicKey","removePeer","peerToBeRemoved","unsubscribeFromEncryptedMessage","removeAllPeers","unsubscribeFromEncryptedMessages","notifyListeners","connectionInfo","length","warn","forEach"],"sourceRoot":"","sources":["../../../src/transports/Transport.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}