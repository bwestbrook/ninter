{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ExposedPromise, ExposedPromiseStatus, generateGUID } from '@airgap/beacon-utils';\nimport { TransportStatus, BeaconMessageType } from '@airgap/beacon-types';\nimport { Serializer } from '../..';\nimport { BeaconClient } from '../beacon-client/BeaconClient';\nimport { AccountManager } from '../../managers/AccountManager';\nimport { BEACON_VERSION } from '../../constants';\nimport { getSenderId } from '../../utils/get-sender-id';\nimport { Logger } from '../../utils/Logger';\nconst logger = new Logger('Client');\n/**\n * @internalapi\n *\n * This abstract class handles the a big part of the logic that is shared between the dapp and wallet client.\n * For example, it selects and manages the transport and accounts.\n */\n\nexport class Client extends BeaconClient {\n  constructor(config) {\n    var _a;\n\n    super(config);\n    /**\n     * How many requests can be sent after another\n     */\n\n    this.rateLimit = 2;\n    /**\n     * The time window in seconds in which the \"rateLimit\" is checked\n     */\n\n    this.rateLimitWindowInSeconds = 5;\n    /**\n     * Stores the times when requests have been made to determine if the rate limit has been reached\n     */\n\n    this.requestCounter = [];\n    this._transport = new ExposedPromise();\n    this.accountManager = new AccountManager(config.storage);\n    this.matrixNodes = (_a = config.matrixNodes) !== null && _a !== void 0 ? _a : [];\n\n    this.handleResponse = (message, connectionInfo) => {\n      throw new Error(`not overwritten${JSON.stringify(message)} - ${JSON.stringify(connectionInfo)}`);\n    };\n  }\n\n  get transport() {\n    return this._transport.promise;\n  }\n  /**\n   * Returns the connection status of the Client\n   */\n\n\n  get connectionStatus() {\n    var _a, _b;\n\n    return (_b = (_a = this._transport.promiseResult) === null || _a === void 0 ? void 0 : _a.connectionStatus) !== null && _b !== void 0 ? _b : TransportStatus.NOT_CONNECTED;\n  }\n  /**\n   * Returns whether or not the transaport is ready\n   */\n\n\n  get ready() {\n    return this.transport.then(() => undefined);\n  }\n  /**\n   * Return all locally known accounts\n   */\n\n\n  getAccounts() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.accountManager.getAccounts();\n    });\n  }\n  /**\n   * Return the account by ID\n   * @param accountIdentifier The ID of an account\n   */\n\n\n  getAccount(accountIdentifier) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.accountManager.getAccount(accountIdentifier);\n    });\n  }\n  /**\n   * Remove the account by ID\n   * @param accountIdentifier The ID of an account\n   */\n\n\n  removeAccount(accountIdentifier) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.accountManager.removeAccount(accountIdentifier);\n    });\n  }\n  /**\n   * Remove all locally stored accounts\n   */\n\n\n  removeAllAccounts() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.accountManager.removeAllAccounts();\n    });\n  }\n  /**\n   * Add a new request (current timestamp) to the pending requests, remove old ones and check if we are above the limit\n   */\n\n\n  addRequestAndCheckIfRateLimited() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const now = new Date().getTime();\n      this.requestCounter = this.requestCounter.filter(date => date + this.rateLimitWindowInSeconds * 1000 > now);\n      this.requestCounter.push(now);\n      return this.requestCounter.length > this.rateLimit;\n    });\n  }\n  /**\n   * This method initializes the client. It will check if the connection should be established to a\n   * browser extension or if the P2P transport should be used.\n   *\n   * @param transport A transport that can be provided by the user\n   */\n\n\n  init(transport) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._transport.status === ExposedPromiseStatus.RESOLVED) {\n        return (yield this.transport).type;\n      }\n\n      yield this.setTransport(transport); // Let users define their own transport\n\n      return transport.type;\n    });\n  }\n  /**\n   * Returns the metadata of this DApp\n   */\n\n\n  getOwnAppMetadata() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        senderId: yield getSenderId(yield this.beaconId),\n        name: this.name,\n        icon: this.iconUrl\n      };\n    });\n  }\n  /**\n   * Return all known peers\n   */\n\n\n  getPeers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.transport).getPeers();\n    });\n  }\n  /**\n   * Add a new peer to the known peers\n   * @param peer The new peer to add\n   */\n\n\n  addPeer(peer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return (yield this.transport).addPeer(peer);\n    });\n  }\n\n  destroy() {\n    const _super = Object.create(null, {\n      destroy: {\n        get: () => super.destroy\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._transport.status === ExposedPromiseStatus.RESOLVED) {\n        yield (yield this.transport).disconnect();\n      }\n\n      yield _super.destroy.call(this);\n    });\n  }\n  /**\n   * A \"setter\" for when the transport needs to be changed.\n   */\n\n\n  setTransport(transport) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (transport) {\n        if (this._transport.isSettled()) {\n          // If the promise has already been resolved we need to create a new one.\n          this._transport = ExposedPromise.resolve(transport);\n        } else {\n          this._transport.resolve(transport);\n        }\n      } else {\n        if (this._transport.isSettled()) {\n          // If the promise has already been resolved we need to create a new one.\n          this._transport = new ExposedPromise();\n        }\n      }\n    });\n  }\n\n  addListener(transport) {\n    return __awaiter(this, void 0, void 0, function* () {\n      transport.addListener((message, connectionInfo) => __awaiter(this, void 0, void 0, function* () {\n        if (typeof message === 'string') {\n          const deserializedMessage = yield new Serializer().deserialize(message);\n          this.handleResponse(deserializedMessage, connectionInfo);\n        }\n      })).catch(error => logger.error('addListener', error));\n    });\n  }\n\n  sendDisconnectToPeer(peer, transport) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const request = {\n        id: yield generateGUID(),\n        version: BEACON_VERSION,\n        senderId: yield getSenderId(yield this.beaconId),\n        type: BeaconMessageType.Disconnect\n      };\n      const payload = yield new Serializer().serialize(request);\n      const selectedTransport = transport !== null && transport !== void 0 ? transport : yield this.transport;\n      yield selectedTransport.send(payload, peer);\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["ExposedPromise","ExposedPromiseStatus","generateGUID","TransportStatus","BeaconMessageType","Serializer","BeaconClient","AccountManager","BEACON_VERSION","getSenderId","Logger","logger","Client","constructor","config","accountManager","storage","matrixNodes","_a","handleResponse","message","connectionInfo","Error","JSON","stringify","transport","_transport","promise","connectionStatus","promiseResult","_b","NOT_CONNECTED","ready","then","undefined","getAccounts","getAccount","accountIdentifier","removeAccount","removeAllAccounts","addRequestAndCheckIfRateLimited","now","Date","getTime","requestCounter","filter","date","rateLimitWindowInSeconds","push","length","rateLimit","init","status","RESOLVED","type","setTransport","getOwnAppMetadata","senderId","beaconId","name","icon","iconUrl","getPeers","addPeer","peer","destroy","disconnect","_super","call","isSettled","resolve","addListener","__awaiter","deserializedMessage","deserialize","catch","error","sendDisconnectToPeer","request","id","version","Disconnect","payload","serialize","selectedTransport","send"],"sourceRoot":"","sources":["../../../../src/clients/client/Client.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}