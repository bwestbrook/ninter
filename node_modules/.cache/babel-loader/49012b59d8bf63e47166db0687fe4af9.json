{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\nimport stringify from 'fast-json-stable-stringify';\nimport BigNumber from 'bignumber.js';\nimport { b58decode, validateAddress, ValidationResult, encodePubKey, encodeKey, validatePublicKey, Prefix, b58cdecode, prefix, encodeKeyHash, validateKeyHash, validateSignature, validateChain } from '@taquito/utils';\n\nvar _a$1;\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid map type being passed or used\r\n */\n\n\nclass InvalidMapTypeError extends Error {\n  constructor(mapType) {\n    super(`The map type '${mapType}' is invalid`);\n    this.mapType = mapType;\n    this.name = 'InvalidMapTypeError';\n  }\n\n} // Retrieve a unique symbol associated with the key from the environment\n// Used in order to identify all object that are of type MichelsonMap even if they come from different module\n\n\nconst michelsonMapTypeSymbol = Symbol.for('taquito-michelson-map-type-symbol');\n\nconst isMapType = value => {\n  return 'args' in value && Array.isArray(value.args) && value.args.length === 2;\n};\n/**\r\n *  @category Error\r\n *  @description Error that indicates a map type mismatch, where an attempt to set a key or value in a Map doesn't match the defined type of the Map\r\n */\n\n\nclass MapTypecheckError extends Error {\n  constructor(value, type, errorType) {\n    super(`${errorType} not compliant with underlying michelson type`);\n    this.value = value;\n    this.type = type;\n    this.name = 'MapTypecheckError';\n  }\n\n}\n/**\r\n * @description Michelson Map is an abstraction over the michelson native map. It supports complex Pair as key\r\n */\n\n\nclass MichelsonMap {\n  /**\r\n   * @param mapType If specified key and value will be type-checked before being added to the map\r\n   *\r\n   * @example new MichelsonMap({ prim: \"map\", args: [{prim: \"string\"}, {prim: \"int\"}]})\r\n   */\n  constructor(mapType) {\n    this.valueMap = new Map();\n    this.keyMap = new Map();\n    this[_a$1] = true;\n\n    if (mapType) {\n      this.setType(mapType);\n    }\n  } // Used to check if an object is a michelson map.\n  // Using instanceof was not working for project that had multiple instance of taquito dependencies\n  // as the class constructor is different\n\n\n  static isMichelsonMap(obj) {\n    return obj && obj[michelsonMapTypeSymbol] === true;\n  }\n\n  setType(mapType) {\n    if (!isMapType(mapType)) {\n      throw new InvalidMapTypeError(mapType.toString());\n    }\n\n    this.keySchema = new Schema(mapType.args[0]);\n    this.valueSchema = new Schema(mapType.args[1]);\n  }\n\n  removeType() {\n    this.keySchema = undefined;\n    this.valueSchema = undefined;\n  }\n\n  static fromLiteral(obj, mapType) {\n    const map = new MichelsonMap(mapType);\n    Object.keys(obj).forEach(key => {\n      map.set(key, obj[key]);\n    });\n    return map;\n  }\n\n  typecheckKey(key) {\n    if (this.keySchema) {\n      return this.keySchema.Typecheck(key);\n    }\n\n    return true;\n  }\n\n  typecheckValue(value) {\n    if (this.valueSchema) {\n      return this.valueSchema.Typecheck(value);\n    }\n\n    return true;\n  }\n\n  assertTypecheckValue(value) {\n    if (!this.typecheckValue(value)) {\n      throw new MapTypecheckError(value, this.valueSchema, 'value');\n    }\n  }\n\n  assertTypecheckKey(key) {\n    if (!this.typecheckKey(key)) {\n      throw new MapTypecheckError(key, this.keySchema, 'key');\n    }\n  }\n\n  serializeDeterministically(key) {\n    return stringify(key);\n  }\n\n  *keys() {\n    for (const [key] of this.entries()) {\n      yield key;\n    }\n  }\n\n  *values() {\n    for (const [, value] of this.entries()) {\n      yield value;\n    }\n  }\n\n  *entries() {\n    for (const key of this.valueMap.keys()) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      yield [this.keyMap.get(key), this.valueMap.get(key)];\n    }\n  }\n\n  get(key) {\n    this.assertTypecheckKey(key);\n    const strKey = this.serializeDeterministically(key);\n    return this.valueMap.get(strKey);\n  }\n  /**\r\n   *\r\n   * @description Set a key and a value in the MichelsonMap. If the key already exists, override the current value.\r\n   *\r\n   * @example map.set(\"myKey\", \"myValue\") // Using a string as key\r\n   *\r\n   * @example map.set({0: \"test\", 1: \"test1\"}, \"myValue\") // Using a pair as key\r\n   *\r\n   * @warn The same key can be represented in multiple ways, depending on the type of the key. This duplicate key situation will cause a runtime error (duplicate key) when sending the map data to the Tezos RPC node.\r\n   *\r\n   * For example, consider a contract with a map whose key is of type boolean.  If you set the following values in MichelsonMap: map.set(false, \"myValue\") and map.set(null, \"myValue\").\r\n   *\r\n   * You will get two unique entries in the MichelsonMap. These values will both be evaluated as falsy by the MichelsonEncoder and ultimately rejected by the Tezos RPC.\r\n   */\n\n\n  set(key, value) {\n    this.assertTypecheckKey(key);\n    this.assertTypecheckValue(value);\n    const strKey = this.serializeDeterministically(key);\n    this.keyMap.set(strKey, key);\n    this.valueMap.set(strKey, value);\n  }\n\n  delete(key) {\n    this.assertTypecheckKey(key);\n    this.keyMap.delete(this.serializeDeterministically(key));\n    this.valueMap.delete(this.serializeDeterministically(key));\n  }\n\n  has(key) {\n    this.assertTypecheckKey(key);\n    const strKey = this.serializeDeterministically(key);\n    return this.keyMap.has(strKey) && this.valueMap.has(strKey);\n  }\n\n  clear() {\n    this.keyMap.clear();\n    this.valueMap.clear();\n  }\n\n  get size() {\n    return this.keyMap.size;\n  }\n\n  forEach(cb) {\n    for (const [key, value] of this.entries()) {\n      cb(value, key, this);\n    }\n  }\n\n}\n\n_a$1 = michelsonMapTypeSymbol;\n/**\r\n *  @category Error\r\n *  @description Error that indicates a failure when encoding invalid or incorrect data (e.g. if an address is expected but a number is received)\r\n */\n\nclass TokenValidationError extends Error {\n  constructor(value, token, baseMessage) {\n    super();\n    this.value = value;\n    this.token = token;\n    this.name = 'ValidationError';\n    const annot = this.token.annot();\n    const annotText = annot ? `[${annot}] ` : '';\n    this.message = `${annotText}${baseMessage}`;\n  }\n\n}\n\nclass Token {\n  constructor(val, idx, fac) {\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n    this.createToken = this.fac;\n  }\n\n  typeWithoutAnnotations() {\n    const removeArgsRec = val => {\n      if (val.args) {\n        return {\n          prim: val.prim,\n          args: val.args.map(x => removeArgsRec(x))\n        };\n      } else {\n        return {\n          prim: val.prim\n        };\n      }\n    };\n\n    return removeArgsRec(this.val);\n  }\n\n  annot() {\n    return (Array.isArray(this.val.annots) && this.val.annots.length > 0 ? this.val.annots[0] : String(this.idx)).replace(/(%|:)(_Liq_entry_)?/, '');\n  }\n\n  hasAnnotations() {\n    return Array.isArray(this.val.annots) && this.val.annots.length;\n  }\n\n  get tokenVal() {\n    return this.val;\n  }\n\n  ExtractSignature() {\n    return [[this.ExtractSchema()]];\n  }\n\n}\n\nclass ComparableToken extends Token {\n  compare(o1, o2) {\n    if (o1 === o2) {\n      return 0;\n    }\n\n    return o1 < o2 ? -1 : 1;\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates a failure happening when parsing encoding/executing Big Map types\r\n */\n\n\nclass BigMapValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'BigMapValidationError';\n  }\n\n}\n\nclass BigMapToken extends Token {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  get ValueSchema() {\n    return this.createToken(this.val.args[1], 0);\n  }\n\n  get KeySchema() {\n    return this.createToken(this.val.args[0], 0);\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return {\n      big_map: {\n        key: this.KeySchema.ExtractSchema(),\n        value: this.ValueSchema.ExtractSchema()\n      }\n    };\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: BigMapToken.prim,\n      schema: {\n        key: this.KeySchema.generateSchema(),\n        value: this.ValueSchema.generateSchema()\n      }\n    };\n  }\n\n  isValid(value) {\n    if (MichelsonMap.isMichelsonMap(value)) {\n      return null;\n    }\n\n    return new BigMapValidationError(value, this, 'Value must be a MichelsonMap');\n  }\n\n  Encode(args) {\n    const val = args.pop();\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return Array.from(val.keys()).sort((a, b) => this.KeySchema.compare(a, b)).map(key => {\n      return {\n        prim: 'Elt',\n        args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))]\n      };\n    });\n  }\n\n  EncodeObject(args) {\n    const val = args;\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return Array.from(val.keys()).sort((a, b) => this.KeySchema.compare(a, b)).map(key => {\n      return {\n        prim: 'Elt',\n        args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))]\n      };\n    });\n  }\n\n  Execute(val, semantic) {\n    if (semantic && semantic[BigMapToken.prim]) {\n      return semantic[BigMapToken.prim](val, this.val);\n    }\n\n    if (Array.isArray(val)) {\n      // Athens is returning an empty array for big map in storage\n      // Internal: In taquito v5 it is still used to decode big map diff (as if they were a regular map)\n      const map = new MichelsonMap(this.val);\n      val.forEach(current => {\n        map.set(this.KeySchema.ToKey(current.args[0]), this.ValueSchema.Execute(current.args[1]));\n      });\n      return map;\n    } else if ('int' in val) {\n      // Babylon is returning an int with the big map id in contract storage\n      return val.int;\n    } else {\n      throw new BigMapValidationError(val, this, `Big map is expecting either an array (Athens) or an object with an int property (Babylon). Got ${JSON.stringify(val)}`);\n    }\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (BigMapToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    this.KeySchema.findAndReturnTokens(tokenToFind, tokens);\n    this.ValueSchema.findAndReturnTokens(tokenToFind, tokens);\n    return tokens;\n  }\n\n}\n\nBigMapToken.prim = 'big_map';\n/**\r\n *  @category Error\r\n *  @description Error that indicates a failure when decoding OR Token methods\r\n */\n\nclass OrTokenDecodingError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'OrTokenDecodingError';\n  }\n\n}\n\nclass OrToken extends ComparableToken {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  Encode(args) {\n    const label = args[args.length - 1];\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken)) {\n      args.pop();\n      return {\n        prim: 'Left',\n        args: [leftToken.Encode(args)]\n      };\n    } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof OrToken)) {\n      args.pop();\n      return {\n        prim: 'Right',\n        args: [rightToken.Encode(args)]\n      };\n    } else {\n      if (leftToken instanceof OrToken) {\n        const val = leftToken.Encode(args);\n\n        if (val) {\n          return {\n            prim: 'Left',\n            args: [val]\n          };\n        }\n      }\n\n      if (rightToken instanceof OrToken) {\n        const val = rightToken.Encode(args);\n\n        if (val) {\n          return {\n            prim: 'Right',\n            args: [val]\n          };\n        }\n      }\n\n      return null;\n    }\n  }\n\n  ExtractSignature() {\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n    const newSig = [];\n\n    if (leftToken instanceof OrToken) {\n      newSig.push(...leftToken.ExtractSignature());\n    } else {\n      for (const sig of leftToken.ExtractSignature()) {\n        newSig.push([leftToken.annot(), ...sig]);\n      }\n    }\n\n    if (rightToken instanceof OrToken) {\n      newSig.push(...rightToken.ExtractSignature());\n    } else {\n      for (const sig of rightToken.ExtractSignature()) {\n        newSig.push([rightToken.annot(), ...sig]);\n      }\n    }\n\n    return newSig;\n  }\n\n  EncodeObject(args) {\n    const label = Object.keys(args)[0];\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken)) {\n      return {\n        prim: 'Left',\n        args: [leftToken.EncodeObject(args[label])]\n      };\n    } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof OrToken)) {\n      return {\n        prim: 'Right',\n        args: [rightToken.EncodeObject(args[label])]\n      };\n    } else {\n      if (leftToken instanceof OrToken) {\n        const val = leftToken.EncodeObject(args);\n\n        if (val) {\n          return {\n            prim: 'Left',\n            args: [val]\n          };\n        }\n      }\n\n      if (rightToken instanceof OrToken) {\n        const val = rightToken.EncodeObject(args);\n\n        if (val) {\n          return {\n            prim: 'Right',\n            args: [val]\n          };\n        }\n      }\n\n      return null;\n    }\n  }\n\n  Execute(val, semantics) {\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    if (val.prim === 'Right') {\n      if (rightToken instanceof OrToken) {\n        return rightToken.Execute(val.args[0], semantics);\n      } else {\n        return {\n          [rightToken.annot()]: rightToken.Execute(val.args[0], semantics)\n        };\n      }\n    } else if (val.prim === 'Left') {\n      if (leftToken instanceof OrToken) {\n        return leftToken.Execute(val.args[0], semantics);\n      }\n\n      return {\n        [leftToken.annot()]: leftToken.Execute(val.args[0], semantics)\n      };\n    } else {\n      throw new OrTokenDecodingError(`Was expecting Left or Right prim but got: ${val.prim}`);\n    }\n  }\n\n  traversal(getLeftValue, getRightValue, concat) {\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n    let leftValue;\n\n    if (leftToken instanceof OrToken && !leftToken.hasAnnotations()) {\n      leftValue = getLeftValue(leftToken);\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    } else {\n      leftValue = {\n        [leftToken.annot()]: getLeftValue(leftToken)\n      };\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n    let rightValue;\n\n    if (rightToken instanceof OrToken && !rightToken.hasAnnotations()) {\n      rightValue = getRightValue(rightToken);\n    } else {\n      rightValue = {\n        [rightToken.annot()]: getRightValue(rightToken)\n      };\n    }\n\n    const res = concat(leftValue, rightValue);\n    return res;\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return this.traversal(leftToken => leftToken.ExtractSchema(), rightToken => rightToken.ExtractSchema(), (leftValue, rightValue) => Object.assign(Object.assign({}, leftValue), rightValue));\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: OrToken.prim,\n      schema: this.traversal(leftToken => {\n        if (leftToken instanceof OrToken && !leftToken.hasAnnotations()) {\n          return leftToken.generateSchema().schema;\n        } else {\n          return leftToken.generateSchema();\n        }\n      }, rightToken => {\n        if (rightToken instanceof OrToken && !rightToken.hasAnnotations()) {\n          return rightToken.generateSchema().schema;\n        } else {\n          return rightToken.generateSchema();\n        }\n      }, (leftValue, rightValue) => Object.assign(Object.assign({}, leftValue), rightValue))\n    };\n  }\n\n  findToken(label) {\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken) && leftToken instanceof ComparableToken) {\n      return leftToken;\n    } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof OrToken) && rightToken instanceof ComparableToken) {\n      return rightToken;\n    } else {\n      if (leftToken instanceof OrToken) {\n        const tok = leftToken.findToken(label);\n\n        if (tok) {\n          return tok;\n        }\n      }\n\n      if (rightToken instanceof OrToken) {\n        const tok = rightToken.findToken(label);\n\n        if (tok) {\n          return tok;\n        }\n      }\n\n      return null;\n    }\n  }\n\n  compare(val1, val2) {\n    const labelVal1 = Object.keys(val1)[0];\n    const labelVal2 = Object.keys(val2)[0];\n\n    if (labelVal1 === labelVal2) {\n      const token = this.findToken(labelVal1);\n\n      if (token instanceof ComparableToken) {\n        return token.compare(val1[labelVal1], val2[labelVal1]);\n      }\n    } else {\n      const encoded1 = JSON.stringify(this.EncodeObject(val1));\n      const encoded2 = JSON.stringify(this.EncodeObject(val2));\n      return encoded1 < encoded2 ? -1 : 1;\n    }\n  }\n\n  ToKey(val) {\n    return this.Execute(val);\n  }\n\n  ToBigMapKey(val) {\n    return {\n      key: this.EncodeObject(val),\n      type: this.typeWithoutAnnotations()\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (OrToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    this.traversal(leftToken => leftToken.findAndReturnTokens(tokenToFind, tokens), rightToken => rightToken.findAndReturnTokens(tokenToFind, tokens), (leftValue, rightValue) => Object.assign(Object.assign({}, leftValue), rightValue));\n    return tokens;\n  }\n\n}\n\nOrToken.prim = 'or';\n/**\r\n *  @category Error\r\n *  @description Error that indicates in invalid token argument being passed\r\n */\n\nclass TokenArgumentValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'TokenArgumentValidationError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates a failure occurring when doing a comparison of tokens\r\n */\n\n\nclass TokenComparisonError extends Error {\n  constructor(val1, val2) {\n    super(`Tokens ${val1} and ${val2} are not comparable`);\n    this.val1 = val1;\n    this.val2 = val2;\n    this.name = 'TokenComparisonError';\n  }\n\n} // collapse comb pair\n\n\nfunction collapse$1(val, prim = PairToken.prim) {\n  if (Array.isArray(val)) {\n    return collapse$1({\n      prim: prim,\n      args: val\n    }, prim);\n  }\n\n  if (val.args === undefined) {\n    throw new TokenArgumentValidationError('Encountered an invalid PairToken with no arguments, a pair must have two or more arguments');\n  }\n\n  if (val.args.length > 2) {\n    return [val.args[0], {\n      prim: prim,\n      args: val.args.slice(1)\n    }];\n  }\n\n  return [val.args[0], val.args[1]];\n}\n\nclass PairToken extends ComparableToken {\n  constructor(val, idx, fac) {\n    super(Array.isArray(val) ? {\n      prim: PairToken.prim,\n      args: val\n    } : val, idx, fac);\n  }\n\n  args() {\n    // collapse comb pair\n    return collapse$1(this.val);\n  }\n\n  tokens() {\n    let cnt = 0;\n    return this.args().map(a => {\n      const tok = this.createToken(a, this.idx + cnt);\n\n      if (tok instanceof PairToken) {\n        cnt += Object.keys(tok.ExtractSchema()).length;\n      } else {\n        cnt++;\n      }\n\n      return tok;\n    });\n  }\n\n  Encode(args) {\n    return {\n      prim: 'Pair',\n      args: this.tokens().map(t => t.Encode(args))\n    };\n  }\n\n  ExtractSignature() {\n    const args = this.args();\n    const leftToken = this.createToken(args[0], this.idx);\n    let keyCount = 1;\n\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    const rightToken = this.createToken(args[1], this.idx + keyCount);\n    const newSig = [];\n\n    for (const leftSig of leftToken.ExtractSignature()) {\n      for (const rightSig of rightToken.ExtractSignature()) {\n        newSig.push([...leftSig, ...rightSig]);\n      }\n    }\n\n    return newSig;\n  }\n\n  ToBigMapKey(val) {\n    return {\n      key: this.EncodeObject(val),\n      type: this.typeWithoutAnnotations()\n    };\n  }\n\n  ToKey(val) {\n    return this.Execute(val);\n  }\n\n  EncodeObject(args) {\n    const [leftToken, rightToken] = this.tokens();\n    let leftValue;\n\n    if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {\n      leftValue = args;\n    } else {\n      leftValue = args[leftToken.annot()];\n    }\n\n    let rightValue;\n\n    if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {\n      rightValue = args;\n    } else {\n      rightValue = args[rightToken.annot()];\n    }\n\n    return {\n      prim: 'Pair',\n      args: [leftToken.EncodeObject(leftValue), rightToken.EncodeObject(rightValue)]\n    };\n  }\n\n  traversal(getLeftValue, getRightValue) {\n    const args = this.args();\n    const leftToken = this.createToken(args[0], this.idx);\n    let keyCount = 1;\n    let leftValue;\n\n    if (leftToken instanceof PairToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {\n      leftValue = getLeftValue(leftToken);\n    } else {\n      leftValue = {\n        [leftToken.annot()]: getLeftValue(leftToken)\n      };\n    }\n\n    const rightToken = this.createToken(args[1], this.idx + keyCount);\n    let rightValue;\n\n    if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {\n      rightValue = getRightValue(rightToken);\n    } else {\n      rightValue = {\n        [rightToken.annot()]: getRightValue(rightToken)\n      };\n    }\n\n    const res = Object.assign(Object.assign({}, leftValue), rightValue);\n    return res;\n  }\n\n  Execute(val, semantics) {\n    const args = collapse$1(val, 'Pair');\n    return this.traversal(leftToken => leftToken.Execute(args[0], semantics), rightToken => rightToken.Execute(args[1], semantics));\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return this.traversal(leftToken => leftToken.ExtractSchema(), rightToken => rightToken.ExtractSchema());\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: PairToken.prim,\n      schema: this.traversal(leftToken => {\n        if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {\n          return leftToken.generateSchema().schema;\n        } else {\n          return leftToken.generateSchema();\n        }\n      }, rightToken => {\n        if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {\n          return rightToken.generateSchema().schema;\n        } else {\n          return rightToken.generateSchema();\n        }\n      })\n    };\n  }\n\n  compare(val1, val2) {\n    const [leftToken, rightToken] = this.tokens();\n\n    const getValue = (token, args) => {\n      if (token instanceof PairToken && !token.hasAnnotations()) {\n        return args;\n      } else {\n        return args[token.annot()];\n      }\n    };\n\n    if (leftToken instanceof ComparableToken && rightToken instanceof ComparableToken) {\n      const result = leftToken.compare(getValue(leftToken, val1), getValue(leftToken, val2));\n\n      if (result === 0) {\n        return rightToken.compare(getValue(rightToken, val1), getValue(rightToken, val2));\n      }\n\n      return result;\n    }\n\n    throw new TokenComparisonError(val1, val2);\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (PairToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    this.tokens().map(t => t.findAndReturnTokens(tokenToFind, tokens));\n    return tokens;\n  }\n\n}\n\nPairToken.prim = 'pair';\n\nclass NatValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'NatValidationError';\n  }\n\n}\n\nclass NatToken extends ComparableToken {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  Execute(val) {\n    return new BigNumber(val[Object.keys(val)[0]]);\n  }\n\n  Encode(args) {\n    const val = args.pop();\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      int: new BigNumber(val).toFixed()\n    };\n  }\n\n  isValid(val) {\n    const bigNumber = new BigNumber(val);\n\n    if (bigNumber.isNaN()) {\n      return new NatValidationError(val, this, `Value is not a number: ${val}`);\n    } else if (bigNumber.isNegative()) {\n      return new NatValidationError(val, this, `Value cannot be negative: ${val}`);\n    } else {\n      return null;\n    }\n  }\n\n  EncodeObject(val) {\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      int: new BigNumber(val).toFixed()\n    };\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return NatToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: NatToken.prim,\n      schema: NatToken.prim\n    };\n  }\n\n  ToBigMapKey(val) {\n    return {\n      key: {\n        int: String(val)\n      },\n      type: {\n        prim: NatToken.prim\n      }\n    };\n  }\n\n  ToKey({\n    int\n  }) {\n    return new BigNumber(int);\n  }\n\n  compare(nat1, nat2) {\n    const o1 = Number(nat1);\n    const o2 = Number(nat2);\n\n    if (o1 === o2) {\n      return 0;\n    }\n\n    return o1 < o2 ? -1 : 1;\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (NatToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nNatToken.prim = 'nat';\n\nclass StringToken extends ComparableToken {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  Execute(val) {\n    return val[Object.keys(val)[0]];\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return StringToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: StringToken.prim,\n      schema: StringToken.prim\n    };\n  }\n\n  Encode(args) {\n    const val = args.pop();\n    return {\n      string: val\n    };\n  }\n\n  EncodeObject(val) {\n    return {\n      string: val\n    };\n  }\n\n  ToKey({\n    string\n  }) {\n    return string;\n  }\n\n  ToBigMapKey(val) {\n    return {\n      key: {\n        string: val\n      },\n      type: {\n        prim: StringToken.prim\n      }\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (StringToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nStringToken.prim = 'string';\n\nclass AddressValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'AddressValidationError';\n  }\n\n}\n\nclass AddressToken extends ComparableToken {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  ToBigMapKey(val) {\n    const decoded = b58decode(val);\n    return {\n      key: {\n        bytes: decoded\n      },\n      type: {\n        prim: 'bytes'\n      }\n    };\n  }\n\n  isValid(value) {\n    if (validateAddress(value) !== ValidationResult.VALID) {\n      return new AddressValidationError(value, this, `Address is not valid: ${value}`);\n    }\n\n    return null;\n  }\n\n  Encode(args) {\n    const val = args.pop();\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  }\n\n  EncodeObject(val) {\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  }\n\n  Execute(val) {\n    if (val.string) {\n      return val.string;\n    }\n\n    return encodePubKey(val.bytes);\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return AddressToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: AddressToken.prim,\n      schema: AddressToken.prim\n    };\n  }\n\n  ToKey({\n    bytes,\n    string\n  }) {\n    if (string) {\n      return string;\n    }\n\n    return encodePubKey(bytes);\n  }\n\n  compare(address1, address2) {\n    const isImplicit = address => {\n      return address.startsWith('tz');\n    };\n\n    if (isImplicit(address1) && isImplicit(address2)) {\n      return super.compare(address1, address2);\n    } else if (isImplicit(address1)) {\n      return -1;\n    } else if (isImplicit(address2)) {\n      return 1;\n    } else {\n      return super.compare(address1, address2);\n    }\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (AddressToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nAddressToken.prim = 'address';\n\nclass MapValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'MapValidationError';\n  }\n\n}\n\nclass MapToken extends Token {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  get ValueSchema() {\n    return this.createToken(this.val.args[1], 0);\n  }\n\n  get KeySchema() {\n    return this.createToken(this.val.args[0], 0);\n  }\n\n  isValid(value) {\n    if (MichelsonMap.isMichelsonMap(value)) {\n      return null;\n    }\n\n    return new MapValidationError(value, this, 'Value must be a MichelsonMap');\n  }\n\n  Execute(val, semantics) {\n    const map = new MichelsonMap(this.val);\n    val.forEach(current => {\n      map.set(this.KeySchema.ToKey(current.args[0]), this.ValueSchema.Execute(current.args[1], semantics));\n    });\n    return map;\n  }\n\n  Encode(args) {\n    const val = args.pop();\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return Array.from(val.keys()).sort((a, b) => this.KeySchema.compare(a, b)).map(key => {\n      return {\n        prim: 'Elt',\n        args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))]\n      };\n    });\n  }\n\n  EncodeObject(args) {\n    const val = args;\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return Array.from(val.keys()).sort((a, b) => this.KeySchema.compare(a, b)).map(key => {\n      return {\n        prim: 'Elt',\n        args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))]\n      };\n    });\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return {\n      map: {\n        key: this.KeySchema.ExtractSchema(),\n        value: this.ValueSchema.ExtractSchema()\n      }\n    };\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: MapToken.prim,\n      schema: {\n        key: this.KeySchema.generateSchema(),\n        value: this.ValueSchema.generateSchema()\n      }\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (MapToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    this.KeySchema.findAndReturnTokens(tokenToFind, tokens);\n    this.ValueSchema.findAndReturnTokens(tokenToFind, tokens);\n    return tokens;\n  }\n\n}\n\nMapToken.prim = 'map';\n\nclass BoolToken extends ComparableToken {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  Execute(val) {\n    return String(val.prim).toLowerCase() === 'true' ? true : false;\n  }\n\n  Encode(args) {\n    const val = args.pop();\n    return {\n      prim: val ? 'True' : 'False'\n    };\n  }\n\n  EncodeObject(val) {\n    return {\n      prim: val ? 'True' : 'False'\n    };\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return BoolToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: BoolToken.prim,\n      schema: BoolToken.prim\n    };\n  }\n\n  ToBigMapKey(val) {\n    return {\n      key: this.EncodeObject(val),\n      type: {\n        prim: BoolToken.prim\n      }\n    };\n  }\n\n  ToKey(val) {\n    return this.EncodeObject(val);\n  }\n\n  compare(val1, val2) {\n    if (val1 && val2 || !val1 && !val2) {\n      return 0;\n    } else if (val1) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (BoolToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nBoolToken.prim = 'bool';\n\nclass ContractValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'ContractValidationError';\n  }\n\n}\n\nclass ContractToken extends Token {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  isValid(value) {\n    // tz1,tz2 and tz3 seems to be valid contract values (for Unit contract)\n    if (validateAddress(value) !== ValidationResult.VALID) {\n      return new ContractValidationError(value, this, 'Contract address is not valid');\n    }\n\n    return null;\n  }\n\n  Execute(val) {\n    if (val.string) {\n      return val.string;\n    }\n\n    return encodePubKey(val.bytes);\n  }\n\n  Encode(args) {\n    const val = args.pop();\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  }\n\n  EncodeObject(val) {\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return ContractToken.prim;\n  }\n\n  generateSchema() {\n    const valueSchema = this.createToken(this.val.args[0], 0);\n    return {\n      __michelsonType: ContractToken.prim,\n      schema: {\n        parameter: valueSchema.generateSchema()\n      }\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (ContractToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nContractToken.prim = 'contract';\n\nclass ListValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'ListValidationError';\n  }\n\n}\n\nclass ListToken extends Token {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  get valueSchema() {\n    return this.createToken(this.val.args[0], this.idx);\n  }\n\n  isValid(value) {\n    if (Array.isArray(value)) {\n      return null;\n    }\n\n    return new ListValidationError(value, this, 'Value must be an array');\n  }\n\n  Encode(args) {\n    const val = args.pop();\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    const schema = this.createToken(this.val.args[0], 0);\n    return val.reduce((prev, current) => {\n      return [...prev, schema.EncodeObject(current)];\n    }, []);\n  }\n\n  Execute(val, semantics) {\n    const schema = this.createToken(this.val.args[0], 0);\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return val.reduce((prev, current) => {\n      return [...prev, schema.Execute(current, semantics)];\n    }, []);\n  }\n\n  EncodeObject(args) {\n    const schema = this.createToken(this.val.args[0], 0);\n    const err = this.isValid(args);\n\n    if (err) {\n      throw err;\n    }\n\n    return args.reduce((prev, current) => {\n      return [...prev, schema.EncodeObject(current)];\n    }, []);\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return {\n      [ListToken.prim]: this.valueSchema.ExtractSchema()\n    };\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: ListToken.prim,\n      schema: this.valueSchema.generateSchema()\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (ListToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    this.createToken(this.val.args[0], this.idx).findAndReturnTokens(tokenToFind, tokens);\n    return tokens;\n  }\n\n}\n\nListToken.prim = 'list';\n\nclass MutezValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'MutezValidationError';\n  }\n\n}\n\nclass MutezToken extends ComparableToken {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  Execute(val) {\n    return new BigNumber(val[Object.keys(val)[0]]);\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return MutezToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: MutezToken.prim,\n      schema: MutezToken.prim\n    };\n  }\n\n  isValid(val) {\n    const bigNumber = new BigNumber(val);\n\n    if (bigNumber.isNaN()) {\n      return new MutezValidationError(val, this, `Value is not a number: ${val}`);\n    } else {\n      return null;\n    }\n  }\n\n  Encode(args) {\n    const val = args.pop();\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      int: String(val).toString()\n    };\n  }\n\n  EncodeObject(val) {\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      int: String(val).toString()\n    };\n  }\n\n  ToBigMapKey(val) {\n    return {\n      key: {\n        int: String(val)\n      },\n      type: {\n        prim: MutezToken.prim\n      }\n    };\n  }\n\n  ToKey({\n    int\n  }) {\n    return int;\n  }\n\n  compare(mutez1, mutez2) {\n    const o1 = Number(mutez1);\n    const o2 = Number(mutez2);\n\n    if (o1 === o2) {\n      return 0;\n    }\n\n    return o1 < o2 ? -1 : 1;\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (MutezToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nMutezToken.prim = 'mutez';\n\nclass BytesValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'BytesValidationError';\n  }\n\n}\n\nclass BytesToken extends ComparableToken {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  ToBigMapKey(val) {\n    return {\n      key: {\n        bytes: val\n      },\n      type: {\n        prim: BytesToken.prim\n      }\n    };\n  }\n\n  isValid(val) {\n    if (typeof val === 'string' && /^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n      return null;\n    } else {\n      return new BytesValidationError(val, this, `Invalid bytes: ${val}`);\n    }\n  }\n\n  convertUint8ArrayToHexString(val) {\n    return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;\n  }\n\n  Encode(args) {\n    let val = args.pop();\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      bytes: String(val).toString()\n    };\n  }\n\n  EncodeObject(val) {\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      bytes: String(val).toString()\n    };\n  }\n\n  Execute(val) {\n    return val.bytes;\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return BytesToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: BytesToken.prim,\n      schema: BytesToken.prim\n    };\n  }\n\n  ToKey({\n    bytes,\n    string\n  }) {\n    if (string) {\n      return string;\n    }\n\n    return bytes;\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (BytesToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nBytesToken.prim = 'bytes';\n\nclass OptionToken extends ComparableToken {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  subToken() {\n    return this.createToken(this.val.args[0], this.idx);\n  }\n\n  schema() {\n    return this.createToken(this.val.args[0], 0);\n  }\n\n  annot() {\n    return Array.isArray(this.val.annots) ? super.annot() : this.createToken(this.val.args[0], this.idx).annot();\n  }\n\n  Encode(args) {\n    const value = args;\n\n    if (value === undefined || value === null) {\n      return {\n        prim: 'None'\n      };\n    } else if (Array.isArray(value) && (value[value.length - 1] === undefined || value[value.length - 1] === null)) {\n      value.pop();\n      return {\n        prim: 'None'\n      };\n    }\n\n    return {\n      prim: 'Some',\n      args: [this.schema().Encode(args)]\n    };\n  }\n\n  EncodeObject(args) {\n    const value = args;\n\n    if (value === undefined || value === null) {\n      return {\n        prim: 'None'\n      };\n    }\n\n    return {\n      prim: 'Some',\n      args: [this.schema().EncodeObject(value)]\n    };\n  }\n\n  Execute(val, semantics) {\n    if (val.prim === 'None') {\n      return null;\n    }\n\n    return this.schema().Execute(val.args[0], semantics);\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return this.schema().ExtractSchema();\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: OptionToken.prim,\n      schema: this.schema().generateSchema()\n    };\n  }\n\n  ExtractSignature() {\n    return [...this.schema().ExtractSignature(), []];\n  }\n\n  get KeySchema() {\n    return this.schema();\n  }\n\n  compare(val1, val2) {\n    if (!val1) {\n      return -1;\n    } else if (!val2) {\n      return 1;\n    }\n\n    return this.KeySchema.compare(val1, val2);\n  }\n\n  ToKey(val) {\n    return this.Execute(val);\n  }\n\n  ToBigMapKey(val) {\n    return {\n      key: this.EncodeObject(val),\n      type: this.typeWithoutAnnotations()\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (OptionToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    this.subToken().findAndReturnTokens(tokenToFind, tokens);\n    return tokens;\n  }\n\n}\n\nOptionToken.prim = 'option';\n\nclass TimestampToken extends ComparableToken {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  Execute(val) {\n    if (val.string && /^\\d+$/.test(val.string)) {\n      return new Date(Number(val.string) * 1000).toISOString();\n    } else if (val.string) {\n      return new Date(val.string).toISOString();\n    } else if (val.int) {\n      return new Date(Number(val.int) * 1000).toISOString();\n    }\n  }\n\n  Encode(args) {\n    const val = args.pop();\n    return {\n      string: val\n    };\n  }\n\n  EncodeObject(val) {\n    return {\n      string: val\n    };\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return TimestampToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: TimestampToken.prim,\n      schema: TimestampToken.prim\n    };\n  }\n\n  ToKey({\n    string\n  }) {\n    return string;\n  }\n\n  ToBigMapKey(val) {\n    return {\n      key: {\n        string: val\n      },\n      type: {\n        prim: TimestampToken.prim\n      }\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (TimestampToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nTimestampToken.prim = 'timestamp';\n\nclass IntValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'IntValidationError';\n  }\n\n}\n\nclass IntToken extends ComparableToken {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  Execute(val) {\n    return new BigNumber(val[Object.keys(val)[0]]);\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return IntToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: IntToken.prim,\n      schema: IntToken.prim\n    };\n  }\n\n  isValid(val) {\n    const bigNumber = new BigNumber(val);\n\n    if (bigNumber.isNaN()) {\n      return new IntValidationError(val, this, `Value is not a number: ${val}`);\n    } else {\n      return null;\n    }\n  }\n\n  Encode(args) {\n    const val = args.pop();\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      int: new BigNumber(val).toFixed()\n    };\n  }\n\n  EncodeObject(val) {\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      int: new BigNumber(val).toFixed()\n    };\n  }\n\n  ToBigMapKey(val) {\n    return {\n      key: {\n        int: String(val)\n      },\n      type: {\n        prim: IntToken.prim\n      }\n    };\n  }\n\n  ToKey({\n    int\n  }) {\n    return int;\n  }\n\n  compare(int1, int2) {\n    const o1 = Number(int1);\n    const o2 = Number(int2);\n\n    if (o1 === o2) {\n      return 0;\n    }\n\n    return o1 < o2 ? -1 : 1;\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (IntToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nIntToken.prim = 'int';\n\nclass UnitToken extends ComparableToken {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  Encode(args) {\n    args.pop();\n    return {\n      prim: 'Unit'\n    };\n  }\n\n  EncodeObject(_val) {\n    return {\n      prim: 'Unit'\n    };\n  }\n\n  Execute(_val) {\n    return UnitValue;\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return UnitToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: UnitToken.prim,\n      schema: UnitToken.prim\n    };\n  }\n\n  compare(_val1, _val2) {\n    return 0;\n  }\n\n  ToKey(_val) {\n    return UnitValue;\n  }\n\n  ToBigMapKey(_val) {\n    return {\n      key: {\n        prim: 'Unit'\n      },\n      type: {\n        prim: UnitToken.prim\n      }\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (UnitToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nUnitToken.prim = 'unit';\nconst publicKeyPrefixLength = 4;\n\nclass KeyValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'KeyValidationError';\n  }\n\n}\n\nclass KeyToken extends ComparableToken {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  Execute(val) {\n    if (val.string) {\n      return val.string;\n    }\n\n    return encodeKey(val.bytes);\n  }\n\n  isValid(value) {\n    if (validatePublicKey(value) !== ValidationResult.VALID) {\n      return new KeyValidationError(value, this, 'Key is not valid');\n    }\n\n    return null;\n  }\n\n  Encode(args) {\n    const val = args.pop();\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  }\n\n  EncodeObject(val) {\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return KeyToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: KeyToken.prim,\n      schema: KeyToken.prim\n    };\n  }\n\n  ToKey(val) {\n    return this.Execute(val);\n  }\n\n  ToBigMapKey(val) {\n    return {\n      key: {\n        string: val\n      },\n      type: {\n        prim: KeyToken.prim\n      }\n    };\n  }\n\n  compare(key1, key2) {\n    const keyPrefix1 = this.getPrefix(key1);\n    const keyPrefix2 = this.getPrefix(key2);\n\n    if (keyPrefix1 === Prefix.EDPK && keyPrefix2 !== Prefix.EDPK) {\n      return -1;\n    } else if (keyPrefix1 === Prefix.SPPK && keyPrefix2 !== Prefix.SPPK) {\n      return keyPrefix2 === Prefix.EDPK ? 1 : -1;\n    } else if (keyPrefix1 === Prefix.P2PK) {\n      if (keyPrefix2 !== Prefix.P2PK) {\n        return 1;\n      }\n\n      const keyBytes1 = this.getP256PublicKeyComparableBytes(key1);\n      const keyBytes2 = this.getP256PublicKeyComparableBytes(key2);\n      return Buffer.compare(keyBytes1, keyBytes2);\n    }\n\n    return super.compare(key1, key2);\n  }\n\n  getPrefix(val) {\n    return val.substring(0, publicKeyPrefixLength);\n  }\n\n  getP256PublicKeyComparableBytes(p2pk) {\n    return b58cdecode(p2pk, prefix[Prefix.P2PK]).slice(1);\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (KeyToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nKeyToken.prim = 'key';\n\nclass KeyHashValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'KeyHashValidationError';\n  }\n\n}\n\nclass KeyHashToken extends ComparableToken {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  Execute(val) {\n    if (val.string) {\n      return val.string;\n    }\n\n    return encodeKeyHash(val.bytes);\n  }\n\n  isValid(value) {\n    if (validateKeyHash(value) !== ValidationResult.VALID) {\n      return new KeyHashValidationError(value, this, `KeyHash is not valid: ${value}`);\n    }\n\n    return null;\n  }\n\n  Encode(args) {\n    const val = args.pop();\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  }\n\n  EncodeObject(val) {\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return KeyHashToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: KeyHashToken.prim,\n      schema: KeyHashToken.prim\n    };\n  }\n\n  ToKey({\n    string,\n    bytes\n  }) {\n    if (string) {\n      return string;\n    }\n\n    return encodeKeyHash(bytes);\n  }\n\n  ToBigMapKey(val) {\n    return {\n      key: {\n        string: val\n      },\n      type: {\n        prim: KeyHashToken.prim\n      }\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (KeyHashToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nKeyHashToken.prim = 'key_hash';\n\nclass SignatureValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'SignatureValidationError';\n  }\n\n}\n\nclass SignatureToken extends ComparableToken {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  Execute(val) {\n    return val.string;\n  }\n\n  isValid(value) {\n    if (validateSignature(value) !== ValidationResult.VALID) {\n      return new SignatureValidationError(value, this, 'Signature is not valid');\n    }\n\n    return null;\n  }\n\n  Encode(args) {\n    const val = args.pop();\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  }\n\n  EncodeObject(val) {\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return SignatureToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: SignatureToken.prim,\n      schema: SignatureToken.prim\n    };\n  }\n\n  ToKey(val) {\n    return this.Execute(val);\n  }\n\n  ToBigMapKey(val) {\n    return {\n      key: {\n        string: val\n      },\n      type: {\n        prim: SignatureToken.prim\n      }\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (SignatureToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nSignatureToken.prim = 'signature';\n\nclass LambdaToken extends Token {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  get paramSchema() {\n    return this.createToken(this.val.args[0], this.idx);\n  }\n\n  get returnSchema() {\n    return this.createToken(this.val.args[1], this.idx + 1);\n  }\n\n  Execute(val) {\n    if (val.string) {\n      return val.string;\n    } else {\n      return val;\n    }\n  }\n\n  Encode(args) {\n    const val = args.pop();\n    return val;\n  }\n\n  EncodeObject(val) {\n    return val;\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return {\n      [LambdaToken.prim]: {\n        parameters: this.paramSchema.ExtractSchema(),\n        returns: this.returnSchema.ExtractSchema()\n      }\n    };\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: LambdaToken.prim,\n      schema: {\n        parameters: this.paramSchema.generateSchema(),\n        returns: this.returnSchema.generateSchema()\n      }\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (LambdaToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    this.createToken(this.val.args[0], this.idx).findAndReturnTokens(tokenToFind, tokens);\n    this.createToken(this.val.args[1], this.idx).findAndReturnTokens(tokenToFind, tokens);\n    return tokens;\n  }\n\n}\n\nLambdaToken.prim = 'lambda';\n\nclass OperationToken extends Token {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  Execute(val) {\n    return val.string;\n  }\n\n  Encode(...args) {\n    const val = args.pop();\n    return {\n      string: val\n    };\n  }\n\n  EncodeObject(val) {\n    return {\n      string: val\n    };\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return OperationToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: OperationToken.prim,\n      schema: OperationToken.prim\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (OperationToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nOperationToken.prim = 'operation';\n\nclass SetValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'SetValidationError';\n  }\n\n}\n\nclass SetToken extends Token {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  get KeySchema() {\n    return this.createToken(this.val.args[0], 0);\n  }\n\n  isValid(value) {\n    if (Array.isArray(value)) {\n      return null;\n    }\n\n    return new SetValidationError(value, this, 'Value must be an array');\n  }\n\n  Encode(args) {\n    const val = args.pop();\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return val.sort((a, b) => this.KeySchema.compare(a, b)).reduce((prev, current) => {\n      return [...prev, this.KeySchema.EncodeObject(current)];\n    }, []);\n  }\n\n  Execute(val, semantics) {\n    return val.reduce((prev, current) => {\n      return [...prev, this.KeySchema.Execute(current, semantics)];\n    }, []);\n  }\n\n  EncodeObject(args) {\n    const err = this.isValid(args);\n\n    if (err) {\n      throw err;\n    }\n\n    return args.sort((a, b) => this.KeySchema.compare(a, b)).reduce((prev, current) => {\n      return [...prev, this.KeySchema.EncodeObject(current)];\n    }, []);\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return SetToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: SetToken.prim,\n      schema: this.KeySchema.generateSchema()\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (SetToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    this.KeySchema.findAndReturnTokens(tokenToFind, tokens);\n    return tokens;\n  }\n\n}\n\nSetToken.prim = 'set';\n\nclass ChainIDValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'ChainIDValidationError';\n  }\n\n}\n\nclass ChainIDToken extends ComparableToken {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  isValid(value) {\n    if (validateChain(value) !== ValidationResult.VALID) {\n      return new ChainIDValidationError(value, this, 'ChainID is not valid');\n    }\n\n    return null;\n  }\n\n  Execute(val) {\n    return val[Object.keys(val)[0]];\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return ChainIDToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: ChainIDToken.prim,\n      schema: ChainIDToken.prim\n    };\n  }\n\n  Encode(args) {\n    const val = args.pop();\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  }\n\n  EncodeObject(val) {\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      string: val\n    };\n  }\n\n  ToKey({\n    string\n  }) {\n    return string;\n  }\n\n  ToBigMapKey(val) {\n    return {\n      key: {\n        string: val\n      },\n      type: {\n        prim: ChainIDToken.prim\n      }\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (ChainIDToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nChainIDToken.prim = 'chain_id';\n/**\r\n *  @category Error\r\n *  @description Error that indicates a failure when encoding and sending a ticket to the blockchain\r\n */\n\nclass EncodeTicketError extends Error {\n  constructor() {\n    super('Tickets cannot be sent to the blockchain; they are created on-chain');\n    this.name = 'TicketEncodeError';\n  }\n\n}\n\nconst ticketerType = {\n  prim: 'contract'\n};\nconst amountType = {\n  prim: 'int'\n};\n\nclass TicketToken extends Token {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  get valueToken() {\n    return this.createToken(this.val.args[0], this.idx);\n  }\n\n  Encode(_args) {\n    throw new EncodeTicketError();\n  }\n\n  EncodeObject(_args) {\n    throw new EncodeTicketError();\n  }\n\n  Execute(val, semantics) {\n    if (semantics && semantics[TicketToken.prim]) {\n      return semantics[TicketToken.prim](val, this.val);\n    }\n\n    const ticketer = this.createToken(ticketerType, this.idx);\n    const value = this.valueToken;\n    const amount = this.createToken(amountType, this.idx);\n\n    if (undefined === val.args[2] && undefined !== val.args[1].args) {\n      return {\n        ticketer: ticketer.Execute(val.args[0], semantics),\n        value: value.Execute(val.args[1].args[0], semantics),\n        amount: amount.Execute(val.args[1].args[1], semantics)\n      };\n    }\n\n    return {\n      ticketer: ticketer.Execute(val.args[0], semantics),\n      value: value.Execute(val.args[1], semantics),\n      amount: amount.Execute(val.args[2], semantics)\n    };\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return {\n      ticketer: ContractToken.prim,\n      value: this.valueToken.ExtractSchema(),\n      amount: IntToken.prim\n    };\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: TicketToken.prim,\n      schema: {\n        value: this.valueToken.generateSchema(),\n        ticketer: {\n          __michelsonType: ContractToken.prim,\n          schema: ContractToken.prim\n        },\n        amount: {\n          __michelsonType: IntToken.prim,\n          schema: IntToken.prim\n        }\n      }\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (TicketToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    this.valueToken.findAndReturnTokens(tokenToFind, tokens);\n    return tokens;\n  }\n\n}\n\nTicketToken.prim = 'ticket';\n\nclass NeverTokenError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'NeverTokenError';\n  }\n\n}\n\nclass NeverToken extends Token {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  Encode(args) {\n    const val = args.pop();\n    throw new NeverTokenError(val, this, 'Assigning a value to the type never is forbidden.');\n  }\n\n  EncodeObject(val) {\n    throw new NeverTokenError(val, this, 'Assigning a value to the type never is forbidden.');\n  }\n\n  Execute(val) {\n    throw new NeverTokenError(val, this, 'There is no literal value for the type never.');\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return NeverToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: NeverToken.prim,\n      schema: NeverToken.prim\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (NeverToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nNeverToken.prim = 'never';\n\nclass SaplingStateValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'SaplingStateValidationError';\n  }\n\n}\n\nclass SaplingStateToken extends Token {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  isValid(val) {\n    return typeof val === 'object' && Object.keys(val).length === 0;\n  }\n\n  Execute(val, semantic) {\n    if (semantic && semantic[SaplingStateToken.prim]) {\n      return semantic[SaplingStateToken.prim](val, this.val);\n    }\n\n    if ('int' in val) {\n      return val.int;\n    } else {\n      throw new SaplingStateValidationError(val, this, `Sapling state is expecting an object with an int property. Got ${JSON.stringify(val)}`);\n    }\n  }\n\n  Encode(args) {\n    const val = args.pop();\n\n    if (this.isValid(val)) {\n      return [];\n    } else {\n      throw new SaplingStateValidationError(val, this, `Invalid sapling_state. Received: ${val} while expecting: {}`);\n    }\n  }\n\n  EncodeObject(val) {\n    if (this.isValid(val)) {\n      return [];\n    } else {\n      throw new SaplingStateValidationError(val, this, `Invalid sapling_state. Received: ${val} while expecting: {}`);\n    }\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return {\n      [SaplingStateToken.prim]: {\n        'memo-size': Number(this.val.args[0]['int'])\n      }\n    };\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: SaplingStateToken.prim,\n      schema: {\n        memoSize: this.val.args[0]['int']\n      }\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (SaplingStateToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nSaplingStateToken.prim = 'sapling_state';\n\nclass SaplingTransactionValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'SaplingTransactionValidationError';\n  }\n\n}\n\nclass SaplingTransactionToken extends Token {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  Execute(_val) {\n    throw new SaplingTransactionValidationError(_val, this, 'There is no literal value for the sapling_transaction type.');\n  }\n\n  validateBytes(val) {\n    const bytes = /^(0x|0X)?([0-9a-fA-F]*$)/.exec(val);\n\n    if (bytes && bytes[2].length % 2 === 0) {\n      return bytes[2];\n    } else {\n      throw new SaplingTransactionValidationError(val, this, `Invalid bytes: ${val}`);\n    }\n  }\n\n  convertUint8ArrayToHexString(val) {\n    return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;\n  }\n\n  Encode(args) {\n    let val = args.pop();\n    val = this.validateBytes(this.convertUint8ArrayToHexString(val));\n    return {\n      bytes: String(val).toString()\n    };\n  }\n\n  EncodeObject(val) {\n    val = this.validateBytes(this.convertUint8ArrayToHexString(val));\n    return {\n      bytes: String(val).toString()\n    };\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return {\n      [SaplingTransactionToken.prim]: {\n        'memo-size': Number(this.val.args[0]['int'])\n      }\n    };\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: SaplingTransactionToken.prim,\n      schema: {\n        memoSize: this.val.args[0]['int']\n      }\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (SaplingTransactionToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nSaplingTransactionToken.prim = 'sapling_transaction';\n\nclass Bls12381frValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'Bls12381frValidationError';\n  }\n\n}\n\nclass Bls12381frToken extends Token {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  isValid(val) {\n    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n      return null;\n    } else {\n      return new Bls12381frValidationError(val, this, `Invalid bytes: ${val}`);\n    }\n  }\n\n  convertUint8ArrayToHexString(val) {\n    return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;\n  }\n\n  Encode(args) {\n    let val = args.pop();\n\n    if (typeof val === 'number') {\n      return {\n        int: val.toString()\n      };\n    } else {\n      val = this.convertUint8ArrayToHexString(val);\n      const err = this.isValid(val);\n\n      if (err) {\n        throw err;\n      }\n\n      return {\n        bytes: val\n      };\n    }\n  }\n\n  EncodeObject(val) {\n    if (typeof val === 'number') {\n      return {\n        int: val.toString()\n      };\n    } else {\n      val = this.convertUint8ArrayToHexString(val);\n      const err = this.isValid(val);\n\n      if (err) {\n        throw err;\n      }\n\n      return {\n        bytes: val\n      };\n    }\n  }\n\n  Execute(val) {\n    return val.bytes;\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return Bls12381frToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: Bls12381frToken.prim,\n      schema: Bls12381frToken.prim\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (Bls12381frToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n} // An element of the BLS12-381 scalar field Fr\n// see https://tezos.gitlab.io/michelson-reference/#type-bls12_381_fr\n\n\nBls12381frToken.prim = 'bls12_381_fr';\n\nclass Bls12381g1ValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'Bls12381g1ValidationError';\n  }\n\n}\n\nclass Bls12381g1Token extends Token {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  isValid(val) {\n    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n      return null;\n    } else {\n      return new Bls12381g1ValidationError(val, this, `Invalid bytes: ${val}`);\n    }\n  }\n\n  convertUint8ArrayToHexString(val) {\n    return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;\n  }\n\n  Encode(args) {\n    let val = args.pop();\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      bytes: val\n    };\n  }\n\n  EncodeObject(val) {\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      bytes: val\n    };\n  }\n\n  Execute(val) {\n    return val.bytes;\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return Bls12381g1Token.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: Bls12381g1Token.prim,\n      schema: Bls12381g1Token.prim\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (Bls12381g1Token.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n} // A point on the BLS12-381 curve G1\n// See https://tezos.gitlab.io/michelson-reference/#type-bls12_381_g1\n\n\nBls12381g1Token.prim = 'bls12_381_g1';\n\nclass Bls12381g2ValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'Bls12381g2ValidationError';\n  }\n\n}\n\nclass Bls12381g2Token extends Token {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  isValid(val) {\n    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n      return null;\n    } else {\n      return new Bls12381g2ValidationError(val, this, `Invalid bytes: ${val}`);\n    }\n  }\n\n  convertUint8ArrayToHexString(val) {\n    return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;\n  }\n\n  Encode(args) {\n    let val = args.pop();\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      bytes: val\n    };\n  }\n\n  EncodeObject(val) {\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      bytes: val\n    };\n  }\n\n  Execute(val) {\n    return val.bytes;\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return Bls12381g2Token.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: Bls12381g2Token.prim,\n      schema: Bls12381g2Token.prim\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (Bls12381g2Token.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n} // A point on the BLS12-381 curve G2\n// See https://tezos.gitlab.io/michelson-reference/#type-bls12_381_g2\n\n\nBls12381g2Token.prim = 'bls12_381_g2';\n\nclass ChestValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'ChestValidationError';\n  }\n\n}\n\nclass ChestToken extends Token {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  isValid(val) {\n    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n      return null;\n    } else {\n      return new ChestValidationError(val, this, `Invalid bytes: ${val}`);\n    }\n  }\n\n  convertUint8ArrayToHexString(val) {\n    return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;\n  }\n\n  Encode(args) {\n    let val = args.pop();\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      bytes: val\n    };\n  }\n\n  EncodeObject(val) {\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      bytes: val\n    };\n  }\n\n  Execute(val) {\n    return val.bytes;\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return ChestToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: ChestToken.prim,\n      schema: ChestToken.prim\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (ChestToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nChestToken.prim = 'chest';\n\nclass ChestKeyValidationError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'ChestKeyValidationError';\n  }\n\n}\n\nclass ChestKeyToken extends Token {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  isValid(val) {\n    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n      return null;\n    } else {\n      return new ChestKeyValidationError(val, this, `Invalid bytes: ${val}`);\n    }\n  }\n\n  convertUint8ArrayToHexString(val) {\n    return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;\n  }\n\n  Encode(args) {\n    let val = args.pop();\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      bytes: val\n    };\n  }\n\n  EncodeObject(val) {\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n\n    if (err) {\n      throw err;\n    }\n\n    return {\n      bytes: val\n    };\n  }\n\n  Execute(val) {\n    return val.bytes;\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return ChestKeyToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: ChestKeyToken.prim,\n      schema: ChestKeyToken.prim\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (ChestKeyToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nChestKeyToken.prim = 'chest_key';\n\nclass GlobalConstantEncodingError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'GlobalConstantEncodingError';\n  }\n\n}\n\nclass GlobalConstantDecodingError extends TokenValidationError {\n  constructor(value, token, message) {\n    super(value, token, message);\n    this.value = value;\n    this.token = token;\n    this.name = 'GlobalConstantDecodingError';\n  }\n\n}\n\nclass GlobalConstantToken extends Token {\n  constructor(val, idx, fac) {\n    super(val, idx, fac);\n    this.val = val;\n    this.idx = idx;\n    this.fac = fac;\n  }\n\n  Execute(val, semantic) {\n    if (semantic && semantic[GlobalConstantToken.prim]) {\n      return semantic[GlobalConstantToken.prim](val, this.val);\n    } else {\n      throw new GlobalConstantDecodingError(val, this, `Unable to decode a value represented by a global constants. Please provide an expanded script to the Michelson-Encoder or semantics for the decoding. The following global constant hash was encountered: ${this.val.args[0]['string']}.`);\n    }\n  }\n\n  Encode(args) {\n    throw new GlobalConstantEncodingError(args, this, `Unable to encode a script containing global constants. Please provide an expanded script to the Michelson-Encoder. The following global constant hash was encountered: ${this.val.args[0]['string']}.`);\n  }\n\n  EncodeObject(val) {\n    throw new GlobalConstantEncodingError(val, this, `Unable to encode a script containing global constants. Please provide an expanded script to the Michelson-Encoder. The following global constant hash was encountered: ${this.val.args[0]['string']}.`);\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return GlobalConstantToken.prim;\n  }\n\n  generateSchema() {\n    return {\n      __michelsonType: GlobalConstantToken.prim,\n      schema: {\n        hash: this.val.args[0]['string']\n      }\n    };\n  }\n\n  findAndReturnTokens(tokenToFind, tokens) {\n    if (GlobalConstantToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n\n    return tokens;\n  }\n\n}\n\nGlobalConstantToken.prim = 'constant';\nconst tokens = [PairToken, NatToken, StringToken, BigMapToken, AddressToken, MapToken, BoolToken, OrToken, ContractToken, ListToken, MutezToken, BytesToken, OptionToken, TimestampToken, IntToken, UnitToken, KeyToken, KeyHashToken, SignatureToken, LambdaToken, OperationToken, SetToken, ChainIDToken, TicketToken, NeverToken, SaplingStateToken, SaplingTransactionToken, Bls12381frToken, Bls12381g1Token, Bls12381g2Token, ChestToken, ChestKeyToken, GlobalConstantToken];\n/**\r\n *  @category Error\r\n *  @description Error that indicates a script having an invalid type or it being unsupported by the Michelson Encoder. Note some protocol changes might affect this, we encourage users to open an issue so we can look into implementing support for said types.\r\n */\n\nclass InvalidTokenError extends Error {\n  constructor(message, data) {\n    super(message);\n    this.message = message;\n    this.data = data;\n    this.name = 'Invalid token error';\n  }\n\n}\n\nfunction createToken(val, idx) {\n  if (Array.isArray(val)) {\n    return new PairToken(val, idx, createToken);\n  }\n\n  const t = tokens.find(x => x.prim === val.prim);\n\n  if (!t) {\n    throw new InvalidTokenError('Malformed data expected a value with a valid prim property', val);\n  }\n\n  return new t(val, idx, createToken);\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates a failure when encoding (transforming JS parameter into JSON Michelson)the parameter of the view\r\n */\n\n\nclass ViewEncodingError extends Error {\n  constructor(smartContractViewName, originalError) {\n    super(`Unable to encode the parameter of the view: ${smartContractViewName}.`);\n    this.smartContractViewName = smartContractViewName;\n    this.originalError = originalError;\n    this.name = 'ViewEncodingError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid on-chain view found on the script\r\n */\n\n\nclass InvalidScriptError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'InvalidScriptError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid RPC response being passed or used\r\n */\n\n\nclass InvalidRpcResponseError extends Error {\n  constructor(script) {\n    super(`Invalid RPC response passed as argument(s)`);\n    this.script = script;\n    this.name = 'InvalidRpcResponseError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates a failure that occurred during encoding\r\n */\n\n\nclass ParameterEncodingError extends Error {\n  constructor(message, args, originalError) {\n    super(`\n      ${message}. Error encountered when trying to encode arguments: \\n\n      [${args}]\n    `);\n    this.message = message;\n    this.args = args;\n    this.originalError = originalError;\n    this.name = 'ParameterEncodingError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid big map schema being passed or used\r\n */\n\n\nclass InvalidBigMapSchema extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'InvalidBigMapSchema';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates an invalid big map diff being passed or used\r\n */\n\n\nclass InvalidBigMapDiff extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'InvalidBigMapDiff';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates a failure when trying to encode big maps\r\n */\n\n\nclass BigMapEncodingError extends Error {\n  constructor(obj, details) {\n    super(`Unable to encode ${obj}. ${details}`);\n    this.obj = obj;\n    this.details = details;\n    this.name = 'BigMapEncodingError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description Error that indicates a failure when trying to encode storage\r\n */\n\n\nclass StorageEncodingError extends Error {\n  constructor(obj, details) {\n    super(`Unable to encode ${obj}. ${details}`);\n    this.obj = obj;\n    this.details = details;\n    this.name = 'StorageEncodingError';\n  }\n\n}\n/**\r\n *  @category Error\r\n *  @description General error that indicates a function not being passed a necessary argument\r\n */\n\n\nclass MissingArgumentError extends Error {\n  constructor(message) {\n    super(message);\n    this.message = message;\n    this.name = 'MissingArgumentError';\n  }\n\n}\n\nvar _a;\n\nconst schemaTypeSymbol = Symbol.for('taquito-schema-type-symbol'); // collapse comb pair\n\nfunction collapse(val, prim = PairToken.prim) {\n  var _b, _c;\n\n  if (Array.isArray(val)) {\n    return collapse({\n      prim: prim,\n      args: val\n    }, prim);\n  }\n\n  if (val.prim === prim && val.args && val.args.length > 2) {\n    return Object.assign(Object.assign({}, val), {\n      args: [(_b = val.args) === null || _b === void 0 ? void 0 : _b[0], {\n        prim: prim,\n        args: (_c = val.args) === null || _c === void 0 ? void 0 : _c.slice(1)\n      }]\n    });\n  }\n\n  return val;\n}\n\nfunction deepEqual(a, b) {\n  const ac = collapse(a);\n  const bc = collapse(b);\n  return ac.prim === bc.prim && (ac.args === undefined && bc.args === undefined || ac.args !== undefined && bc.args !== undefined && ac.args.length === bc.args.length && ac.args.every((v, i) => {\n    var _b;\n\n    return deepEqual(v, (_b = bc.args) === null || _b === void 0 ? void 0 : _b[i]);\n  })) && (ac.annots === undefined && bc.annots === undefined || ac.annots !== undefined && bc.annots !== undefined && ac.annots.length === bc.annots.length && ac.annots.every((v, i) => {\n    var _b;\n\n    return v === ((_b = bc.annots) === null || _b === void 0 ? void 0 : _b[i]);\n  }));\n}\n/**\r\n * @warn Our current smart contract abstraction feature is currently in preview. It's API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.\r\n */\n\n\nclass Schema {\n  constructor(val) {\n    this.val = val;\n    this[_a] = true;\n    this.root = createToken(val, 0);\n\n    if (this.root instanceof BigMapToken) {\n      this.bigMap = this.root;\n    } else if (this.isExpressionExtended(val) && val.prim === 'pair') {\n      const exp = val.args[0];\n\n      if (this.isExpressionExtended(exp) && exp.prim === 'big_map') {\n        this.bigMap = new BigMapToken(exp, 0, createToken);\n      }\n    }\n  }\n\n  static isSchema(obj) {\n    return obj && obj[schemaTypeSymbol] === true;\n  }\n\n  static fromRPCResponse(val) {\n    const storage = val && val.script && Array.isArray(val.script.code) && val.script.code.find(x => x.prim === 'storage');\n\n    if (!storage || !Array.isArray(storage.args)) {\n      throw new InvalidRpcResponseError(val.script);\n    }\n\n    return new Schema(storage.args[0]);\n  }\n\n  isExpressionExtended(val) {\n    return 'prim' in val && Array.isArray(val.args);\n  }\n\n  removeTopLevelAnnotation(obj) {\n    // PairToken and OrToken can have redundant top level annotation in their storage\n    if (this.root instanceof PairToken || this.root instanceof OrToken) {\n      if (this.root.hasAnnotations() && typeof obj === 'object' && Object.keys(obj).length === 1) {\n        return obj[Object.keys(obj)[0]];\n      }\n    }\n\n    return obj;\n  }\n\n  Execute(val, semantics) {\n    const storage = this.root.Execute(val, semantics);\n    return this.removeTopLevelAnnotation(storage);\n  }\n\n  Typecheck(val) {\n    if (this.root instanceof BigMapToken && Number.isInteger(Number(val))) {\n      return true;\n    }\n\n    try {\n      this.root.EncodeObject(val);\n      return true;\n    } catch (ex) {\n      return false;\n    }\n  }\n\n  ExecuteOnBigMapDiff(diff, semantics) {\n    if (!this.bigMap) {\n      throw new InvalidBigMapSchema('Big map schema is undefined');\n    }\n\n    if (!Array.isArray(diff)) {\n      throw new InvalidBigMapDiff('Big map diff must be an array');\n    }\n\n    const eltFormat = diff.map(({\n      key,\n      value\n    }) => ({\n      args: [key, value]\n    }));\n    return this.bigMap.Execute(eltFormat, semantics);\n  }\n\n  ExecuteOnBigMapValue(key, semantics) {\n    if (!this.bigMap) {\n      throw new InvalidBigMapSchema('No big map schema');\n    }\n\n    return this.bigMap.ValueSchema.Execute(key, semantics);\n  }\n\n  EncodeBigMapKey(key) {\n    if (!this.bigMap) {\n      throw new InvalidBigMapSchema('Big map schema is undefined');\n    }\n\n    try {\n      return this.bigMap.KeySchema.ToBigMapKey(key);\n    } catch (ex) {\n      throw new BigMapEncodingError('big map key', ex);\n    }\n  }\n\n  Encode(_value) {\n    try {\n      return this.root.EncodeObject(_value);\n    } catch (ex) {\n      if (ex instanceof TokenValidationError) {\n        throw ex;\n      }\n\n      throw new StorageEncodingError('storage object', ex);\n    }\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return this.removeTopLevelAnnotation(this.root.ExtractSchema());\n  }\n  /**\r\n   * @description Produce a representation of the storage schema.\r\n   * Note: Provide guidance on how to write the storage object for the origination operation with Taquito.\r\n   */\n\n\n  generateSchema() {\n    return this.removeTopLevelAnnotation(this.root.generateSchema());\n  }\n  /**\r\n   * @deprecated\r\n   */\n\n\n  ComputeState(tx, state) {\n    if (!this.bigMap) {\n      throw new InvalidBigMapSchema('Big map schema is undefined');\n    }\n\n    const bigMap = tx.reduce((prev, current) => {\n      return Object.assign(Object.assign({}, prev), this.ExecuteOnBigMapDiff(current.contents[0].metadata.operation_result.big_map_diff));\n    }, {});\n    return Object.assign(Object.assign({}, this.Execute(state)), {\n      [this.bigMap.annot()]: bigMap\n    });\n  }\n  /**\r\n   * @description Look up in top-level pairs of the storage to find a value matching the specified type\r\n   *\r\n   * @returns The first value found that match the type or `undefined` if no value is found\r\n   *\r\n   * @param storage storage to parse to find the value\r\n   * @param valueType type of value to look for\r\n   *\r\n   */\n\n\n  FindFirstInTopLevelPair(storage, valueType) {\n    return this.findValue(this.root['val'], storage, valueType);\n  }\n\n  findValue(schema, storage, valueToFind) {\n    if (deepEqual(valueToFind, schema)) {\n      return storage;\n    }\n\n    if (Array.isArray(schema) || schema['prim'] === 'pair') {\n      const sch = collapse(schema);\n      const str = collapse(storage, 'Pair');\n\n      if (sch.args === undefined || str.args === undefined) {\n        throw new MissingArgumentError('Tokens have no arguments'); // unlikely\n      }\n\n      return this.findValue(sch.args[0], str.args[0], valueToFind) || this.findValue(sch.args[1], str.args[1], valueToFind);\n    }\n  }\n  /**\r\n   * @description Look up the schema to find any occurrence of a particular token.\r\n   *\r\n   * @returns an array of tokens of the specified kind or an empty array if no token was found\r\n   *\r\n   * @param tokenToFind string representing the prim property of the token to find\r\n   *\r\n   * @example\r\n   * ```\r\n   * Useful to find all global constants in a script, an array of GlobalConstantToken is returned:\r\n   *\r\n   * const schema = new Schema(script);\r\n   * const allGlobalConstantTokens = schema.findToken('constant');\r\n   * ```\r\n   *\r\n   */\n\n\n  findToken(tokenToFind) {\n    const tokens = [];\n    return this.root.findAndReturnTokens(tokenToFind, tokens);\n  }\n\n}\n\n_a = schemaTypeSymbol;\n/**\r\n * @warn Our current smart contract abstraction feature is currently in preview. It's API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.\r\n */\n\nclass ParameterSchema {\n  constructor(val) {\n    this.root = createToken(val, 0);\n  }\n\n  static fromRPCResponse(val) {\n    const parameter = val && val.script && Array.isArray(val.script.code) && val.script.code.find(x => x.prim === 'parameter');\n\n    if (!parameter || !Array.isArray(parameter.args)) {\n      throw new InvalidRpcResponseError(val.script);\n    }\n\n    return new ParameterSchema(parameter.args[0]);\n  }\n\n  get isMultipleEntryPoint() {\n    return this.root instanceof OrToken || this.root instanceof OptionToken && this.root.subToken() instanceof OrToken;\n  }\n\n  get hasAnnotation() {\n    if (this.isMultipleEntryPoint) {\n      return Object.keys(this.ExtractSchema())[0] !== '0';\n    } else {\n      return true;\n    }\n  }\n\n  Execute(val, semantics) {\n    return this.root.Execute(val, semantics);\n  }\n\n  Encode(...args) {\n    try {\n      return this.root.Encode(args.reverse());\n    } catch (ex) {\n      if (ex instanceof TokenValidationError) {\n        throw ex;\n      }\n\n      throw new ParameterEncodingError('Unable to encode parameter', args.toString(), ex);\n    }\n  }\n\n  EncodeObject(_value) {\n    try {\n      return this.root.EncodeObject(_value);\n    } catch (ex) {\n      if (ex instanceof TokenValidationError) {\n        throw ex;\n      }\n\n      throw new ParameterEncodingError('Unable to encode parameter object', _value, ex);\n    }\n  }\n  /**\r\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\r\n   *\r\n   */\n\n\n  ExtractSchema() {\n    return this.root.ExtractSchema();\n  }\n  /**\r\n   * @description Produce a schema grouping together all the entry points of a contract.\r\n   */\n\n\n  generateSchema() {\n    return this.root.generateSchema();\n  }\n\n  ExtractSignatures() {\n    return this.root.ExtractSignature();\n  }\n\n}\n\nclass ViewSchema {\n  constructor(val) {\n    if (val.length !== 4 || !('string' in val[0])) {\n      throw new InvalidScriptError(`Invalid on-chain view: ${JSON.stringify(val)}`);\n    } // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n\n\n    this.viewName = val[0]['string'];\n    this.viewArgsType = val[1];\n    this.viewReturnType = val[2];\n    this.instructions = val[3];\n    this.rootArgsType = createToken(this.viewArgsType, 0);\n    this.rootReturnType = createToken(this.viewReturnType, 0);\n  }\n  /**\r\n   *\r\n   * @description Create an instance of ViewSchema for each view in a script\r\n   *\r\n   * @param val contract script obtained from the RPC\r\n   * @returns array of ViewSchema or empty array if there is no view in the contract\r\n   */\n\n\n  static fromRPCResponse(val) {\n    const allViewSchema = [];\n    const views = val && val.script && Array.isArray(val.script.code) && val.script.code.filter(x => x.prim === 'view');\n\n    if (views) {\n      views.forEach(view => {\n        if (!view.args || view.args.length !== 4) {\n          throw new InvalidScriptError(`Invalid on-chain view found in the script: ${JSON.stringify(view)}`);\n        }\n\n        allViewSchema.push(new ViewSchema(view.args));\n      });\n    }\n\n    return allViewSchema;\n  }\n  /**\r\n   *\r\n   * @description Transform the view parameter into Michelson\r\n   *\r\n   * @param args parameter of the view in js format\r\n   * @returns parameter of the view in Michelson\r\n   */\n\n\n  encodeViewArgs(args) {\n    try {\n      return this.rootArgsType.EncodeObject(args);\n    } catch (ex) {\n      throw new ViewEncodingError(this.viewName, ex);\n    }\n  }\n  /**\r\n   *\r\n   * @description Transform the view result from Michelson to readable data\r\n   *\r\n   * @param val result of the view in JSON Michelson\r\n   * @param semantics optional semantics to override the default decoding behavior\r\n   * @returns result of the view in a readable format\r\n   */\n\n\n  decodeViewResult(val, semantics) {\n    return this.rootReturnType.Execute(val, semantics);\n  }\n  /**\r\n   *\r\n   * @description Return the signature of the view parameter\r\n   */\n\n\n  extractArgsSchema() {\n    return this.rootArgsType.ExtractSchema();\n  }\n  /**\r\n   *\r\n   * @description Return the format of the view result\r\n   */\n\n\n  extractResultSchema() {\n    return this.rootReturnType.ExtractSchema();\n  }\n\n} // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\n\n\nconst VERSION = {\n  \"commitHash\": \"cbdd0af87e400489076259d065e2d328feb8e1b4\",\n  \"version\": \"12.1.0\"\n};\n/**\r\n * @packageDocumentation\r\n * @module @taquito/michelson-encoder\r\n */\n\nconst UnitValue = Symbol();\nconst SaplingStateValue = {};\nexport { AddressValidationError, BigMapEncodingError, BigMapValidationError, BytesValidationError, ChainIDValidationError, ContractValidationError, EncodeTicketError, IntValidationError, InvalidBigMapDiff, InvalidBigMapSchema, InvalidMapTypeError, InvalidRpcResponseError, InvalidScriptError, KeyHashValidationError, KeyValidationError, ListValidationError, MapTypecheckError, MapValidationError, MichelsonMap, MissingArgumentError, MutezValidationError, NatValidationError, OrTokenDecodingError, ParameterEncodingError, ParameterSchema, SaplingStateValue, Schema, SetValidationError, SignatureValidationError, StorageEncodingError, Token, TokenArgumentValidationError, TokenComparisonError, UnitValue, VERSION, ViewEncodingError, ViewSchema };","map":{"version":3,"mappings":"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","names":["InvalidMapTypeError","Error","constructor","mapType","michelsonMapTypeSymbol","Symbol","for","isMapType","value","Array","isArray","args","length","MapTypecheckError","type","errorType","MichelsonMap","Map","setType","isMichelsonMap","obj","toString","keySchema","Schema","valueSchema","removeType","undefined","fromLiteral","map","Object","keys","forEach","key","set","typecheckKey","Typecheck","typecheckValue","assertTypecheckValue","assertTypecheckKey","serializeDeterministically","stringify","entries","values","valueMap","keyMap","get","strKey","delete","has","clear","size","cb","TokenValidationError","token","baseMessage","annot","annotText","message","Token","val","idx","fac","typeWithoutAnnotations","removeArgsRec","prim","x","annots","String","replace","hasAnnotations","tokenVal","ExtractSignature","ExtractSchema","ComparableToken","compare","o1","o2","BigMapValidationError","BigMapToken","ValueSchema","createToken","KeySchema","big_map","generateSchema","__michelsonType","schema","isValid","Encode","pop","err","from","sort","a","b","EncodeObject","Execute","semantic","current","ToKey","int","JSON","findAndReturnTokens","tokenToFind","tokens","push","OrTokenDecodingError","OrToken","label","leftToken","keyCount","rightToken","newSig","sig","semantics","traversal","getLeftValue","getRightValue","concat","leftValue","rightValue","res","findToken","tok","val1","val2","labelVal1","labelVal2","encoded1","encoded2","ToBigMapKey","TokenArgumentValidationError","TokenComparisonError","collapse","PairToken","slice","cnt","t","leftSig","rightSig","getValue","result","NatValidationError","NatToken","BigNumber","toFixed","bigNumber","isNaN","isNegative","nat1","nat2","Number","StringToken","string","AddressValidationError","AddressToken","decoded","b58decode","bytes","validateAddress","ValidationResult","VALID","encodePubKey","address1","address2","isImplicit","address","startsWith","MapValidationError","MapToken","BoolToken","toLowerCase","ContractValidationError","ContractToken","parameter","ListValidationError","ListToken","reduce","prev","MutezValidationError","MutezToken","mutez1","mutez2","BytesValidationError","BytesToken","test","convertUint8ArrayToHexString","Uint8Array","Buffer","OptionToken","subToken","TimestampToken","Date","toISOString","IntValidationError","IntToken","int1","int2","UnitToken","_val","UnitValue","_val1","_val2","publicKeyPrefixLength","KeyValidationError","KeyToken","encodeKey","validatePublicKey","key1","key2","keyPrefix1","getPrefix","keyPrefix2","Prefix","EDPK","SPPK","P2PK","keyBytes1","getP256PublicKeyComparableBytes","keyBytes2","substring","p2pk","b58cdecode","prefix","KeyHashValidationError","KeyHashToken","encodeKeyHash","validateKeyHash","SignatureValidationError","SignatureToken","validateSignature","LambdaToken","paramSchema","returnSchema","parameters","returns","OperationToken","SetValidationError","SetToken","ChainIDValidationError","ChainIDToken","validateChain","EncodeTicketError","ticketerType","amountType","TicketToken","valueToken","_args","ticketer","amount","NeverTokenError","NeverToken","SaplingStateValidationError","SaplingStateToken","memoSize","SaplingTransactionValidationError","SaplingTransactionToken","validateBytes","exec","Bls12381frValidationError","Bls12381frToken","Bls12381g1ValidationError","Bls12381g1Token","Bls12381g2ValidationError","Bls12381g2Token","ChestValidationError","ChestToken","ChestKeyValidationError","ChestKeyToken","GlobalConstantEncodingError","GlobalConstantDecodingError","GlobalConstantToken","hash","InvalidTokenError","data","find","ViewEncodingError","smartContractViewName","originalError","InvalidScriptError","InvalidRpcResponseError","script","ParameterEncodingError","InvalidBigMapSchema","InvalidBigMapDiff","BigMapEncodingError","details","StorageEncodingError","MissingArgumentError","schemaTypeSymbol","_c","deepEqual","ac","bc","every","v","i","_b","root","bigMap","isExpressionExtended","exp","isSchema","fromRPCResponse","storage","code","removeTopLevelAnnotation","isInteger","ex","ExecuteOnBigMapDiff","diff","eltFormat","ExecuteOnBigMapValue","EncodeBigMapKey","_value","ComputeState","tx","state","contents","metadata","operation_result","big_map_diff","FindFirstInTopLevelPair","valueType","findValue","valueToFind","sch","str","ParameterSchema","isMultipleEntryPoint","hasAnnotation","reverse","ExtractSignatures","ViewSchema","viewName","viewArgsType","viewReturnType","instructions","rootArgsType","rootReturnType","allViewSchema","views","filter","view","encodeViewArgs","decodeViewResult","extractArgsSchema","extractResultSchema","VERSION","SaplingStateValue"],"sources":["../src/michelson-map.ts","../src/tokens/token.ts","../src/tokens/bigmap.ts","../src/tokens/or.ts","../src/tokens/pair.ts","../src/tokens/comparable/nat.ts","../src/tokens/comparable/string.ts","../src/tokens/comparable/address.ts","../src/tokens/map.ts","../src/tokens/comparable/bool.ts","../src/tokens/contract.ts","../src/tokens/list.ts","../src/tokens/comparable/mutez.ts","../src/tokens/comparable/bytes.ts","../src/tokens/option.ts","../src/tokens/comparable/timestamp.ts","../src/tokens/comparable/int.ts","../src/tokens/unit.ts","../src/tokens/key.ts","../src/tokens/comparable/key_hash.ts","../src/tokens/signature.ts","../src/tokens/lambda.ts","../src/tokens/operation.ts","../src/tokens/set.ts","../src/tokens/chain-id.ts","../src/tokens/ticket.ts","../src/tokens/never.ts","../src/tokens/sapling-state.ts","../src/tokens/sapling-transaction.ts","../src/tokens/bls12-381-fr.ts","../src/tokens/bls12-381-g1.ts","../src/tokens/bls12-381-g2.ts","../src/tokens/chest.ts","../src/tokens/chest-key.ts","../src/tokens/constant.ts","../src/tokens/tokens.ts","../src/tokens/createToken.ts","../src/schema/error.ts","../src/schema/storage.ts","../src/schema/parameter.ts","../src/schema/view-schema.ts","../src/version.ts","../src/taquito-michelson-encoder.ts"],"sourcesContent":["import { MichelsonV1Expression } from '@taquito/rpc';\nimport { Schema } from './schema/storage';\nimport stringify from 'fast-json-stable-stringify';\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid map type being passed or used\n */\nexport class InvalidMapTypeError extends Error {\n  public name = 'InvalidMapTypeError';\n  constructor(public mapType: string) {\n    super(`The map type '${mapType}' is invalid`);\n  }\n}\n\n// Retrieve a unique symbol associated with the key from the environment\n// Used in order to identify all object that are of type MichelsonMap even if they come from different module\nconst michelsonMapTypeSymbol = Symbol.for('taquito-michelson-map-type-symbol');\n\nexport type MichelsonMapKey = Array<any> | object | string | boolean | number;\n\nconst isMapType = (\n  value: MichelsonV1Expression\n): value is { prim: 'map' | 'big_map'; args: [MichelsonV1Expression, MichelsonV1Expression] } => {\n  return 'args' in value && Array.isArray(value.args) && value.args.length === 2;\n};\n\n/**\n *  @category Error\n *  @description Error that indicates a map type mismatch, where an attempt to set a key or value in a Map doesn't match the defined type of the Map\n */\nexport class MapTypecheckError extends Error {\n  name = 'MapTypecheckError';\n\n  constructor(public readonly value: any, public readonly type: any, errorType: 'key' | 'value') {\n    super(`${errorType} not compliant with underlying michelson type`);\n  }\n}\n\n/**\n * @description Michelson Map is an abstraction over the michelson native map. It supports complex Pair as key\n */\nexport class MichelsonMap<K extends MichelsonMapKey, T> {\n  private valueMap = new Map<string, T>();\n  private keyMap = new Map<string, K>();\n\n  public [michelsonMapTypeSymbol] = true;\n\n  // Used to check if an object is a michelson map.\n  // Using instanceof was not working for project that had multiple instance of taquito dependencies\n  // as the class constructor is different\n  static isMichelsonMap(obj: any): obj is MichelsonMap<any, any> {\n    return obj && obj[michelsonMapTypeSymbol] === true;\n  }\n\n  private keySchema?: Schema;\n  private valueSchema?: Schema;\n\n  /**\n   * @param mapType If specified key and value will be type-checked before being added to the map\n   *\n   * @example new MichelsonMap({ prim: \"map\", args: [{prim: \"string\"}, {prim: \"int\"}]})\n   */\n  constructor(mapType?: MichelsonV1Expression) {\n    if (mapType) {\n      this.setType(mapType);\n    }\n  }\n\n  setType(mapType: MichelsonV1Expression) {\n    if (!isMapType(mapType)) {\n      throw new InvalidMapTypeError(mapType.toString());\n    }\n\n    this.keySchema = new Schema(mapType.args[0]);\n    this.valueSchema = new Schema(mapType.args[1]);\n  }\n\n  removeType() {\n    this.keySchema = undefined;\n    this.valueSchema = undefined;\n  }\n\n  static fromLiteral(obj: { [key: string]: any }, mapType?: MichelsonV1Expression) {\n    const map = new MichelsonMap(mapType);\n    Object.keys(obj).forEach((key) => {\n      map.set(key, obj[key]);\n    });\n    return map;\n  }\n\n  private typecheckKey(key: K) {\n    if (this.keySchema) {\n      return this.keySchema.Typecheck(key);\n    }\n\n    return true;\n  }\n\n  private typecheckValue(value: T) {\n    if (this.valueSchema) {\n      return this.valueSchema.Typecheck(value);\n    }\n\n    return true;\n  }\n\n  private assertTypecheckValue(value: T) {\n    if (!this.typecheckValue(value)) {\n      throw new MapTypecheckError(value, this.valueSchema, 'value');\n    }\n  }\n\n  private assertTypecheckKey(key: K) {\n    if (!this.typecheckKey(key)) {\n      throw new MapTypecheckError(key, this.keySchema, 'key');\n    }\n  }\n\n  private serializeDeterministically(key: K): string {\n    return stringify(key);\n  }\n\n  *keys(): Generator<K> {\n    for (const [key] of this.entries()) {\n      yield key;\n    }\n  }\n\n  *values(): Generator<T> {\n    for (const [, value] of this.entries()) {\n      yield value;\n    }\n  }\n\n  *entries(): Generator<[K, T]> {\n    for (const key of this.valueMap.keys()) {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      yield [this.keyMap.get(key)!, this.valueMap.get(key)!];\n    }\n  }\n\n  get(key: K): T | undefined {\n    this.assertTypecheckKey(key);\n\n    const strKey = this.serializeDeterministically(key);\n    return this.valueMap.get(strKey);\n  }\n\n  /**\n   *\n   * @description Set a key and a value in the MichelsonMap. If the key already exists, override the current value.\n   *\n   * @example map.set(\"myKey\", \"myValue\") // Using a string as key\n   *\n   * @example map.set({0: \"test\", 1: \"test1\"}, \"myValue\") // Using a pair as key\n   *\n   * @warn The same key can be represented in multiple ways, depending on the type of the key. This duplicate key situation will cause a runtime error (duplicate key) when sending the map data to the Tezos RPC node.\n   *\n   * For example, consider a contract with a map whose key is of type boolean.  If you set the following values in MichelsonMap: map.set(false, \"myValue\") and map.set(null, \"myValue\").\n   *\n   * You will get two unique entries in the MichelsonMap. These values will both be evaluated as falsy by the MichelsonEncoder and ultimately rejected by the Tezos RPC.\n   */\n  set(key: K, value: T) {\n    this.assertTypecheckKey(key);\n    this.assertTypecheckValue(value);\n\n    const strKey = this.serializeDeterministically(key);\n    this.keyMap.set(strKey, key);\n    this.valueMap.set(strKey, value);\n  }\n\n  delete(key: K) {\n    this.assertTypecheckKey(key);\n\n    this.keyMap.delete(this.serializeDeterministically(key));\n    this.valueMap.delete(this.serializeDeterministically(key));\n  }\n\n  has(key: K) {\n    this.assertTypecheckKey(key);\n\n    const strKey = this.serializeDeterministically(key);\n    return this.keyMap.has(strKey) && this.valueMap.has(strKey);\n  }\n\n  clear(): void {\n    this.keyMap.clear();\n    this.valueMap.clear();\n  }\n\n  get size() {\n    return this.keyMap.size;\n  }\n\n  forEach(cb: (value: T, key: K, map: MichelsonMap<K, T>) => void) {\n    for (const [key, value] of this.entries()) {\n      cb(value, key, this);\n    }\n  }\n}\n","import { MichelsonV1Expression } from '@taquito/rpc';\nimport { TokenSchema } from '../schema/types';\n\n/**\n *  @category Error\n *  @description Error that indicates a failure when encoding invalid or incorrect data (e.g. if an address is expected but a number is received)\n */\nexport abstract class TokenValidationError extends Error {\n  name = 'ValidationError';\n\n  constructor(public value: any, public token: Token, baseMessage: string) {\n    super();\n    const annot = this.token.annot();\n    const annotText = annot ? `[${annot}] ` : '';\n    this.message = `${annotText}${baseMessage}`;\n  }\n}\n\nexport type TokenFactory = (val: any, idx: number) => Token;\n\nexport interface Semantic {\n  [key: string]: (value: MichelsonV1Expression, schema: MichelsonV1Expression) => any;\n}\n\nexport abstract class Token {\n  constructor(\n    protected val: { prim: string; args?: any[]; annots?: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {}\n\n  protected typeWithoutAnnotations() {\n    const removeArgsRec = (val: Token['val']): { prim: string; args?: any[] } => {\n      if (val.args) {\n        return {\n          prim: val.prim,\n          args: val.args.map((x) => removeArgsRec(x)),\n        };\n      } else {\n        return {\n          prim: val.prim,\n        };\n      }\n    };\n\n    return removeArgsRec(this.val);\n  }\n\n  annot() {\n    return (\n      Array.isArray(this.val.annots) && this.val.annots.length > 0\n        ? this.val.annots[0]\n        : String(this.idx)\n    ).replace(/(%|:)(_Liq_entry_)?/, '');\n  }\n\n  hasAnnotations() {\n    return Array.isArray(this.val.annots) && this.val.annots.length;\n  }\n\n  get tokenVal() {\n    return this.val;\n  }\n\n  public createToken = this.fac;\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public abstract ExtractSchema(): any;\n\n  abstract generateSchema(): TokenSchema;\n\n  public abstract Execute(val: any, semantics?: Semantic): any;\n\n  public abstract Encode(_args: any[]): any;\n\n  public abstract EncodeObject(args: any): any;\n\n  public ExtractSignature() {\n    return [[this.ExtractSchema()]];\n  }\n\n  abstract findAndReturnTokens(tokenToFind: string, tokens: Array<Token>): Array<Token>;\n}\n\nexport type BigMapKeyType = string | number | object;\n\nexport abstract class ComparableToken extends Token {\n  abstract ToBigMapKey(val: BigMapKeyType): {\n    key: { [key: string]: string | object[] };\n    type: { prim: string; args?: object[] };\n  };\n\n  abstract ToKey(val: string): any;\n\n  compare(o1: string, o2: string): number {\n    if (o1 === o2) {\n      return 0;\n    }\n\n    return o1 < o2 ? -1 : 1;\n  }\n}\n","import { MichelsonMap } from '../michelson-map';\nimport { BigMapTokenSchema } from '../schema/types';\nimport { ComparableToken, Semantic, Token, TokenFactory, TokenValidationError } from './token';\n\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing Big Map types\n */\nexport class BigMapValidationError extends TokenValidationError {\n  name = 'BigMapValidationError';\n  constructor(public value: any, public token: BigMapToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class BigMapToken extends Token {\n  static prim: 'big_map' = 'big_map';\n  constructor(\n    protected val: { prim: string; args: any[]; annots?: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  get ValueSchema() {\n    return this.createToken(this.val.args[1], 0);\n  }\n\n  get KeySchema(): ComparableToken {\n    return this.createToken(this.val.args[0], 0) as unknown as ComparableToken;\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return {\n      big_map: {\n        key: this.KeySchema.ExtractSchema(),\n        value: this.ValueSchema.ExtractSchema(),\n      },\n    };\n  }\n\n  generateSchema(): BigMapTokenSchema {\n    return {\n      __michelsonType: BigMapToken.prim,\n      schema: {\n        key: this.KeySchema.generateSchema(),\n        value: this.ValueSchema.generateSchema(),\n      },\n    };\n  }\n\n  private isValid(value: any): BigMapValidationError | null {\n    if (MichelsonMap.isMichelsonMap(value)) {\n      return null;\n    }\n\n    return new BigMapValidationError(value, this, 'Value must be a MichelsonMap');\n  }\n\n  public Encode(args: any[]): any {\n    const val: MichelsonMap<any, any> = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return Array.from(val.keys())\n      .sort((a: any, b: any) => this.KeySchema.compare(a, b))\n      .map((key) => {\n        return {\n          prim: 'Elt',\n          args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))],\n        };\n      });\n  }\n\n  public EncodeObject(args: any): any {\n    const val: MichelsonMap<any, any> = args;\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return Array.from(val.keys())\n      .sort((a: any, b: any) => this.KeySchema.compare(a, b))\n      .map((key) => {\n        return {\n          prim: 'Elt',\n          args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))],\n        };\n      });\n  }\n\n  public Execute(val: any[] | { int: string }, semantic?: Semantic) {\n    if (semantic && semantic[BigMapToken.prim]) {\n      return semantic[BigMapToken.prim](val as any, this.val);\n    }\n\n    if (Array.isArray(val)) {\n      // Athens is returning an empty array for big map in storage\n      // Internal: In taquito v5 it is still used to decode big map diff (as if they were a regular map)\n      const map = new MichelsonMap(this.val);\n      val.forEach((current) => {\n        map.set(this.KeySchema.ToKey(current.args[0]), this.ValueSchema.Execute(current.args[1]));\n      });\n      return map;\n    } else if ('int' in val) {\n      // Babylon is returning an int with the big map id in contract storage\n      return val.int;\n    } else {\n      throw new BigMapValidationError(\n        val,\n        this,\n        `Big map is expecting either an array (Athens) or an object with an int property (Babylon). Got ${JSON.stringify(\n          val\n        )}`\n      );\n    }\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (BigMapToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    this.KeySchema.findAndReturnTokens(tokenToFind, tokens);\n    this.ValueSchema.findAndReturnTokens(tokenToFind, tokens);\n    return tokens;\n  }\n}\n","import { OrTokenSchema } from '../schema/types';\nimport { Token, TokenFactory, Semantic, ComparableToken } from './token';\n\n/**\n *  @category Error\n *  @description Error that indicates a failure when decoding OR Token methods\n */\nexport class OrTokenDecodingError extends Error {\n  public name = 'OrTokenDecodingError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n\nexport class OrToken extends ComparableToken {\n  static prim: 'or' = 'or';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Encode(args: any[]): any {\n    const label = args[args.length - 1];\n\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken)) {\n      args.pop();\n      return { prim: 'Left', args: [leftToken.Encode(args)] };\n    } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof OrToken)) {\n      args.pop();\n      return { prim: 'Right', args: [rightToken.Encode(args)] };\n    } else {\n      if (leftToken instanceof OrToken) {\n        const val = leftToken.Encode(args);\n        if (val) {\n          return { prim: 'Left', args: [val] };\n        }\n      }\n\n      if (rightToken instanceof OrToken) {\n        const val = rightToken.Encode(args);\n        if (val) {\n          return { prim: 'Right', args: [val] };\n        }\n      }\n      return null;\n    }\n  }\n\n  public ExtractSignature(): any {\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    const newSig = [];\n\n    if (leftToken instanceof OrToken) {\n      newSig.push(...leftToken.ExtractSignature());\n    } else {\n      for (const sig of leftToken.ExtractSignature()) {\n        newSig.push([leftToken.annot(), ...sig]);\n      }\n    }\n\n    if (rightToken instanceof OrToken) {\n      newSig.push(...rightToken.ExtractSignature());\n    } else {\n      for (const sig of rightToken.ExtractSignature()) {\n        newSig.push([rightToken.annot(), ...sig]);\n      }\n    }\n\n    return newSig;\n  }\n\n  public EncodeObject(args: any): any {\n    const label = Object.keys(args)[0];\n\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken)) {\n      return { prim: 'Left', args: [leftToken.EncodeObject(args[label])] };\n    } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof OrToken)) {\n      return { prim: 'Right', args: [rightToken.EncodeObject(args[label])] };\n    } else {\n      if (leftToken instanceof OrToken) {\n        const val = leftToken.EncodeObject(args);\n        if (val) {\n          return { prim: 'Left', args: [val] };\n        }\n      }\n\n      if (rightToken instanceof OrToken) {\n        const val = rightToken.EncodeObject(args);\n        if (val) {\n          return { prim: 'Right', args: [val] };\n        }\n      }\n      return null;\n    }\n  }\n\n  public Execute(val: any, semantics?: Semantic): any {\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    if (val.prim === 'Right') {\n      if (rightToken instanceof OrToken) {\n        return rightToken.Execute(val.args[0], semantics);\n      } else {\n        return {\n          [rightToken.annot()]: rightToken.Execute(val.args[0], semantics),\n        };\n      }\n    } else if (val.prim === 'Left') {\n      if (leftToken instanceof OrToken) {\n        return leftToken.Execute(val.args[0], semantics);\n      }\n      return {\n        [leftToken.annot()]: leftToken.Execute(val.args[0], semantics),\n      };\n    } else {\n      throw new OrTokenDecodingError(`Was expecting Left or Right prim but got: ${val.prim}`);\n    }\n  }\n\n  private traversal(\n    getLeftValue: (token: Token) => any,\n    getRightValue: (token: Token) => any,\n    concat: (left: any, right: any) => any\n  ) {\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n    let leftValue;\n    if (leftToken instanceof OrToken && !leftToken.hasAnnotations()) {\n      leftValue = getLeftValue(leftToken);\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    } else {\n      leftValue = { [leftToken.annot()]: getLeftValue(leftToken) };\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n    let rightValue;\n    if (rightToken instanceof OrToken && !rightToken.hasAnnotations()) {\n      rightValue = getRightValue(rightToken);\n    } else {\n      rightValue = { [rightToken.annot()]: getRightValue(rightToken) };\n    }\n\n    const res = concat(leftValue, rightValue);\n\n    return res;\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema(): any {\n    return this.traversal(\n      (leftToken) => leftToken.ExtractSchema(),\n      (rightToken) => rightToken.ExtractSchema(),\n      (leftValue, rightValue) => ({\n        ...leftValue,\n        ...rightValue,\n      })\n    );\n  }\n\n  generateSchema(): OrTokenSchema {\n    return {\n      __michelsonType: OrToken.prim,\n      schema: this.traversal(\n        (leftToken) => {\n          if (leftToken instanceof OrToken && !leftToken.hasAnnotations()) {\n            return leftToken.generateSchema().schema;\n          } else {\n            return leftToken.generateSchema();\n          }\n        },\n        (rightToken) => {\n          if (rightToken instanceof OrToken && !rightToken.hasAnnotations()) {\n            return rightToken.generateSchema().schema;\n          } else {\n            return rightToken.generateSchema();\n          }\n        },\n        (leftValue, rightValue) => ({\n          ...leftValue,\n          ...rightValue,\n        })\n      ),\n    };\n  }\n\n  private findToken(label: any): Token | null {\n    const leftToken = this.createToken(this.val.args[0], this.idx);\n    let keyCount = 1;\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n\n    if (\n      String(leftToken.annot()) === String(label) &&\n      !(leftToken instanceof OrToken) &&\n      leftToken instanceof ComparableToken\n    ) {\n      return leftToken;\n    } else if (\n      String(rightToken.annot()) === String(label) &&\n      !(rightToken instanceof OrToken) &&\n      rightToken instanceof ComparableToken\n    ) {\n      return rightToken;\n    } else {\n      if (leftToken instanceof OrToken) {\n        const tok = leftToken.findToken(label);\n        if (tok) {\n          return tok;\n        }\n      }\n\n      if (rightToken instanceof OrToken) {\n        const tok = rightToken.findToken(label);\n        if (tok) {\n          return tok;\n        }\n      }\n      return null;\n    }\n  }\n\n  compare(val1: any, val2: any): any {\n    const labelVal1 = Object.keys(val1)[0];\n    const labelVal2 = Object.keys(val2)[0];\n\n    if (labelVal1 === labelVal2) {\n      const token = this.findToken(labelVal1);\n      if (token instanceof ComparableToken) {\n        return token.compare(val1[labelVal1], val2[labelVal1]);\n      }\n    } else {\n      const encoded1 = JSON.stringify(this.EncodeObject(val1));\n      const encoded2 = JSON.stringify(this.EncodeObject(val2));\n      return encoded1 < encoded2 ? -1 : 1;\n    }\n  }\n\n  public ToKey(val: any) {\n    return this.Execute(val);\n  }\n\n  public ToBigMapKey(val: any) {\n    return {\n      key: this.EncodeObject(val),\n      type: this.typeWithoutAnnotations(),\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (OrToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    this.traversal(\n      (leftToken) => leftToken.findAndReturnTokens(tokenToFind, tokens),\n      (rightToken) => rightToken.findAndReturnTokens(tokenToFind, tokens),\n      (leftValue, rightValue) => ({\n        ...leftValue,\n        ...rightValue,\n      })\n    );\n    return tokens;\n  }\n}\n","import { Token, TokenFactory, Semantic, ComparableToken } from './token';\nimport { OrToken } from './or';\nimport { PairTokenSchema } from '../schema/types';\n\n/**\n *  @category Error\n *  @description Error that indicates in invalid token argument being passed\n */\nexport class TokenArgumentValidationError extends Error {\n  public name = 'TokenArgumentValidationError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates a failure occurring when doing a comparison of tokens\n */\nexport class TokenComparisonError extends Error {\n  public name = 'TokenComparisonError';\n  constructor(public val1: string, public val2: string) {\n    super(`Tokens ${val1} and ${val2} are not comparable`);\n  }\n}\n\n// collapse comb pair\nfunction collapse(val: Token['val'] | any[], prim: string = PairToken.prim): [any, any] {\n  if (Array.isArray(val)) {\n    return collapse(\n      {\n        prim: prim,\n        args: val,\n      },\n      prim\n    );\n  }\n  if (val.args === undefined) {\n    throw new TokenArgumentValidationError(\n      'Encountered an invalid PairToken with no arguments, a pair must have two or more arguments'\n    );\n  }\n  if (val.args.length > 2) {\n    return [\n      val.args[0],\n      {\n        prim: prim,\n        args: val.args.slice(1),\n      },\n    ];\n  }\n  return [val.args[0], val.args[1]];\n}\nexport class PairToken extends ComparableToken {\n  static prim: 'pair' = 'pair';\n\n  constructor(\n    val: { prim: string; args: any[]; annots: any[] } | any[],\n    idx: number,\n    fac: TokenFactory\n  ) {\n    super(\n      Array.isArray(val)\n        ? {\n            prim: PairToken.prim,\n            args: val,\n          }\n        : val,\n      idx,\n      fac\n    );\n  }\n\n  private args(): [any, any] {\n    // collapse comb pair\n    return collapse(this.val);\n  }\n\n  private tokens(): [Token, Token] {\n    let cnt = 0;\n    return this.args().map((a) => {\n      const tok = this.createToken(a, this.idx + cnt);\n      if (tok instanceof PairToken) {\n        cnt += Object.keys(tok.ExtractSchema()).length;\n      } else {\n        cnt++;\n      }\n      return tok;\n    }) as [Token, Token];\n  }\n\n  public Encode(args: any[]): any {\n    return {\n      prim: 'Pair',\n      args: this.tokens().map((t) => t.Encode(args)),\n    };\n  }\n\n  public ExtractSignature(): any {\n    const args = this.args();\n    const leftToken = this.createToken(args[0], this.idx);\n    let keyCount = 1;\n    if (leftToken instanceof OrToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n\n    const rightToken = this.createToken(args[1], this.idx + keyCount);\n\n    const newSig = [];\n\n    for (const leftSig of leftToken.ExtractSignature()) {\n      for (const rightSig of rightToken.ExtractSignature()) {\n        newSig.push([...leftSig, ...rightSig]);\n      }\n    }\n\n    return newSig;\n  }\n\n  public ToBigMapKey(val: any) {\n    return {\n      key: this.EncodeObject(val),\n      type: this.typeWithoutAnnotations(),\n    };\n  }\n\n  public ToKey(val: any) {\n    return this.Execute(val);\n  }\n\n  public EncodeObject(args: any): any {\n    const [leftToken, rightToken] = this.tokens();\n\n    let leftValue;\n    if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {\n      leftValue = args;\n    } else {\n      leftValue = args[leftToken.annot()];\n    }\n\n    let rightValue;\n    if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {\n      rightValue = args;\n    } else {\n      rightValue = args[rightToken.annot()];\n    }\n\n    return {\n      prim: 'Pair',\n      args: [leftToken.EncodeObject(leftValue), rightToken.EncodeObject(rightValue)],\n    };\n  }\n\n  private traversal(getLeftValue: (token: Token) => any, getRightValue: (token: Token) => any) {\n    const args = this.args();\n\n    const leftToken = this.createToken(args[0], this.idx);\n    let keyCount = 1;\n    let leftValue;\n    if (leftToken instanceof PairToken) {\n      keyCount = Object.keys(leftToken.ExtractSchema()).length;\n    }\n    if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {\n      leftValue = getLeftValue(leftToken);\n    } else {\n      leftValue = { [leftToken.annot()]: getLeftValue(leftToken) };\n    }\n\n    const rightToken = this.createToken(args[1], this.idx + keyCount);\n    let rightValue;\n    if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {\n      rightValue = getRightValue(rightToken);\n    } else {\n      rightValue = { [rightToken.annot()]: getRightValue(rightToken) };\n    }\n\n    const res = {\n      ...leftValue,\n      ...rightValue,\n    };\n\n    return res;\n  }\n\n  public Execute(val: any, semantics?: Semantic): { [key: string]: any } {\n    const args = collapse(val, 'Pair');\n    return this.traversal(\n      (leftToken) => leftToken.Execute(args[0], semantics),\n      (rightToken) => rightToken.Execute(args[1], semantics)\n    );\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema(): any {\n    return this.traversal(\n      (leftToken) => leftToken.ExtractSchema(),\n      (rightToken) => rightToken.ExtractSchema()\n    );\n  }\n\n  generateSchema(): PairTokenSchema {\n    return {\n      __michelsonType: PairToken.prim,\n      schema: this.traversal(\n        (leftToken) => {\n          if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {\n            return leftToken.generateSchema().schema;\n          } else {\n            return leftToken.generateSchema();\n          }\n        },\n        (rightToken) => {\n          if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {\n            return rightToken.generateSchema().schema;\n          } else {\n            return rightToken.generateSchema();\n          }\n        }\n      ),\n    };\n  }\n\n  public compare(val1: any, val2: any) {\n    const [leftToken, rightToken] = this.tokens();\n\n    const getValue = (token: Token, args: any) => {\n      if (token instanceof PairToken && !token.hasAnnotations()) {\n        return args;\n      } else {\n        return args[token.annot()];\n      }\n    };\n\n    if (leftToken instanceof ComparableToken && rightToken instanceof ComparableToken) {\n      const result: number = leftToken.compare(\n        getValue(leftToken, val1),\n        getValue(leftToken, val2)\n      );\n\n      if (result === 0) {\n        return rightToken.compare(getValue(rightToken, val1), getValue(rightToken, val2));\n      }\n\n      return result;\n    }\n\n    throw new TokenComparisonError(val1, val2);\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (PairToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    this.tokens().map((t) => t.findAndReturnTokens(tokenToFind, tokens));\n    return tokens;\n  }\n}\n","import { Token, TokenFactory, ComparableToken, TokenValidationError } from '../token';\nimport BigNumber from 'bignumber.js';\nimport { BaseTokenSchema } from '../../schema/types';\n\nexport class NatValidationError extends TokenValidationError {\n  name = 'NatValidationError';\n  constructor(public value: any, public token: NatToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class NatToken extends ComparableToken {\n  static prim: 'nat' = 'nat';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: any): { [key: string]: any } {\n    return new BigNumber(val[Object.keys(val)[0]]);\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { int: new BigNumber(val).toFixed() };\n  }\n\n  private isValid(val: any): NatValidationError | null {\n    const bigNumber = new BigNumber(val);\n    if (bigNumber.isNaN()) {\n      return new NatValidationError(val, this, `Value is not a number: ${val}`);\n    } else if (bigNumber.isNegative()) {\n      return new NatValidationError(val, this, `Value cannot be negative: ${val}`);\n    } else {\n      return null;\n    }\n  }\n\n  public EncodeObject(val: any): any {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { int: new BigNumber(val).toFixed() };\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return NatToken.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: NatToken.prim,\n      schema: NatToken.prim,\n    };\n  }\n\n  public ToBigMapKey(val: string | number) {\n    return {\n      key: { int: String(val) },\n      type: { prim: NatToken.prim },\n    };\n  }\n\n  public ToKey({ int }: any) {\n    return new BigNumber(int);\n  }\n\n  compare(nat1: string | number, nat2: string | number) {\n    const o1 = Number(nat1);\n    const o2 = Number(nat2);\n    if (o1 === o2) {\n      return 0;\n    }\n\n    return o1 < o2 ? -1 : 1;\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (NatToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { BaseTokenSchema } from '../../schema/types';\nimport { Token, TokenFactory, ComparableToken } from '../token';\n\nexport class StringToken extends ComparableToken {\n  static prim: 'string' = 'string';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: any): string {\n    return val[Object.keys(val)[0]];\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return StringToken.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: StringToken.prim,\n      schema: StringToken.prim,\n    };\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n    return { string: val };\n  }\n\n  public EncodeObject(val: any): any {\n    return { string: val };\n  }\n\n  public ToKey({ string }: any) {\n    return string;\n  }\n\n  public ToBigMapKey(val: string) {\n    return {\n      key: { string: val },\n      type: { prim: StringToken.prim },\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (StringToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { Token, TokenFactory, ComparableToken, TokenValidationError } from '../token';\nimport { b58decode, encodePubKey, validateAddress, ValidationResult } from '@taquito/utils';\nimport { BaseTokenSchema } from '../../schema/types';\n\nexport class AddressValidationError extends TokenValidationError {\n  name = 'AddressValidationError';\n  constructor(public value: any, public token: AddressToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class AddressToken extends ComparableToken {\n  static prim: 'address' = 'address';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public ToBigMapKey(val: any) {\n    const decoded = b58decode(val);\n    return {\n      key: { bytes: decoded },\n      type: { prim: 'bytes' },\n    };\n  }\n\n  private isValid(value: any): AddressValidationError | null {\n    if (validateAddress(value) !== ValidationResult.VALID) {\n      return new AddressValidationError(value, this, `Address is not valid: ${value}`);\n    }\n\n    return null;\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  public EncodeObject(val: any): any {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  public Execute(val: { bytes: string; string: string }): string {\n    if (val.string) {\n      return val.string;\n    }\n\n    return encodePubKey(val.bytes);\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return AddressToken.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: AddressToken.prim,\n      schema: AddressToken.prim,\n    };\n  }\n\n  public ToKey({ bytes, string }: any) {\n    if (string) {\n      return string;\n    }\n\n    return encodePubKey(bytes);\n  }\n\n  compare(address1: string, address2: string) {\n    const isImplicit = (address: string) => {\n      return address.startsWith('tz');\n    };\n\n    if (isImplicit(address1) && isImplicit(address2)) {\n      return super.compare(address1, address2);\n    } else if (isImplicit(address1)) {\n      return -1;\n    } else if (isImplicit(address2)) {\n      return 1;\n    } else {\n      return super.compare(address1, address2);\n    }\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (AddressToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { MichelsonMap } from '../michelson-map';\nimport { MapTokenSchema } from '../schema/types';\nimport { ComparableToken, Semantic, Token, TokenFactory, TokenValidationError } from './token';\n\nexport class MapValidationError extends TokenValidationError {\n  name = 'MapValidationError';\n  constructor(public value: any, public token: MapToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class MapToken extends Token {\n  static prim: 'map' = 'map';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  get ValueSchema() {\n    return this.createToken(this.val.args[1], 0);\n  }\n\n  get KeySchema(): ComparableToken {\n    return this.createToken(this.val.args[0], 0) as any;\n  }\n\n  private isValid(value: any): MapValidationError | null {\n    if (MichelsonMap.isMichelsonMap(value)) {\n      return null;\n    }\n\n    return new MapValidationError(value, this, 'Value must be a MichelsonMap');\n  }\n\n  public Execute(val: any[], semantics?: Semantic): { [key: string]: any } {\n    const map = new MichelsonMap(this.val);\n\n    val.forEach((current) => {\n      map.set(\n        this.KeySchema.ToKey(current.args[0]),\n        this.ValueSchema.Execute(current.args[1], semantics)\n      );\n    });\n    return map;\n  }\n\n  public Encode(args: any[]): any {\n    const val: MichelsonMap<any, any> = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return Array.from(val.keys())\n      .sort((a: any, b: any) => this.KeySchema.compare(a, b))\n      .map((key) => {\n        return {\n          prim: 'Elt',\n          args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))],\n        };\n      });\n  }\n\n  public EncodeObject(args: any): any {\n    const val: MichelsonMap<any, any> = args;\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return Array.from(val.keys())\n      .sort((a: any, b: any) => this.KeySchema.compare(a, b))\n      .map((key) => {\n        return {\n          prim: 'Elt',\n          args: [this.KeySchema.EncodeObject(key), this.ValueSchema.EncodeObject(val.get(key))],\n        };\n      });\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return {\n      map: {\n        key: this.KeySchema.ExtractSchema(),\n        value: this.ValueSchema.ExtractSchema(),\n      },\n    };\n  }\n\n  generateSchema(): MapTokenSchema {\n    return {\n      __michelsonType: MapToken.prim,\n      schema: {\n        key: this.KeySchema.generateSchema(),\n        value: this.ValueSchema.generateSchema(),\n      },\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (MapToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    this.KeySchema.findAndReturnTokens(tokenToFind, tokens);\n    this.ValueSchema.findAndReturnTokens(tokenToFind, tokens);\n    return tokens;\n  }\n}\n","import { BaseTokenSchema } from '../../schema/types';\nimport { Token, TokenFactory, ComparableToken } from '../token';\n\nexport class BoolToken extends ComparableToken {\n  static prim: 'bool' = 'bool';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: any): boolean {\n    return String(val.prim).toLowerCase() === 'true' ? true : false;\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n    return { prim: val ? 'True' : 'False' };\n  }\n\n  public EncodeObject(val: any) {\n    return { prim: val ? 'True' : 'False' };\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return BoolToken.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: BoolToken.prim,\n      schema: BoolToken.prim,\n    };\n  }\n\n  ToBigMapKey(val: string): { key: { [key: string]: string }; type: { prim: string } } {\n    return {\n      key: this.EncodeObject(val),\n      type: { prim: BoolToken.prim },\n    };\n  }\n\n  ToKey(val: string) {\n    return this.EncodeObject(val);\n  }\n\n  compare(val1: any, val2: any) {\n    if ((val1 && val2) || (!val1 && !val2)) {\n      return 0;\n    } else if (val1) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (BoolToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { encodePubKey, validateAddress, ValidationResult } from '@taquito/utils';\nimport { ContractTokenSchema } from '../schema/types';\nimport { Token, TokenFactory, TokenValidationError } from './token';\n\nexport class ContractValidationError extends TokenValidationError {\n  name = 'ContractValidationError';\n  constructor(public value: any, public token: ContractToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class ContractToken extends Token {\n  static prim: 'contract' = 'contract';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  private isValid(value: any): ContractValidationError | null {\n    // tz1,tz2 and tz3 seems to be valid contract values (for Unit contract)\n    if (validateAddress(value) !== ValidationResult.VALID) {\n      return new ContractValidationError(value, this, 'Contract address is not valid');\n    }\n\n    return null;\n  }\n\n  public Execute(val: { bytes: string; string: string }) {\n    if (val.string) {\n      return val.string;\n    }\n\n    return encodePubKey(val.bytes);\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n    return { string: val };\n  }\n\n  public EncodeObject(val: any): any {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n    return { string: val };\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return ContractToken.prim;\n  }\n\n  generateSchema(): ContractTokenSchema {\n    const valueSchema = this.createToken(this.val.args[0], 0);\n    return {\n      __michelsonType: ContractToken.prim,\n      schema: {\n        parameter: valueSchema.generateSchema(),\n      },\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (ContractToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { ListTokenSchema } from '../schema/types';\nimport { Token, TokenFactory, Semantic, TokenValidationError } from './token';\n\nexport class ListValidationError extends TokenValidationError {\n  name = 'ListValidationError';\n  constructor(public value: any, public token: ListToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class ListToken extends Token {\n  static prim: 'list' = 'list';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  get valueSchema() {\n    return this.createToken(this.val.args[0], this.idx);\n  }\n\n  private isValid(value: any): ListValidationError | null {\n    if (Array.isArray(value)) {\n      return null;\n    }\n\n    return new ListValidationError(value, this, 'Value must be an array');\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    const schema = this.createToken(this.val.args[0], 0);\n    return val.reduce((prev: any, current: any) => {\n      return [...prev, schema.EncodeObject(current)];\n    }, []);\n  }\n\n  public Execute(val: any, semantics?: Semantic) {\n    const schema = this.createToken(this.val.args[0], 0);\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return val.reduce((prev: any, current: any) => {\n      return [...prev, schema.Execute(current, semantics)];\n    }, []);\n  }\n\n  public EncodeObject(args: any): any {\n    const schema = this.createToken(this.val.args[0], 0);\n\n    const err = this.isValid(args);\n    if (err) {\n      throw err;\n    }\n\n    return args.reduce((prev: any, current: any) => {\n      return [...prev, schema.EncodeObject(current)];\n    }, []);\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return {\n      [ListToken.prim]: this.valueSchema.ExtractSchema(),\n    };\n  }\n\n  generateSchema(): ListTokenSchema {\n    return {\n      __michelsonType: ListToken.prim,\n      schema: this.valueSchema.generateSchema(),\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (ListToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    this.createToken(this.val.args[0], this.idx).findAndReturnTokens(tokenToFind, tokens);\n    return tokens;\n  }\n}\n","import { Token, TokenFactory, ComparableToken, TokenValidationError } from '../token';\nimport BigNumber from 'bignumber.js';\nimport { BaseTokenSchema } from '../../schema/types';\n\nexport class MutezValidationError extends TokenValidationError {\n  name = 'MutezValidationError';\n  constructor(public value: any, public token: MutezToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class MutezToken extends ComparableToken {\n  static prim: 'mutez' = 'mutez';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: any) {\n    return new BigNumber(val[Object.keys(val)[0]]);\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return MutezToken.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: MutezToken.prim,\n      schema: MutezToken.prim,\n    };\n  }\n\n  private isValid(val: any): MutezValidationError | null {\n    const bigNumber = new BigNumber(val);\n    if (bigNumber.isNaN()) {\n      return new MutezValidationError(val, this, `Value is not a number: ${val}`);\n    } else {\n      return null;\n    }\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { int: String(val).toString() };\n  }\n\n  public EncodeObject(val: any): any {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { int: String(val).toString() };\n  }\n\n  public ToBigMapKey(val: string | number) {\n    return {\n      key: { int: String(val) },\n      type: { prim: MutezToken.prim },\n    };\n  }\n\n  public ToKey({ int }: any) {\n    return int;\n  }\n\n  compare(mutez1: string | number, mutez2: string | number) {\n    const o1 = Number(mutez1);\n    const o2 = Number(mutez2);\n    if (o1 === o2) {\n      return 0;\n    }\n\n    return o1 < o2 ? -1 : 1;\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (MutezToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { BaseTokenSchema } from '../../schema/types';\nimport { TokenFactory, ComparableToken, TokenValidationError, Token } from '../token';\n\nexport class BytesValidationError extends TokenValidationError {\n  name = 'BytesValidationError';\n  constructor(public value: any, public token: BytesToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class BytesToken extends ComparableToken {\n  static prim: 'bytes' = 'bytes';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public ToBigMapKey(val: string) {\n    return {\n      key: { bytes: val },\n      type: { prim: BytesToken.prim },\n    };\n  }\n\n  private isValid(val: any): BytesValidationError | null {\n    if (typeof val === 'string' && /^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n      return null;\n    } else {\n      return new BytesValidationError(val, this, `Invalid bytes: ${val}`);\n    }\n  }\n\n  private convertUint8ArrayToHexString(val: any) {\n    return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;\n  }\n\n  public Encode(args: any[]): any {\n    let val = args.pop();\n\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { bytes: String(val).toString() };\n  }\n\n  public EncodeObject(val: string | Uint8Array) {\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { bytes: String(val).toString() };\n  }\n\n  public Execute(val: any): string {\n    return val.bytes;\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return BytesToken.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: BytesToken.prim,\n      schema: BytesToken.prim,\n    };\n  }\n\n  public ToKey({ bytes, string }: any) {\n    if (string) {\n      return string;\n    }\n\n    return bytes;\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (BytesToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { OptionTokenSchema } from '../schema/types';\nimport { Token, TokenFactory, Semantic, ComparableToken } from './token';\n\nexport class OptionToken extends ComparableToken {\n  static prim: 'option' = 'option';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public subToken(): Token {\n    return this.createToken(this.val.args[0], this.idx);\n  }\n\n  schema(): Token {\n    return this.createToken(this.val.args[0], 0);\n  }\n\n  annot(): string {\n    return Array.isArray(this.val.annots)\n      ? super.annot()\n      : this.createToken(this.val.args[0], this.idx).annot();\n  }\n\n  public Encode(args: any): any {\n    const value = args;\n    if (value === undefined || value === null) {\n      return { prim: 'None' };\n    } else if (\n      Array.isArray(value) &&\n      (value[value.length - 1] === undefined || value[value.length - 1] === null)\n    ) {\n      value.pop();\n      return { prim: 'None' };\n    }\n\n    return { prim: 'Some', args: [this.schema().Encode(args)] };\n  }\n\n  public EncodeObject(args: any): any {\n    const value = args;\n\n    if (value === undefined || value === null) {\n      return { prim: 'None' };\n    }\n\n    return { prim: 'Some', args: [this.schema().EncodeObject(value)] };\n  }\n\n  public Execute(val: any, semantics?: Semantic) {\n    if (val.prim === 'None') {\n      return null;\n    }\n\n    return this.schema().Execute(val.args[0], semantics);\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return this.schema().ExtractSchema();\n  }\n\n  generateSchema(): OptionTokenSchema {\n    return {\n      __michelsonType: OptionToken.prim,\n      schema: this.schema().generateSchema(),\n    };\n  }\n\n  public ExtractSignature() {\n    return [...this.schema().ExtractSignature(), []];\n  }\n\n  get KeySchema(): ComparableToken {\n    return this.schema() as any;\n  }\n\n  compare(val1: any, val2: any) {\n    if (!val1) {\n      return -1;\n    } else if (!val2) {\n      return 1;\n    }\n    return this.KeySchema.compare(val1, val2);\n  }\n\n  public ToKey(val: any) {\n    return this.Execute(val);\n  }\n\n  public ToBigMapKey(val: any) {\n    return {\n      key: this.EncodeObject(val),\n      type: this.typeWithoutAnnotations(),\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (OptionToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    this.subToken().findAndReturnTokens(tokenToFind, tokens);\n    return tokens;\n  }\n}\n","import { BaseTokenSchema } from '../../schema/types';\nimport { Token, TokenFactory, ComparableToken } from '../token';\n\nexport class TimestampToken extends ComparableToken {\n  static prim: 'timestamp' = 'timestamp';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: { string?: string; int?: string }) {\n    if (val.string && /^\\d+$/.test(val.string)) {\n      return new Date(Number(val.string) * 1000).toISOString();\n    } else if (val.string) {\n      return new Date(val.string).toISOString();\n    } else if (val.int) {\n      return new Date(Number(val.int) * 1000).toISOString();\n    }\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n    return { string: val };\n  }\n\n  public EncodeObject(val: any): any {\n    return { string: val };\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return TimestampToken.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: TimestampToken.prim,\n      schema: TimestampToken.prim,\n    };\n  }\n\n  public ToKey({ string }: any) {\n    return string;\n  }\n\n  public ToBigMapKey(val: string) {\n    return {\n      key: { string: val },\n      type: { prim: TimestampToken.prim },\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (TimestampToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { Token, TokenFactory, ComparableToken, TokenValidationError } from '../token';\nimport BigNumber from 'bignumber.js';\nimport { BaseTokenSchema } from '../../schema/types';\n\nexport class IntValidationError extends TokenValidationError {\n  name = 'IntValidationError';\n  constructor(public value: any, public token: IntToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class IntToken extends ComparableToken {\n  static prim: 'int' = 'int';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: { [key: string]: string }): { [key: string]: any } {\n    return new BigNumber(val[Object.keys(val)[0]]);\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return IntToken.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: IntToken.prim,\n      schema: IntToken.prim,\n    };\n  }\n\n  private isValid(val: any): IntValidationError | null {\n    const bigNumber = new BigNumber(val);\n    if (bigNumber.isNaN()) {\n      return new IntValidationError(val, this, `Value is not a number: ${val}`);\n    } else {\n      return null;\n    }\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { int: new BigNumber(val).toFixed() };\n  }\n\n  public EncodeObject(val: any): any {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { int: new BigNumber(val).toFixed() };\n  }\n\n  public ToBigMapKey(val: string | number) {\n    return {\n      key: { int: String(val) },\n      type: { prim: IntToken.prim },\n    };\n  }\n\n  public ToKey({ int }: any) {\n    return int;\n  }\n\n  compare(int1: string | number, int2: string | number) {\n    const o1 = Number(int1);\n    const o2 = Number(int2);\n    if (o1 === o2) {\n      return 0;\n    }\n\n    return o1 < o2 ? -1 : 1;\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (IntToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { ComparableToken, Token, TokenFactory } from './token';\nimport { BaseTokenSchema } from '../schema/types';\nimport { UnitValue } from '../taquito-michelson-encoder';\n\nexport class UnitToken extends ComparableToken {\n  static prim: 'unit' = 'unit';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Encode(args: any[]): any {\n    args.pop();\n    return { prim: 'Unit' };\n  }\n\n  public EncodeObject(_val: any): any {\n    return { prim: 'Unit' };\n  }\n\n  public Execute(_val: { prim: string }) {\n    return UnitValue;\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return UnitToken.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: UnitToken.prim,\n      schema: UnitToken.prim,\n    };\n  }\n\n  compare(_val1: any, _val2: any) {\n    return 0;\n  }\n\n  ToKey(_val: any) {\n    return UnitValue;\n  }\n\n  ToBigMapKey(_val: any) {\n    return {\n      key: { prim: 'Unit' },\n      type: { prim: UnitToken.prim },\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (UnitToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { ComparableToken, Token, TokenFactory, TokenValidationError } from './token';\nimport {\n  encodeKey,\n  validatePublicKey,\n  ValidationResult,\n  Prefix,\n  b58cdecode,\n  prefix,\n} from '@taquito/utils';\nimport { BaseTokenSchema } from '../schema/types';\n\nconst publicKeyPrefixLength = 4;\n\nexport class KeyValidationError extends TokenValidationError {\n  name = 'KeyValidationError';\n  constructor(public value: any, public token: KeyToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class KeyToken extends ComparableToken {\n  static prim: 'key' = 'key';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: { bytes: string; string: string }) {\n    if (val.string) {\n      return val.string;\n    }\n\n    return encodeKey(val.bytes);\n  }\n\n  private isValid(value: any): KeyValidationError | null {\n    if (validatePublicKey(value) !== ValidationResult.VALID) {\n      return new KeyValidationError(value, this, 'Key is not valid');\n    }\n\n    return null;\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  public EncodeObject(val: any): any {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return KeyToken.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: KeyToken.prim,\n      schema: KeyToken.prim,\n    };\n  }\n\n  ToKey(val: any) {\n    return this.Execute(val);\n  }\n\n  ToBigMapKey(val: string) {\n    return {\n      key: { string: val },\n      type: { prim: KeyToken.prim },\n    };\n  }\n\n  compare(key1: string, key2: string): number {\n    const keyPrefix1 = this.getPrefix(key1);\n    const keyPrefix2 = this.getPrefix(key2);\n\n    if (keyPrefix1 === Prefix.EDPK && keyPrefix2 !== Prefix.EDPK) {\n      return -1;\n    } else if (keyPrefix1 === Prefix.SPPK && keyPrefix2 !== Prefix.SPPK) {\n      return keyPrefix2 === Prefix.EDPK ? 1 : -1;\n    } else if (keyPrefix1 === Prefix.P2PK) {\n      if (keyPrefix2 !== Prefix.P2PK) {\n        return 1;\n      }\n\n      const keyBytes1 = this.getP256PublicKeyComparableBytes(key1);\n      const keyBytes2 = this.getP256PublicKeyComparableBytes(key2);\n      return Buffer.compare(keyBytes1, keyBytes2);\n    }\n\n    return super.compare(key1, key2);\n  }\n\n  private getPrefix(val: string) {\n    return val.substring(0, publicKeyPrefixLength);\n  }\n\n  private getP256PublicKeyComparableBytes(p2pk: string) {\n    return b58cdecode(p2pk, prefix[Prefix.P2PK]).slice(1);\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (KeyToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { Token, TokenFactory, ComparableToken, TokenValidationError } from '../token';\nimport { encodeKeyHash, validateKeyHash, ValidationResult } from '@taquito/utils';\nimport { BaseTokenSchema } from '../../schema/types';\n\nexport class KeyHashValidationError extends TokenValidationError {\n  name = 'KeyHashValidationError';\n  constructor(public value: any, public token: KeyHashToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class KeyHashToken extends ComparableToken {\n  static prim: 'key_hash' = 'key_hash';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: { bytes: string; string: string }) {\n    if (val.string) {\n      return val.string;\n    }\n\n    return encodeKeyHash(val.bytes);\n  }\n\n  private isValid(value: any): KeyHashValidationError | null {\n    if (validateKeyHash(value) !== ValidationResult.VALID) {\n      return new KeyHashValidationError(value, this, `KeyHash is not valid: ${value}`);\n    }\n\n    return null;\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  public EncodeObject(val: any): any {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return KeyHashToken.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: KeyHashToken.prim,\n      schema: KeyHashToken.prim,\n    };\n  }\n\n  public ToKey({ string, bytes }: any) {\n    if (string) {\n      return string;\n    }\n\n    return encodeKeyHash(bytes);\n  }\n\n  public ToBigMapKey(val: string) {\n    return {\n      key: { string: val },\n      type: { prim: KeyHashToken.prim },\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (KeyHashToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { ComparableToken, Token, TokenFactory, TokenValidationError } from './token';\nimport { validateSignature, ValidationResult } from '@taquito/utils';\nimport { BaseTokenSchema } from '../schema/types';\n\nexport class SignatureValidationError extends TokenValidationError {\n  name = 'SignatureValidationError';\n  constructor(public value: any, public token: SignatureToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class SignatureToken extends ComparableToken {\n  static prim: 'signature' = 'signature';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: any): { [key: string]: any } {\n    return val.string;\n  }\n\n  private isValid(value: any): SignatureValidationError | null {\n    if (validateSignature(value) !== ValidationResult.VALID) {\n      return new SignatureValidationError(value, this, 'Signature is not valid');\n    }\n\n    return null;\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  public EncodeObject(val: any): any {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return SignatureToken.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: SignatureToken.prim,\n      schema: SignatureToken.prim,\n    };\n  }\n\n  ToKey(val: any) {\n    return this.Execute(val);\n  }\n\n  ToBigMapKey(val: string) {\n    return {\n      key: { string: val },\n      type: { prim: SignatureToken.prim },\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (SignatureToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { LambdaTokenSchema } from '../schema/types';\nimport { Token, TokenFactory } from './token';\n\nexport class LambdaToken extends Token {\n  static prim: 'lambda' = 'lambda';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  get paramSchema() {\n    return this.createToken(this.val.args[0], this.idx);\n  }\n\n  get returnSchema() {\n    return this.createToken(this.val.args[1], this.idx + 1);\n  }\n\n  public Execute(val: any) {\n    if (val.string) {\n      return val.string;\n    } else {\n      return val;\n    }\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n    return val;\n  }\n\n  public EncodeObject(val: any): any {\n    return val;\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return {\n      [LambdaToken.prim]: {\n        parameters: this.paramSchema.ExtractSchema(),\n        returns: this.returnSchema.ExtractSchema(),\n      },\n    };\n  }\n\n  generateSchema(): LambdaTokenSchema {\n    return {\n      __michelsonType: LambdaToken.prim,\n      schema: {\n        parameters: this.paramSchema.generateSchema(),\n        returns: this.returnSchema.generateSchema(),\n      },\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (LambdaToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    this.createToken(this.val.args[0], this.idx).findAndReturnTokens(tokenToFind, tokens);\n    this.createToken(this.val.args[1], this.idx).findAndReturnTokens(tokenToFind, tokens);\n    return tokens;\n  }\n}\n","import { BaseTokenSchema } from '../schema/types';\nimport { Token, TokenFactory } from './token';\n\nexport class OperationToken extends Token {\n  static prim: 'operation' = 'operation';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: any): { [key: string]: any } {\n    return val.string;\n  }\n\n  public Encode(...args: any[]): any {\n    const val = args.pop();\n    return { string: val };\n  }\n\n  public EncodeObject(val: any): any {\n    return { string: val };\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return OperationToken.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: OperationToken.prim,\n      schema: OperationToken.prim,\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (OperationToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { SetTokenSchema } from '../schema/types';\nimport { Token, TokenFactory, Semantic, TokenValidationError, ComparableToken } from './token';\n\nexport class SetValidationError extends TokenValidationError {\n  name = 'SetValidationError';\n  constructor(public value: any, public token: SetToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class SetToken extends Token {\n  static prim: 'set' = 'set';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  get KeySchema(): ComparableToken {\n    return this.createToken(this.val.args[0], 0) as any;\n  }\n\n  private isValid(value: any): SetValidationError | null {\n    if (Array.isArray(value)) {\n      return null;\n    }\n\n    return new SetValidationError(value, this, 'Value must be an array');\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return val\n      .sort((a: any, b: any) => this.KeySchema.compare(a, b))\n      .reduce((prev: any, current: any) => {\n        return [...prev, this.KeySchema.EncodeObject(current)];\n      }, []);\n  }\n\n  public Execute(val: any, semantics?: Semantic) {\n    return val.reduce((prev: any, current: any) => {\n      return [...prev, this.KeySchema.Execute(current, semantics)];\n    }, []);\n  }\n\n  public EncodeObject(args: any): any {\n    const err = this.isValid(args);\n    if (err) {\n      throw err;\n    }\n\n    return args\n      .sort((a: any, b: any) => this.KeySchema.compare(a, b))\n      .reduce((prev: any, current: any) => {\n        return [...prev, this.KeySchema.EncodeObject(current)];\n      }, []);\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return SetToken.prim;\n  }\n\n  generateSchema(): SetTokenSchema {\n    return {\n      __michelsonType: SetToken.prim,\n      schema: this.KeySchema.generateSchema(),\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (SetToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    this.KeySchema.findAndReturnTokens(tokenToFind, tokens);\n    return tokens;\n  }\n}\n","import { Token, TokenFactory, ComparableToken, TokenValidationError } from './token';\nimport { validateChain, ValidationResult } from '@taquito/utils';\nimport { BaseTokenSchema } from '../schema/types';\n\nexport class ChainIDValidationError extends TokenValidationError {\n  name = 'ChainIDValidationError';\n  constructor(public value: any, public token: ChainIDToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class ChainIDToken extends ComparableToken {\n  static prim: 'chain_id' = 'chain_id';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  private isValid(value: any): ChainIDValidationError | null {\n    if (validateChain(value) !== ValidationResult.VALID) {\n      return new ChainIDValidationError(value, this, 'ChainID is not valid');\n    }\n\n    return null;\n  }\n\n  public Execute(val: any): string {\n    return val[Object.keys(val)[0]];\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return ChainIDToken.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: ChainIDToken.prim,\n      schema: ChainIDToken.prim,\n    };\n  }\n\n  public Encode(args: any[]): any {\n    const val = args.pop();\n\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  public EncodeObject(val: any): any {\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n\n    return { string: val };\n  }\n\n  public ToKey({ string }: any) {\n    return string;\n  }\n\n  public ToBigMapKey(val: string) {\n    return {\n      key: { string: val },\n      type: { prim: ChainIDToken.prim },\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (ChainIDToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { TicketTokenSchema } from '../schema/types';\nimport { IntToken } from './comparable/int';\nimport { ContractToken } from './contract';\nimport { Token, TokenFactory, Semantic } from './token';\n\n/**\n *  @category Error\n *  @description Error that indicates a failure when encoding and sending a ticket to the blockchain\n */\nexport class EncodeTicketError extends Error {\n  name = 'TicketEncodeError';\n\n  constructor() {\n    super('Tickets cannot be sent to the blockchain; they are created on-chain');\n  }\n}\n\nconst ticketerType = { prim: 'contract' };\nconst amountType = { prim: 'int' };\n\nexport class TicketToken extends Token {\n  static prim: 'ticket' = 'ticket';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  get valueToken() {\n    return this.createToken(this.val.args[0], this.idx);\n  }\n\n  public Encode(_args: any[]): any {\n    throw new EncodeTicketError();\n  }\n\n  public EncodeObject(_args: any): any {\n    throw new EncodeTicketError();\n  }\n\n  public Execute(val: any, semantics?: Semantic) {\n    if (semantics && semantics[TicketToken.prim]) {\n      return semantics[TicketToken.prim](val, this.val);\n    }\n    const ticketer = this.createToken(ticketerType, this.idx);\n    const value = this.valueToken;\n    const amount = this.createToken(amountType, this.idx);\n\n    if (undefined === val.args[2] && undefined !== val.args[1].args) {\n      return {\n        ticketer: ticketer.Execute(val.args[0], semantics),\n        value: value.Execute(val.args[1].args[0], semantics),\n        amount: amount.Execute(val.args[1].args[1], semantics),\n      };\n    }\n\n    return {\n      ticketer: ticketer.Execute(val.args[0], semantics),\n      value: value.Execute(val.args[1], semantics),\n      amount: amount.Execute(val.args[2], semantics),\n    };\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return {\n      ticketer: ContractToken.prim,\n      value: this.valueToken.ExtractSchema(),\n      amount: IntToken.prim,\n    };\n  }\n\n  generateSchema(): TicketTokenSchema {\n    return {\n      __michelsonType: TicketToken.prim,\n      schema: {\n        value: this.valueToken.generateSchema(),\n        ticketer: {\n          __michelsonType: ContractToken.prim,\n          schema: ContractToken.prim,\n        },\n        amount: {\n          __michelsonType: IntToken.prim,\n          schema: IntToken.prim,\n        },\n      },\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (TicketToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    this.valueToken.findAndReturnTokens(tokenToFind, tokens);\n    return tokens;\n  }\n}\n","import { BaseTokenSchema } from '../schema/types';\nimport { Token, TokenFactory, TokenValidationError } from './token';\n\nexport class NeverTokenError extends TokenValidationError {\n  name = 'NeverTokenError';\n  constructor(public value: any, public token: NeverToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class NeverToken extends Token {\n  static prim: 'never' = 'never';\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n  public Encode(args: any[]): any {\n    const val = args.pop();\n    throw new NeverTokenError(val, this, 'Assigning a value to the type never is forbidden.');\n  }\n  public EncodeObject(val: any): any {\n    throw new NeverTokenError(val, this, 'Assigning a value to the type never is forbidden.');\n  }\n  public Execute(val: any) {\n    throw new NeverTokenError(val, this, 'There is no literal value for the type never.');\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return NeverToken.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: NeverToken.prim,\n      schema: NeverToken.prim,\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (NeverToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { SaplingStateTokenSchema } from '../schema/types';\nimport { Semantic, Token, TokenFactory, TokenValidationError } from './token';\n\nexport class SaplingStateValidationError extends TokenValidationError {\n  name = 'SaplingStateValidationError';\n  constructor(public value: any, public token: SaplingStateToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class SaplingStateToken extends Token {\n  static prim: 'sapling_state' = 'sapling_state';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  private isValid(val: any) {\n    return typeof val === 'object' && Object.keys(val).length === 0;\n  }\n\n  Execute(val: { int: string }, semantic?: Semantic) {\n    if (semantic && semantic[SaplingStateToken.prim]) {\n      return semantic[SaplingStateToken.prim](val, this.val);\n    }\n    if ('int' in val) {\n      return val.int;\n    } else {\n      throw new SaplingStateValidationError(\n        val,\n        this,\n        `Sapling state is expecting an object with an int property. Got ${JSON.stringify(val)}`\n      );\n    }\n  }\n\n  Encode(args: any[]): any {\n    const val = args.pop();\n    if (this.isValid(val)) {\n      return [];\n    } else {\n      throw new SaplingStateValidationError(\n        val,\n        this,\n        `Invalid sapling_state. Received: ${val} while expecting: {}`\n      );\n    }\n  }\n\n  EncodeObject(val: any): any {\n    if (this.isValid(val)) {\n      return [];\n    } else {\n      throw new SaplingStateValidationError(\n        val,\n        this,\n        `Invalid sapling_state. Received: ${val} while expecting: {}`\n      );\n    }\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  ExtractSchema() {\n    return {\n      [SaplingStateToken.prim]: {\n        'memo-size': Number(this.val.args[0]['int']),\n      },\n    };\n  }\n\n  generateSchema(): SaplingStateTokenSchema {\n    return {\n      __michelsonType: SaplingStateToken.prim,\n      schema: {\n        memoSize: this.val.args[0]['int'],\n      },\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (SaplingStateToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { SaplingTransactionTokenSchema } from '../schema/types';\nimport { Token, TokenFactory, TokenValidationError } from './token';\n\nexport class SaplingTransactionValidationError extends TokenValidationError {\n  name = 'SaplingTransactionValidationError';\n  constructor(public value: any, public token: SaplingTransactionToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class SaplingTransactionToken extends Token {\n  static prim: 'sapling_transaction' = 'sapling_transaction';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  Execute(_val: any) {\n    throw new SaplingTransactionValidationError(\n      _val,\n      this,\n      'There is no literal value for the sapling_transaction type.'\n    );\n  }\n\n  private validateBytes(val: any) {\n    const bytes = /^(0x|0X)?([0-9a-fA-F]*$)/.exec(val);\n    if (bytes && bytes[2].length % 2 === 0) {\n      return bytes[2];\n    } else {\n      throw new SaplingTransactionValidationError(val, this, `Invalid bytes: ${val}`);\n    }\n  }\n\n  private convertUint8ArrayToHexString(val: Uint8Array | string) {\n    return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;\n  }\n\n  Encode(args: any[]): any {\n    let val = args.pop();\n    val = this.validateBytes(this.convertUint8ArrayToHexString(val));\n    return { bytes: String(val).toString() };\n  }\n\n  EncodeObject(val: string | Uint8Array) {\n    val = this.validateBytes(this.convertUint8ArrayToHexString(val));\n    return { bytes: String(val).toString() };\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  ExtractSchema() {\n    return {\n      [SaplingTransactionToken.prim]: {\n        'memo-size': Number(this.val.args[0]['int']),\n      },\n    };\n  }\n\n  generateSchema(): SaplingTransactionTokenSchema {\n    return {\n      __michelsonType: SaplingTransactionToken.prim,\n      schema: {\n        memoSize: this.val.args[0]['int'],\n      },\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (SaplingTransactionToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { BaseTokenSchema } from '../schema/types';\nimport { Token, TokenFactory, TokenValidationError } from './token';\n\nexport class Bls12381frValidationError extends TokenValidationError {\n  name = 'Bls12381frValidationError';\n  constructor(public value: any, public token: Bls12381frToken, message: string) {\n    super(value, token, message);\n  }\n}\nexport class Bls12381frToken extends Token {\n  // An element of the BLS12-381 scalar field Fr\n  // see https://tezos.gitlab.io/michelson-reference/#type-bls12_381_fr\n  static prim: 'bls12_381_fr' = 'bls12_381_fr';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  private isValid(val: any): Bls12381frValidationError | null {\n    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n      return null;\n    } else {\n      return new Bls12381frValidationError(val, this, `Invalid bytes: ${val}`);\n    }\n  }\n\n  private convertUint8ArrayToHexString(val: any) {\n    return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;\n  }\n\n  Encode(args: any[]) {\n    let val = args.pop();\n    if (typeof val === 'number') {\n      return { int: val.toString() };\n    } else {\n      val = this.convertUint8ArrayToHexString(val);\n      const err = this.isValid(val);\n      if (err) {\n        throw err;\n      }\n      return { bytes: val };\n    }\n  }\n\n  EncodeObject(val: string | Uint8Array | number) {\n    if (typeof val === 'number') {\n      return { int: val.toString() };\n    } else {\n      val = this.convertUint8ArrayToHexString(val);\n      const err = this.isValid(val);\n      if (err) {\n        throw err;\n      }\n      return { bytes: val };\n    }\n  }\n\n  Execute(val: any): string {\n    return val.bytes;\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return Bls12381frToken.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: Bls12381frToken.prim,\n      schema: Bls12381frToken.prim,\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (Bls12381frToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { BaseTokenSchema } from '../schema/types';\nimport { Token, TokenFactory, TokenValidationError } from './token';\n\nexport class Bls12381g1ValidationError extends TokenValidationError {\n  name = 'Bls12381g1ValidationError';\n  constructor(public value: any, public token: Bls12381g1Token, message: string) {\n    super(value, token, message);\n  }\n}\nexport class Bls12381g1Token extends Token {\n  // A point on the BLS12-381 curve G1\n  // See https://tezos.gitlab.io/michelson-reference/#type-bls12_381_g1\n  static prim: 'bls12_381_g1' = 'bls12_381_g1';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  private isValid(val: any): Bls12381g1ValidationError | null {\n    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n      return null;\n    } else {\n      return new Bls12381g1ValidationError(val, this, `Invalid bytes: ${val}`);\n    }\n  }\n\n  private convertUint8ArrayToHexString(val: any) {\n    return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;\n  }\n\n  Encode(args: any[]) {\n    let val = args.pop();\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n    return { bytes: val };\n  }\n\n  EncodeObject(val: string | Uint8Array) {\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n    return { bytes: val };\n  }\n\n  Execute(val: any): string {\n    return val.bytes;\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return Bls12381g1Token.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: Bls12381g1Token.prim,\n      schema: Bls12381g1Token.prim,\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (Bls12381g1Token.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { BaseTokenSchema } from '../schema/types';\nimport { Token, TokenFactory, TokenValidationError } from './token';\n\nexport class Bls12381g2ValidationError extends TokenValidationError {\n  name = 'Bls12381g2ValidationError';\n  constructor(public value: any, public token: Bls12381g2Token, message: string) {\n    super(value, token, message);\n  }\n}\nexport class Bls12381g2Token extends Token {\n  // A point on the BLS12-381 curve G2\n  // See https://tezos.gitlab.io/michelson-reference/#type-bls12_381_g2\n  static prim: 'bls12_381_g2' = 'bls12_381_g2';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  private isValid(val: any): Bls12381g2ValidationError | null {\n    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n      return null;\n    } else {\n      return new Bls12381g2ValidationError(val, this, `Invalid bytes: ${val}`);\n    }\n  }\n\n  private convertUint8ArrayToHexString(val: any) {\n    return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;\n  }\n\n  Encode(args: any[]) {\n    let val = args.pop();\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n    return { bytes: val };\n  }\n\n  EncodeObject(val: string | Uint8Array) {\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n    return { bytes: val };\n  }\n\n  Execute(val: any): string {\n    return val.bytes;\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return Bls12381g2Token.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: Bls12381g2Token.prim,\n      schema: Bls12381g2Token.prim,\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (Bls12381g2Token.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { BaseTokenSchema } from '../schema/types';\nimport { Token, TokenFactory, TokenValidationError } from './token';\n\nexport class ChestValidationError extends TokenValidationError {\n  name = 'ChestValidationError';\n  constructor(public value: any, public token: ChestToken, message: string) {\n    super(value, token, message);\n  }\n}\nexport class ChestToken extends Token {\n  static prim: 'chest' = 'chest';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  private isValid(val: any): ChestValidationError | null {\n    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n      return null;\n    } else {\n      return new ChestValidationError(val, this, `Invalid bytes: ${val}`);\n    }\n  }\n\n  private convertUint8ArrayToHexString(val: any) {\n    return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;\n  }\n\n  Encode(args: any[]) {\n    let val = args.pop();\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n    return { bytes: val };\n  }\n\n  EncodeObject(val: string | Uint8Array) {\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n    return { bytes: val };\n  }\n\n  Execute(val: any): string {\n    return val.bytes;\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return ChestToken.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: ChestToken.prim,\n      schema: ChestToken.prim,\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (ChestToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { BaseTokenSchema } from '../schema/types';\nimport { Token, TokenFactory, TokenValidationError } from './token';\n\nexport class ChestKeyValidationError extends TokenValidationError {\n  name = 'ChestKeyValidationError';\n  constructor(public value: any, public token: ChestKeyToken, message: string) {\n    super(value, token, message);\n  }\n}\nexport class ChestKeyToken extends Token {\n  static prim: 'chest_key' = 'chest_key';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  private isValid(val: any): ChestKeyValidationError | null {\n    if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n      return null;\n    } else {\n      return new ChestKeyValidationError(val, this, `Invalid bytes: ${val}`);\n    }\n  }\n\n  private convertUint8ArrayToHexString(val: any) {\n    return val.constructor === Uint8Array ? Buffer.from(val).toString('hex') : val;\n  }\n\n  Encode(args: any[]) {\n    let val = args.pop();\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n    return { bytes: val };\n  }\n\n  EncodeObject(val: string | Uint8Array) {\n    val = this.convertUint8ArrayToHexString(val);\n    const err = this.isValid(val);\n    if (err) {\n      throw err;\n    }\n    return { bytes: val };\n  }\n\n  Execute(val: any): string {\n    return val.bytes;\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return ChestKeyToken.prim;\n  }\n\n  generateSchema(): BaseTokenSchema {\n    return {\n      __michelsonType: ChestKeyToken.prim,\n      schema: ChestKeyToken.prim,\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (ChestKeyToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { ConstantTokenSchema } from '../schema/types';\nimport { Semantic, Token, TokenFactory, TokenValidationError } from './token';\n\nexport class GlobalConstantEncodingError extends TokenValidationError {\n  name = 'GlobalConstantEncodingError';\n  constructor(public value: any, public token: GlobalConstantToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class GlobalConstantDecodingError extends TokenValidationError {\n  name = 'GlobalConstantDecodingError';\n  constructor(public value: any, public token: GlobalConstantToken, message: string) {\n    super(value, token, message);\n  }\n}\n\nexport class GlobalConstantToken extends Token {\n  static prim: 'constant' = 'constant';\n\n  constructor(\n    protected val: { prim: string; args: any[]; annots?: any[] },\n    protected idx: number,\n    protected fac: TokenFactory\n  ) {\n    super(val, idx, fac);\n  }\n\n  public Execute(val: any, semantic?: Semantic) {\n    if (semantic && semantic[GlobalConstantToken.prim]) {\n      return semantic[GlobalConstantToken.prim](val as any, this.val);\n    } else {\n      throw new GlobalConstantDecodingError(\n        val,\n        this,\n        `Unable to decode a value represented by a global constants. Please provide an expanded script to the Michelson-Encoder or semantics for the decoding. The following global constant hash was encountered: ${this.val.args[0]['string']}.`\n      );\n    }\n  }\n\n  public Encode(args: any[]): any {\n    throw new GlobalConstantEncodingError(\n      args,\n      this,\n      `Unable to encode a script containing global constants. Please provide an expanded script to the Michelson-Encoder. The following global constant hash was encountered: ${this.val.args[0]['string']}.`\n    );\n  }\n\n  public EncodeObject(val: any): any {\n    throw new GlobalConstantEncodingError(\n      val,\n      this,\n      `Unable to encode a script containing global constants. Please provide an expanded script to the Michelson-Encoder. The following global constant hash was encountered: ${this.val.args[0]['string']}.`\n    );\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  public ExtractSchema() {\n    return GlobalConstantToken.prim;\n  }\n\n  generateSchema(): ConstantTokenSchema {\n    return {\n      __michelsonType: GlobalConstantToken.prim,\n      schema: {\n        hash: this.val.args[0]['string'],\n      },\n    };\n  }\n\n  findAndReturnTokens(tokenToFind: string, tokens: Token[]) {\n    if (GlobalConstantToken.prim === tokenToFind) {\n      tokens.push(this);\n    }\n    return tokens;\n  }\n}\n","import { PairToken } from './pair';\n\nimport { NatToken } from './comparable/nat';\n\nimport { StringToken } from './comparable/string';\n\nimport { BigMapToken } from './bigmap';\n\nimport { AddressToken } from './comparable/address';\n\nimport { MapToken } from './map';\n\nimport { BoolToken } from './comparable/bool';\n\nimport { OrToken } from './or';\n\nimport { ContractToken } from './contract';\n\nimport { ListToken } from './list';\nimport { MutezToken } from './comparable/mutez';\nimport { BytesToken } from './comparable/bytes';\nimport { OptionToken } from './option';\nimport { TimestampToken } from './comparable/timestamp';\nimport { IntToken } from './comparable/int';\nimport { UnitToken } from './unit';\nimport { KeyToken } from './key';\nimport { KeyHashToken } from './comparable/key_hash';\nimport { SignatureToken } from './signature';\nimport { LambdaToken } from './lambda';\nimport { OperationToken } from './operation';\nimport { SetToken } from './set';\nimport { ChainIDToken } from './chain-id';\nimport { TicketToken } from './ticket';\nimport { NeverToken } from './never';\nimport { SaplingStateToken } from './sapling-state';\nimport { SaplingTransactionToken } from './sapling-transaction';\nimport { Bls12381frToken } from './bls12-381-fr';\nimport { Bls12381g1Token } from './bls12-381-g1';\nimport { Bls12381g2Token } from './bls12-381-g2';\nimport { ChestToken } from './chest';\nimport { ChestKeyToken } from './chest-key';\nimport { GlobalConstantToken } from './constant';\n\nexport const tokens = [\n  PairToken,\n  NatToken,\n  StringToken,\n  BigMapToken,\n  AddressToken,\n  MapToken,\n  BoolToken,\n  OrToken,\n  ContractToken,\n  ListToken,\n  MutezToken,\n  BytesToken,\n  OptionToken,\n  TimestampToken,\n  IntToken,\n  UnitToken,\n  KeyToken,\n  KeyHashToken,\n  SignatureToken,\n  LambdaToken,\n  OperationToken,\n  SetToken,\n  ChainIDToken,\n  TicketToken,\n  NeverToken,\n  SaplingStateToken,\n  SaplingTransactionToken,\n  Bls12381frToken,\n  Bls12381g1Token,\n  Bls12381g2Token,\n  ChestToken,\n  ChestKeyToken,\n  GlobalConstantToken\n];\n","import { tokens } from './tokens';\nimport { Token } from './token';\nimport { PairToken } from './pair';\n\n/**\n *  @category Error\n *  @description Error that indicates a script having an invalid type or it being unsupported by the Michelson Encoder. Note some protocol changes might affect this, we encourage users to open an issue so we can look into implementing support for said types.\n */\nexport class InvalidTokenError extends Error {\n  name = 'Invalid token error';\n  constructor(public message: string, public data: any) {\n    super(message);\n  }\n}\n\nexport function createToken(val: any, idx: number): Token {\n  if (Array.isArray(val)) {\n    return new PairToken(val, idx, createToken);\n  }\n\n  const t = tokens.find((x) => x.prim === val.prim);\n  if (!t) {\n    throw new InvalidTokenError('Malformed data expected a value with a valid prim property', val);\n  }\n  return new t(val, idx, createToken);\n}\n","/**\n *  @category Error\n *  @description Error that indicates a failure when encoding (transforming JS parameter into JSON Michelson)the parameter of the view\n */\nexport class ViewEncodingError extends Error {\n  name = 'ViewEncodingError';\n\n  constructor(public smartContractViewName: string, public originalError: any) {\n    super(`Unable to encode the parameter of the view: ${smartContractViewName}.`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid on-chain view found on the script\n */\nexport class InvalidScriptError extends Error {\n  name = 'InvalidScriptError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid RPC response being passed or used\n */\nexport class InvalidRpcResponseError extends Error {\n  public name = 'InvalidRpcResponseError';\n  constructor(public script: any) {\n    super(`Invalid RPC response passed as argument(s)`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates a failure that occurred during encoding\n */\nexport class ParameterEncodingError extends Error {\n  public name = 'ParameterEncodingError';\n  constructor(public message: string, public args: any, public originalError: any) {\n    super(`\n      ${message}. Error encountered when trying to encode arguments: \\n\n      [${args}]\n    `);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid big map schema being passed or used\n */\nexport class InvalidBigMapSchema extends Error {\n  public name = 'InvalidBigMapSchema';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates an invalid big map diff being passed or used\n */\nexport class InvalidBigMapDiff extends Error {\n  public name = 'InvalidBigMapDiff';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates a failure when trying to encode big maps\n */\nexport class BigMapEncodingError extends Error {\n  public name = 'BigMapEncodingError';\n  constructor(private obj: string, public details: any) {\n    super(`Unable to encode ${obj}. ${details}`);\n  }\n}\n\n/**\n *  @category Error\n *  @description Error that indicates a failure when trying to encode storage\n */\nexport class StorageEncodingError extends Error {\n  public name = 'StorageEncodingError';\n  constructor(private obj: string, public details: any) {\n    super(`Unable to encode ${obj}. ${details}`);\n  }\n}\n\n/**\n *  @category Error\n *  @description General error that indicates a function not being passed a necessary argument\n */\nexport class MissingArgumentError extends Error {\n  public name = 'MissingArgumentError';\n  constructor(public message: string) {\n    super(message);\n  }\n}\n","import { MichelsonV1Expression, MichelsonV1ExpressionExtended, ScriptResponse } from '@taquito/rpc';\nimport { BigMapToken } from '../tokens/bigmap';\nimport { createToken } from '../tokens/createToken';\nimport { OrToken } from '../tokens/or';\nimport { PairToken } from '../tokens/pair';\nimport { BigMapKeyType, Semantic, Token, TokenValidationError } from '../tokens/token';\nimport {\n  InvalidRpcResponseError,\n  InvalidBigMapSchema,\n  InvalidBigMapDiff,\n  BigMapEncodingError,\n  StorageEncodingError,\n  MissingArgumentError,\n} from './error';\nimport { RpcTransaction } from './model';\nimport { Falsy, TokenSchema } from './types';\n\nconst schemaTypeSymbol = Symbol.for('taquito-schema-type-symbol');\n\n// collapse comb pair\nfunction collapse(val: Token['val'] | any[], prim: string = PairToken.prim): Token['val'] {\n  if (Array.isArray(val)) {\n    return collapse(\n      {\n        prim: prim,\n        args: val,\n      },\n      prim\n    );\n  }\n  if (val.prim === prim && val.args && val.args.length > 2) {\n    return {\n      ...val,\n      args: [\n        val.args?.[0],\n        {\n          prim: prim,\n          args: val.args?.slice(1),\n        },\n      ],\n    };\n  }\n  return val;\n}\n\nfunction deepEqual(a: Token['val'] | any[], b: Token['val'] | any[]): boolean {\n  const ac = collapse(a);\n  const bc = collapse(b);\n  return (\n    ac.prim === bc.prim &&\n    ((ac.args === undefined && bc.args === undefined) ||\n      (ac.args !== undefined &&\n        bc.args !== undefined &&\n        ac.args.length === bc.args.length &&\n        ac.args.every((v, i) => deepEqual(v, bc.args?.[i])))) &&\n    ((ac.annots === undefined && bc.annots === undefined) ||\n      (ac.annots !== undefined &&\n        bc.annots !== undefined &&\n        ac.annots.length === bc.annots.length &&\n        ac.annots.every((v, i) => v === bc.annots?.[i])))\n  );\n}\n\n/**\n * @warn Our current smart contract abstraction feature is currently in preview. It's API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.\n */\nexport class Schema {\n  private root: Token;\n\n  public [schemaTypeSymbol] = true;\n\n  public static isSchema(obj: any): obj is Schema {\n    return obj && obj[schemaTypeSymbol] === true;\n  }\n\n  // TODO: Should we deprecate this?\n  private bigMap?: BigMapToken;\n\n  static fromRPCResponse(val: { script: ScriptResponse }) {\n    const storage: Falsy<MichelsonV1ExpressionExtended> =\n      val &&\n      val.script &&\n      Array.isArray(val.script.code) &&\n      (val.script.code.find((x: any) => x.prim === 'storage') as MichelsonV1ExpressionExtended);\n\n    if (!storage || !Array.isArray(storage.args)) {\n      throw new InvalidRpcResponseError(val.script);\n    }\n\n    return new Schema(storage.args[0]);\n  }\n\n  private isExpressionExtended(\n    val: any\n  ): val is Required<Pick<MichelsonV1ExpressionExtended, 'prim' | 'args'>> {\n    return 'prim' in val && Array.isArray(val.args);\n  }\n\n  constructor(readonly val: MichelsonV1Expression) {\n    this.root = createToken(val, 0);\n\n    if (this.root instanceof BigMapToken) {\n      this.bigMap = this.root;\n    } else if (this.isExpressionExtended(val) && val.prim === 'pair') {\n      const exp = val.args[0];\n      if (this.isExpressionExtended(exp) && exp.prim === 'big_map') {\n        this.bigMap = new BigMapToken(exp, 0, createToken);\n      }\n    }\n  }\n\n  private removeTopLevelAnnotation(obj: any) {\n    // PairToken and OrToken can have redundant top level annotation in their storage\n    if (this.root instanceof PairToken || this.root instanceof OrToken) {\n      if (this.root.hasAnnotations() && typeof obj === 'object' && Object.keys(obj).length === 1) {\n        return obj[Object.keys(obj)[0]];\n      }\n    }\n\n    return obj;\n  }\n\n  Execute(val: any, semantics?: Semantic) {\n    const storage = this.root.Execute(val, semantics);\n\n    return this.removeTopLevelAnnotation(storage);\n  }\n\n  Typecheck(val: any) {\n    if (this.root instanceof BigMapToken && Number.isInteger(Number(val))) {\n      return true;\n    }\n    try {\n      this.root.EncodeObject(val);\n      return true;\n    } catch (ex) {\n      return false;\n    }\n  }\n\n  ExecuteOnBigMapDiff(diff: any[], semantics?: Semantic) {\n    if (!this.bigMap) {\n      throw new InvalidBigMapSchema('Big map schema is undefined');\n    }\n\n    if (!Array.isArray(diff)) {\n      throw new InvalidBigMapDiff('Big map diff must be an array');\n    }\n\n    const eltFormat = diff.map(({ key, value }) => ({ args: [key, value] }));\n\n    return this.bigMap.Execute(eltFormat, semantics);\n  }\n\n  ExecuteOnBigMapValue(key: any, semantics?: Semantic) {\n    if (!this.bigMap) {\n      throw new InvalidBigMapSchema('No big map schema');\n    }\n\n    return this.bigMap.ValueSchema.Execute(key, semantics);\n  }\n\n  EncodeBigMapKey(key: BigMapKeyType) {\n    if (!this.bigMap) {\n      throw new InvalidBigMapSchema('Big map schema is undefined');\n    }\n\n    try {\n      return this.bigMap.KeySchema.ToBigMapKey(key);\n    } catch (ex) {\n      throw new BigMapEncodingError('big map key', ex);\n    }\n  }\n\n  Encode(_value?: any) {\n    try {\n      return this.root.EncodeObject(_value);\n    } catch (ex) {\n      if (ex instanceof TokenValidationError) {\n        throw ex;\n      }\n\n      throw new StorageEncodingError('storage object', ex);\n    }\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  ExtractSchema() {\n    return this.removeTopLevelAnnotation(this.root.ExtractSchema());\n  }\n\n  /**\n   * @description Produce a representation of the storage schema.\n   * Note: Provide guidance on how to write the storage object for the origination operation with Taquito.\n   */\n  generateSchema(): TokenSchema {\n    return this.removeTopLevelAnnotation(this.root.generateSchema());\n  }\n\n  /**\n   * @deprecated\n   */\n  ComputeState(tx: RpcTransaction[], state: any) {\n    if (!this.bigMap) {\n      throw new InvalidBigMapSchema('Big map schema is undefined');\n    }\n\n    const bigMap = tx.reduce((prev, current) => {\n      return {\n        ...prev,\n        ...this.ExecuteOnBigMapDiff(current.contents[0].metadata.operation_result.big_map_diff),\n      };\n    }, {});\n\n    return {\n      ...this.Execute(state),\n      [this.bigMap.annot()]: bigMap,\n    };\n  }\n\n  /**\n   * @description Look up in top-level pairs of the storage to find a value matching the specified type\n   *\n   * @returns The first value found that match the type or `undefined` if no value is found\n   *\n   * @param storage storage to parse to find the value\n   * @param valueType type of value to look for\n   *\n   */\n  FindFirstInTopLevelPair<T extends MichelsonV1Expression>(storage: any, valueType: any) {\n    return this.findValue(this.root['val'], storage, valueType) as T | undefined;\n  }\n\n  private findValue(schema: Token['val'] | any[], storage: any, valueToFind: any): any {\n    if (deepEqual(valueToFind, schema)) {\n      return storage;\n    }\n    if (Array.isArray(schema) || schema['prim'] === 'pair') {\n      const sch = collapse(schema);\n      const str = collapse(storage, 'Pair');\n      if (sch.args === undefined || str.args === undefined) {\n        throw new MissingArgumentError('Tokens have no arguments'); // unlikely\n      }\n      return (\n        this.findValue(sch.args[0], str.args[0], valueToFind) ||\n        this.findValue(sch.args[1], str.args[1], valueToFind)\n      );\n    }\n  }\n\n  /**\n   * @description Look up the schema to find any occurrence of a particular token.\n   *\n   * @returns an array of tokens of the specified kind or an empty array if no token was found\n   *\n   * @param tokenToFind string representing the prim property of the token to find\n   *\n   * @example\n   * ```\n   * Useful to find all global constants in a script, an array of GlobalConstantToken is returned:\n   *\n   * const schema = new Schema(script);\n   * const allGlobalConstantTokens = schema.findToken('constant');\n   * ```\n   *\n   */\n  findToken(tokenToFind: string): Array<Token> {\n    const tokens: Array<Token> = [];\n    return this.root.findAndReturnTokens(tokenToFind, tokens);\n  }\n}\n","import { createToken } from '../tokens/createToken';\nimport { Token, Semantic, TokenValidationError } from '../tokens/token';\nimport { OrToken } from '../tokens/or';\nimport { OptionToken } from '../tokens/option';\nimport { ScriptResponse, MichelsonV1ExpressionExtended, MichelsonV1Expression } from '@taquito/rpc';\nimport { Falsy, TokenSchema } from './types';\nimport { InvalidRpcResponseError, ParameterEncodingError } from './error';\n\n/**\n * @warn Our current smart contract abstraction feature is currently in preview. It's API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.\n */\nexport class ParameterSchema {\n  private root: Token;\n\n  static fromRPCResponse(val: { script: ScriptResponse }) {\n    const parameter: Falsy<MichelsonV1ExpressionExtended> =\n      val &&\n      val.script &&\n      Array.isArray(val.script.code) &&\n      (val.script.code.find((x: any) => x.prim === 'parameter') as MichelsonV1ExpressionExtended);\n    if (!parameter || !Array.isArray(parameter.args)) {\n      throw new InvalidRpcResponseError(val.script);\n    }\n\n    return new ParameterSchema(parameter.args[0]);\n  }\n\n  get isMultipleEntryPoint() {\n    return (\n      this.root instanceof OrToken ||\n      (this.root instanceof OptionToken && this.root.subToken() instanceof OrToken)\n    );\n  }\n\n  get hasAnnotation() {\n    if (this.isMultipleEntryPoint) {\n      return Object.keys(this.ExtractSchema())[0] !== '0';\n    } else {\n      return true;\n    }\n  }\n\n  constructor(val: MichelsonV1Expression) {\n    this.root = createToken(val, 0);\n  }\n\n  Execute(val: any, semantics?: Semantic) {\n    return this.root.Execute(val, semantics);\n  }\n\n  Encode(...args: any[]) {\n    try {\n      return this.root.Encode(args.reverse());\n    } catch (ex) {\n      if (ex instanceof TokenValidationError) {\n        throw ex;\n      }\n\n      throw new ParameterEncodingError('Unable to encode parameter', args.toString(), ex);\n    }\n  }\n\n  EncodeObject(_value?: any) {\n    try {\n      return this.root.EncodeObject(_value);\n    } catch (ex) {\n      if (ex instanceof TokenValidationError) {\n        throw ex;\n      }\n\n      throw new ParameterEncodingError('Unable to encode parameter object', _value, ex);\n    }\n  }\n\n  /**\n   * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n   *\n   */\n  ExtractSchema() {\n    return this.root.ExtractSchema();\n  }\n\n  /**\n   * @description Produce a schema grouping together all the entry points of a contract.\n   */\n  generateSchema(): TokenSchema {\n    return this.root.generateSchema();\n  }\n\n  ExtractSignatures() {\n    return this.root.ExtractSignature();\n  }\n}\n","import { MichelsonV1Expression, MichelsonV1ExpressionExtended, ScriptResponse } from '@taquito/rpc';\nimport { createToken } from '../tokens/createToken';\nimport { Semantic, Token } from '../tokens/token';\nimport { InvalidScriptError, ViewEncodingError } from './error';\n\nexport class ViewSchema {\n  readonly viewName: string;\n  readonly viewArgsType: MichelsonV1ExpressionExtended;\n  readonly viewReturnType: MichelsonV1ExpressionExtended;\n  readonly instructions: MichelsonV1ExpressionExtended[];\n  private rootArgsType: Token;\n  private rootReturnType: Token;\n\n  /**\n   *\n   * @description Create an instance of ViewSchema for each view in a script\n   *\n   * @param val contract script obtained from the RPC\n   * @returns array of ViewSchema or empty array if there is no view in the contract\n   */\n  static fromRPCResponse(val: { script: ScriptResponse }) {\n    const allViewSchema: ViewSchema[] = [];\n\n    const views =\n      val &&\n      val.script &&\n      Array.isArray(val.script.code) &&\n      (val.script.code.filter((x: any) => x.prim === 'view') as MichelsonV1ExpressionExtended[]);\n\n    if (views) {\n      views.forEach((view) => {\n        if (!view.args || view.args.length !== 4) {\n          throw new InvalidScriptError(\n            `Invalid on-chain view found in the script: ${JSON.stringify(view)}`\n          );\n        }\n        allViewSchema.push(new ViewSchema(view.args));\n      });\n    }\n    return allViewSchema;\n  }\n\n  constructor(val: MichelsonV1Expression[]) {\n    if (val.length !== 4 || !('string' in val[0])) {\n      throw new InvalidScriptError(`Invalid on-chain view: ${JSON.stringify(val)}`);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    this.viewName = val[0]['string']!;\n    this.viewArgsType = val[1] as MichelsonV1ExpressionExtended;\n    this.viewReturnType = val[2] as MichelsonV1ExpressionExtended;\n    this.instructions = val[3] as MichelsonV1ExpressionExtended[];\n\n    this.rootArgsType = createToken(this.viewArgsType, 0);\n    this.rootReturnType = createToken(this.viewReturnType, 0);\n  }\n\n  /**\n   *\n   * @description Transform the view parameter into Michelson\n   *\n   * @param args parameter of the view in js format\n   * @returns parameter of the view in Michelson\n   */\n  encodeViewArgs(args: any) {\n    try {\n      return this.rootArgsType.EncodeObject(args);\n    } catch (ex) {\n      throw new ViewEncodingError(this.viewName, ex);\n    }\n  }\n\n  /**\n   *\n   * @description Transform the view result from Michelson to readable data\n   *\n   * @param val result of the view in JSON Michelson\n   * @param semantics optional semantics to override the default decoding behavior\n   * @returns result of the view in a readable format\n   */\n  decodeViewResult(val: any, semantics?: Semantic) {\n    return this.rootReturnType.Execute(val, semantics);\n  }\n\n  /**\n   *\n   * @description Return the signature of the view parameter\n   */\n  extractArgsSchema() {\n    return this.rootArgsType.ExtractSchema();\n  }\n\n  /**\n   *\n   * @description Return the format of the view result\n   */\n  extractResultSchema() {\n    return this.rootReturnType.ExtractSchema();\n  }\n}\n","\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\nexport const VERSION = {\n    \"commitHash\": \"cbdd0af87e400489076259d065e2d328feb8e1b4\",\n    \"version\": \"12.1.0\"\n};\n","/**\n * @packageDocumentation\n * @module @taquito/michelson-encoder\n */\n\nexport * from './schema/storage';\nexport * from './schema/parameter';\nexport * from './schema/view-schema';\nexport * from './schema/error';\nexport * from './schema/types';\nexport { Semantic, BigMapKeyType } from './tokens/token';\nexport * from './errors';\n\nexport const UnitValue = Symbol();\nexport const SaplingStateValue = {};\nexport * from './michelson-map';\nexport { VERSION } from './version';\nexport { Token } from './tokens/token';\n"]},"metadata":{},"sourceType":"module"}