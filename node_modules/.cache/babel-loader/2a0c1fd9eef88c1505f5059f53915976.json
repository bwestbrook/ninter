{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\nimport \"core-js/modules/es.typed-array.at.js\";\nimport \"core-js/modules/es.typed-array.set.js\";\n// Michelson abstract syntax tree types https://tezos.gitlab.io/whitedoc/michelson.html#concrete-syntax\nvar sourceReference = Symbol(\"source_reference\");\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spreadArray(to, from) {\n  for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];\n\n  return to;\n}\n\nvar ScanError =\n/** @class */\nfunction (_super) {\n  __extends(ScanError, _super);\n\n  function ScanError(src, idx, message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.src = src;\n    _this.idx = idx;\n    Object.setPrototypeOf(_this, ScanError.prototype);\n    return _this;\n  }\n\n  return ScanError;\n}(Error);\n\nvar Literal;\n\n(function (Literal) {\n  Literal[Literal[\"Comment\"] = 0] = \"Comment\";\n  Literal[Literal[\"Number\"] = 1] = \"Number\";\n  Literal[Literal[\"String\"] = 2] = \"String\";\n  Literal[Literal[\"Bytes\"] = 3] = \"Bytes\";\n  Literal[Literal[\"Ident\"] = 4] = \"Ident\";\n})(Literal || (Literal = {}));\n\nvar isSpace = new RegExp(\"\\\\s\");\nvar isIdentStart = new RegExp(\"[:@%_A-Za-z]\");\nvar isIdent = new RegExp(\"[@%_\\\\.A-Za-z0-9]\");\nvar isDigit = new RegExp(\"[0-9]\");\nvar isHex = new RegExp(\"[0-9a-fA-F]\");\n\nfunction scan(src, scanComments) {\n  var i, s, start, ii, esc;\n\n  if (scanComments === void 0) {\n    scanComments = false;\n  }\n\n  return __generator(this, function (_a) {\n    switch (_a.label) {\n      case 0:\n        i = 0;\n        _a.label = 1;\n\n      case 1:\n        if (!(i < src.length)) return [3\n        /*break*/\n        , 19]; // Skip space\n\n        while (i < src.length && isSpace.test(src[i])) {\n          i++;\n        }\n\n        if (i === src.length) {\n          return [2\n          /*return*/\n          ];\n        }\n\n        s = src[i];\n        start = i;\n        if (!isIdentStart.test(s)) return [3\n        /*break*/\n        , 3]; // Identifier\n\n        i++;\n\n        while (i < src.length && isIdent.test(src[i])) {\n          i++;\n        }\n\n        return [4\n        /*yield*/\n        , {\n          t: Literal.Ident,\n          v: src.slice(start, i),\n          first: start,\n          last: i\n        }];\n\n      case 2:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 18];\n\n      case 3:\n        if (!(src.length - i > 1 && src.substr(i, 2) === \"0x\")) return [3\n        /*break*/\n        , 5]; // Bytes\n\n        i += 2;\n\n        while (i < src.length && isHex.test(src[i])) {\n          i++;\n        }\n\n        if ((i - start & 1) !== 0) {\n          throw new ScanError(src, i, \"Bytes literal length is expected to be power of two\");\n        }\n\n        return [4\n        /*yield*/\n        , {\n          t: Literal.Bytes,\n          v: src.slice(start, i),\n          first: start,\n          last: i\n        }];\n\n      case 4:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 18];\n\n      case 5:\n        if (!(isDigit.test(s) || s === \"-\")) return [3\n        /*break*/\n        , 7]; // Number\n\n        if (s === \"-\") {\n          i++;\n        }\n\n        ii = i;\n\n        while (i < src.length && isDigit.test(src[i])) {\n          i++;\n        }\n\n        if (ii === i) {\n          throw new ScanError(src, i, \"Number literal is too short\");\n        }\n\n        return [4\n        /*yield*/\n        , {\n          t: Literal.Number,\n          v: src.slice(start, i),\n          first: start,\n          last: i\n        }];\n\n      case 6:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 18];\n\n      case 7:\n        if (!(s === \"\\\"\")) return [3\n        /*break*/\n        , 9]; // String\n\n        i++;\n        esc = false;\n\n        for (; i < src.length && (esc || src[i] !== \"\\\"\"); i++) {\n          if (!esc && src[i] === \"\\\\\") {\n            esc = true;\n          } else {\n            esc = false;\n          }\n        }\n\n        if (i === src.length) {\n          throw new ScanError(src, i, \"Unterminated string literal\");\n        }\n\n        i++;\n        return [4\n        /*yield*/\n        , {\n          t: Literal.String,\n          v: src.slice(start, i),\n          first: start,\n          last: i\n        }];\n\n      case 8:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 18];\n\n      case 9:\n        if (!(s === \"#\")) return [3\n        /*break*/\n        , 12]; // Comment\n\n        i++;\n\n        while (i < src.length && src[i] !== \"\\n\") {\n          i++;\n        }\n\n        if (!scanComments) return [3\n        /*break*/\n        , 11];\n        return [4\n        /*yield*/\n        , {\n          t: Literal.Comment,\n          v: src.slice(start, i),\n          first: start,\n          last: i\n        }];\n\n      case 10:\n        _a.sent();\n\n        _a.label = 11;\n\n      case 11:\n        return [3\n        /*break*/\n        , 18];\n\n      case 12:\n        if (!(src.length - i > 1 && src.substr(i, 2) === \"/*\")) return [3\n        /*break*/\n        , 15]; // C style comment\n\n        i += 2;\n\n        while (i < src.length && !(src.length - i > 1 && src.substr(i, 2) === \"*/\")) {\n          i++;\n        }\n\n        if (i === src.length) {\n          throw new ScanError(src, i, \"Unterminated C style comment\");\n        }\n\n        i += 2;\n        if (!scanComments) return [3\n        /*break*/\n        , 14];\n        return [4\n        /*yield*/\n        , {\n          t: Literal.Comment,\n          v: src.slice(start, i),\n          first: start,\n          last: i\n        }];\n\n      case 13:\n        _a.sent();\n\n        _a.label = 14;\n\n      case 14:\n        return [3\n        /*break*/\n        , 18];\n\n      case 15:\n        if (!(s === \"(\" || s === \")\" || s === \"{\" || s === \"}\" || s === \";\")) return [3\n        /*break*/\n        , 17];\n        i++;\n        return [4\n        /*yield*/\n        , {\n          t: s,\n          v: s,\n          first: start,\n          last: i\n        }];\n\n      case 16:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 18];\n\n      case 17:\n        throw new ScanError(src, i, \"Invalid character at offset \" + i + \": `\" + s + \"'\");\n\n      case 18:\n        return [3\n        /*break*/\n        , 1];\n\n      case 19:\n        return [2\n        /*return*/\n        ];\n    }\n  });\n} // Michelson types\n\n\nvar refContract = Symbol(\"ref_contract\");\nvar Protocol;\n\n(function (Protocol) {\n  Protocol[\"Pt24m4xi\"] = \"Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd\";\n  Protocol[\"PsBABY5H\"] = \"PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU\";\n  Protocol[\"PsBabyM1\"] = \"PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS\";\n  Protocol[\"PsCARTHA\"] = \"PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb\";\n  Protocol[\"PsDELPH1\"] = \"PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo\";\n  Protocol[\"PtEdo2Zk\"] = \"PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA\";\n  Protocol[\"PsFLorena\"] = \"PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i\";\n  Protocol[\"PtGRANADs\"] = \"PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV\";\n  Protocol[\"PtHangzH\"] = \"PtHangzHogokSuiMHemCuowEavgYTP8J5qQ9fQS793MHYFpCY3r\";\n})(Protocol || (Protocol = {}));\n\nvar DefaultProtocol = Protocol.PsDELPH1;\n\nvar MacroError =\n/** @class */\nfunction (_super) {\n  __extends(MacroError, _super);\n\n  function MacroError(prim, message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.prim = prim;\n    Object.setPrototypeOf(_this, MacroError.prototype);\n    return _this;\n  }\n\n  return MacroError;\n}(Error);\n\nfunction assertArgs$1(ex, n) {\n  var _a, _b;\n\n  if (n === 0 && ex.args === undefined || ((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === n) {\n    return true;\n  }\n\n  throw new MacroError(ex, \"macro \" + ex.prim + \" expects \" + n + \" arguments, was given \" + ((_b = ex.args) === null || _b === void 0 ? void 0 : _b.length));\n}\n\nfunction assertNoAnnots(ex) {\n  if (ex.annots === undefined) {\n    return true;\n  }\n\n  throw new MacroError(ex, \"unexpected annotation on macro \" + ex.prim + \": \" + ex.annots);\n}\n\nfunction assertIntArg(ex, arg) {\n  if (\"int\" in arg) {\n    return true;\n  }\n\n  throw new MacroError(ex, \"macro \" + ex.prim + \" expects int argument\");\n}\n\nfunction parsePairUnpairExpr(p, expr, annotations, agg) {\n  var i = 0;\n  var ai = 0;\n  var ann = [null, null]; // Left expression\n\n  var lexpr;\n\n  if (i === expr.length) {\n    throw new MacroError(p, \"unexpected end: \" + p.prim);\n  }\n\n  var c = expr[i++];\n\n  switch (c) {\n    case \"P\":\n      var _a = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg),\n          r = _a.r,\n          n = _a.n,\n          an = _a.an;\n\n      lexpr = r;\n      i += n;\n      ai += an;\n      break;\n\n    case \"A\":\n      if (ai !== annotations.length) {\n        ann[0] = annotations[ai++];\n      }\n\n      break;\n\n    default:\n      throw new MacroError(p, p.prim + \": unexpected character: \" + c);\n  } // Right expression\n\n\n  var rexpr;\n\n  if (i === expr.length) {\n    throw new MacroError(p, \"unexpected end: \" + p.prim);\n  }\n\n  c = expr[i++];\n\n  switch (c) {\n    case \"P\":\n      var _b = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg),\n          r = _b.r,\n          n = _b.n,\n          an = _b.an;\n\n      rexpr = r.map(function (_a) {\n        var _b = __read(_a, 2),\n            v = _b[0],\n            a = _b[1];\n\n        return [v + 1, a];\n      });\n      i += n;\n      ai += an;\n      break;\n\n    case \"I\":\n      if (ai !== annotations.length) {\n        ann[1] = annotations[ai++];\n      }\n\n      break;\n\n    default:\n      throw new MacroError(p, p.prim + \": unexpected character: \" + c);\n  }\n\n  return {\n    r: agg(lexpr, rexpr, [0, ann]),\n    n: i,\n    an: ai\n  };\n}\n\nfunction parseSetMapCadr(p, expr, vann, term) {\n  var c = expr[0];\n\n  switch (c) {\n    case \"A\":\n      return expr.length > 1 ? [{\n        prim: \"DUP\"\n      }, {\n        prim: \"DIP\",\n        args: [[{\n          prim: \"CAR\",\n          annots: [\"@%%\"]\n        }, parseSetMapCadr(p, expr.slice(1), [], term)]]\n      }, {\n        prim: \"CDR\",\n        annots: [\"@%%\"]\n      }, {\n        prim: \"SWAP\"\n      }, {\n        prim: \"PAIR\",\n        annots: __spreadArray([\"%@\", \"%@\"], __read(vann))\n      }] : term.a;\n\n    case \"D\":\n      return expr.length > 1 ? [{\n        prim: \"DUP\"\n      }, {\n        prim: \"DIP\",\n        args: [[{\n          prim: \"CDR\",\n          annots: [\"@%%\"]\n        }, parseSetMapCadr(p, expr.slice(1), [], term)]]\n      }, {\n        prim: \"CAR\",\n        annots: [\"@%%\"]\n      }, {\n        prim: \"PAIR\",\n        annots: __spreadArray([\"%@\", \"%@\"], __read(vann))\n      }] : term.d;\n\n    default:\n      throw new MacroError(p, p.prim + \": unexpected character: \" + c);\n  }\n}\n\nfunction trimLast(a, v) {\n  var l = a.length;\n\n  while (l > 0 && a[l - 1] === v) {\n    l--;\n  }\n\n  return a.slice(0, l);\n}\n\nfunction filterAnnotations(a) {\n  var e_1, _a;\n\n  var fields = [];\n  var rest = [];\n\n  if (a !== undefined) {\n    try {\n      for (var a_1 = __values(a), a_1_1 = a_1.next(); !a_1_1.done; a_1_1 = a_1.next()) {\n        var v = a_1_1.value;\n        (v.length !== 0 && v[0] === \"%\" ? fields : rest).push(v);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (a_1_1 && !a_1_1.done && (_a = a_1.return)) _a.call(a_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n\n  return {\n    fields: fields,\n    rest: rest\n  };\n}\n\nfunction mkPrim(_a) {\n  var prim = _a.prim,\n      annots = _a.annots,\n      args = _a.args;\n  return __assign(__assign({\n    prim: prim\n  }, annots && {\n    annots: annots\n  }), args && {\n    args: args\n  });\n}\n\nvar pairRe = /^P[PAI]{3,}R$/;\nvar unpairRe = /^UNP[PAI]{2,}R$/;\nvar cadrRe = /^C[AD]{2,}R$/;\nvar setCadrRe = /^SET_C[AD]+R$/;\nvar mapCadrRe = /^MAP_C[AD]+R$/;\nvar diipRe = /^DI{2,}P$/;\nvar duupRe = /^DU+P$/;\n\nfunction expandMacros(ex, opt) {\n  var proto = (opt === null || opt === void 0 ? void 0 : opt.protocol) || DefaultProtocol;\n\n  function mayRename(annots) {\n    return annots !== undefined ? [{\n      prim: \"RENAME\",\n      annots: annots\n    }] : [];\n  }\n\n  switch (ex.prim) {\n    // Compare\n    case \"CMPEQ\":\n    case \"CMPNEQ\":\n    case \"CMPLT\":\n    case \"CMPGT\":\n    case \"CMPLE\":\n    case \"CMPGE\":\n      if (assertArgs$1(ex, 0)) {\n        return [{\n          prim: \"COMPARE\"\n        }, mkPrim({\n          prim: ex.prim.slice(3),\n          annots: ex.annots\n        })];\n      }\n\n      break;\n\n    case \"IFEQ\":\n    case \"IFNEQ\":\n    case \"IFLT\":\n    case \"IFGT\":\n    case \"IFLE\":\n    case \"IFGE\":\n      if (assertArgs$1(ex, 2)) {\n        return [{\n          prim: ex.prim.slice(2)\n        }, mkPrim({\n          prim: \"IF\",\n          annots: ex.annots,\n          args: ex.args\n        })];\n      }\n\n      break;\n\n    case \"IFCMPEQ\":\n    case \"IFCMPNEQ\":\n    case \"IFCMPLT\":\n    case \"IFCMPGT\":\n    case \"IFCMPLE\":\n    case \"IFCMPGE\":\n      if (assertArgs$1(ex, 2)) {\n        return [{\n          prim: \"COMPARE\"\n        }, {\n          prim: ex.prim.slice(5)\n        }, mkPrim({\n          prim: \"IF\",\n          annots: ex.annots,\n          args: ex.args\n        })];\n      }\n\n      break;\n    // Fail\n\n    case \"FAIL\":\n      if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {\n        return [{\n          prim: \"UNIT\"\n        }, {\n          prim: \"FAILWITH\"\n        }];\n      }\n\n      break;\n    // Assertion macros\n\n    case \"ASSERT\":\n      if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {\n        return [{\n          prim: \"IF\",\n          args: [[], [[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]]]\n        }];\n      }\n\n      break;\n\n    case \"ASSERT_EQ\":\n    case \"ASSERT_NEQ\":\n    case \"ASSERT_LT\":\n    case \"ASSERT_GT\":\n    case \"ASSERT_LE\":\n    case \"ASSERT_GE\":\n      if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {\n        return [{\n          prim: ex.prim.slice(7)\n        }, {\n          prim: \"IF\",\n          args: [[], [[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]]]\n        }];\n      }\n\n      break;\n\n    case \"ASSERT_CMPEQ\":\n    case \"ASSERT_CMPNEQ\":\n    case \"ASSERT_CMPLT\":\n    case \"ASSERT_CMPGT\":\n    case \"ASSERT_CMPLE\":\n    case \"ASSERT_CMPGE\":\n      if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {\n        return [[{\n          prim: \"COMPARE\"\n        }, {\n          prim: ex.prim.slice(10)\n        }], {\n          prim: \"IF\",\n          args: [[], [[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]]]\n        }];\n      }\n\n      break;\n\n    case \"ASSERT_NONE\":\n      if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {\n        return [{\n          prim: \"IF_NONE\",\n          args: [[], [[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]]]\n        }];\n      }\n\n      break;\n\n    case \"ASSERT_SOME\":\n      if (assertArgs$1(ex, 0)) {\n        return [{\n          prim: \"IF_NONE\",\n          args: [[[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]], mayRename(ex.annots)]\n        }];\n      }\n\n      break;\n\n    case \"ASSERT_LEFT\":\n      if (assertArgs$1(ex, 0)) {\n        return [{\n          prim: \"IF_LEFT\",\n          args: [mayRename(ex.annots), [[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]]]\n        }];\n      }\n\n      break;\n\n    case \"ASSERT_RIGHT\":\n      if (assertArgs$1(ex, 0)) {\n        return [{\n          prim: \"IF_LEFT\",\n          args: [[[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]], mayRename(ex.annots)]\n        }];\n      }\n\n      break;\n    // Syntactic conveniences\n\n    case \"IF_SOME\":\n      if (assertArgs$1(ex, 2)) {\n        return [mkPrim({\n          prim: \"IF_NONE\",\n          annots: ex.annots,\n          args: [ex.args[1], ex.args[0]]\n        })];\n      }\n\n      break;\n\n    case \"IF_RIGHT\":\n      if (assertArgs$1(ex, 2)) {\n        return [mkPrim({\n          prim: \"IF_LEFT\",\n          annots: ex.annots,\n          args: [ex.args[1], ex.args[0]]\n        })];\n      }\n\n      break;\n    // CAR/CDR n\n\n    case \"CAR\":\n    case \"CDR\":\n      if (ex.args !== undefined) {\n        if (assertArgs$1(ex, 1) && assertIntArg(ex, ex.args[0])) {\n          var n = parseInt(ex.args[0].int, 10);\n          return mkPrim({\n            prim: \"GET\",\n            args: [{\n              int: ex.prim === \"CAR\" ? String(n * 2 + 1) : String(n * 2)\n            }],\n            annots: ex.annots\n          });\n        }\n      } else {\n        return ex;\n      }\n\n  } // More syntactic conveniences\n  // PAPPAIIR macro\n\n\n  if (pairRe.test(ex.prim)) {\n    if (assertArgs$1(ex, 0)) {\n      var _a = filterAnnotations(ex.annots),\n          fields = _a.fields,\n          rest_1 = _a.rest;\n\n      var r_1 = parsePairUnpairExpr(ex, ex.prim.slice(1), fields, function (l, r, top) {\n        return __spreadArray(__spreadArray(__spreadArray([], __read(l || [])), __read(r || [])), [top]);\n      }).r;\n      return r_1.map(function (_a, i) {\n        var _b = __read(_a, 2),\n            v = _b[0],\n            a = _b[1];\n\n        var ann = __spreadArray(__spreadArray([], __read(trimLast(a, null).map(function (v) {\n          return v === null ? \"%\" : v;\n        }))), __read(v === 0 && i === r_1.length - 1 ? rest_1 : []));\n\n        var leaf = mkPrim({\n          prim: \"PAIR\",\n          annots: ann.length !== 0 ? ann : undefined\n        });\n        return v === 0 ? leaf : {\n          prim: \"DIP\",\n          args: v === 1 ? [[leaf]] : [{\n            int: String(v)\n          }, [leaf]]\n        };\n      });\n    }\n  } // UNPAPPAIIR macro\n\n\n  if (unpairRe.test(ex.prim)) {\n    if (proto === Protocol.PtEdo2Zk || proto === Protocol.PsFLorena || proto === Protocol.PtGRANADs || proto === Protocol.PtHangzH) {\n      if (ex.prim === \"UNPAIR\") {\n        return ex;\n      }\n\n      if (assertArgs$1(ex, 0)) {\n        // 008_edo: annotations are deprecated\n        var r = parsePairUnpairExpr(ex, ex.prim.slice(3), [], function (l, r, top) {\n          return __spreadArray(__spreadArray([top], __read(r || [])), __read(l || []));\n        }).r;\n        return r.map(function (_a) {\n          var _b = __read(_a, 1),\n              v = _b[0];\n\n          var leaf = mkPrim({\n            prim: \"UNPAIR\"\n          });\n          return v === 0 ? leaf : {\n            prim: \"DIP\",\n            args: v === 1 ? [[leaf]] : [{\n              int: String(v)\n            }, [leaf]]\n          };\n        });\n      }\n    } else if (assertArgs$1(ex, 0)) {\n      var r = parsePairUnpairExpr(ex, ex.prim.slice(3), ex.annots || [], function (l, r, top) {\n        return __spreadArray(__spreadArray([top], __read(r || [])), __read(l || []));\n      }).r;\n      return r.map(function (_a) {\n        var _b = __read(_a, 2),\n            v = _b[0],\n            a = _b[1];\n\n        var leaf = [{\n          prim: \"DUP\"\n        }, mkPrim({\n          prim: \"CAR\",\n          annots: a[0] !== null ? [a[0]] : undefined\n        }), {\n          prim: \"DIP\",\n          args: [[mkPrim({\n            prim: \"CDR\",\n            annots: a[1] !== null ? [a[1]] : undefined\n          })]]\n        }];\n        return v === 0 ? leaf : {\n          prim: \"DIP\",\n          args: v === 1 ? [[leaf]] : [{\n            int: String(v)\n          }, [leaf]]\n        };\n      });\n    }\n  } // C[AD]+R macro\n\n\n  if (cadrRe.test(ex.prim)) {\n    if (assertArgs$1(ex, 0)) {\n      var ch_1 = __spreadArray([], __read(ex.prim.slice(1, ex.prim.length - 1)));\n\n      return ch_1.map(function (c, i) {\n        var ann = i === ch_1.length - 1 ? ex.annots : undefined;\n\n        switch (c) {\n          case \"A\":\n            return mkPrim({\n              prim: \"CAR\",\n              annots: ann\n            });\n\n          case \"D\":\n            return mkPrim({\n              prim: \"CDR\",\n              annots: ann\n            });\n\n          default:\n            throw new MacroError(ex, \"unexpected character: \" + c);\n        }\n      });\n    }\n  } // SET_C[AD]+R macro\n\n\n  if (setCadrRe.test(ex.prim)) {\n    if (assertArgs$1(ex, 0)) {\n      var _b = filterAnnotations(ex.annots),\n          fields = _b.fields,\n          rest = _b.rest;\n\n      if (fields.length > 1) {\n        throw new MacroError(ex, \"unexpected annotation on macro \" + ex.prim + \": \" + fields);\n      }\n\n      var term = fields.length !== 0 ? {\n        a: [{\n          prim: \"DUP\"\n        }, {\n          prim: \"CAR\",\n          annots: fields\n        }, {\n          prim: \"DROP\"\n        }, {\n          prim: \"CDR\",\n          annots: [\"@%%\"]\n        }, {\n          prim: \"SWAP\"\n        }, {\n          prim: \"PAIR\",\n          annots: [fields[0], \"%@\"]\n        }],\n        d: [{\n          prim: \"DUP\"\n        }, {\n          prim: \"CDR\",\n          annots: fields\n        }, {\n          prim: \"DROP\"\n        }, {\n          prim: \"CAR\",\n          annots: [\"@%%\"]\n        }, {\n          prim: \"PAIR\",\n          annots: [\"%@\", fields[0]]\n        }]\n      } : {\n        a: [{\n          prim: \"CDR\",\n          annots: [\"@%%\"]\n        }, {\n          prim: \"SWAP\"\n        }, {\n          prim: \"PAIR\",\n          annots: [\"%\", \"%@\"]\n        }],\n        d: [{\n          prim: \"CAR\",\n          annots: [\"@%%\"]\n        }, {\n          prim: \"PAIR\",\n          annots: [\"%@\", \"%\"]\n        }]\n      };\n      return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), rest, term);\n    }\n  } // MAP_C[AD]+R macro\n\n\n  if (mapCadrRe.test(ex.prim)) {\n    if (assertArgs$1(ex, 1)) {\n      var fields = filterAnnotations(ex.annots).fields;\n\n      if (fields.length > 1) {\n        throw new MacroError(ex, \"unexpected annotation on macro \" + ex.prim + \": \" + fields);\n      }\n\n      var term = {\n        a: [{\n          prim: \"DUP\"\n        }, {\n          prim: \"CDR\",\n          annots: [\"@%%\"]\n        }, {\n          prim: \"DIP\",\n          args: [[mkPrim({\n            prim: \"CAR\",\n            annots: fields.length !== 0 ? [\"@\" + fields[0].slice(1)] : undefined\n          }), ex.args[0]]]\n        }, {\n          prim: \"SWAP\"\n        }, {\n          prim: \"PAIR\",\n          annots: [fields.length !== 0 ? fields[0] : \"%\", \"%@\"]\n        }],\n        d: [{\n          prim: \"DUP\"\n        }, mkPrim({\n          prim: \"CDR\",\n          annots: fields.length !== 0 ? [\"@\" + fields[0].slice(1)] : undefined\n        }), ex.args[0], {\n          prim: \"SWAP\"\n        }, {\n          prim: \"CAR\",\n          annots: [\"@%%\"]\n        }, {\n          prim: \"PAIR\",\n          annots: [\"%@\", fields.length !== 0 ? fields[0] : \"%\"]\n        }]\n      };\n      return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), [], term);\n    }\n  } // Expand deprecated DI...IP to [DIP n]\n\n\n  if (diipRe.test(ex.prim)) {\n    if (assertArgs$1(ex, 1)) {\n      var n = 0;\n\n      while (ex.prim[1 + n] === \"I\") {\n        n++;\n      }\n\n      return mkPrim({\n        prim: \"DIP\",\n        args: [{\n          int: String(n)\n        }, ex.args[0]]\n      });\n    }\n  } // Expand DU...UP and DUP n\n\n\n  if (duupRe.test(ex.prim)) {\n    var n = 0;\n\n    while (ex.prim[1 + n] === \"U\") {\n      n++;\n    }\n\n    if (proto === Protocol.PtEdo2Zk || proto === Protocol.PsFLorena || proto === Protocol.PtGRANADs || proto === Protocol.PtHangzH) {\n      if (n === 1) {\n        return ex;\n      }\n\n      if (assertArgs$1(ex, 0)) {\n        return mkPrim({\n          prim: \"DUP\",\n          args: [{\n            int: String(n)\n          }],\n          annots: ex.annots\n        });\n      }\n    } else {\n      if (n === 1) {\n        if (ex.args === undefined) {\n          return ex; // skip\n        }\n\n        if (assertArgs$1(ex, 1) && assertIntArg(ex, ex.args[0])) {\n          n = parseInt(ex.args[0].int, 10);\n        }\n      } else {\n        assertArgs$1(ex, 0);\n      }\n\n      if (n === 1) {\n        return [mkPrim({\n          prim: \"DUP\",\n          annots: ex.annots\n        })];\n      } else if (n === 2) {\n        return [{\n          prim: \"DIP\",\n          args: [[mkPrim({\n            prim: \"DUP\",\n            annots: ex.annots\n          })]]\n        }, {\n          prim: \"SWAP\"\n        }];\n      } else {\n        return [{\n          prim: \"DIP\",\n          args: [{\n            int: String(n - 1)\n          }, [mkPrim({\n            prim: \"DUP\",\n            annots: ex.annots\n          })]]\n        }, {\n          prim: \"DIG\",\n          args: [{\n            int: String(n)\n          }]\n        }];\n      }\n    }\n  }\n\n  return ex;\n}\n\nvar MichelineParseError =\n/** @class */\nfunction (_super) {\n  __extends(MichelineParseError, _super);\n  /**\r\n   * @param token A token caused the error\r\n   * @param message An error message\r\n   */\n\n\n  function MichelineParseError(token, message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.token = token;\n    Object.setPrototypeOf(_this, MichelineParseError.prototype);\n    return _this;\n  }\n\n  return MichelineParseError;\n}(Error);\n\nvar JSONParseError =\n/** @class */\nfunction (_super) {\n  __extends(JSONParseError, _super);\n  /**\r\n   * @param node A node caused the error\r\n   * @param message An error message\r\n   */\n\n\n  function JSONParseError(node, message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.node = node;\n    Object.setPrototypeOf(_this, JSONParseError.prototype);\n    return _this;\n  }\n\n  return JSONParseError;\n}(Error);\n\nvar errEOF = new MichelineParseError(null, 'Unexpected EOF');\n\nfunction isAnnotation(tok) {\n  return tok.t === Literal.Ident && (tok.v[0] === '@' || tok.v[0] === '%' || tok.v[0] === ':');\n}\n\nvar intRe = new RegExp('^-?[0-9]+$');\nvar bytesRe = new RegExp('^([0-9a-fA-F]{2})*$');\n/**\r\n * Converts and validates Michelson expressions between JSON-based Michelson and Micheline\r\n *\r\n * Pretty Print a Michelson Smart Contract:\r\n * ```\r\n * const contract = await Tezos.contract.at(\"KT1Vsw3kh9638gqWoHTjvHCoHLPKvCbMVbCg\");\r\n * const p = new Parser();\r\n *\r\n * const michelsonCode = p.parseJSON(contract.script.code);\r\n * const storage = p.parseJSON(contract.script.storage);\r\n *\r\n * console.log(\"Pretty print Michelson smart contract:\");\r\n * console.log(emitMicheline(michelsonCode, {indent:\"    \", newline: \"\\n\",}));\r\n *\r\n * console.log(\"Pretty print Storage:\");\r\n * console.log(emitMicheline(storage, {indent:\"    \", newline: \"\\n\",}));\r\n * ```\r\n *\r\n * Encode a Michelson expression for inital storage of a smart contract\r\n * ```\r\n * const src = `(Pair (Pair { Elt 1\r\n *                (Pair (Pair \"tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN\" \"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx\")\r\n *                      0x0501000000026869) }\r\n *          10000000)\r\n *    (Pair 2 333))`;\r\n *\r\n * const p = new Parser();\r\n *\r\n * const exp = p.parseMichelineExpression(src);\r\n * console.log(JSON.stringify(exp));\r\n * ```\r\n */\n\nvar Parser =\n/** @class */\nfunction () {\n  function Parser(opt) {\n    this.opt = opt;\n  }\n\n  Parser.prototype.expand = function (ex) {\n    var _a, _b;\n\n    if (((_a = this.opt) === null || _a === void 0 ? void 0 : _a.expandMacros) !== undefined ? (_b = this.opt) === null || _b === void 0 ? void 0 : _b.expandMacros : true) {\n      var ret = expandMacros(ex, this.opt);\n\n      if (ret !== ex) {\n        ret[sourceReference] = __assign(__assign({}, ex[sourceReference] || {\n          first: 0,\n          last: 0\n        }), {\n          macro: ex\n        });\n      }\n\n      return ret;\n    } else {\n      return ex;\n    }\n  };\n\n  Parser.prototype.parseListExpr = function (scanner, start) {\n    var _a;\n\n    var _b;\n\n    var ref = {\n      first: start.first,\n      last: start.last\n    };\n    var expectBracket = start.t === \"(\";\n    var tok;\n\n    if (expectBracket) {\n      tok = scanner.next();\n\n      if (tok.done) {\n        throw errEOF;\n      }\n\n      ref.last = tok.value.last;\n    } else {\n      tok = {\n        value: start\n      };\n    }\n\n    if (tok.value.t !== Literal.Ident) {\n      throw new MichelineParseError(tok.value, \"not an identifier: \" + tok.value.v);\n    }\n\n    var ret = (_a = {\n      prim: tok.value.v\n    }, _a[sourceReference] = ref, _a);\n\n    for (;;) {\n      var tok_1 = scanner.next();\n\n      if (tok_1.done) {\n        if (expectBracket) {\n          throw errEOF;\n        }\n\n        break;\n      } else if (tok_1.value.t === ')') {\n        if (!expectBracket) {\n          throw new MichelineParseError(tok_1.value, \"unexpected closing bracket\");\n        }\n\n        ref.last = tok_1.value.last;\n        break;\n      } else if (isAnnotation(tok_1.value)) {\n        ret.annots = ret.annots || [];\n        ret.annots.push(tok_1.value.v);\n        ref.last = tok_1.value.last;\n      } else {\n        ret.args = ret.args || [];\n        var arg = this.parseExpr(scanner, tok_1.value);\n        ref.last = ((_b = arg[sourceReference]) === null || _b === void 0 ? void 0 : _b.last) || ref.last;\n        ret.args.push(arg);\n      }\n    }\n\n    return this.expand(ret);\n  };\n\n  Parser.prototype.parseArgs = function (scanner, start) {\n    var _a;\n\n    var _b; // Identifier with arguments\n\n\n    var ref = {\n      first: start.first,\n      last: start.last\n    };\n    var p = (_a = {\n      prim: start.v\n    }, _a[sourceReference] = ref, _a);\n\n    for (;;) {\n      var t = scanner.next();\n\n      if (t.done || t.value.t === '}' || t.value.t === ';') {\n        return [p, t];\n      }\n\n      if (isAnnotation(t.value)) {\n        ref.last = t.value.last;\n        p.annots = p.annots || [];\n        p.annots.push(t.value.v);\n      } else {\n        var arg = this.parseExpr(scanner, t.value);\n        ref.last = ((_b = arg[sourceReference]) === null || _b === void 0 ? void 0 : _b.last) || ref.last;\n        p.args = p.args || [];\n        p.args.push(arg);\n      }\n    }\n  };\n\n  Parser.prototype.parseSequenceExpr = function (scanner, start) {\n    var _a, _b;\n\n    var ref = {\n      first: start.first,\n      last: start.last\n    };\n    var seq = [];\n    seq[sourceReference] = ref;\n    var expectBracket = start.t === \"{\";\n    var tok = start.t === \"{\" ? null : {\n      value: start\n    };\n\n    for (;;) {\n      if (tok === null) {\n        tok = scanner.next();\n\n        if (!tok.done) {\n          ref.last = tok.value.last;\n        }\n      }\n\n      if (tok.done) {\n        if (expectBracket) {\n          throw errEOF;\n        } else {\n          return seq;\n        }\n      }\n\n      if (tok.value.t === \"}\") {\n        if (!expectBracket) {\n          throw new MichelineParseError(tok.value, \"unexpected closing bracket\");\n        } else {\n          return seq;\n        }\n      } else if (tok.value.t === Literal.Ident) {\n        // Identifier with arguments\n        var _c = __read(this.parseArgs(scanner, tok.value), 2),\n            itm = _c[0],\n            n = _c[1];\n\n        ref.last = ((_a = itm[sourceReference]) === null || _a === void 0 ? void 0 : _a.last) || ref.last;\n        seq.push(this.expand(itm));\n        tok = n;\n      } else {\n        // Other\n        var ex = this.parseExpr(scanner, tok.value);\n        ref.last = ((_b = ex[sourceReference]) === null || _b === void 0 ? void 0 : _b.last) || ref.last;\n        seq.push(ex);\n        tok = null;\n      }\n\n      if (tok === null) {\n        tok = scanner.next();\n\n        if (!tok.done) {\n          ref.last = tok.value.last;\n        }\n      }\n\n      if (!tok.done && tok.value.t === \";\") {\n        tok = null;\n      }\n    }\n  };\n\n  Parser.prototype.parseExpr = function (scanner, tok) {\n    var _a, _b, _c, _d;\n\n    switch (tok.t) {\n      case Literal.Ident:\n        return this.expand((_a = {\n          prim: tok.v\n        }, _a[sourceReference] = {\n          first: tok.first,\n          last: tok.last\n        }, _a));\n\n      case Literal.Number:\n        return _b = {\n          int: tok.v\n        }, _b[sourceReference] = {\n          first: tok.first,\n          last: tok.last\n        }, _b;\n\n      case Literal.String:\n        return _c = {\n          string: JSON.parse(tok.v)\n        }, _c[sourceReference] = {\n          first: tok.first,\n          last: tok.last\n        }, _c;\n\n      case Literal.Bytes:\n        return _d = {\n          bytes: tok.v.slice(2)\n        }, _d[sourceReference] = {\n          first: tok.first,\n          last: tok.last\n        }, _d;\n\n      case '{':\n        return this.parseSequenceExpr(scanner, tok);\n\n      default:\n        return this.parseListExpr(scanner, tok);\n    }\n  };\n  /**\r\n   * Parses a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.\r\n   * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`\r\n   */\n\n\n  Parser.prototype.parseSequence = function (src) {\n    // tslint:disable-next-line: strict-type-predicates\n    if (typeof src !== \"string\") {\n      throw new TypeError(\"string type was expected, got \" + typeof src + \" instead\");\n    }\n\n    var scanner = scan(src);\n    var tok = scanner.next();\n\n    if (tok.done) {\n      return null;\n    }\n\n    return this.parseSequenceExpr(scanner, tok.value);\n  };\n  /**\r\n   * Parse a Micheline sequence expression. Enclosing curly brackets may be omitted.\r\n   * @param src A Michelson list expression such as `(Pair {Elt \"0\" 0} 0)` or `Pair {Elt \"0\" 0} 0`\r\n   * @returns An AST node or null for empty document.\r\n   */\n\n\n  Parser.prototype.parseList = function (src) {\n    // tslint:disable-next-line: strict-type-predicates\n    if (typeof src !== \"string\") {\n      throw new TypeError(\"string type was expected, got \" + typeof src + \" instead\");\n    }\n\n    var scanner = scan(src);\n    var tok = scanner.next();\n\n    if (tok.done) {\n      return null;\n    }\n\n    return this.parseListExpr(scanner, tok.value);\n  };\n  /**\r\n   * Parse any Michelson expression\r\n   * @param src A Michelson expression such as `(Pair {Elt \"0\" 0} 0)` or `{parameter ...; storage int; code { DUP ; ...};}`\r\n   * @returns An AST node or null for empty document.\r\n   */\n\n\n  Parser.prototype.parseMichelineExpression = function (src) {\n    // tslint:disable-next-line: strict-type-predicates\n    if (typeof src !== \"string\") {\n      throw new TypeError(\"string type was expected, got \" + typeof src + \" instead\");\n    }\n\n    var scanner = scan(src);\n    var tok = scanner.next();\n\n    if (tok.done) {\n      return null;\n    }\n\n    return this.parseExpr(scanner, tok.value);\n  };\n  /**\r\n   * Parse a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.\r\n   * An alias for `parseSequence`\r\n   * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`\r\n   */\n\n\n  Parser.prototype.parseScript = function (src) {\n    return this.parseSequence(src);\n  };\n  /**\r\n   * Parse a Micheline sequence expression. Enclosing curly brackets may be omitted.\r\n   * An alias for `parseList`\r\n   * @param src A Michelson list expression such as `(Pair {Elt \"0\" 0} 0)` or `Pair {Elt \"0\" 0} 0`\r\n   * @returns An AST node or null for empty document.\r\n   */\n\n\n  Parser.prototype.parseData = function (src) {\n    return this.parseList(src);\n  };\n  /**\r\n   * Takes a JSON-encoded Michelson, validates it, strips away unneeded properties and optionally expands macros (See {@link ParserOptions}).\r\n   * @param src An object containing JSON-encoded Michelson, usually returned by `JSON.parse()`\r\n   */\n\n\n  Parser.prototype.parseJSON = function (src) {\n    var e_1, _a, e_2, _b, e_3, _c; // tslint:disable-next-line: strict-type-predicates\n\n\n    if (typeof src !== \"object\") {\n      throw new TypeError(\"object type was expected, got \" + typeof src + \" instead\");\n    }\n\n    if (Array.isArray(src)) {\n      var ret = [];\n\n      try {\n        for (var src_1 = __values(src), src_1_1 = src_1.next(); !src_1_1.done; src_1_1 = src_1.next()) {\n          var n = src_1_1.value;\n\n          if (n === null || typeof n !== 'object') {\n            throw new JSONParseError(n, \"unexpected sequence element: \" + n);\n          }\n\n          ret.push(this.parseJSON(n));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (src_1_1 && !src_1_1.done && (_a = src_1.return)) _a.call(src_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return ret;\n    } else if ('prim' in src) {\n      var p = src;\n\n      if (typeof p.prim === 'string' && (p.annots === undefined || Array.isArray(p.annots)) && (p.args === undefined || Array.isArray(p.args))) {\n        var ret = {\n          prim: p.prim\n        };\n\n        if (p.annots !== undefined) {\n          try {\n            for (var _d = __values(p.annots), _e = _d.next(); !_e.done; _e = _d.next()) {\n              var a = _e.value;\n\n              if (typeof a !== 'string') {\n                throw new JSONParseError(a, \"string expected: \" + a);\n              }\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n\n          ret.annots = p.annots;\n        }\n\n        if (p.args !== undefined) {\n          ret.args = [];\n\n          try {\n            for (var _f = __values(p.args), _g = _f.next(); !_g.done; _g = _f.next()) {\n              var a = _g.value;\n\n              if (a === null || typeof a !== 'object') {\n                throw new JSONParseError(a, \"unexpected argument: \" + a);\n              }\n\n              ret.args.push(this.parseJSON(a));\n            }\n          } catch (e_3_1) {\n            e_3 = {\n              error: e_3_1\n            };\n          } finally {\n            try {\n              if (_g && !_g.done && (_c = _f.return)) _c.call(_f);\n            } finally {\n              if (e_3) throw e_3.error;\n            }\n          }\n        }\n\n        return this.expand(ret);\n      }\n\n      throw new JSONParseError(src, \"malformed prim expression: \" + src);\n    } else if ('string' in src) {\n      if (typeof src.string === 'string') {\n        return {\n          string: src.string\n        };\n      }\n\n      throw new JSONParseError(src, \"malformed string literal: \" + src);\n    } else if ('int' in src) {\n      if (typeof src.int === 'string' && intRe.test(src.int)) {\n        return {\n          int: src.int\n        };\n      }\n\n      throw new JSONParseError(src, \"malformed int literal: \" + src);\n    } else if ('bytes' in src) {\n      if (typeof src.bytes === 'string' && bytesRe.test(src.bytes)) {\n        return {\n          bytes: src.bytes\n        };\n      }\n\n      throw new JSONParseError(src, \"malformed bytes literal: \" + src);\n    } else {\n      throw new JSONParseError(src, \"unexpected object: \" + src);\n    }\n  };\n\n  return Parser;\n}();\n\nvar Formatter =\n/** @class */\nfunction () {\n  function Formatter(opt, lev) {\n    if (lev === void 0) {\n      lev = 0;\n    }\n\n    this.opt = opt;\n    this.lev = lev;\n  }\n\n  Formatter.prototype.indent = function (n) {\n    var _a;\n\n    if (n === void 0) {\n      n = 0;\n    }\n\n    var ret = \"\";\n\n    if (((_a = this.opt) === null || _a === void 0 ? void 0 : _a.indent) !== undefined) {\n      for (var i = this.lev + n; i > 0; i--) {\n        ret += this.opt.indent;\n      }\n    }\n\n    return ret;\n  };\n\n  Object.defineProperty(Formatter.prototype, \"lf\", {\n    get: function () {\n      var _a;\n\n      return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.newline) || \"\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Formatter.prototype, \"lfsp\", {\n    get: function () {\n      var _a;\n\n      return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.newline) || \" \";\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Formatter.prototype.down = function (n) {\n    return new Formatter(this.opt, this.lev + n);\n  };\n\n  return Formatter;\n}();\n\nfunction hasArgs(node) {\n  return \"prim\" in node && (node.annots !== undefined && node.annots.length !== 0 || node.args !== undefined && node.args.length !== 0);\n}\n\nfunction isMultiline(node) {\n  var e_1, _a;\n\n  if (node.args !== undefined) {\n    try {\n      for (var _b = __values(node.args), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var a = _c.value;\n\n        if (Array.isArray(a) || hasArgs(a)) {\n          return true;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction emitExpr(node, f, foldMacros) {\n  var e_2, _a, e_3, _b;\n\n  var _c;\n\n  var macro = (_c = node[sourceReference]) === null || _c === void 0 ? void 0 : _c.macro;\n\n  if (foldMacros && macro) {\n    return emitExpr(macro, f, foldMacros);\n  }\n\n  if (Array.isArray(node)) {\n    return emitSeq(node, f, foldMacros);\n  } else if (\"string\" in node) {\n    return JSON.stringify(node.string);\n  } else if (\"int\" in node) {\n    return node.int;\n  } else if (\"bytes\" in node) {\n    return \"0x\" + node.bytes;\n  } else {\n    if ((node.annots === undefined || node.annots.length === 0) && (node.args === undefined || node.args.length === 0)) {\n      return node.prim;\n    }\n\n    var ret = \"(\" + node.prim;\n\n    if (node.annots !== undefined) {\n      try {\n        for (var _d = __values(node.annots), _e = _d.next(); !_e.done; _e = _d.next()) {\n          var a = _e.value;\n          ret += \" \" + a;\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_e && !_e.done && (_a = _d.return)) _a.call(_d);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n\n    if (node.args !== undefined) {\n      var multiline = isMultiline(node);\n\n      try {\n        for (var _f = __values(node.args), _g = _f.next(); !_g.done; _g = _f.next()) {\n          var a = _g.value;\n\n          if (multiline) {\n            ret += f.lfsp + f.indent(1) + emitExpr(a, f.down(1), foldMacros);\n          } else {\n            ret += \" \" + emitExpr(a, f, foldMacros);\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    }\n\n    return ret + \")\";\n  }\n}\n\nfunction emitSeq(node, f, foldMacros) {\n  var e_4, _a, e_5, _b, e_6, _c;\n\n  var ret = \"{\" + f.lf;\n  var i = node.length;\n\n  try {\n    for (var node_1 = __values(node), node_1_1 = node_1.next(); !node_1_1.done; node_1_1 = node_1.next()) {\n      var el = node_1_1.value;\n      ret += f.indent(1);\n\n      if (\"prim\" in el) {\n        ret += el.prim;\n\n        if (el.annots !== undefined) {\n          try {\n            for (var _d = (e_5 = void 0, __values(el.annots)), _e = _d.next(); !_e.done; _e = _d.next()) {\n              var a = _e.value;\n              ret += \" \" + a;\n            }\n          } catch (e_5_1) {\n            e_5 = {\n              error: e_5_1\n            };\n          } finally {\n            try {\n              if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n            } finally {\n              if (e_5) throw e_5.error;\n            }\n          }\n        }\n\n        if (el.args !== undefined) {\n          var multiline = isMultiline(el);\n\n          try {\n            for (var _f = (e_6 = void 0, __values(el.args)), _g = _f.next(); !_g.done; _g = _f.next()) {\n              var a = _g.value;\n\n              if (multiline) {\n                ret += f.lfsp + f.indent(2) + emitExpr(a, f.down(2), foldMacros);\n              } else {\n                ret += \" \" + emitExpr(a, f, foldMacros);\n              }\n            }\n          } catch (e_6_1) {\n            e_6 = {\n              error: e_6_1\n            };\n          } finally {\n            try {\n              if (_g && !_g.done && (_c = _f.return)) _c.call(_f);\n            } finally {\n              if (e_6) throw e_6.error;\n            }\n          }\n        }\n      } else {\n        ret += emitExpr(el, f.down(1), foldMacros);\n      }\n\n      ret += i > 1 ? \";\" + f.lfsp : f.lf;\n      i--;\n    }\n  } catch (e_4_1) {\n    e_4 = {\n      error: e_4_1\n    };\n  } finally {\n    try {\n      if (node_1_1 && !node_1_1.done && (_a = node_1.return)) _a.call(node_1);\n    } finally {\n      if (e_4) throw e_4.error;\n    }\n  }\n\n  return ret + f.indent() + \"}\";\n}\n/**\r\n * Formats Micheline expression\r\n * @param expr An AST node\r\n * @param opt Options\r\n */\n\n\nfunction emitMicheline(expr, opt, foldMacros) {\n  if (foldMacros === void 0) {\n    foldMacros = false;\n  } // tslint:disable-next-line: strict-type-predicates\n\n\n  if (typeof expr !== \"object\") {\n    throw new TypeError(\"object type was expected, got \" + typeof expr + \" instead\");\n  }\n\n  return emitExpr(expr, new Formatter(opt), foldMacros);\n}\n\nvar H = [0x6a09e667 | 0, 0xbb67ae85 | 0, 0x3c6ef372 | 0, 0xa54ff53a | 0, 0x510e527f | 0, 0x9b05688c | 0, 0x1f83d9ab | 0, 0x5be0cd19 | 0];\nvar K = [0x428a2f98 | 0, 0x71374491 | 0, 0xb5c0fbcf | 0, 0xe9b5dba5 | 0, 0x3956c25b | 0, 0x59f111f1 | 0, 0x923f82a4 | 0, 0xab1c5ed5 | 0, 0xd807aa98 | 0, 0x12835b01 | 0, 0x243185be | 0, 0x550c7dc3 | 0, 0x72be5d74 | 0, 0x80deb1fe | 0, 0x9bdc06a7 | 0, 0xc19bf174 | 0, 0xe49b69c1 | 0, 0xefbe4786 | 0, 0x0fc19dc6 | 0, 0x240ca1cc | 0, 0x2de92c6f | 0, 0x4a7484aa | 0, 0x5cb0a9dc | 0, 0x76f988da | 0, 0x983e5152 | 0, 0xa831c66d | 0, 0xb00327c8 | 0, 0xbf597fc7 | 0, 0xc6e00bf3 | 0, 0xd5a79147 | 0, 0x06ca6351 | 0, 0x14292967 | 0, 0x27b70a85 | 0, 0x2e1b2138 | 0, 0x4d2c6dfc | 0, 0x53380d13 | 0, 0x650a7354 | 0, 0x766a0abb | 0, 0x81c2c92e | 0, 0x92722c85 | 0, 0xa2bfe8a1 | 0, 0xa81a664b | 0, 0xc24b8b70 | 0, 0xc76c51a3 | 0, 0xd192e819 | 0, 0xd6990624 | 0, 0xf40e3585 | 0, 0x106aa070 | 0, 0x19a4c116 | 0, 0x1e376c08 | 0, 0x2748774c | 0, 0x34b0bcb5 | 0, 0x391c0cb3 | 0, 0x4ed8aa4a | 0, 0x5b9cca4f | 0, 0x682e6ff3 | 0, 0x748f82ee | 0, 0x78a5636f | 0, 0x84c87814 | 0, 0x8cc70208 | 0, 0x90befffa | 0, 0xa4506ceb | 0, 0xbef9a3f7 | 0, 0xc67178f2 | 0]; // https://tools.ietf.org/html/rfc6234\n\nfunction sha256(msg) {\n  var e_1, _a; // pad the message\n\n\n  var r = (msg.length + 9) % 64;\n  var pad = r === 0 ? 0 : 64 - r;\n\n  if (msg.length > 268435455) {\n    throw new Error(\"sha256: message length is too big: \" + msg.length);\n  }\n\n  var l = msg.length << 3;\n\n  var buffer = __spreadArray(__spreadArray(__spreadArray(__spreadArray([], __read(msg)), [0x80]), __read(new Array(pad).fill(0))), [0, 0, 0, 0, l >> 24 & 0xff, l >> 16 & 0xff, l >> 8 & 0xff, l & 0xff]);\n\n  function ror(x, n) {\n    return x >>> n | x << 32 - n;\n  }\n\n  var h = __spreadArray([], __read(H));\n\n  var w = new Array(64);\n  var v = new Array(8);\n\n  for (var offset = 0; offset < buffer.length; offset += 64) {\n    var q = offset;\n    var i = 0;\n\n    while (i < 16) {\n      w[i] = buffer[q] << 24 | buffer[q + 1] << 16 | buffer[q + 2] << 8 | buffer[q + 3];\n      q += 4;\n      i++;\n    }\n\n    while (i < 64) {\n      var s0 = ror(w[i - 15], 7) ^ ror(w[i - 15], 18) ^ w[i - 15] >>> 3;\n      var s1 = ror(w[i - 2], 17) ^ ror(w[i - 2], 19) ^ w[i - 2] >>> 10;\n      w[i] = (s1 | 0) + w[i - 7] + s0 + w[i - 16] | 0;\n      i++;\n    }\n\n    for (var i_1 = 0; i_1 < 8; i_1++) {\n      v[i_1] = h[i_1];\n    }\n\n    for (var i_2 = 0; i_2 < 64; i_2++) {\n      var b0 = ror(v[0], 2) ^ ror(v[0], 13) ^ ror(v[0], 22);\n      var b1 = ror(v[4], 6) ^ ror(v[4], 11) ^ ror(v[4], 25);\n      var t1 = v[7] + b1 + (v[4] & v[5] ^ ~v[4] & v[6]) + K[i_2] + w[i_2] | 0;\n      var t2 = b0 + (v[0] & v[1] ^ v[0] & v[2] ^ v[1] & v[2]) | 0;\n      v[7] = v[6];\n      v[6] = v[5];\n      v[5] = v[4];\n      v[4] = v[3] + t1 | 0;\n      v[3] = v[2];\n      v[2] = v[1];\n      v[1] = v[0];\n      v[0] = t1 + t2 | 0;\n    }\n\n    for (var i_3 = 0; i_3 < 8; i_3++) {\n      h[i_3] = h[i_3] + v[i_3] | 0;\n    }\n  }\n\n  var digest = [];\n\n  try {\n    for (var h_1 = __values(h), h_1_1 = h_1.next(); !h_1_1.done; h_1_1 = h_1.next()) {\n      var v_1 = h_1_1.value;\n      digest.push(v_1 >> 24 & 0xff);\n      digest.push(v_1 >> 16 & 0xff);\n      digest.push(v_1 >> 8 & 0xff);\n      digest.push(v_1 & 0xff);\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (h_1_1 && !h_1_1.done && (_a = h_1.return)) _a.call(h_1);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return digest;\n}\n\nvar base58alphabetFwd = [0, 1, 2, 3, 4, 5, 6, 7, 8, -1, -1, -1, -1, -1, -1, -1, 9, 10, 11, 12, 13, 14, 15, 16, -1, 17, 18, 19, 20, 21, -1, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, -1, -1, -1, -1, -1, -1, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, -1, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57];\nvar base58alphabetBwd = [0, 1, 2, 3, 4, 5, 6, 7, 8, 16, 17, 18, 19, 20, 21, 22, 23, 25, 26, 27, 28, 29, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73];\n\nfunction byteAt(src, i) {\n  var c = src.charCodeAt(i) - 49;\n\n  if (c >= base58alphabetFwd.length || base58alphabetFwd[c] === -1) {\n    throw new Error(\"Base58 decoding error: unexpected character at position \" + i + \": \" + src[i]);\n  }\n\n  return base58alphabetFwd[c];\n}\n\nfunction decodeBase58(src) {\n  var acc = [];\n  var i = 0; // count and skip leading zeros\n\n  while (i < src.length && byteAt(src, i) === 0) {\n    i++;\n  }\n\n  var zeros = i;\n\n  while (i < src.length) {\n    var carry = byteAt(src, i++);\n    /*\r\n    for every symbol x\r\n    acc = acc * 58 + x\r\n    where acc is a little endian arbitrary length integer\r\n    */\n\n    var ii = 0;\n\n    while (carry !== 0 || ii < acc.length) {\n      var m = (acc[ii] || 0) * 58 + carry;\n      acc[ii++] = m % 256;\n      carry = Math.floor(m / 256);\n    }\n  }\n\n  while (zeros-- > 0) {\n    acc.push(0);\n  }\n\n  return acc.reverse();\n}\n\nfunction encodeBase58(src) {\n  var acc = [];\n  var i = 0; // count and skip leading zeros\n\n  while (i < src.length && src[i] === 0) {\n    i++;\n  }\n\n  var zeros = i;\n\n  while (i < src.length) {\n    var carry = src[i++];\n    var ii = 0;\n\n    while (carry !== 0 || ii < acc.length) {\n      var m = (acc[ii] || 0) * 256 + carry;\n      acc[ii++] = m % 58;\n      carry = Math.floor(m / 58);\n    }\n  }\n\n  while (zeros-- > 0) {\n    acc.push(0);\n  }\n\n  acc.reverse();\n  return String.fromCharCode.apply(String, __spreadArray([], __read(acc.map(function (v) {\n    return base58alphabetBwd[v] + 49;\n  }))));\n}\n\nfunction decodeBase58Check(src) {\n  var buffer = decodeBase58(src);\n\n  if (buffer.length < 4) {\n    throw new Error(\"Base58Check decoding error: data is too short \" + buffer.length);\n  }\n\n  var data = buffer.slice(0, buffer.length - 4);\n  var sum = buffer.slice(buffer.length - 4);\n  var computed = sha256(sha256(data));\n\n  if (sum[0] !== computed[0] || sum[1] !== computed[1] || sum[2] !== computed[2] || sum[3] !== computed[3]) {\n    throw new Error(\"Base58Check decoding error: invalid checksum\");\n  }\n\n  return data;\n}\n\nfunction encodeBase58Check(src) {\n  var sum = sha256(sha256(src));\n  return encodeBase58(__spreadArray(__spreadArray([], __read(src)), __read(sum.slice(0, 4))));\n}\n\nvar MichelsonError =\n/** @class */\nfunction (_super) {\n  __extends(MichelsonError, _super);\n  /**\r\n   * @param val Value of a AST node caused the error\r\n   * @param path Path to a node caused the error\r\n   * @param message An error message\r\n   */\n\n\n  function MichelsonError(val, message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.val = val;\n    Object.setPrototypeOf(_this, MichelsonError.prototype);\n    return _this;\n  }\n\n  return MichelsonError;\n}(Error);\n\nfunction isMichelsonError(err) {\n  return err instanceof MichelsonError;\n}\n\nvar MichelsonTypeError =\n/** @class */\nfunction (_super) {\n  __extends(MichelsonTypeError, _super);\n  /**\r\n   * @param val Value of a type node caused the error\r\n   * @param data Value of a data node caused the error\r\n   * @param message An error message\r\n   */\n\n\n  function MichelsonTypeError(val, data, message) {\n    var _this = _super.call(this, val, message) || this;\n\n    if (data !== undefined) {\n      _this.data = data;\n    }\n\n    Object.setPrototypeOf(_this, MichelsonTypeError.prototype);\n    return _this;\n  }\n\n  return MichelsonTypeError;\n}(MichelsonError); // Ad hoc big integer parser\n\n\nvar LongInteger =\n/** @class */\nfunction () {\n  function LongInteger(arg) {\n    this.neg = false;\n    this.buf = [];\n\n    if (arg === undefined) {\n      return;\n    }\n\n    if (typeof arg === \"string\") {\n      for (var i = 0; i < arg.length; i++) {\n        var c = arg.charCodeAt(i);\n\n        if (i === 0 && c === 0x2d) {\n          this.neg = true;\n        } else {\n          if (c < 0x30 || c > 0x39) {\n            throw new Error(\"unexpected character in integer constant: \" + arg[i]);\n          }\n\n          this.append(c - 0x30);\n        }\n      }\n    } else if (arg < 0) {\n      this.neg = true;\n      this.append(-arg);\n    } else {\n      this.append(arg);\n    }\n  }\n\n  LongInteger.prototype.append = function (c) {\n    var i = 0;\n\n    while (c !== 0 || i < this.buf.length) {\n      var m = (this.buf[i] || 0) * 10 + c;\n      this.buf[i++] = m % 256;\n      c = Math.floor(m / 256);\n    }\n  };\n\n  LongInteger.prototype.cmp = function (arg) {\n    if (this.neg !== arg.neg) {\n      return (arg.neg ? 1 : 0) - (this.neg ? 1 : 0);\n    } else {\n      var ret = 0;\n\n      if (this.buf.length !== arg.buf.length) {\n        ret = this.buf.length < arg.buf.length ? -1 : 1;\n      } else if (this.buf.length !== 0) {\n        var i = arg.buf.length - 1;\n\n        while (i >= 0 && this.buf[i] === arg.buf[i]) {\n          i--;\n        }\n\n        ret = i < 0 ? 0 : this.buf[i] < arg.buf[i] ? -1 : 1;\n      }\n\n      return !this.neg ? ret : ret === 0 ? 0 : -ret;\n    }\n  };\n\n  Object.defineProperty(LongInteger.prototype, \"sign\", {\n    get: function () {\n      return this.buf.length === 0 ? 0 : this.neg ? -1 : 1;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  return LongInteger;\n}();\n\nfunction parseBytes(s) {\n  var ret = [];\n\n  for (var i = 0; i < s.length; i += 2) {\n    var x = parseInt(s.slice(i, i + 2), 16);\n\n    if (Number.isNaN(x)) {\n      return null;\n    }\n\n    ret.push(x);\n  }\n\n  return ret;\n}\n\nfunction compareBytes(a, b) {\n  if (a.length !== b.length) {\n    return a.length < b.length ? -1 : 1;\n  } else if (a.length !== 0) {\n    var i = 0;\n\n    while (i < a.length && a[i] === b[i]) {\n      i++;\n    }\n\n    return i === a.length ? 0 : a[i] < b[i] ? -1 : 1;\n  } else {\n    return 0;\n  }\n}\n\nfunction isDecimal(x) {\n  try {\n    // tslint:disable-next-line: no-unused-expression\n    new LongInteger(x);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\n\nfunction isNatural(x) {\n  try {\n    return new LongInteger(x).sign >= 0;\n  } catch (_a) {\n    return false;\n  }\n}\n\nvar annRe = /^(@%|@%%|%@|[@:%]([_0-9a-zA-Z][_0-9a-zA-Z\\.%@]*)?)$/;\n\nfunction unpackAnnotations(p, opt) {\n  var e_1, _a;\n\n  if (Array.isArray(p)) {\n    return {};\n  }\n\n  var field;\n  var type;\n  var vars;\n\n  if (p.annots !== undefined) {\n    try {\n      for (var _b = __values(p.annots), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var v = _c.value;\n\n        if (v.length !== 0) {\n          if (!annRe.test(v) || !(opt === null || opt === void 0 ? void 0 : opt.specialVar) && (v === \"@%\" || v === \"@%%\") || !(opt === null || opt === void 0 ? void 0 : opt.specialFields) && v === \"%@\") {\n            throw new MichelsonError(p, p.prim + \": unexpected annotation: \" + v);\n          }\n\n          switch (v[0]) {\n            case \"%\":\n              if ((opt === null || opt === void 0 ? void 0 : opt.emptyFields) || v.length > 1) {\n                field = field || [];\n                field.push(v);\n              }\n\n              break;\n\n            case \":\":\n              if (v.length > 1) {\n                type = type || [];\n                type.push(v);\n              }\n\n              break;\n\n            case \"@\":\n              if ((opt === null || opt === void 0 ? void 0 : opt.emptyVar) || v.length > 1) {\n                vars = vars || [];\n                vars.push(v);\n              }\n\n              break;\n          }\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n\n  return {\n    f: field,\n    t: type,\n    v: vars\n  };\n}\n\nvar tezosPrefix = {\n  BlockHash: [32, [1, 52]],\n  OperationHash: [32, [5, 116]],\n  OperationListHash: [32, [133, 233]],\n  OperationListListHash: [32, [29, 159, 109]],\n  ProtocolHash: [32, [2, 170]],\n  ContextHash: [32, [79, 199]],\n  ED25519PublicKeyHash: [20, [6, 161, 159]],\n  SECP256K1PublicKeyHash: [20, [6, 161, 161]],\n  P256PublicKeyHash: [20, [6, 161, 164]],\n  ContractHash: [20, [2, 90, 121]],\n  CryptoboxPublicKeyHash: [16, [153, 103]],\n  ED25519Seed: [32, [13, 15, 58, 7]],\n  ED25519PublicKey: [32, [13, 15, 37, 217]],\n  SECP256K1SecretKey: [32, [17, 162, 224, 201]],\n  P256SecretKey: [32, [16, 81, 238, 189]],\n  ED25519EncryptedSeed: [56, [7, 90, 60, 179, 41]],\n  SECP256K1EncryptedSecretKey: [56, [9, 237, 241, 174, 150]],\n  P256EncryptedSecretKey: [56, [9, 48, 57, 115, 171]],\n  SECP256K1PublicKey: [33, [3, 254, 226, 86]],\n  P256PublicKey: [33, [3, 178, 139, 127]],\n  SECP256K1Scalar: [33, [38, 248, 136]],\n  SECP256K1Element: [33, [5, 92, 0]],\n  ED25519SecretKey: [64, [43, 246, 78, 7]],\n  ED25519Signature: [64, [9, 245, 205, 134, 18]],\n  SECP256K1Signature: [64, [13, 115, 101, 19, 63]],\n  P256Signature: [64, [54, 240, 44, 52]],\n  GenericSignature: [64, [4, 130, 43]],\n  ChainID: [4, [87, 82, 0]]\n};\n\nfunction checkDecodeTezosID(id) {\n  var e_2, _a;\n\n  var types = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    types[_i - 1] = arguments[_i];\n  }\n\n  var buf = decodeBase58Check(id);\n\n  try {\n    for (var types_1 = __values(types), types_1_1 = types_1.next(); !types_1_1.done; types_1_1 = types_1.next()) {\n      var t = types_1_1.value;\n\n      var _b = __read(tezosPrefix[t], 2),\n          plen = _b[0],\n          p = _b[1];\n\n      if (buf.length === plen + p.length) {\n        var i = 0;\n\n        while (i < p.length && buf[i] === p[i]) {\n          i++;\n        }\n\n        if (i === p.length) {\n          return [t, buf.slice(p.length)];\n        }\n      }\n    }\n  } catch (e_2_1) {\n    e_2 = {\n      error: e_2_1\n    };\n  } finally {\n    try {\n      if (types_1_1 && !types_1_1.done && (_a = types_1.return)) _a.call(types_1);\n    } finally {\n      if (e_2) throw e_2.error;\n    }\n  }\n\n  return null;\n}\n\nfunction encodeTezosID(id, data) {\n  var _a = __read(tezosPrefix[id], 2),\n      plen = _a[0],\n      p = _a[1];\n\n  if (data.length !== plen) {\n    throw new Error(\"incorrect data length for \" + id + \": \" + data.length);\n  }\n\n  return encodeBase58Check(__spreadArray(__spreadArray([], __read(p)), __read(data)));\n}\n\nfunction unpackComb(id, v) {\n  var vv = v;\n  var args = Array.isArray(vv) ? vv : vv.args;\n\n  if (args.length === 2) {\n    // it's a way to make a union of two interfaces not an interface with two independent properties of union types\n    var ret = id === \"pair\" ? {\n      prim: \"pair\",\n      args: args\n    } : {\n      prim: \"Pair\",\n      args: args\n    };\n    return ret;\n  }\n\n  return __assign(__assign({}, Array.isArray(vv) ? {\n    prim: id\n  } : vv), {\n    args: [args[0], {\n      prim: id,\n      args: args.slice(1)\n    }]\n  });\n}\n\nfunction isPairType(t) {\n  return Array.isArray(t) || t.prim === \"pair\";\n}\n\nfunction isPairData(d) {\n  return Array.isArray(d) || \"prim\" in d && d.prim === \"Pair\";\n}\n\nvar rfc3339Re = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])[T ]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|[+-]([01][0-9]|2[0-3]):([0-5][0-9]))$/;\n\nfunction parseDate(a) {\n  if (\"string\" in a) {\n    if (isNatural(a.string)) {\n      return new Date(parseInt(a.string, 10));\n    } else if (rfc3339Re.test(a.string)) {\n      var x = new Date(a.string);\n\n      if (!Number.isNaN(x.valueOf)) {\n        return x;\n      }\n    }\n  } else if (isNatural(a.int)) {\n    return new Date(parseInt(a.int, 10));\n  }\n\n  return null;\n}\n\nfunction parseHex(s) {\n  var res = [];\n\n  for (var i = 0; i < s.length; i += 2) {\n    var ss = s.slice(i, i + 2);\n    var x = parseInt(ss, 16);\n\n    if (Number.isNaN(x)) {\n      throw new Error(\"can't parse hex byte: \" + ss);\n    }\n\n    res.push(x);\n  }\n\n  return res;\n}\n\nfunction hexBytes(bytes) {\n  return bytes.map(function (x) {\n    return (x >> 4 & 0xf).toString(16) + (x & 0xf).toString(16);\n  }).join(\"\");\n} // Michelson validator\n\n\nvar noArgInstructionIDs = {\n  \"ABS\": true,\n  \"ADD\": true,\n  \"ADDRESS\": true,\n  \"AMOUNT\": true,\n  \"AND\": true,\n  \"APPLY\": true,\n  \"BALANCE\": true,\n  \"BLAKE2B\": true,\n  \"CAR\": true,\n  \"CDR\": true,\n  \"CHAIN_ID\": true,\n  \"CHECK_SIGNATURE\": true,\n  \"COMPARE\": true,\n  \"CONCAT\": true,\n  \"CONS\": true,\n  \"EDIV\": true,\n  \"EQ\": true,\n  \"EXEC\": true,\n  \"FAILWITH\": true,\n  \"GE\": true,\n  \"GET_AND_UPDATE\": true,\n  \"GT\": true,\n  \"HASH_KEY\": true,\n  \"IMPLICIT_ACCOUNT\": true,\n  \"INT\": true,\n  \"ISNAT\": true,\n  \"JOIN_TICKETS\": true,\n  \"KECCAK\": true,\n  \"LE\": true,\n  \"LEVEL\": true,\n  \"LSL\": true,\n  \"LSR\": true,\n  \"LT\": true,\n  \"MEM\": true,\n  \"MUL\": true,\n  \"NEG\": true,\n  \"NEQ\": true,\n  \"NEVER\": true,\n  \"NOT\": true,\n  \"NOW\": true,\n  \"OR\": true,\n  \"PACK\": true,\n  \"PAIRING_CHECK\": true,\n  \"READ_TICKET\": true,\n  \"SAPLING_VERIFY_UPDATE\": true,\n  \"SELF\": true,\n  \"SELF_ADDRESS\": true,\n  \"SENDER\": true,\n  \"SET_DELEGATE\": true,\n  \"SHA256\": true,\n  \"SHA3\": true,\n  \"SHA512\": true,\n  \"SIZE\": true,\n  \"SLICE\": true,\n  \"SOME\": true,\n  \"SOURCE\": true,\n  \"SPLIT_TICKET\": true,\n  \"SUB\": true,\n  \"SWAP\": true,\n  \"TICKET\": true,\n  \"TOTAL_VOTING_POWER\": true,\n  \"TRANSFER_TOKENS\": true,\n  \"UNIT\": true,\n  \"VOTING_POWER\": true,\n  \"XOR\": true,\n  \"RENAME\": true\n};\nvar instructionIDs = Object.assign({}, noArgInstructionIDs, {\n  \"CONTRACT\": true,\n  \"CREATE_CONTRACT\": true,\n  \"DIG\": true,\n  \"DIP\": true,\n  \"DROP\": true,\n  \"DUG\": true,\n  \"DUP\": true,\n  \"EMPTY_BIG_MAP\": true,\n  \"EMPTY_MAP\": true,\n  \"EMPTY_SET\": true,\n  \"GET\": true,\n  \"IF\": true,\n  \"IF_CONS\": true,\n  \"IF_LEFT\": true,\n  \"IF_NONE\": true,\n  \"ITER\": true,\n  \"LAMBDA\": true,\n  \"LEFT\": true,\n  \"LOOP\": true,\n  \"LOOP_LEFT\": true,\n  \"MAP\": true,\n  \"NIL\": true,\n  \"NONE\": true,\n  \"PAIR\": true,\n  \"PUSH\": true,\n  \"RIGHT\": true,\n  \"SAPLING_EMPTY_STATE\": true,\n  \"UNPACK\": true,\n  \"UNPAIR\": true,\n  \"UPDATE\": true,\n  \"CAST\": true\n});\nvar simpleComparableTypeIDs = {\n  \"unit\": true,\n  \"never\": true,\n  \"bool\": true,\n  \"int\": true,\n  \"nat\": true,\n  \"string\": true,\n  \"chain_id\": true,\n  \"bytes\": true,\n  \"mutez\": true,\n  \"key_hash\": true,\n  \"key\": true,\n  \"signature\": true,\n  \"timestamp\": true,\n  \"address\": true\n};\nvar typeIDs = Object.assign({}, simpleComparableTypeIDs, {\n  \"or\": true,\n  \"pair\": true,\n  \"set\": true,\n  \"big_map\": true,\n  \"contract\": true,\n  \"lambda\": true,\n  \"list\": true,\n  \"map\": true,\n  \"operation\": true,\n  \"option\": true,\n  \"bls12_381_g1\": true,\n  \"bls12_381_g2\": true,\n  \"bls12_381_fr\": true,\n  \"sapling_transaction\": true,\n  \"sapling_state\": true,\n  \"ticket\": true\n});\n\nvar MichelsonValidationError =\n/** @class */\nfunction (_super) {\n  __extends(MichelsonValidationError, _super);\n  /**\r\n   * @param val Value of a node caused the error\r\n   * @param message An error message\r\n   */\n\n\n  function MichelsonValidationError(val, message) {\n    var _this = _super.call(this, val, message) || this;\n\n    _this.val = val;\n    Object.setPrototypeOf(_this, MichelsonValidationError.prototype);\n    return _this;\n  }\n\n  return MichelsonValidationError;\n}(MichelsonError);\n\nfunction isPrim(ex) {\n  return \"prim\" in ex;\n}\n\nfunction isPrimOrSeq(ex) {\n  return Array.isArray(ex) || \"prim\" in ex;\n}\n\nfunction assertPrim(ex) {\n  if (isPrim(ex)) {\n    return true;\n  }\n\n  throw new MichelsonValidationError(ex, \"prim expression expected\");\n}\n\nfunction assertSeq(ex) {\n  if (Array.isArray(ex)) {\n    return true;\n  }\n\n  throw new MichelsonValidationError(ex, \"sequence expression expected\");\n}\n\nfunction assertPrimOrSeq(ex) {\n  if (isPrimOrSeq(ex)) {\n    return true;\n  }\n\n  throw new MichelsonValidationError(ex, \"prim or sequence expression expected\");\n}\n\nfunction assertNatural(i) {\n  if (i.int[0] === \"-\") {\n    throw new MichelsonValidationError(i, \"natural number expected\");\n  }\n}\n\nfunction assertIntLiteral(ex) {\n  if (\"int\" in ex) {\n    return true;\n  }\n\n  throw new MichelsonValidationError(ex, \"int literal expected\");\n}\n\nfunction assertArgs(ex, n) {\n  var _a;\n\n  if (n === 0 && ex.args === undefined || ((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === n) {\n    return true;\n  }\n\n  throw new MichelsonValidationError(ex, n + \" arguments expected\");\n}\n/**\r\n * Checks if the node is a valid Michelson code (sequence of instructions).\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\n\n\nfunction assertMichelsonInstruction(ex) {\n  var e_1, _a;\n\n  var _b, _c;\n\n  if (Array.isArray(ex)) {\n    try {\n      for (var ex_1 = __values(ex), ex_1_1 = ex_1.next(); !ex_1_1.done; ex_1_1 = ex_1.next()) {\n        var n = ex_1_1.value;\n\n        if (!Array.isArray(n) && !isPrim(n)) {\n          throw new MichelsonValidationError(ex, \"sequence or prim expected\");\n        }\n\n        assertMichelsonInstruction(n);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (ex_1_1 && !ex_1_1.done && (_a = ex_1.return)) _a.call(ex_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return true;\n  }\n\n  if (assertPrim(ex)) {\n    if (Object.prototype.hasOwnProperty.call(noArgInstructionIDs, ex.prim)) {\n      assertArgs(ex, 0);\n      return true;\n    }\n\n    switch (ex.prim) {\n      case \"DROP\":\n      case \"PAIR\":\n      case \"UNPAIR\":\n      case \"DUP\":\n      case \"UPDATE\":\n      case \"GET\":\n        if (ex.args !== undefined && assertArgs(ex, 1)) {\n          /* istanbul ignore else */\n          if (assertIntLiteral(ex.args[0])) {\n            assertNatural(ex.args[0]);\n          }\n        }\n\n        break;\n\n      case \"DIG\":\n      case \"DUG\":\n      case \"SAPLING_EMPTY_STATE\":\n        /* istanbul ignore else */\n        if (assertArgs(ex, 1)) {\n          /* istanbul ignore else */\n          if (assertIntLiteral(ex.args[0])) {\n            assertNatural(ex.args[0]);\n          }\n        }\n\n        break;\n\n      case \"NONE\":\n      case \"LEFT\":\n      case \"RIGHT\":\n      case \"NIL\":\n      case \"CAST\":\n        /* istanbul ignore else */\n        if (assertArgs(ex, 1)) {\n          assertMichelsonType(ex.args[0]);\n        }\n\n        break;\n\n      case \"UNPACK\":\n        /* istanbul ignore else */\n        if (assertArgs(ex, 1)) {\n          assertMichelsonPackableType(ex.args[0]);\n        }\n\n        break;\n\n      case \"CONTRACT\":\n        /* istanbul ignore else */\n        if (assertArgs(ex, 1)) {\n          assertMichelsonPassableType(ex.args[0]);\n        }\n\n        break;\n\n      case \"IF_NONE\":\n      case \"IF_LEFT\":\n      case \"IF_CONS\":\n      case \"IF\":\n        /* istanbul ignore else */\n        if (assertArgs(ex, 2)) {\n          /* istanbul ignore else */\n          if (assertSeq(ex.args[0])) {\n            assertMichelsonInstruction(ex.args[0]);\n          }\n          /* istanbul ignore else */\n\n\n          if (assertSeq(ex.args[1])) {\n            assertMichelsonInstruction(ex.args[1]);\n          }\n        }\n\n        break;\n\n      case \"MAP\":\n      case \"ITER\":\n      case \"LOOP\":\n      case \"LOOP_LEFT\":\n        /* istanbul ignore else */\n        if (assertArgs(ex, 1)) {\n          assertMichelsonInstruction(ex.args[0]);\n        }\n\n        break;\n\n      case \"CREATE_CONTRACT\":\n        /* istanbul ignore else */\n        if (assertArgs(ex, 1)) {\n          assertMichelsonContract(ex.args[0]);\n        }\n\n        break;\n\n      case \"DIP\":\n        if (((_b = ex.args) === null || _b === void 0 ? void 0 : _b.length) === 2) {\n          /* istanbul ignore else */\n          if (assertIntLiteral(ex.args[0])) {\n            assertNatural(ex.args[0]);\n          }\n          /* istanbul ignore else */\n\n\n          if (assertSeq(ex.args[1])) {\n            assertMichelsonInstruction(ex.args[1]);\n          }\n        } else if (((_c = ex.args) === null || _c === void 0 ? void 0 : _c.length) === 1) {\n          /* istanbul ignore else */\n          if (assertSeq(ex.args[0])) {\n            assertMichelsonInstruction(ex.args[0]);\n          }\n        } else {\n          throw new MichelsonValidationError(ex, \"1 or 2 arguments expected\");\n        }\n\n        break;\n\n      case \"PUSH\":\n        /* istanbul ignore else */\n        if (assertArgs(ex, 2)) {\n          assertMichelsonPushableType(ex.args[0]);\n          assertMichelsonData(ex.args[1]);\n        }\n\n        break;\n\n      case \"EMPTY_SET\":\n        /* istanbul ignore else */\n        if (assertArgs(ex, 1)) {\n          assertMichelsonComparableType(ex.args[0]);\n        }\n\n        break;\n\n      case \"EMPTY_MAP\":\n        /* istanbul ignore else */\n        if (assertArgs(ex, 2)) {\n          assertMichelsonComparableType(ex.args[0]);\n          assertMichelsonType(ex.args[1]);\n        }\n\n        break;\n\n      case \"EMPTY_BIG_MAP\":\n        /* istanbul ignore else */\n        if (assertArgs(ex, 2)) {\n          assertMichelsonComparableType(ex.args[0]);\n          assertMichelsonBigMapStorableType(ex.args[1]);\n        }\n\n        break;\n\n      case \"LAMBDA\":\n        /* istanbul ignore else */\n        if (assertArgs(ex, 3)) {\n          assertMichelsonType(ex.args[0]);\n          assertMichelsonType(ex.args[1]);\n          /* istanbul ignore else */\n\n          if (assertSeq(ex.args[2])) {\n            assertMichelsonInstruction(ex.args[2]);\n          }\n        }\n\n        break;\n\n      default:\n        throw new MichelsonValidationError(ex, \"instruction expected\");\n    }\n  }\n\n  return true;\n}\n\nfunction assertMichelsonComparableType(ex) {\n  /* istanbul ignore else */\n  if (assertPrimOrSeq(ex)) {\n    if (Array.isArray(ex) || ex.prim === \"pair\" || ex.prim === \"or\" || ex.prim === \"option\") {\n      traverseType(ex, function (ex) {\n        return assertMichelsonComparableType(ex);\n      });\n    } else if (!Object.prototype.hasOwnProperty.call(simpleComparableTypeIDs, ex.prim)) {\n      throw new MichelsonValidationError(ex, ex.prim + \": type is not comparable\");\n    }\n  }\n\n  return true;\n}\n\nfunction assertMichelsonPackableType(ex) {\n  /* istanbul ignore else */\n  if (assertPrimOrSeq(ex)) {\n    if (isPrim(ex)) {\n      if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === \"big_map\" || ex.prim === \"operation\" || ex.prim === \"sapling_state\" || ex.prim === \"ticket\") {\n        throw new MichelsonValidationError(ex, ex.prim + \": type can't be used inside PACK/UNPACK instructions\");\n      }\n\n      traverseType(ex, function (ex) {\n        return assertMichelsonPackableType(ex);\n      });\n    }\n  }\n\n  return true;\n}\n\nfunction assertMichelsonPushableType(ex) {\n  /* istanbul ignore else */\n  if (assertPrimOrSeq(ex)) {\n    if (isPrim(ex)) {\n      if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === \"big_map\" || ex.prim === \"operation\" || ex.prim === \"sapling_state\" || ex.prim === \"ticket\" || ex.prim === \"contract\") {\n        throw new MichelsonValidationError(ex, ex.prim + \": type can't be pushed\");\n      }\n\n      traverseType(ex, function (ex) {\n        return assertMichelsonPushableType(ex);\n      });\n    }\n  }\n\n  return true;\n}\n\nfunction assertMichelsonStorableType(ex) {\n  /* istanbul ignore else */\n  if (assertPrimOrSeq(ex)) {\n    if (isPrim(ex)) {\n      if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === \"operation\" || ex.prim === \"contract\") {\n        throw new MichelsonValidationError(ex, ex.prim + \": type can't be used as part of a storage\");\n      }\n\n      traverseType(ex, function (ex) {\n        return assertMichelsonStorableType(ex);\n      });\n    }\n  }\n\n  return true;\n}\n\nfunction assertMichelsonPassableType(ex) {\n  /* istanbul ignore else */\n  if (assertPrimOrSeq(ex)) {\n    if (isPrim(ex)) {\n      if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === \"operation\") {\n        throw new MichelsonValidationError(ex, ex.prim + \": type can't be used as part of a parameter\");\n      }\n\n      traverseType(ex, function (ex) {\n        return assertMichelsonPassableType(ex);\n      });\n    }\n  }\n\n  return true;\n}\n\nfunction assertMichelsonBigMapStorableType(ex) {\n  /* istanbul ignore else */\n  if (assertPrimOrSeq(ex)) {\n    if (isPrim(ex)) {\n      if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === \"big_map\" || ex.prim === \"operation\" || ex.prim === \"sapling_state\") {\n        throw new MichelsonValidationError(ex, ex.prim + \": type can't be used inside a big_map\");\n      }\n\n      traverseType(ex, function (ex) {\n        return assertMichelsonBigMapStorableType(ex);\n      });\n    }\n  }\n\n  return true;\n}\n/**\r\n * Checks if the node is a valid Michelson type expression.\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\n\n\nfunction assertMichelsonType(ex) {\n  /* istanbul ignore else */\n  if (assertPrimOrSeq(ex)) {\n    if (isPrim(ex)) {\n      if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim)) {\n        throw new MichelsonValidationError(ex, \"type expected\");\n      }\n\n      traverseType(ex, function (ex) {\n        return assertMichelsonType(ex);\n      });\n    }\n  }\n\n  return true;\n}\n\nfunction traverseType(ex, cb) {\n  if (Array.isArray(ex) || ex.prim === \"pair\") {\n    var args = Array.isArray(ex) ? ex : ex.args;\n\n    if (args === undefined || args.length < 2) {\n      throw new MichelsonValidationError(ex, \"at least 2 arguments expected\");\n    }\n\n    args.forEach(function (a) {\n      if (assertPrimOrSeq(a)) {\n        cb(a);\n      }\n    });\n    return true;\n  }\n\n  switch (ex.prim) {\n    case \"option\":\n    case \"list\":\n      /* istanbul ignore else */\n      if (assertArgs(ex, 1) && assertPrimOrSeq(ex.args[0])) {\n        cb(ex.args[0]);\n      }\n\n      break;\n\n    case \"contract\":\n      /* istanbul ignore else */\n      if (assertArgs(ex, 1)) {\n        assertMichelsonPassableType(ex.args[0]);\n      }\n\n      break;\n\n    case \"or\":\n      /* istanbul ignore else */\n      if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {\n        cb(ex.args[0]);\n        cb(ex.args[1]);\n      }\n\n      break;\n\n    case \"lambda\":\n      /* istanbul ignore else */\n      if (assertArgs(ex, 2)) {\n        assertMichelsonType(ex.args[0]);\n        assertMichelsonType(ex.args[1]);\n      }\n\n      break;\n\n    case \"set\":\n      /* istanbul ignore else */\n      if (assertArgs(ex, 1)) {\n        assertMichelsonComparableType(ex.args[0]);\n      }\n\n      break;\n\n    case \"map\":\n      /* istanbul ignore else */\n      if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {\n        assertMichelsonComparableType(ex.args[0]);\n        cb(ex.args[1]);\n      }\n\n      break;\n\n    case \"big_map\":\n      /* istanbul ignore else */\n      if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {\n        assertMichelsonComparableType(ex.args[0]);\n        assertMichelsonBigMapStorableType(ex.args[1]);\n        cb(ex.args[1]);\n      }\n\n      break;\n\n    case \"ticket\":\n      /* istanbul ignore else */\n      if (assertArgs(ex, 1) && assertPrimOrSeq(ex.args[0])) {\n        assertMichelsonComparableType(ex.args[0]);\n      }\n\n      break;\n\n    case \"sapling_state\":\n    case \"sapling_transaction\":\n      if (assertArgs(ex, 1)) {\n        assertIntLiteral(ex.args[0]);\n      }\n\n      break;\n\n    default:\n      assertArgs(ex, 0);\n  }\n\n  return true;\n}\n/**\r\n * Checks if the node is a valid Michelson data literal such as `(Pair {Elt \"0\" 0} 0)`.\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\n\n\nfunction assertMichelsonData(ex) {\n  var e_2, _a, e_3, _b;\n\n  if (\"int\" in ex || \"string\" in ex || \"bytes\" in ex) {\n    return true;\n  }\n\n  if (Array.isArray(ex)) {\n    var mapElts = 0;\n\n    try {\n      for (var ex_2 = __values(ex), ex_2_1 = ex_2.next(); !ex_2_1.done; ex_2_1 = ex_2.next()) {\n        var n = ex_2_1.value;\n\n        if (isPrim(n) && n.prim === \"Elt\") {\n          /* istanbul ignore else */\n          if (assertArgs(n, 2)) {\n            assertMichelsonData(n.args[0]);\n            assertMichelsonData(n.args[1]);\n          }\n\n          mapElts++;\n        } else {\n          assertMichelsonData(n);\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (ex_2_1 && !ex_2_1.done && (_a = ex_2.return)) _a.call(ex_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    if (mapElts !== 0 && mapElts !== ex.length) {\n      throw new MichelsonValidationError(ex, \"data entries and map elements can't be intermixed\");\n    }\n\n    return true;\n  }\n\n  if (isPrim(ex)) {\n    switch (ex.prim) {\n      case \"Unit\":\n      case \"True\":\n      case \"False\":\n      case \"None\":\n        assertArgs(ex, 0);\n        break;\n\n      case \"Pair\":\n        /* istanbul ignore else */\n        if (ex.args === undefined || ex.args.length < 2) {\n          throw new MichelsonValidationError(ex, \"at least 2 arguments expected\");\n        }\n\n        try {\n          for (var _c = __values(ex.args), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var a = _d.value;\n            assertMichelsonData(a);\n          }\n        } catch (e_3_1) {\n          e_3 = {\n            error: e_3_1\n          };\n        } finally {\n          try {\n            if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n          } finally {\n            if (e_3) throw e_3.error;\n          }\n        }\n\n        break;\n\n      case \"Left\":\n      case \"Right\":\n      case \"Some\":\n        /* istanbul ignore else */\n        if (assertArgs(ex, 1)) {\n          assertMichelsonData(ex.args[0]);\n        }\n\n        break;\n\n      default:\n        if (Object.prototype.hasOwnProperty.call(instructionIDs, ex.prim)) {\n          assertMichelsonInstruction(ex);\n        } else {\n          throw new MichelsonValidationError(ex, \"data entry or instruction expected\");\n        }\n\n    }\n  } else {\n    throw new MichelsonValidationError(ex, \"data entry expected\");\n  }\n\n  return true;\n}\n/**\r\n * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\n\n\nfunction assertMichelsonContract(ex) {\n  var e_4, _a;\n  /* istanbul ignore else */\n\n\n  if (assertSeq(ex)) {\n    var ent = {};\n\n    try {\n      for (var ex_3 = __values(ex), ex_3_1 = ex_3.next(); !ex_3_1.done; ex_3_1 = ex_3.next()) {\n        var sec = ex_3_1.value;\n\n        if (assertPrim(sec)) {\n          if (sec.prim !== \"code\" && sec.prim !== \"parameter\" && sec.prim !== \"storage\") {\n            throw new MichelsonValidationError(ex, \"unexpected contract section: \" + sec.prim);\n          }\n\n          if (sec.prim in ent) {\n            throw new MichelsonValidationError(ex, \"duplicate contract section: \" + sec.prim);\n          }\n\n          ent[sec.prim] = true;\n          /* istanbul ignore else */\n\n          if (assertArgs(sec, 1)) {\n            switch (sec.prim) {\n              case \"code\":\n                /* istanbul ignore else */\n                if (assertSeq(sec.args[0])) {\n                  assertMichelsonInstruction(sec.args[0]);\n                }\n\n                break;\n\n              case \"parameter\":\n                assertMichelsonPassableType(sec.args[0]);\n                break;\n\n              case \"storage\":\n                assertMichelsonStorableType(sec.args[0]);\n            }\n          }\n        }\n      }\n    } catch (e_4_1) {\n      e_4 = {\n        error: e_4_1\n      };\n    } finally {\n      try {\n        if (ex_3_1 && !ex_3_1.done && (_a = ex_3.return)) _a.call(ex_3);\n      } finally {\n        if (e_4) throw e_4.error;\n      }\n    }\n  }\n\n  return true;\n}\n/**\r\n * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.\r\n * @param ex An AST node\r\n */\n\n\nfunction isMichelsonScript(ex) {\n  try {\n    assertMichelsonContract(ex);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\n/**\r\n * Checks if the node is a valid Michelson data literal such as `(Pair {Elt \"0\" 0} 0)`.\r\n * @param ex An AST node\r\n */\n\n\nfunction isMichelsonData(ex) {\n  try {\n    assertMichelsonData(ex);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\n/**\r\n * Checks if the node is a valid Michelson code (sequence of instructions).\r\n * @param ex An AST node\r\n */\n\n\nfunction isMichelsonCode(ex) {\n  try {\n    assertMichelsonInstruction(ex);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\n/**\r\n * Checks if the node is a valid Michelson type expression.\r\n * @param ex An AST node\r\n */\n\n\nfunction isMichelsonType(ex) {\n  try {\n    assertMichelsonType(ex);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\n\nfunction isInstruction(p) {\n  return Object.prototype.hasOwnProperty.call(instructionIDs, p.prim);\n}\n\nfunction assertDataListIfAny(d) {\n  var e_5, _a;\n\n  if (!Array.isArray(d)) {\n    return false;\n  }\n\n  try {\n    for (var d_1 = __values(d), d_1_1 = d_1.next(); !d_1_1.done; d_1_1 = d_1.next()) {\n      var v = d_1_1.value;\n\n      if (\"prim\" in v) {\n        if (isInstruction(v)) {\n          throw new MichelsonError(d, \"Instruction outside of a lambda: \" + JSON.stringify(d));\n        } else if (v.prim === \"Elt\") {\n          throw new MichelsonError(d, \"Elt item outside of a map literal: \" + JSON.stringify(d));\n        }\n      }\n    }\n  } catch (e_5_1) {\n    e_5 = {\n      error: e_5_1\n    };\n  } finally {\n    try {\n      if (d_1_1 && !d_1_1.done && (_a = d_1.return)) _a.call(d_1);\n    } finally {\n      if (e_5) throw e_5.error;\n    }\n  }\n\n  return true;\n}\n\nvar primitives = [\"parameter\", \"storage\", \"code\", \"False\", \"Elt\", \"Left\", \"None\", \"Pair\", \"Right\", \"Some\", \"True\", \"Unit\", \"PACK\", \"UNPACK\", \"BLAKE2B\", \"SHA256\", \"SHA512\", \"ABS\", \"ADD\", \"AMOUNT\", \"AND\", \"BALANCE\", \"CAR\", \"CDR\", \"CHECK_SIGNATURE\", \"COMPARE\", \"CONCAT\", \"CONS\", \"CREATE_ACCOUNT\", \"CREATE_CONTRACT\", \"IMPLICIT_ACCOUNT\", \"DIP\", \"DROP\", \"DUP\", \"EDIV\", \"EMPTY_MAP\", \"EMPTY_SET\", \"EQ\", \"EXEC\", \"FAILWITH\", \"GE\", \"GET\", \"GT\", \"HASH_KEY\", \"IF\", \"IF_CONS\", \"IF_LEFT\", \"IF_NONE\", \"INT\", \"LAMBDA\", \"LE\", \"LEFT\", \"LOOP\", \"LSL\", \"LSR\", \"LT\", \"MAP\", \"MEM\", \"MUL\", \"NEG\", \"NEQ\", \"NIL\", \"NONE\", \"NOT\", \"NOW\", \"OR\", \"PAIR\", \"PUSH\", \"RIGHT\", \"SIZE\", \"SOME\", \"SOURCE\", \"SENDER\", \"SELF\", \"STEPS_TO_QUOTA\", \"SUB\", \"SWAP\", \"TRANSFER_TOKENS\", \"SET_DELEGATE\", \"UNIT\", \"UPDATE\", \"XOR\", \"ITER\", \"LOOP_LEFT\", \"ADDRESS\", \"CONTRACT\", \"ISNAT\", \"CAST\", \"RENAME\", \"bool\", \"contract\", \"int\", \"key\", \"key_hash\", \"lambda\", \"list\", \"map\", \"big_map\", \"nat\", \"option\", \"or\", \"pair\", \"set\", \"signature\", \"string\", \"bytes\", \"mutez\", \"timestamp\", \"unit\", \"operation\", \"address\", \"SLICE\", \"DIG\", \"DUG\", \"EMPTY_BIG_MAP\", \"APPLY\", \"chain_id\", \"CHAIN_ID\", \"LEVEL\", \"SELF_ADDRESS\", \"never\", \"NEVER\", \"UNPAIR\", \"VOTING_POWER\", \"TOTAL_VOTING_POWER\", \"KECCAK\", \"SHA3\", \"PAIRING_CHECK\", \"bls12_381_g1\", \"bls12_381_g2\", \"bls12_381_fr\", \"sapling_state\", \"sapling_transaction\", \"SAPLING_EMPTY_STATE\", \"SAPLING_VERIFY_UPDATE\", \"ticket\", \"TICKET\", \"READ_TICKET\", \"SPLIT_TICKET\", \"JOIN_TICKETS\", \"GET_AND_UPDATE\"];\nvar primTags = Object.assign.apply(Object, __spreadArray([{}], __read(primitives.map(function (v, i) {\n  var _a;\n\n  return _a = {}, _a[v] = i, _a;\n}))));\nvar Tag;\n\n(function (Tag) {\n  Tag[Tag[\"Int\"] = 0] = \"Int\";\n  Tag[Tag[\"String\"] = 1] = \"String\";\n  Tag[Tag[\"Sequence\"] = 2] = \"Sequence\";\n  Tag[Tag[\"Prim0\"] = 3] = \"Prim0\";\n  Tag[Tag[\"Prim0Annot\"] = 4] = \"Prim0Annot\";\n  Tag[Tag[\"Prim1\"] = 5] = \"Prim1\";\n  Tag[Tag[\"Prim1Annot\"] = 6] = \"Prim1Annot\";\n  Tag[Tag[\"Prim2\"] = 7] = \"Prim2\";\n  Tag[Tag[\"Prim2Annot\"] = 8] = \"Prim2Annot\";\n  Tag[Tag[\"Prim\"] = 9] = \"Prim\";\n  Tag[Tag[\"Bytes\"] = 10] = \"Bytes\";\n})(Tag || (Tag = {}));\n\nvar Writer =\n/** @class */\nfunction () {\n  function Writer() {\n    this.buffer = [];\n  }\n\n  Object.defineProperty(Writer.prototype, \"length\", {\n    get: function () {\n      return this.buffer.length;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Writer.prototype.writeBytes = function (val) {\n    var _a;\n\n    (_a = this.buffer).push.apply(_a, __spreadArray([], __read(val.map(function (v) {\n      return v & 0xff;\n    }))));\n  };\n\n  Writer.prototype.writeUint8 = function (val) {\n    var v = val | 0;\n    this.buffer.push(v & 0xff);\n  };\n\n  Writer.prototype.writeUint16 = function (val) {\n    var v = val | 0;\n    this.buffer.push(v >> 8 & 0xff);\n    this.buffer.push(v & 0xff);\n  };\n\n  Writer.prototype.writeUint32 = function (val) {\n    var v = val | 0;\n    this.buffer.push(v >> 24 & 0xff);\n    this.buffer.push(v >> 16 & 0xff);\n    this.buffer.push(v >> 8 & 0xff);\n    this.buffer.push(v & 0xff);\n  };\n\n  Writer.prototype.writeInt8 = function (val) {\n    this.writeUint8(val);\n  };\n\n  Writer.prototype.writeInt16 = function (val) {\n    this.writeUint16(val);\n  };\n\n  Writer.prototype.writeInt32 = function (val) {\n    this.writeUint32(val);\n  };\n\n  return Writer;\n}();\n\nvar boundsErr = new Error(\"bounds out of range\");\n\nvar Reader =\n/** @class */\nfunction () {\n  function Reader(buffer, idx, cap) {\n    if (idx === void 0) {\n      idx = 0;\n    }\n\n    if (cap === void 0) {\n      cap = buffer.length;\n    }\n\n    this.buffer = buffer;\n    this.idx = idx;\n    this.cap = cap;\n  }\n\n  Object.defineProperty(Reader.prototype, \"length\", {\n    /** Remaining length */\n    get: function () {\n      return this.cap - this.idx;\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Reader.prototype.readBytes = function (len) {\n    if (this.cap - this.idx < len) {\n      throw boundsErr;\n    }\n\n    var ret = this.buffer.slice(this.idx, this.idx + len);\n    this.idx += len;\n    return ret;\n  };\n\n  Reader.prototype.reader = function (len) {\n    if (this.cap - this.idx < len) {\n      throw boundsErr;\n    }\n\n    var ret = new Reader(this.buffer, this.idx, this.idx + len);\n    this.idx += len;\n    return ret;\n  };\n\n  Reader.prototype.copy = function () {\n    return new Reader(this.buffer, this.idx, this.cap);\n  };\n\n  Reader.prototype.readUint8 = function () {\n    if (this.cap - this.idx < 1) {\n      throw boundsErr;\n    }\n\n    return this.buffer[this.idx++] >>> 0;\n  };\n\n  Reader.prototype.readUint16 = function () {\n    if (this.cap - this.idx < 2) {\n      throw boundsErr;\n    }\n\n    var x0 = this.buffer[this.idx++];\n    var x1 = this.buffer[this.idx++];\n    return (x0 << 8 | x1) >>> 0;\n  };\n\n  Reader.prototype.readUint32 = function () {\n    if (this.cap - this.idx < 4) {\n      throw boundsErr;\n    }\n\n    var x0 = this.buffer[this.idx++];\n    var x1 = this.buffer[this.idx++];\n    var x2 = this.buffer[this.idx++];\n    var x3 = this.buffer[this.idx++];\n    return (x0 << 24 | x1 << 16 | x2 << 8 | x3) >>> 0;\n  };\n\n  Reader.prototype.readInt8 = function () {\n    if (this.cap - this.idx < 1) {\n      throw boundsErr;\n    }\n\n    var x = this.buffer[this.idx++];\n    return x << 24 >> 24;\n  };\n\n  Reader.prototype.readInt16 = function () {\n    if (this.cap - this.idx < 2) {\n      throw boundsErr;\n    }\n\n    var x0 = this.buffer[this.idx++];\n    var x1 = this.buffer[this.idx++];\n    return (x0 << 8 | x1) << 16 >> 16;\n  };\n\n  Reader.prototype.readInt32 = function () {\n    if (this.cap - this.idx < 4) {\n      throw boundsErr;\n    }\n\n    var x0 = this.buffer[this.idx++];\n    var x1 = this.buffer[this.idx++];\n    var x2 = this.buffer[this.idx++];\n    var x3 = this.buffer[this.idx++];\n    return x0 << 24 | x1 << 16 | x2 << 8 | x3;\n  };\n\n  return Reader;\n}();\n\nvar ContractID;\n\n(function (ContractID) {\n  ContractID[ContractID[\"Implicit\"] = 0] = \"Implicit\";\n  ContractID[ContractID[\"Originated\"] = 1] = \"Originated\";\n})(ContractID || (ContractID = {}));\n\nvar PublicKeyHashID;\n\n(function (PublicKeyHashID) {\n  PublicKeyHashID[PublicKeyHashID[\"ED25519\"] = 0] = \"ED25519\";\n  PublicKeyHashID[PublicKeyHashID[\"SECP256K1\"] = 1] = \"SECP256K1\";\n  PublicKeyHashID[PublicKeyHashID[\"P256\"] = 2] = \"P256\";\n})(PublicKeyHashID || (PublicKeyHashID = {}));\n\nfunction readPublicKeyHash(rd) {\n  var type;\n  var tag = rd.readUint8();\n\n  switch (tag) {\n    case PublicKeyHashID.ED25519:\n      type = \"ED25519PublicKeyHash\";\n      break;\n\n    case PublicKeyHashID.SECP256K1:\n      type = \"SECP256K1PublicKeyHash\";\n      break;\n\n    case PublicKeyHashID.P256:\n      type = \"P256PublicKeyHash\";\n      break;\n\n    default:\n      throw new Error(\"unknown public key hash tag: \" + tag);\n  }\n\n  return {\n    type: type,\n    hash: rd.readBytes(20)\n  };\n}\n\nfunction readAddress(rd) {\n  var address;\n  var tag = rd.readUint8();\n\n  switch (tag) {\n    case ContractID.Implicit:\n      address = readPublicKeyHash(rd);\n      break;\n\n    case ContractID.Originated:\n      address = {\n        type: \"ContractHash\",\n        hash: rd.readBytes(20)\n      };\n      rd.readBytes(1);\n      break;\n\n    default:\n      throw new Error(\"unknown address tag: \" + tag);\n  }\n\n  if (rd.length !== 0) {\n    // entry point\n    var dec = new TextDecoder();\n    address.entryPoint = dec.decode(new Uint8Array(rd.readBytes(rd.length)));\n  }\n\n  return address;\n}\n\nfunction writePublicKeyHash(a, w) {\n  var tag;\n\n  switch (a.type) {\n    case \"ED25519PublicKeyHash\":\n      tag = PublicKeyHashID.ED25519;\n      break;\n\n    case \"SECP256K1PublicKeyHash\":\n      tag = PublicKeyHashID.SECP256K1;\n      break;\n\n    case \"P256PublicKeyHash\":\n      tag = PublicKeyHashID.P256;\n      break;\n\n    default:\n      throw new Error(\"unexpected address type: \" + a.type);\n  }\n\n  w.writeUint8(tag);\n  w.writeBytes(Array.from(a.hash));\n}\n\nfunction writeAddress(a, w) {\n  if (a.type === \"ContractHash\") {\n    w.writeUint8(ContractID.Originated);\n    w.writeBytes(Array.from(a.hash));\n    w.writeUint8(0);\n  } else {\n    w.writeUint8(ContractID.Implicit);\n    writePublicKeyHash(a, w);\n  }\n\n  if (a.entryPoint !== undefined && a.entryPoint !== \"\" && a.entryPoint !== \"default\") {\n    var enc = new TextEncoder();\n    var bytes = enc.encode(a.entryPoint);\n    w.writeBytes(Array.from(bytes));\n  }\n}\n\nvar PublicKeyID;\n\n(function (PublicKeyID) {\n  PublicKeyID[PublicKeyID[\"ED25519\"] = 0] = \"ED25519\";\n  PublicKeyID[PublicKeyID[\"SECP256K1\"] = 1] = \"SECP256K1\";\n  PublicKeyID[PublicKeyID[\"P256\"] = 2] = \"P256\";\n})(PublicKeyID || (PublicKeyID = {}));\n\nfunction readPublicKey(rd) {\n  var ln;\n  var type;\n  var tag = rd.readUint8();\n\n  switch (tag) {\n    case PublicKeyID.ED25519:\n      type = \"ED25519PublicKey\";\n      ln = 32;\n      break;\n\n    case PublicKeyID.SECP256K1:\n      type = \"SECP256K1PublicKey\";\n      ln = 33;\n      break;\n\n    case PublicKeyID.P256:\n      type = \"P256PublicKey\";\n      ln = 33;\n      break;\n\n    default:\n      throw new Error(\"unknown public key tag: \" + tag);\n  }\n\n  return {\n    type: type,\n    publicKey: rd.readBytes(ln)\n  };\n}\n\nfunction writePublicKey(pk, w) {\n  var tag;\n\n  switch (pk.type) {\n    case \"ED25519PublicKey\":\n      tag = PublicKeyID.ED25519;\n      break;\n\n    case \"SECP256K1PublicKey\":\n      tag = PublicKeyID.SECP256K1;\n      break;\n\n    case \"P256PublicKey\":\n      tag = PublicKeyID.P256;\n      break;\n\n    default:\n      throw new Error(\"unexpected public key type: \" + pk.type);\n  }\n\n  w.writeUint8(tag);\n  w.writeBytes(Array.from(pk.publicKey));\n}\n\nfunction writeExpr(expr, wr, tf) {\n  var e_1, _a, e_2, _b, e_3, _c;\n\n  var _d, _e;\n\n  var _f = __read(tf(expr), 2),\n      e = _f[0],\n      args = _f[1];\n\n  if (Array.isArray(e)) {\n    var w = new Writer();\n\n    try {\n      for (var e_4 = __values(e), e_4_1 = e_4.next(); !e_4_1.done; e_4_1 = e_4.next()) {\n        var v = e_4_1.value;\n        var a = args.next();\n\n        if (a.done) {\n          throw new Error(\"REPORT ME: iterator is done\");\n        }\n\n        writeExpr(v, w, a.value);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (e_4_1 && !e_4_1.done && (_a = e_4.return)) _a.call(e_4);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    wr.writeUint8(Tag.Sequence);\n    wr.writeUint32(w.length);\n    wr.writeBytes(w.buffer);\n    return;\n  }\n\n  if (\"string\" in e) {\n    var enc = new TextEncoder();\n    var bytes = enc.encode(e.string);\n    wr.writeUint8(Tag.String);\n    wr.writeUint32(bytes.length);\n    wr.writeBytes(Array.from(bytes));\n    return;\n  }\n\n  if (\"int\" in e) {\n    wr.writeUint8(Tag.Int);\n    var val = BigInt(e.int);\n    var sign = val < 0;\n\n    if (sign) {\n      val = -val;\n    }\n\n    var i = 0;\n\n    do {\n      var bits = i === 0 ? BigInt(6) : BigInt(7);\n      var byte = val & (BigInt(1) << bits) - BigInt(1);\n      val >>= bits;\n\n      if (val) {\n        byte |= BigInt(0x80);\n      }\n\n      if (i === 0 && sign) {\n        byte |= BigInt(0x40);\n      }\n\n      wr.writeUint8(Number(byte));\n      i++;\n    } while (val);\n\n    return;\n  }\n\n  if (\"bytes\" in e) {\n    var bytes = parseHex(e.bytes);\n    wr.writeUint8(Tag.Bytes);\n    wr.writeUint32(bytes.length);\n    wr.writeBytes(bytes);\n    return;\n  }\n\n  var prim = primTags[e.prim];\n\n  if (prim === undefined) {\n    throw new TypeError(\"Can't encode primary: \" + e.prim);\n  }\n\n  var tag = (((_d = e.args) === null || _d === void 0 ? void 0 : _d.length) || 0) < 3 ? Tag.Prim0 + (((_e = e.args) === null || _e === void 0 ? void 0 : _e.length) || 0) * 2 + (e.annots === undefined || e.annots.length === 0 ? 0 : 1) : Tag.Prim;\n  wr.writeUint8(tag);\n  wr.writeUint8(prim);\n\n  if (e.args !== undefined) {\n    if (e.args.length < 3) {\n      try {\n        for (var _g = __values(e.args), _h = _g.next(); !_h.done; _h = _g.next()) {\n          var v = _h.value;\n          var a = args.next();\n\n          if (a.done) {\n            throw new Error(\"REPORT ME: iterator is done\");\n          }\n\n          writeExpr(v, wr, a.value);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_h && !_h.done && (_b = _g.return)) _b.call(_g);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    } else {\n      var w = new Writer();\n\n      try {\n        for (var _j = __values(e.args), _k = _j.next(); !_k.done; _k = _j.next()) {\n          var v = _k.value;\n          var a = args.next();\n\n          if (a.done) {\n            throw new Error(\"REPORT ME: iterator is done\");\n          }\n\n          writeExpr(v, w, a.value);\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_k && !_k.done && (_c = _j.return)) _c.call(_j);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n\n      wr.writeUint32(w.length);\n      wr.writeBytes(w.buffer);\n    }\n  }\n\n  if (e.annots !== undefined && e.annots.length !== 0) {\n    var enc = new TextEncoder();\n    var bytes = enc.encode(e.annots.join(\" \"));\n    wr.writeUint32(bytes.length);\n    wr.writeBytes(Array.from(bytes));\n  } else if (e.args !== undefined && e.args.length >= 3) {\n    wr.writeUint32(0);\n  }\n}\n\nfunction readExpr(rd, tf) {\n  function passThrough() {\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , readPassThrough];\n\n        case 1:\n          _a.sent();\n\n          return [3\n          /*break*/\n          , 0];\n\n        case 2:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  }\n\n  var _a = __read(tf, 2),\n      args = _a[0],\n      tr = _a[1];\n\n  var tag = rd.readUint8();\n\n  switch (tag) {\n    case Tag.Int:\n      {\n        var buf = [];\n        var byte = void 0;\n\n        do {\n          byte = rd.readInt8();\n          buf.push(byte);\n        } while ((byte & 0x80) !== 0);\n\n        var val = BigInt(0);\n        var sign = false;\n\n        for (var i = buf.length - 1; i >= 0; i--) {\n          var bits = i === 0 ? BigInt(6) : BigInt(7);\n          var byte_1 = BigInt(buf[i]);\n          val <<= bits;\n          val |= byte_1 & (BigInt(1) << bits) - BigInt(1);\n\n          if (i === 0) {\n            sign = !!(byte_1 & BigInt(0x40));\n          }\n        }\n\n        if (sign) {\n          val = -val;\n        }\n\n        return tr({\n          int: String(val)\n        });\n      }\n\n    case Tag.String:\n      {\n        var length_1 = rd.readUint32();\n        var bytes = rd.readBytes(length_1);\n        var dec = new TextDecoder();\n        return tr({\n          string: dec.decode(new Uint8Array(bytes))\n        });\n      }\n\n    case Tag.Bytes:\n      {\n        var length_2 = rd.readUint32();\n        var bytes = rd.readBytes(length_2);\n        var hex = hexBytes(Array.from(bytes));\n        return tr({\n          bytes: hex\n        });\n      }\n\n    case Tag.Sequence:\n      {\n        var length_3 = rd.readUint32();\n        var res = [];\n        var savedrd = rd.copy(); // make two passes\n\n        var it_1 = passThrough();\n\n        for (var n = 0; n < 2; n++) {\n          var r = savedrd.reader(length_3);\n          res = [];\n\n          while (r.length > 0) {\n            var a = it_1.next();\n\n            if (a.done) {\n              throw new Error(\"REPORT ME: iterator is done\");\n            }\n\n            res.push(readExpr(r, a.value));\n          } // make a second pass with injected side effects\n\n\n          it_1 = args(res);\n          savedrd = rd;\n        }\n\n        return tr(res);\n      }\n\n    default:\n      {\n        if (tag > 9) {\n          throw new Error(\"Unknown tag: \" + tag);\n        }\n\n        var p = rd.readUint8();\n\n        if (p >= primitives.length) {\n          throw new Error(\"Unknown primitive tag: \" + p);\n        }\n\n        var prim = primitives[p];\n        var argn = tag - 3 >> 1;\n        var res = {\n          prim: prim\n        }; // make two passes\n\n        var it_2 = passThrough();\n        var savedrd = rd.copy();\n\n        for (var n = 0; n < 2; n++) {\n          res = {\n            prim: prim\n          };\n\n          if (argn < 3) {\n            for (var i = 0; i < argn; i++) {\n              var a = it_2.next();\n\n              if (a.done) {\n                throw new Error(\"REPORT ME: iterator is done\");\n              }\n\n              res.args = res.args || [];\n              res.args.push(readExpr(savedrd, a.value));\n            }\n          } else {\n            res.args = res.args || [];\n            var length_4 = savedrd.readUint32();\n            var r = savedrd.reader(length_4);\n\n            while (r.length > 0) {\n              var a = it_2.next();\n\n              if (a.done) {\n                throw new Error(\"REPORT ME: iterator is done\");\n              }\n\n              res.args.push(readExpr(r, a.value));\n            }\n          } // make a second pass with injected side effects\n\n\n          it_2 = args(res);\n          savedrd = rd;\n        }\n\n        if ((tag - 3 & 1) === 1 || argn === 3) {\n          // read annotations\n          var length_5 = rd.readUint32();\n\n          if (length_5 !== 0) {\n            var bytes = rd.readBytes(length_5);\n            var dec = new TextDecoder();\n            res.annots = dec.decode(new Uint8Array(bytes)).split(\" \");\n          }\n        }\n\n        return tr(res);\n      }\n  }\n}\n\nvar isOrData = function (e) {\n  return \"prim\" in e && (e.prim === \"Left\" || e.prim === \"Right\");\n};\n\nvar isOptionData = function (e) {\n  return \"prim\" in e && (e.prim === \"Some\" || e.prim === \"None\");\n};\n\nvar getWriteTransformFunc = function (t) {\n  if (isPairType(t)) {\n    return function (d) {\n      if (!isPairData(d)) {\n        throw new MichelsonTypeError(t, d, \"pair expected: \" + JSON.stringify(d));\n      }\n\n      assertDataListIfAny(d); // combs aren't used in pack format\n\n      var tc = unpackComb(\"pair\", t);\n      var dc = unpackComb(\"Pair\", d);\n      return [dc, function () {\n        var _a, _b, a, e_5_1;\n\n        var e_5, _c;\n\n        return __generator(this, function (_d) {\n          switch (_d.label) {\n            case 0:\n              _d.trys.push([0, 5, 6, 7]);\n\n              _a = __values(tc.args), _b = _a.next();\n              _d.label = 1;\n\n            case 1:\n              if (!!_b.done) return [3\n              /*break*/\n              , 4];\n              a = _b.value;\n              return [4\n              /*yield*/\n              , getWriteTransformFunc(a)];\n\n            case 2:\n              _d.sent();\n\n              _d.label = 3;\n\n            case 3:\n              _b = _a.next();\n              return [3\n              /*break*/\n              , 1];\n\n            case 4:\n              return [3\n              /*break*/\n              , 7];\n\n            case 5:\n              e_5_1 = _d.sent();\n              e_5 = {\n                error: e_5_1\n              };\n              return [3\n              /*break*/\n              , 7];\n\n            case 6:\n              try {\n                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n              } finally {\n                if (e_5) throw e_5.error;\n              }\n\n              return [7\n              /*endfinally*/\n              ];\n\n            case 7:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      }()];\n    };\n  }\n\n  switch (t.prim) {\n    case \"or\":\n      return function (d) {\n        if (!isOrData(d)) {\n          throw new MichelsonTypeError(t, d, \"or expected: \" + JSON.stringify(d));\n        }\n\n        return [d, function () {\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                return [4\n                /*yield*/\n                , getWriteTransformFunc(t.args[d.prim === \"Left\" ? 0 : 1])];\n\n              case 1:\n                _a.sent();\n\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        }()];\n      };\n\n    case \"option\":\n      return function (d) {\n        if (!isOptionData(d)) {\n          throw new MichelsonTypeError(t, d, \"option expected: \" + JSON.stringify(d));\n        }\n\n        return [d, function () {\n          var dd;\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                dd = d;\n                if (!(dd.prim === \"Some\")) return [3\n                /*break*/\n                , 2];\n                return [4\n                /*yield*/\n                , getWriteTransformFunc(t.args[0])];\n\n              case 1:\n                _a.sent();\n\n                _a.label = 2;\n\n              case 2:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        }()];\n      };\n\n    case \"list\":\n    case \"set\":\n      return function (d) {\n        if (!Array.isArray(d)) {\n          throw new MichelsonTypeError(t, d, t.prim + \" expected: \" + JSON.stringify(d));\n        }\n\n        return [d, function () {\n          var d_1, d_1_1, e_6_1;\n\n          var e_6, _a;\n\n          return __generator(this, function (_b) {\n            switch (_b.label) {\n              case 0:\n                _b.trys.push([0, 5, 6, 7]);\n\n                d_1 = __values(d), d_1_1 = d_1.next();\n                _b.label = 1;\n\n              case 1:\n                if (!!d_1_1.done) return [3\n                /*break*/\n                , 4];\n                return [4\n                /*yield*/\n                , getWriteTransformFunc(t.args[0])];\n\n              case 2:\n                _b.sent();\n\n                _b.label = 3;\n\n              case 3:\n                d_1_1 = d_1.next();\n                return [3\n                /*break*/\n                , 1];\n\n              case 4:\n                return [3\n                /*break*/\n                , 7];\n\n              case 5:\n                e_6_1 = _b.sent();\n                e_6 = {\n                  error: e_6_1\n                };\n                return [3\n                /*break*/\n                , 7];\n\n              case 6:\n                try {\n                  if (d_1_1 && !d_1_1.done && (_a = d_1.return)) _a.call(d_1);\n                } finally {\n                  if (e_6) throw e_6.error;\n                }\n\n                return [7\n                /*endfinally*/\n                ];\n\n              case 7:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        }()];\n      };\n\n    case \"map\":\n      return function (d) {\n        if (!Array.isArray(d)) {\n          throw new MichelsonTypeError(t, d, \"map expected: \" + JSON.stringify(d));\n        }\n\n        return [d, function () {\n          var d_2, d_2_1, e_7_1;\n\n          var e_7, _a;\n\n          return __generator(this, function (_b) {\n            switch (_b.label) {\n              case 0:\n                _b.trys.push([0, 5, 6, 7]);\n\n                d_2 = __values(d), d_2_1 = d_2.next();\n                _b.label = 1;\n\n              case 1:\n                if (!!d_2_1.done) return [3\n                /*break*/\n                , 4];\n                return [4\n                /*yield*/\n                , function (elt) {\n                  if (!(\"prim\" in elt) || elt.prim !== \"Elt\") {\n                    throw new MichelsonTypeError(t, elt, \"map element expected: \" + JSON.stringify(elt));\n                  }\n\n                  return [elt, function () {\n                    var _a, _b, a, e_8_1;\n\n                    var e_8, _c;\n\n                    return __generator(this, function (_d) {\n                      switch (_d.label) {\n                        case 0:\n                          _d.trys.push([0, 5, 6, 7]);\n\n                          _a = __values(t.args), _b = _a.next();\n                          _d.label = 1;\n\n                        case 1:\n                          if (!!_b.done) return [3\n                          /*break*/\n                          , 4];\n                          a = _b.value;\n                          return [4\n                          /*yield*/\n                          , getWriteTransformFunc(a)];\n\n                        case 2:\n                          _d.sent();\n\n                          _d.label = 3;\n\n                        case 3:\n                          _b = _a.next();\n                          return [3\n                          /*break*/\n                          , 1];\n\n                        case 4:\n                          return [3\n                          /*break*/\n                          , 7];\n\n                        case 5:\n                          e_8_1 = _d.sent();\n                          e_8 = {\n                            error: e_8_1\n                          };\n                          return [3\n                          /*break*/\n                          , 7];\n\n                        case 6:\n                          try {\n                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n                          } finally {\n                            if (e_8) throw e_8.error;\n                          }\n\n                          return [7\n                          /*endfinally*/\n                          ];\n\n                        case 7:\n                          return [2\n                          /*return*/\n                          ];\n                      }\n                    });\n                  }()];\n                }];\n\n              case 2:\n                _b.sent();\n\n                _b.label = 3;\n\n              case 3:\n                d_2_1 = d_2.next();\n                return [3\n                /*break*/\n                , 1];\n\n              case 4:\n                return [3\n                /*break*/\n                , 7];\n\n              case 5:\n                e_7_1 = _b.sent();\n                e_7 = {\n                  error: e_7_1\n                };\n                return [3\n                /*break*/\n                , 7];\n\n              case 6:\n                try {\n                  if (d_2_1 && !d_2_1.done && (_a = d_2.return)) _a.call(d_2);\n                } finally {\n                  if (e_7) throw e_7.error;\n                }\n\n                return [7\n                /*endfinally*/\n                ];\n\n              case 7:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        }()];\n      };\n\n    case \"chain_id\":\n      return function (d) {\n        if (!(\"bytes\" in d) && !(\"string\" in d)) {\n          throw new MichelsonTypeError(t, d, \"chain id expected: \" + JSON.stringify(d));\n        }\n\n        var bytes;\n\n        if (\"string\" in d) {\n          var id = checkDecodeTezosID(d.string, \"ChainID\");\n\n          if (id === null) {\n            throw new MichelsonTypeError(t, d, \"chain id base58 expected: \" + d.string);\n          }\n\n          bytes = {\n            bytes: hexBytes(id[1])\n          };\n        } else {\n          bytes = d;\n        }\n\n        return [bytes, [][Symbol.iterator]()];\n      };\n\n    case \"signature\":\n      return function (d) {\n        if (!(\"bytes\" in d) && !(\"string\" in d)) {\n          throw new MichelsonTypeError(t, d, \"signature expected: \" + JSON.stringify(d));\n        }\n\n        var bytes;\n\n        if (\"string\" in d) {\n          var sig = checkDecodeTezosID(d.string, \"ED25519Signature\", \"SECP256K1Signature\", \"P256Signature\", \"GenericSignature\");\n\n          if (sig === null) {\n            throw new MichelsonTypeError(t, d, \"signature base58 expected: \" + d.string);\n          }\n\n          bytes = {\n            bytes: hexBytes(sig[1])\n          };\n        } else {\n          bytes = d;\n        }\n\n        return [bytes, [][Symbol.iterator]()];\n      };\n\n    case \"key_hash\":\n      return function (d) {\n        if (!(\"bytes\" in d) && !(\"string\" in d)) {\n          throw new MichelsonTypeError(t, d, \"key hash expected: \" + JSON.stringify(d));\n        }\n\n        var bytes;\n\n        if (\"string\" in d) {\n          var pkh = checkDecodeTezosID(d.string, \"ED25519PublicKeyHash\", \"SECP256K1PublicKeyHash\", \"P256PublicKeyHash\");\n\n          if (pkh === null) {\n            throw new MichelsonTypeError(t, d, \"key hash base58 expected: \" + d.string);\n          }\n\n          var w = new Writer();\n          writePublicKeyHash({\n            type: pkh[0],\n            hash: pkh[1]\n          }, w);\n          bytes = {\n            bytes: hexBytes(w.buffer)\n          };\n        } else {\n          bytes = d;\n        }\n\n        return [bytes, [][Symbol.iterator]()];\n      };\n\n    case \"key\":\n      return function (d) {\n        if (!(\"bytes\" in d) && !(\"string\" in d)) {\n          throw new MichelsonTypeError(t, d, \"public key expected: \" + JSON.stringify(d));\n        }\n\n        var bytes;\n\n        if (\"string\" in d) {\n          var key = checkDecodeTezosID(d.string, \"ED25519PublicKey\", \"SECP256K1PublicKey\", \"P256PublicKey\");\n\n          if (key === null) {\n            throw new MichelsonTypeError(t, d, \"public key base58 expected: \" + d.string);\n          }\n\n          var w = new Writer();\n          writePublicKey({\n            type: key[0],\n            publicKey: key[1]\n          }, w);\n          bytes = {\n            bytes: hexBytes(w.buffer)\n          };\n        } else {\n          bytes = d;\n        }\n\n        return [bytes, [][Symbol.iterator]()];\n      };\n\n    case \"address\":\n      return function (d) {\n        if (!(\"bytes\" in d) && !(\"string\" in d)) {\n          throw new MichelsonTypeError(t, d, \"address expected: \" + JSON.stringify(d));\n        }\n\n        var bytes;\n\n        if (\"string\" in d) {\n          var s = d.string.split(\"%\");\n          var address = checkDecodeTezosID(s[0], \"ED25519PublicKeyHash\", \"SECP256K1PublicKeyHash\", \"P256PublicKeyHash\", \"ContractHash\");\n\n          if (address === null) {\n            throw new MichelsonTypeError(t, d, \"address base58 expected: \" + d.string);\n          }\n\n          var w = new Writer();\n          writeAddress({\n            type: address[0],\n            hash: address[1],\n            entryPoint: s.length > 1 ? s[1] : undefined\n          }, w);\n          bytes = {\n            bytes: hexBytes(w.buffer)\n          };\n        } else {\n          bytes = d;\n        }\n\n        return [bytes, [][Symbol.iterator]()];\n      };\n\n    case \"timestamp\":\n      return function (d) {\n        if (!(\"string\" in d) && !(\"int\" in d)) {\n          throw new MichelsonTypeError(t, d, \"timestamp expected: \" + JSON.stringify(d));\n        }\n\n        var int;\n\n        if (\"string\" in d) {\n          var p = parseDate(d);\n\n          if (p === null) {\n            throw new MichelsonTypeError(t, d, \"can't parse date: \" + d.string);\n          }\n\n          int = {\n            int: String(Math.floor(p.getTime() / 1000))\n          };\n        } else {\n          int = d;\n        }\n\n        return [int, [][Symbol.iterator]()];\n      };\n\n    default:\n      return writePassThrough;\n  }\n};\n\nvar isPushInstruction = function (e) {\n  return \"prim\" in e && e.prim === \"PUSH\";\n};\n\nvar writePassThrough = function (e) {\n  if (isPushInstruction(e)) {\n    assertMichelsonInstruction(e); // capture inlined type definition\n\n    return [e, function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , writePassThrough];\n\n          case 1:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , getWriteTransformFunc(e.args[0])];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    }()];\n  }\n\n  return [e, function () {\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , writePassThrough];\n\n        case 1:\n          _a.sent();\n\n          return [3\n          /*break*/\n          , 0];\n\n        case 2:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  }()];\n};\n/**\r\n * Serializes any value of packable type to its optimized binary representation\r\n * identical to the one used by PACK and UNPACK Michelson instructions.\r\n * Without a type definition (not recommended) the data will be encoded as a binary form of a generic Michelson expression.\r\n * Type definition allows some types like `timestamp` and `address` and other base58 representable types to be encoded to\r\n * corresponding optimized binary forms borrowed from the Tezos protocol\r\n *\r\n * ```typescript\r\n * const data: MichelsonData = {\r\n *     string: \"KT1RvkwF4F7pz1gCoxkyZrG1RkrxQy3gmFTv%foo\"\r\n * };\r\n *\r\n * const typ: MichelsonType = {\r\n *     prim: \"address\"\r\n * };\r\n *\r\n * const packed = packData(data, typ);\r\n *\r\n * // 050a0000001901be41ee922ddd2cf33201e49d32da0afec571dce300666f6f\r\n * ```\r\n *\r\n * Without a type definition the base58 encoded address will be treated as a string\r\n * ```typescript\r\n * const data: MichelsonData = {\r\n *     string: \"KT1RvkwF4F7pz1gCoxkyZrG1RkrxQy3gmFTv%foo\"\r\n * };\r\n *\r\n * const packed = packData(data);\r\n *\r\n * // 0501000000284b543152766b7746344637707a3167436f786b795a724731526b7278517933676d46547625666f6f\r\n * ```\r\n * @param d Data object\r\n * @param t Optional type definition\r\n * @returns Binary representation as numeric array\r\n */\n\n\nfunction packData(d, t) {\n  var w = new Writer();\n  w.writeUint8(5);\n  writeExpr(d, w, t !== undefined ? getWriteTransformFunc(t) : writePassThrough);\n  return w.buffer;\n}\n/**\r\n * Serializes any value of packable type to its optimized binary representation\r\n * identical to the one used by PACK and UNPACK Michelson instructions.\r\n * Same as {@link packData} but returns a `bytes` Michelson data literal instead of an array\r\n *\r\n * ```typescript\r\n * const data: MichelsonData = {\r\n *     string: \"2019-09-26T10:59:51Z\"\r\n * };\r\n *\r\n * const typ: MichelsonType = {\r\n *     prim: \"timestamp\"\r\n * };\r\n *\r\n * const packed = packDataBytes(data, typ);\r\n *\r\n * // { bytes: \"0500a7e8e4d80b\" }\r\n * ```\r\n * @param d Data object\r\n * @param t Optional type definition\r\n * @returns Binary representation as a bytes literal\r\n */\n\n\nfunction packDataBytes(d, t) {\n  return {\n    bytes: hexBytes(packData(d, t))\n  };\n}\n\nvar getReadTransformFuncs = function (t) {\n  if (isPairType(t)) {\n    var args_1 = Array.isArray(t) ? t : t.args;\n    return [function (d) {\n      if (!isPairData(d)) {\n        throw new MichelsonTypeError(t, d, \"pair expected: \" + JSON.stringify(d));\n      }\n\n      return function () {\n        var args_2, args_2_1, a, e_9_1;\n\n        var e_9, _a;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              _b.trys.push([0, 5, 6, 7]);\n\n              args_2 = __values(args_1), args_2_1 = args_2.next();\n              _b.label = 1;\n\n            case 1:\n              if (!!args_2_1.done) return [3\n              /*break*/\n              , 4];\n              a = args_2_1.value;\n              return [4\n              /*yield*/\n              , getReadTransformFuncs(a)];\n\n            case 2:\n              _b.sent();\n\n              _b.label = 3;\n\n            case 3:\n              args_2_1 = args_2.next();\n              return [3\n              /*break*/\n              , 1];\n\n            case 4:\n              return [3\n              /*break*/\n              , 7];\n\n            case 5:\n              e_9_1 = _b.sent();\n              e_9 = {\n                error: e_9_1\n              };\n              return [3\n              /*break*/\n              , 7];\n\n            case 6:\n              try {\n                if (args_2_1 && !args_2_1.done && (_a = args_2.return)) _a.call(args_2);\n              } finally {\n                if (e_9) throw e_9.error;\n              }\n\n              return [7\n              /*endfinally*/\n              ];\n\n            case 7:\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      }();\n    }, function (d) {\n      return d;\n    }];\n  }\n\n  switch (t.prim) {\n    case \"or\":\n      return [function (d) {\n        if (!isOrData(d)) {\n          throw new MichelsonTypeError(t, d, \"or expected: \" + JSON.stringify(d));\n        }\n\n        return function () {\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                return [4\n                /*yield*/\n                , getReadTransformFuncs(t.args[d.prim === \"Left\" ? 0 : 1])];\n\n              case 1:\n                _a.sent();\n\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        }();\n      }, function (d) {\n        return d;\n      }];\n\n    case \"option\":\n      return [function (d) {\n        if (!isOptionData(d)) {\n          throw new MichelsonTypeError(t, d, \"option expected: \" + JSON.stringify(d));\n        }\n\n        return function () {\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                if (!(d.prim === \"Some\")) return [3\n                /*break*/\n                , 2];\n                return [4\n                /*yield*/\n                , getReadTransformFuncs(t.args[0])];\n\n              case 1:\n                _a.sent();\n\n                _a.label = 2;\n\n              case 2:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        }();\n      }, function (d) {\n        return d;\n      }];\n\n    case \"list\":\n    case \"set\":\n      return [function (d) {\n        if (!Array.isArray(d)) {\n          throw new MichelsonTypeError(t, d, t.prim + \" expected: \" + JSON.stringify(d));\n        }\n\n        return function () {\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                return [4\n                /*yield*/\n                , getReadTransformFuncs(t.args[0])];\n\n              case 1:\n                _a.sent();\n\n                return [3\n                /*break*/\n                , 0];\n\n              case 2:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        }();\n      }, function (d) {\n        return d;\n      }];\n\n    case \"map\":\n      return [function (d) {\n        if (!Array.isArray(d)) {\n          throw new MichelsonTypeError(t, d, \"map expected: \" + JSON.stringify(d));\n        }\n\n        return function () {\n          return __generator(this, function (_a) {\n            switch (_a.label) {\n              case 0:\n                return [4\n                /*yield*/\n                , [function (elt) {\n                  if (!(\"prim\" in elt) || elt.prim !== \"Elt\") {\n                    throw new MichelsonTypeError(t, elt, \"map element expected: \" + JSON.stringify(elt));\n                  }\n\n                  return function () {\n                    var _a, _b, a, e_10_1;\n\n                    var e_10, _c;\n\n                    return __generator(this, function (_d) {\n                      switch (_d.label) {\n                        case 0:\n                          _d.trys.push([0, 5, 6, 7]);\n\n                          _a = __values(t.args), _b = _a.next();\n                          _d.label = 1;\n\n                        case 1:\n                          if (!!_b.done) return [3\n                          /*break*/\n                          , 4];\n                          a = _b.value;\n                          return [4\n                          /*yield*/\n                          , getReadTransformFuncs(a)];\n\n                        case 2:\n                          _d.sent();\n\n                          _d.label = 3;\n\n                        case 3:\n                          _b = _a.next();\n                          return [3\n                          /*break*/\n                          , 1];\n\n                        case 4:\n                          return [3\n                          /*break*/\n                          , 7];\n\n                        case 5:\n                          e_10_1 = _d.sent();\n                          e_10 = {\n                            error: e_10_1\n                          };\n                          return [3\n                          /*break*/\n                          , 7];\n\n                        case 6:\n                          try {\n                            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);\n                          } finally {\n                            if (e_10) throw e_10.error;\n                          }\n\n                          return [7\n                          /*endfinally*/\n                          ];\n\n                        case 7:\n                          return [2\n                          /*return*/\n                          ];\n                      }\n                    });\n                  }();\n                }, function (elt) {\n                  return elt;\n                }]];\n\n              case 1:\n                _a.sent();\n\n                return [3\n                /*break*/\n                , 0];\n\n              case 2:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        }();\n      }, function (d) {\n        return d;\n      }];\n\n    case \"chain_id\":\n      return [function () {\n        return [][Symbol.iterator]();\n      }, function (d) {\n        if (!(\"bytes\" in d) && !(\"string\" in d)) {\n          throw new MichelsonTypeError(t, d, \"chain id expected: \" + JSON.stringify(d));\n        }\n\n        if (\"string\" in d) {\n          return d;\n        }\n\n        var bytes = parseBytes(d.bytes);\n\n        if (bytes === null) {\n          throw new MichelsonTypeError(t, d, \"can't parse bytes: \" + d.bytes);\n        }\n\n        return {\n          string: encodeTezosID(\"ChainID\", bytes)\n        };\n      }];\n\n    case \"signature\":\n      return [function () {\n        return [][Symbol.iterator]();\n      }, function (d) {\n        if (!(\"bytes\" in d) && !(\"string\" in d)) {\n          throw new MichelsonTypeError(t, d, \"signature expected: \" + JSON.stringify(d));\n        }\n\n        if (\"string\" in d) {\n          return d;\n        }\n\n        var bytes = parseBytes(d.bytes);\n\n        if (bytes === null) {\n          throw new MichelsonTypeError(t, d, \"can't parse bytes: \" + d.bytes);\n        }\n\n        return {\n          string: encodeTezosID(\"GenericSignature\", bytes)\n        };\n      }];\n\n    case \"key_hash\":\n      return [function () {\n        return [][Symbol.iterator]();\n      }, function (d) {\n        if (!(\"bytes\" in d) && !(\"string\" in d)) {\n          throw new MichelsonTypeError(t, d, \"key hash expected: \" + JSON.stringify(d));\n        }\n\n        if (\"string\" in d) {\n          return d;\n        }\n\n        var bytes = parseBytes(d.bytes);\n\n        if (bytes === null) {\n          throw new MichelsonTypeError(t, d, \"can't parse bytes: \" + d.bytes);\n        }\n\n        var rd = new Reader(new Uint8Array(bytes));\n        var addr = readPublicKeyHash(rd);\n        return {\n          string: encodeTezosID(addr.type, addr.hash) + (addr.entryPoint ? \"%\" + addr.entryPoint : \"\")\n        };\n      }];\n\n    case \"key\":\n      return [function () {\n        return [][Symbol.iterator]();\n      }, function (d) {\n        if (!(\"bytes\" in d) && !(\"string\" in d)) {\n          throw new MichelsonTypeError(t, d, \"public key expected: \" + JSON.stringify(d));\n        }\n\n        if (\"string\" in d) {\n          return d;\n        }\n\n        var bytes = parseBytes(d.bytes);\n\n        if (bytes === null) {\n          throw new MichelsonTypeError(t, d, \"can't parse bytes: \" + d.bytes);\n        }\n\n        var rd = new Reader(new Uint8Array(bytes));\n        var pk = readPublicKey(rd);\n        return {\n          string: encodeTezosID(pk.type, pk.publicKey)\n        };\n      }];\n\n    case \"address\":\n      return [function () {\n        return [][Symbol.iterator]();\n      }, function (d) {\n        if (!(\"bytes\" in d) && !(\"string\" in d)) {\n          throw new MichelsonTypeError(t, d, \"address expected: \" + JSON.stringify(d));\n        }\n\n        if (\"string\" in d) {\n          return d;\n        }\n\n        var bytes = parseBytes(d.bytes);\n\n        if (bytes === null) {\n          throw new MichelsonTypeError(t, d, \"can't parse bytes: \" + d.bytes);\n        }\n\n        var rd = new Reader(new Uint8Array(bytes));\n        var addr = readAddress(rd);\n        return {\n          string: encodeTezosID(addr.type, addr.hash) + (addr.entryPoint ? \"%\" + addr.entryPoint : \"\")\n        };\n      }];\n\n    case \"timestamp\":\n      return [function () {\n        return [][Symbol.iterator]();\n      }, function (d) {\n        if (!(\"int\" in d) && !(\"string\" in d)) {\n          throw new MichelsonTypeError(t, d, \"address expected: \" + JSON.stringify(d));\n        }\n\n        if (\"string\" in d) {\n          return d;\n        }\n\n        var date = new Date(parseInt(d.int, 10) * 1000);\n        return {\n          string: date.toISOString().slice(0, 19) + \"Z\"\n        };\n      }];\n\n    default:\n      return readPassThrough;\n  }\n};\n\nvar readPassThrough = [function (e) {\n  if (isPushInstruction(e)) {\n    assertMichelsonInstruction(e); // capture inlined type definition\n\n    return function () {\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , readPassThrough];\n\n          case 1:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , getReadTransformFuncs(e.args[0])];\n\n          case 2:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    }();\n  }\n\n  return function () {\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          return [4\n          /*yield*/\n          , readPassThrough];\n\n        case 1:\n          _a.sent();\n\n          return [3\n          /*break*/\n          , 0];\n\n        case 2:\n          return [2\n          /*return*/\n          ];\n      }\n    });\n  }();\n}, function (e) {\n  return e;\n}];\n/**\r\n * Deserialize a byte array into the corresponding Michelson value.\r\n * Without a type definition (not recommended) the binary data will be treated as a binary form of a generic Michelson expression and returned as is.\r\n * Type definition allows some types like `timestamp` and `address` and other types usually encoded in optimized binary forms to be transformed\r\n * back to their string representations like base58 and ISO timestamps.\r\n *\r\n * ```typescript\r\n * const src = [0x05, 0x00, 0xa7, 0xe8, 0xe4, 0xd8, 0x0b];\r\n *\r\n * const typ: MichelsonType = {\r\n *     prim: \"timestamp\"\r\n * };\r\n *\r\n * const data = unpackData(src, typ);\r\n *\r\n * // { string: \"2019-09-26T10:59:51Z\" }\r\n * ```\r\n *\r\n * Same binary data without a type definition\r\n * ```typescript\r\n * const src = [0x05, 0x00, 0xa7, 0xe8, 0xe4, 0xd8, 0x0b];\r\n *\r\n * const data = unpackData(src);\r\n *\r\n * // { int: \"1569495591\" }\r\n * ```\r\n * @param src Byte array\r\n * @param t Optional type definition\r\n * @returns Deserialized data\r\n */\n\nfunction unpackData(src, t) {\n  var r = new Reader(src);\n\n  if (r.readUint8() !== 5) {\n    throw new Error(\"incorrect packed data magic number\");\n  }\n\n  var ex = readExpr(r, t !== undefined ? getReadTransformFuncs(t) : readPassThrough);\n\n  if (assertMichelsonData(ex)) {\n    return ex;\n  }\n\n  throw new Error(); // never\n}\n/**\r\n * Deserialize a byte array into the corresponding Michelson value.\r\n * Same as {@link unpackData} but takes a `bytes` Michelson data literal instead of an array\r\n *\r\n * ```typescript\r\n * const src = { bytes: \"0500a7e8e4d80b\" };\r\n *\r\n * const typ: MichelsonType = {\r\n *     prim: \"timestamp\"\r\n * };\r\n *\r\n * const data = unpackDataBytes(src, typ);\r\n *\r\n * // { string: \"2019-09-26T10:59:51Z\" }\r\n * ```\r\n * @param src Bytes object\r\n * @param t Optional type definition\r\n * @returns Deserialized data\r\n */\n\n\nfunction unpackDataBytes(src, t) {\n  var bytes = parseBytes(src.bytes);\n\n  if (bytes === null) {\n    throw new Error(\"can't parse bytes: \\\"\" + src.bytes + \"\\\"\");\n  }\n\n  return unpackData(bytes, t);\n} // helper functions also used by validator\n\n\nfunction decodeAddressBytes(b) {\n  var bytes = parseBytes(b.bytes);\n\n  if (bytes === null) {\n    throw new Error(\"can't parse bytes: \\\"\" + b.bytes + \"\\\"\");\n  }\n\n  var rd = new Reader(new Uint8Array(bytes));\n  return readAddress(rd);\n}\n\nfunction decodePublicKeyHashBytes(b) {\n  var bytes = parseBytes(b.bytes);\n\n  if (bytes === null) {\n    throw new Error(\"can't parse bytes: \\\"\" + b.bytes + \"\\\"\");\n  }\n\n  var rd = new Reader(new Uint8Array(bytes));\n  return readPublicKeyHash(rd);\n}\n\nfunction decodePublicKeyBytes(b) {\n  var bytes = parseBytes(b.bytes);\n\n  if (bytes === null) {\n    throw new Error(\"can't parse bytes: \\\"\" + b.bytes + \"\\\"\");\n  }\n\n  var rd = new Reader(new Uint8Array(bytes));\n  return readPublicKey(rd);\n}\n\nvar MichelsonInstructionError =\n/** @class */\nfunction (_super) {\n  __extends(MichelsonInstructionError, _super);\n  /**\r\n   * @param val Value of a type node caused the error\r\n   * @param stackState Current stack state\r\n   * @param message An error message\r\n   */\n\n\n  function MichelsonInstructionError(val, stackState, message) {\n    var _this = _super.call(this, val, message) || this;\n\n    _this.stackState = stackState;\n    Object.setPrototypeOf(_this, MichelsonInstructionError.prototype);\n    return _this;\n  }\n\n  return MichelsonInstructionError;\n}(MichelsonError); // 'sequence as a pair' edo syntax helpers\n\n\nfunction typeID(t) {\n  return Array.isArray(t) ? \"pair\" : t.prim;\n}\n\nfunction typeArgs(t) {\n  return \"prim\" in t ? t.args : t;\n}\n\nfunction assertScalarTypesEqual(a, b, field) {\n  if (field === void 0) {\n    field = false;\n  }\n\n  if (typeID(a) !== typeID(b)) {\n    throw new MichelsonTypeError(a, undefined, \"types mismatch: \" + typeID(a) + \" != \" + typeID(b));\n  }\n\n  var ann = [unpackAnnotations(a), unpackAnnotations(b)];\n\n  if (ann[0].t && ann[1].t && ann[0].t[0] !== ann[1].t[0]) {\n    throw new MichelsonTypeError(a, undefined, typeID(a) + \": type names mismatch: \" + ann[0].t[0] + \" != \" + ann[1].t[0]);\n  }\n\n  if (field && ann[0].f && ann[1].f && ann[0].f[0] !== ann[1].f[0]) {\n    throw new MichelsonTypeError(a, undefined, typeID(a) + \": field names mismatch: \" + ann[0].f[0] + \" != \" + ann[1].f);\n  }\n\n  if (isPairType(a)) {\n    var aArgs = unpackComb(\"pair\", a);\n    var bArgs = unpackComb(\"pair\", b);\n    assertScalarTypesEqual(aArgs.args[0], bArgs.args[0], true);\n    assertScalarTypesEqual(aArgs.args[1], bArgs.args[1], true);\n    return;\n  }\n\n  switch (a.prim) {\n    case \"option\":\n    case \"list\":\n    case \"contract\":\n    case \"set\":\n    case \"ticket\":\n      assertScalarTypesEqual(a.args[0], b.args[0]);\n      break;\n\n    case \"or\":\n      assertScalarTypesEqual(a.args[0], b.args[0], true);\n      assertScalarTypesEqual(a.args[1], b.args[1], true);\n      break;\n\n    case \"lambda\":\n    case \"map\":\n    case \"big_map\":\n      assertScalarTypesEqual(a.args[0], b.args[0]);\n      assertScalarTypesEqual(a.args[1], b.args[1]);\n      break;\n\n    case \"sapling_state\":\n    case \"sapling_transaction\":\n      if (parseInt(a.args[0].int, 10) !== parseInt(b.args[0].int, 10)) {\n        throw new MichelsonTypeError(a, undefined, typeID(a) + \": type argument mismatch: \" + a.args[0].int + \" != \" + b.args[0].int);\n      }\n\n  }\n}\n\nfunction assertStacksEqual(a, b) {\n  if (a.length !== b.length) {\n    throw new MichelsonTypeError(a, undefined, \"stack length mismatch: \" + a.length + \" != \" + b.length);\n  }\n\n  for (var i = 0; i < a.length; i++) {\n    assertScalarTypesEqual(a[i], b[i]);\n  }\n}\n\nfunction assertTypeAnnotationsValid(t, field) {\n  var e_1, _a, e_2, _b;\n\n  var _c, _d, _e;\n\n  if (field === void 0) {\n    field = false;\n  }\n\n  if (!Array.isArray(t)) {\n    var ann = unpackAnnotations(t);\n\n    if ((((_c = ann.t) === null || _c === void 0 ? void 0 : _c.length) || 0) > 1) {\n      throw new MichelsonTypeError(t, undefined, t.prim + \": at most one type annotation allowed: \" + t.annots);\n    }\n\n    if (field) {\n      if ((((_d = ann.f) === null || _d === void 0 ? void 0 : _d.length) || 0) > 1) {\n        throw new MichelsonTypeError(t, undefined, t.prim + \": at most one field annotation allowed: \" + t.annots);\n      }\n    } else {\n      if ((((_e = ann.f) === null || _e === void 0 ? void 0 : _e.length) || 0) > 0) {\n        throw new MichelsonTypeError(t, undefined, t.prim + \": field annotations aren't allowed: \" + t.annots);\n      }\n    }\n  }\n\n  if (isPairType(t)) {\n    var args = typeArgs(t);\n\n    try {\n      for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {\n        var a = args_1_1.value;\n        assertTypeAnnotationsValid(a, true);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return;\n  }\n\n  switch (t.prim) {\n    case \"option\":\n    case \"list\":\n    case \"contract\":\n    case \"set\":\n      assertTypeAnnotationsValid(t.args[0]);\n      break;\n\n    case \"or\":\n      try {\n        for (var _f = __values(t.args), _g = _f.next(); !_g.done; _g = _f.next()) {\n          var a = _g.value;\n          assertTypeAnnotationsValid(a, true);\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_g && !_g.done && (_b = _f.return)) _b.call(_f);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n\n      break;\n\n    case \"lambda\":\n    case \"map\":\n    case \"big_map\":\n      assertTypeAnnotationsValid(t.args[0]);\n      assertTypeAnnotationsValid(t.args[1]);\n  }\n} // Data integrity check\n\n\nfunction compareMichelsonData(t, a, b) {\n  if (isPairType(t)) {\n    if (isPairData(a) && isPairData(b)) {\n      assertDataListIfAny(a);\n      assertDataListIfAny(b);\n      var tComb = unpackComb(\"pair\", t);\n      var aComb = unpackComb(\"Pair\", a);\n      var bComb = unpackComb(\"Pair\", b);\n      var x = compareMichelsonData(tComb.args[0], aComb.args[0], bComb.args[0]);\n\n      if (x !== 0) {\n        return x;\n      }\n\n      return compareMichelsonData(tComb.args[0], aComb.args[1], bComb.args[1]);\n    }\n  } else {\n    switch (t.prim) {\n      case \"int\":\n      case \"nat\":\n      case \"mutez\":\n        if (\"int\" in a && \"int\" in b) {\n          return new LongInteger(a.int).cmp(new LongInteger(b.int));\n        }\n\n        break;\n\n      case \"string\":\n        if (\"string\" in a && \"string\" in b) {\n          var x = a.string.localeCompare(b.string);\n          return x < 0 ? -1 : x > 0 ? 1 : 0;\n        }\n\n        break;\n\n      case \"bytes\":\n        if (\"bytes\" in a && \"bytes\" in b) {\n          var aa = parseBytes(a.bytes);\n          var bb = parseBytes(b.bytes);\n\n          if (aa !== null && bb !== null) {\n            return compareBytes(aa, bb);\n          }\n        }\n\n        break;\n\n      case \"bool\":\n        if (\"prim\" in a && \"prim\" in b && (a.prim === \"True\" || a.prim === \"False\") && (b.prim === \"True\" || b.prim === \"False\")) {\n          return a.prim === b.prim ? 0 : a.prim === \"False\" ? -1 : 1;\n        }\n\n        break;\n\n      case \"key\":\n      case \"key_hash\":\n      case \"address\":\n      case \"signature\":\n      case \"chain_id\":\n        if ((\"string\" in a || \"bytes\" in a) && (\"string\" in b || \"bytes\" in b)) {\n          return compareBytes(\"string\" in a ? decodeBase58Check(a.string) : parseBytes(a.bytes) || [], \"string\" in b ? decodeBase58Check(b.string) : parseBytes(b.bytes) || []);\n        }\n\n        break;\n\n      case \"timestamp\":\n        if ((\"string\" in a || \"int\" in a) && (\"string\" in b || \"int\" in b)) {\n          var aa = parseDate(a);\n          var bb = parseDate(b);\n\n          if (aa !== null && bb !== null) {\n            var x = aa.valueOf() - bb.valueOf();\n            return x < 0 ? -1 : x > 0 ? 1 : 0;\n          }\n        }\n\n        break;\n\n      case \"unit\":\n        if (\"prim\" in a && \"prim\" in b && a.prim === \"Unit\" && b.prim === \"Unit\") {\n          return 0;\n        }\n\n    }\n  } // Unlikely, types are expected to be verified before the function call\n\n\n  throw new MichelsonTypeError(t, undefined, typeID(t) + \": not comparable values: \" + JSON.stringify(a) + \", \" + JSON.stringify(b));\n} // Simplified version of assertMichelsonInstruction() for previously validated data\n\n\nfunction isFunction(d) {\n  var e_3, _a;\n\n  if (!Array.isArray(d)) {\n    return false;\n  }\n\n  try {\n    for (var d_1 = __values(d), d_1_1 = d_1.next(); !d_1_1.done; d_1_1 = d_1.next()) {\n      var v = d_1_1.value;\n\n      if (!(Array.isArray(v) && isFunction(v) || \"prim\" in v && isInstruction(v))) {\n        return false;\n      }\n    }\n  } catch (e_3_1) {\n    e_3 = {\n      error: e_3_1\n    };\n  } finally {\n    try {\n      if (d_1_1 && !d_1_1.done && (_a = d_1.return)) _a.call(d_1);\n    } finally {\n      if (e_3) throw e_3.error;\n    }\n  }\n\n  return true;\n}\n\nfunction assertDataValidInternal(d, t, ctx) {\n  var e_4, _a, e_5, _b;\n\n  if (isPairType(t)) {\n    if (isPairData(d)) {\n      assertDataListIfAny(d);\n      var dc = unpackComb(\"Pair\", d);\n      var tc = unpackComb(\"pair\", t);\n      assertDataValidInternal(dc.args[0], tc.args[0], ctx);\n      assertDataValidInternal(dc.args[1], tc.args[1], ctx);\n      return;\n    }\n\n    throw new MichelsonTypeError(t, d, \"pair expected: \" + JSON.stringify(d));\n  }\n\n  switch (t.prim) {\n    // Atomic literals\n    case \"int\":\n      if (\"int\" in d && isDecimal(d.int)) {\n        return;\n      }\n\n      throw new MichelsonTypeError(t, d, \"integer value expected: \" + JSON.stringify(d));\n\n    case \"nat\":\n    case \"mutez\":\n      if (\"int\" in d && isNatural(d.int)) {\n        return;\n      }\n\n      throw new MichelsonTypeError(t, d, \"natural value expected: \" + JSON.stringify(d));\n\n    case \"string\":\n      if (\"string\" in d) {\n        return;\n      }\n\n      throw new MichelsonTypeError(t, d, \"string value expected: \" + JSON.stringify(d));\n\n    case \"bytes\":\n    case \"bls12_381_g1\":\n    case \"bls12_381_g2\":\n      if (\"bytes\" in d && parseBytes(d.bytes) !== null) {\n        return;\n      }\n\n      throw new MichelsonTypeError(t, d, \"bytes value expected: \" + JSON.stringify(d));\n\n    case \"bool\":\n      if (\"prim\" in d && (d.prim === \"True\" || d.prim === \"False\")) {\n        return;\n      }\n\n      throw new MichelsonTypeError(t, d, \"boolean value expected: \" + JSON.stringify(d));\n\n    case \"key_hash\":\n      if (\"string\" in d && checkDecodeTezosID(d.string, \"ED25519PublicKeyHash\", \"SECP256K1PublicKeyHash\", \"P256PublicKeyHash\") !== null) {\n        return;\n      } else if (\"bytes\" in d) {\n        try {\n          decodePublicKeyHashBytes(d);\n          return;\n        } catch (err) {// ignore message\n        }\n      }\n\n      throw new MichelsonTypeError(t, d, \"key hash expected: \" + JSON.stringify(d));\n\n    case \"timestamp\":\n      if ((\"string\" in d || \"int\" in d) && parseDate(d) !== null) {\n        return;\n      }\n\n      throw new MichelsonTypeError(t, d, \"timestamp expected: \" + JSON.stringify(d));\n\n    case \"address\":\n      if (\"string\" in d) {\n        var address = d.string;\n        var ep = d.string.indexOf(\"%\");\n\n        if (ep >= 0) {\n          // trim entry point\n          address = d.string.slice(0, ep);\n        }\n\n        if (checkDecodeTezosID(address, \"ED25519PublicKeyHash\", \"SECP256K1PublicKeyHash\", \"P256PublicKeyHash\", \"ContractHash\") !== null) {\n          return;\n        }\n      } else if (\"bytes\" in d) {\n        try {\n          decodeAddressBytes(d);\n          return;\n        } catch (err) {// ignore message\n        }\n      }\n\n      throw new MichelsonTypeError(t, d, \"address expected: \" + JSON.stringify(d));\n\n    case \"key\":\n      if (\"string\" in d && checkDecodeTezosID(d.string, \"ED25519PublicKey\", \"SECP256K1PublicKey\", \"P256PublicKey\") !== null) {\n        return;\n      } else if (\"bytes\" in d) {\n        try {\n          decodePublicKeyBytes(d);\n          return;\n        } catch (err) {// ignore message\n        }\n      }\n\n      throw new MichelsonTypeError(t, d, \"public key expected: \" + JSON.stringify(d));\n\n    case \"unit\":\n      if (\"prim\" in d && d.prim === \"Unit\") {\n        return;\n      }\n\n      throw new MichelsonTypeError(t, d, \"unit value expected: \" + JSON.stringify(d));\n\n    case \"signature\":\n      if (\"bytes\" in d || \"string\" in d && checkDecodeTezosID(d.string, \"ED25519Signature\", \"SECP256K1Signature\", \"P256Signature\", \"GenericSignature\") !== null) {\n        return;\n      }\n\n      throw new MichelsonTypeError(t, d, \"signature expected: \" + JSON.stringify(d));\n\n    case \"chain_id\":\n      if (\"bytes\" in d || \"string\" in d) {\n        var x = \"string\" in d ? decodeBase58Check(d.string) : parseBytes(d.bytes);\n\n        if (x !== null) {\n          return;\n        }\n      }\n\n      throw new MichelsonTypeError(t, d, \"chain id expected: \" + JSON.stringify(d));\n\n    case \"operation\":\n      throw new MichelsonTypeError(t, d, \"operation type can't be represented as a literal value\");\n\n    case \"contract\":\n      throw new MichelsonTypeError(t, d, \"contract type can't be represented as a literal value\");\n    // Complex types\n\n    case \"option\":\n      if (\"prim\" in d) {\n        if (d.prim === \"None\") {\n          return;\n        } else if (d.prim === \"Some\") {\n          assertDataValidInternal(d.args[0], t.args[0], ctx);\n          return;\n        }\n      }\n\n      throw new MichelsonTypeError(t, d, \"option expected: \" + JSON.stringify(d));\n\n    case \"list\":\n    case \"set\":\n      if (assertDataListIfAny(d)) {\n        var prev = void 0;\n\n        try {\n          for (var d_2 = __values(d), d_2_1 = d_2.next(); !d_2_1.done; d_2_1 = d_2.next()) {\n            var v = d_2_1.value;\n            assertDataValidInternal(v, t.args[0], ctx);\n\n            if (t.prim === \"set\") {\n              if (prev === undefined) {\n                prev = v;\n              } else if (compareMichelsonData(t.args[0], prev, v) > 0) {\n                throw new MichelsonTypeError(t, d, \"set elements must be ordered: \" + JSON.stringify(d));\n              }\n            }\n          }\n        } catch (e_4_1) {\n          e_4 = {\n            error: e_4_1\n          };\n        } finally {\n          try {\n            if (d_2_1 && !d_2_1.done && (_a = d_2.return)) _a.call(d_2);\n          } finally {\n            if (e_4) throw e_4.error;\n          }\n        }\n\n        return;\n      }\n\n      throw new MichelsonTypeError(t, d, t.prim + \" expected: \" + JSON.stringify(d));\n\n    case \"or\":\n      if (\"prim\" in d) {\n        if (d.prim === \"Left\") {\n          assertDataValidInternal(d.args[0], t.args[0], ctx);\n          return;\n        } else if (d.prim === \"Right\") {\n          assertDataValidInternal(d.args[0], t.args[1], ctx);\n          return;\n        }\n      }\n\n      throw new MichelsonTypeError(t, d, \"union (or) expected: \" + JSON.stringify(d));\n\n    case \"lambda\":\n      if (isFunction(d)) {\n        var ret = functionTypeInternal(d, [t.args[0]], ctx);\n\n        if (\"failed\" in ret) {\n          throw new MichelsonTypeError(t, d, \"function is failed with error type: \" + ret.failed);\n        }\n\n        if (ret.length !== 1) {\n          throw new MichelsonTypeError(t, d, \"function must return a value\");\n        }\n\n        assertScalarTypesEqual(t.args[1], ret[0]);\n        return;\n      }\n\n      throw new MichelsonTypeError(t, d, \"function expected: \" + JSON.stringify(d));\n\n    case \"map\":\n    case \"big_map\":\n      if (Array.isArray(d)) {\n        var prev = void 0;\n\n        try {\n          for (var d_3 = __values(d), d_3_1 = d_3.next(); !d_3_1.done; d_3_1 = d_3.next()) {\n            var v = d_3_1.value;\n\n            if (!(\"prim\" in v) || v.prim !== \"Elt\") {\n              throw new MichelsonTypeError(t, d, \"map elements expected: \" + JSON.stringify(d));\n            }\n\n            assertDataValidInternal(v.args[0], t.args[0], ctx);\n            assertDataValidInternal(v.args[1], t.args[1], ctx);\n\n            if (prev === undefined) {\n              prev = v;\n            } else if (compareMichelsonData(t.args[0], prev.args[0], v.args[0]) > 0) {\n              throw new MichelsonTypeError(t, d, \"map elements must be ordered: \" + JSON.stringify(d));\n            }\n          }\n        } catch (e_5_1) {\n          e_5 = {\n            error: e_5_1\n          };\n        } finally {\n          try {\n            if (d_3_1 && !d_3_1.done && (_b = d_3.return)) _b.call(d_3);\n          } finally {\n            if (e_5) throw e_5.error;\n          }\n        }\n\n        return;\n      }\n\n      throw new MichelsonTypeError(t, d, t.prim + \" expected: \" + JSON.stringify(d));\n\n    case \"bls12_381_fr\":\n      if (\"int\" in d && isDecimal(d.int) || \"bytes\" in d && parseBytes(d.bytes) !== null) {\n        return;\n      }\n\n      throw new MichelsonTypeError(t, d, \"BLS12-381 element expected: \" + JSON.stringify(d));\n\n    case \"sapling_state\":\n      if (Array.isArray(d)) {\n        return;\n      }\n\n      throw new MichelsonTypeError(t, d, \"sapling state expected: \" + JSON.stringify(d));\n\n    case \"ticket\":\n      assertDataValidInternal(d, {\n        prim: \"pair\",\n        args: [{\n          prim: \"address\"\n        }, t.args[0], {\n          prim: \"nat\"\n        }]\n      }, ctx);\n      return;\n\n    default:\n      throw new MichelsonTypeError(t, d, \"unexpected type: \" + typeID(t));\n  }\n}\n\nfunction instructionListType(inst, stack, ctx) {\n  var e_6, _a;\n\n  var ret = stack;\n  var s = stack;\n  var i = 0;\n\n  try {\n    for (var inst_1 = __values(inst), inst_1_1 = inst_1.next(); !inst_1_1.done; inst_1_1 = inst_1.next()) {\n      var op = inst_1_1.value;\n      var ft = functionTypeInternal(op, s, ctx);\n      ret = ft;\n\n      if (\"failed\" in ft) {\n        break;\n      }\n\n      s = ft;\n      i++;\n    }\n  } catch (e_6_1) {\n    e_6 = {\n      error: e_6_1\n    };\n  } finally {\n    try {\n      if (inst_1_1 && !inst_1_1.done && (_a = inst_1.return)) _a.call(inst_1);\n    } finally {\n      if (e_6) throw e_6.error;\n    }\n  }\n\n  if (\"failed\" in ret && i !== inst.length - 1) {\n    throw new MichelsonInstructionError(inst, ret, \"FAIL must appear in a tail position\");\n  }\n\n  if ((ctx === null || ctx === void 0 ? void 0 : ctx.traceCallback) !== undefined) {\n    var trace = {\n      op: inst,\n      in: stack,\n      out: ret\n    };\n    ctx.traceCallback(trace);\n  }\n\n  return ret;\n}\n\nfunction functionTypeInternal(inst, stack, ctx) {\n  var proto = (ctx === null || ctx === void 0 ? void 0 : ctx.protocol) || DefaultProtocol;\n\n  if (Array.isArray(inst)) {\n    return instructionListType(inst, stack, ctx);\n  }\n\n  var instruction = inst; // Make it const for type guarding\n  // make sure the stack has enough number of arguments of specific types\n\n  function args(n) {\n    var e_7, _a;\n\n    var typeIds = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      typeIds[_i - 1] = arguments[_i];\n    }\n\n    if (stack.length < typeIds.length + n) {\n      throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": stack must have at least \" + typeIds.length + \" element(s)\");\n    }\n\n    var i = n;\n\n    try {\n      for (var typeIds_1 = __values(typeIds), typeIds_1_1 = typeIds_1.next(); !typeIds_1_1.done; typeIds_1_1 = typeIds_1.next()) {\n        var ids = typeIds_1_1.value;\n\n        if (ids !== null && ids.length !== 0) {\n          var ii = 0;\n\n          while (ii < ids.length && ids[ii] !== typeID(stack[i])) {\n            ii++;\n          }\n\n          if (ii === ids.length) {\n            throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": stack type mismatch: [\" + i + \"] expected to be \" + ids + \", got \" + typeID(stack[i]) + \" instead\");\n          }\n        }\n\n        i++;\n      }\n    } catch (e_7_1) {\n      e_7 = {\n        error: e_7_1\n      };\n    } finally {\n      try {\n        if (typeIds_1_1 && !typeIds_1_1.done && (_a = typeIds_1.return)) _a.call(typeIds_1);\n      } finally {\n        if (e_7) throw e_7.error;\n      }\n    }\n\n    return stack.slice(n, typeIds.length + n);\n  }\n\n  function rethrow(fn) {\n    return function () {\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      try {\n        return fn.apply(void 0, __spreadArray([], __read(args)));\n      } catch (err) {\n        if (err instanceof MichelsonError) {\n          throw new MichelsonInstructionError(instruction, stack, err.message);\n        } else {\n          throw err;\n        }\n      }\n    };\n  }\n\n  function rethrowTypeGuard(fn) {\n    return function (arg) {\n      try {\n        return fn(arg);\n      } catch (err) {\n        if (err instanceof MichelsonError) {\n          throw new MichelsonInstructionError(instruction, stack, err.message);\n        } else {\n          throw err;\n        }\n      }\n    };\n  }\n\n  var argAnn = rethrow(unpackAnnotations);\n  var ensureStacksEqual = rethrow(assertStacksEqual);\n  var ensureTypesEqual = rethrow(assertScalarTypesEqual);\n  var ensureComparableType = rethrowTypeGuard(assertMichelsonComparableType);\n  var ensurePackableType = rethrowTypeGuard(assertMichelsonPackableType);\n  var ensureStorableType = rethrowTypeGuard(assertMichelsonStorableType);\n  var ensurePushableType = rethrowTypeGuard(assertMichelsonPushableType);\n  var ensureBigMapStorableType = rethrowTypeGuard(assertMichelsonBigMapStorableType); // unpack instruction annotations and assert their maximum number\n\n  function instructionAnn(num, opt) {\n    var a = argAnn(instruction, __assign(__assign({}, opt), {\n      emptyFields: num.f !== undefined && num.f > 1,\n      emptyVar: num.v !== undefined && num.v > 1\n    }));\n\n    var assertNum = function (a, n, type) {\n      if (a && a.length > (n || 0)) {\n        throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": at most \" + (n || 0) + \" \" + type + \" annotations allowed\");\n      }\n    };\n\n    assertNum(a.f, num.f, \"field\");\n    assertNum(a.t, num.t, \"type\");\n    assertNum(a.v, num.v, \"variable\");\n    return a;\n  } // also keeps annotation class if null is provided\n\n\n  function annotate(tt, a) {\n    var tx = tt;\n    var t = Array.isArray(tx) ? {\n      prim: \"pair\",\n      args: tx\n    } : tx;\n    var src = argAnn(t);\n    var ann = a.v !== undefined || a.t !== undefined || a.f !== undefined ? __spreadArray(__spreadArray(__spreadArray([], __read((a.v === null ? src.v : a.v) || [])), __read((a.t === null ? src.t : a.t) || [])), __read((a.f === null ? src.f : a.f) || [])) : undefined;\n    t.annots;\n\n    var rest = __rest(t, [\"annots\"]);\n\n    return __assign(__assign({}, rest), ann && ann.length !== 0 && {\n      annots: ann\n    });\n  } // shortcut to copy at most one variable annotation from the instruction to the type\n\n\n  function annotateVar(t, def) {\n    var ia = instructionAnn({\n      v: 1\n    });\n    return annotate(t, {\n      v: ia.v !== undefined ? ia.v : def !== undefined ? [def] : null,\n      t: null\n    });\n  } // annotate CAR/CDR/UNPAIR/GET\n\n\n  function annotateField(arg, field, insAnn, n, defField) {\n    var _a, _b, _c, _d;\n\n    var fieldAnn = (_a = argAnn(field).f) === null || _a === void 0 ? void 0 : _a[0]; // field's field annotation\n\n    var insFieldAnn = (_b = insAnn.f) === null || _b === void 0 ? void 0 : _b[n];\n\n    if (insFieldAnn !== undefined && insFieldAnn !== \"%\" && fieldAnn !== undefined && insFieldAnn !== fieldAnn) {\n      throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": field names doesn't match: \" + insFieldAnn + \" !== \" + fieldAnn);\n    }\n\n    var insVarAnn = (_c = insAnn.v) === null || _c === void 0 ? void 0 : _c[n]; // nth instruction's variable annotation\n\n    var varAnn = (_d = argAnn(arg).v) === null || _d === void 0 ? void 0 : _d[0]; // instruction argument's variable annotation\n\n    return annotate(field, {\n      t: null,\n      v: insVarAnn ? insVarAnn === \"@%\" ? fieldAnn ? [\"@\" + fieldAnn.slice(1)] : undefined : insVarAnn === \"@%%\" ? varAnn ? [\"@\" + varAnn.slice(1) + \".\" + (fieldAnn ? fieldAnn.slice(1) : defField)] : fieldAnn ? [\"@\" + fieldAnn.slice(1)] : undefined : [insVarAnn] : null\n    });\n  } // comb helper functions\n\n\n  function getN(src, n, i) {\n    if (i === void 0) {\n      i = n;\n    }\n\n    var p = unpackComb(\"pair\", src);\n\n    if (i === 1) {\n      return [p.args[0]];\n    } else if (i === 2) {\n      return p.args;\n    }\n\n    var right = p.args[1];\n\n    if (isPairType(right)) {\n      return __spreadArray([p.args[0]], __read(getN(right, n, i - 1)));\n    } else {\n      throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": at least \" + n + \" fields are expected\");\n    }\n  }\n\n  function getNth(src, n, i) {\n    if (i === void 0) {\n      i = n;\n    }\n\n    if (i === 0) {\n      return src;\n    }\n\n    var p = unpackComb(\"pair\", src);\n\n    if (i === 1) {\n      return p.args[0];\n    }\n\n    var right = p.args[1];\n\n    if (isPairType(right)) {\n      return getNth(right, n, i - 2);\n    } else if (i === 2) {\n      return right;\n    }\n\n    throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": at least \" + (n + 1) + \" fields are expected\");\n  }\n\n  function updateNth(src, x, n, i) {\n    if (i === void 0) {\n      i = n;\n    }\n\n    if (i === 0) {\n      return x;\n    }\n\n    var p = unpackComb(\"pair\", src);\n\n    if (i === 1) {\n      return __assign(__assign({}, p), {\n        args: [x, p.args[1]]\n      });\n    }\n\n    var right = p.args[1];\n\n    if (isPairType(right)) {\n      return __assign(__assign({}, p), {\n        args: [p.args[0], updateNth(right, x, n, i - 2)]\n      });\n    } else if (i === 2) {\n      return __assign(__assign({}, p), {\n        args: [p.args[0], x]\n      });\n    }\n\n    throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": at least \" + (n + 1) + \" fields are expected\");\n  }\n\n  var varSuffix = function (a, suffix) {\n    return [\"@\" + (a.v ? a.v[0].slice(1) + \".\" : \"\") + suffix];\n  };\n\n  function branchType(br0, br1) {\n    if (\"failed\" in br0 || \"failed\" in br1) {\n      // Might be useful for debugging\n      if (\"failed\" in br0 && \"failed\" in br1) {\n        try {\n          assertScalarTypesEqual(br0.failed, br1.failed);\n          return br0;\n        } catch (_a) {\n          return {\n            failed: {\n              prim: \"or\",\n              args: [br0.failed, br1.failed]\n            }\n          };\n        }\n      } else {\n        return \"failed\" in br0 ? br1 : br0;\n      }\n    } else {\n      ensureStacksEqual(br0, br1);\n      return br0;\n    }\n  }\n\n  var retStack = function (instruction) {\n    var _a, _b;\n\n    var _c, _d, _e, _f, _g;\n\n    switch (instruction.prim) {\n      case \"DUP\":\n        {\n          var n = instruction.args ? parseInt(instruction.args[0].int, 10) : 1;\n\n          if (n === 0) {\n            throw new MichelsonInstructionError(instruction, stack, \"DUP 0 is forbidden\");\n          }\n\n          var s_1 = args(n - 1, null)[0];\n\n          if (typeID(s_1) === \"ticket\") {\n            throw new MichelsonInstructionError(instruction, stack, \"ticket can't be DUPed\");\n          }\n\n          return __spreadArray([s_1], __read(stack));\n        }\n\n      case \"SWAP\":\n        {\n          var s_2 = args(0, null, null);\n          instructionAnn({});\n          return __spreadArray([s_2[1], s_2[0]], __read(stack.slice(2)));\n        }\n\n      case \"SOME\":\n        return __spreadArray([annotate({\n          prim: \"option\",\n          args: [args(0, null)[0]]\n        }, instructionAnn({\n          t: 1,\n          v: 1\n        }))], __read(stack.slice(1)));\n\n      case \"UNIT\":\n        return __spreadArray([annotate({\n          prim: \"unit\"\n        }, instructionAnn({\n          v: 1,\n          t: 1\n        }))], __read(stack));\n\n      case \"PAIR\":\n        {\n          var n = instruction.args ? parseInt(instruction.args[0].int, 10) : 2;\n\n          if (n < 2) {\n            throw new MichelsonInstructionError(instruction, stack, \"PAIR \" + n + \" is forbidden\");\n          }\n\n          var s_3 = args.apply(void 0, __spreadArray([0], __read(new Array(n).fill(null))));\n          var ia_1 = instructionAnn({\n            f: n,\n            t: 1,\n            v: 1\n          }, {\n            specialFields: true\n          });\n\n          var trim_1 = function (s) {\n            var i = s.lastIndexOf(\".\");\n            return s.slice(i > 0 ? i + 1 : 1);\n          };\n\n          var retArgs = s_3.map(function (v, i) {\n            var _a;\n\n            var va = argAnn(v);\n            var f = ia_1.f && ia_1.f.length > i && ia_1.f[i] !== \"%\" ? ia_1.f[i] === \"%@\" ? va.v ? [\"%\" + trim_1(((_a = va.v) === null || _a === void 0 ? void 0 : _a[0]) || \"\")] : undefined : [ia_1.f[i]] : undefined;\n            return annotate(v, {\n              v: null,\n              t: null,\n              f: f\n            });\n          });\n          return __spreadArray([annotate({\n            prim: \"pair\",\n            args: retArgs\n          }, {\n            t: ia_1.t,\n            v: ia_1.v\n          })], __read(stack.slice(n)));\n        }\n\n      case \"UNPAIR\":\n        {\n          var n = instruction.args ? parseInt(instruction.args[0].int, 10) : 2;\n\n          if (n < 2) {\n            throw new MichelsonInstructionError(instruction, stack, \"UNPAIR \" + n + \" is forbidden\");\n          }\n\n          var s_4 = args(0, [\"pair\"])[0];\n          var ia_2 = instructionAnn({\n            f: 2,\n            v: 2\n          }, {\n            specialVar: true\n          });\n          var fields = getN(s_4, n);\n          return __spreadArray(__spreadArray([], __read(fields.map(function (field, i) {\n            return annotateField(s_4, field, ia_2, i, i === 0 ? \"car\" : \"cdr\");\n          }))), __read(stack.slice(1)));\n        }\n\n      case \"CAR\":\n      case \"CDR\":\n        {\n          var s_5 = unpackComb(\"pair\", args(0, [\"pair\"])[0]);\n          var field = s_5.args[instruction.prim === \"CAR\" ? 0 : 1];\n          var ia = instructionAnn({\n            f: 1,\n            v: 1\n          }, {\n            specialVar: true\n          });\n          return __spreadArray([annotateField(s_5, field, ia, 0, instruction.prim.toLocaleLowerCase())], __read(stack.slice(1)));\n        }\n\n      case \"CONS\":\n        {\n          var s_6 = args(0, null, [\"list\"]);\n          ensureTypesEqual(s_6[0], s_6[1].args[0]);\n          return __spreadArray([annotateVar({\n            prim: \"list\",\n            args: [s_6[1].args[0]]\n          })], __read(stack.slice(2)));\n        }\n\n      case \"SIZE\":\n        args(0, [\"string\", \"list\", \"set\", \"map\", \"bytes\"]);\n        return __spreadArray([annotateVar({\n          prim: \"nat\"\n        })], __read(stack.slice(1)));\n\n      case \"MEM\":\n        {\n          var s_7 = args(0, null, [\"set\", \"map\", \"big_map\"]);\n          ensureComparableType(s_7[0]);\n          ensureTypesEqual(s_7[0], s_7[1].args[0]);\n          return __spreadArray([annotateVar({\n            prim: \"bool\"\n          })], __read(stack.slice(2)));\n        }\n\n      case \"GET\":\n        if (instruction.args) {\n          // comb operation\n          var n = parseInt(instruction.args[0].int, 10);\n          var s_8 = args(0, [\"pair\"])[0];\n          return __spreadArray([annotateVar(getNth(s_8, n))], __read(stack.slice(1)));\n        } else {\n          // map operation\n          var s_9 = args(0, null, [\"map\", \"big_map\"]);\n          ensureComparableType(s_9[0]);\n          ensureTypesEqual(s_9[0], s_9[1].args[0]);\n          return __spreadArray([annotateVar({\n            prim: \"option\",\n            args: [s_9[1].args[1]]\n          })], __read(stack.slice(2)));\n        }\n\n      case \"UPDATE\":\n        if (instruction.args) {\n          // comb operation\n          var n = parseInt(instruction.args[0].int, 10);\n          var s_10 = args(0, null, [\"pair\"]);\n          return __spreadArray([annotateVar(updateNth(s_10[1], s_10[0], n))], __read(stack.slice(2)));\n        } else {\n          // map operation\n          var s0 = args(0, null, [\"bool\", \"option\"]);\n          ensureComparableType(s0[0]);\n\n          if (s0[1].prim === \"bool\") {\n            var s1_1 = args(2, [\"set\"]);\n            ensureTypesEqual(s0[0], s1_1[0].args[0]);\n            return __spreadArray([annotateVar({\n              prim: \"set\",\n              args: [annotate(s0[0], {\n                t: null\n              })]\n            })], __read(stack.slice(3)));\n          }\n\n          var s1 = args(2, [\"map\", \"big_map\"]);\n          ensureTypesEqual(s0[0], s1[0].args[0]);\n\n          if (s1[0].prim === \"map\") {\n            return __spreadArray([annotateVar({\n              prim: \"map\",\n              args: [annotate(s0[0], {\n                t: null\n              }), annotate(s0[1].args[0], {\n                t: null\n              })]\n            })], __read(stack.slice(3)));\n          }\n\n          ensureBigMapStorableType(s0[1].args[0]);\n          return __spreadArray([annotateVar({\n            prim: \"big_map\",\n            args: [annotate(s0[0], {\n              t: null\n            }), annotate(s0[1].args[0], {\n              t: null\n            })]\n          })], __read(stack.slice(3)));\n        }\n\n      case \"GET_AND_UPDATE\":\n        {\n          var ia = instructionAnn({\n            v: 2\n          });\n          var s_11 = args(0, null, [\"option\"], [\"map\", \"big_map\"]);\n          ensureComparableType(s_11[0]);\n          ensureTypesEqual(s_11[0], s_11[2].args[0]);\n          ensureTypesEqual(s_11[1].args[0], s_11[2].args[1]);\n          var va = (_c = ia.v) === null || _c === void 0 ? void 0 : _c.map(function (v) {\n            return v !== \"@\" ? [v] : undefined;\n          });\n\n          if (s_11[2].prim === \"map\") {\n            return __spreadArray([annotate({\n              prim: \"option\",\n              args: [s_11[2].args[1]]\n            }, {\n              v: va === null || va === void 0 ? void 0 : va[0]\n            }), annotate({\n              prim: \"map\",\n              args: [annotate(s_11[0], {\n                t: null\n              }), annotate(s_11[1].args[0], {\n                t: null\n              })]\n            }, {\n              v: va === null || va === void 0 ? void 0 : va[1]\n            })], __read(stack.slice(3)));\n          }\n\n          ensureBigMapStorableType(s_11[1].args[0]);\n          return __spreadArray([annotate({\n            prim: \"option\",\n            args: [s_11[2].args[1]]\n          }, {\n            v: va === null || va === void 0 ? void 0 : va[0]\n          }), annotate({\n            prim: \"big_map\",\n            args: [annotate(s_11[0], {\n              t: null\n            }), annotate(s_11[1].args[0], {\n              t: null\n            })]\n          }, {\n            v: va === null || va === void 0 ? void 0 : va[1]\n          })], __read(stack.slice(3)));\n        }\n\n      case \"EXEC\":\n        {\n          var s_12 = args(0, null, [\"lambda\"]);\n          ensureTypesEqual(s_12[0], s_12[1].args[0]);\n          return __spreadArray([annotateVar(s_12[1].args[1])], __read(stack.slice(2)));\n        }\n\n      case \"APPLY\":\n        {\n          var s_13 = args(0, null, [\"lambda\"]);\n          ensureStorableType(s_13[0]);\n          ensurePushableType(s_13[0]);\n\n          if (!isPairType(s_13[1].args[0])) {\n            throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": function's argument must be a pair: \" + typeID(s_13[1].args[0]));\n          }\n\n          var pt = s_13[1].args[0];\n          ensureTypesEqual(s_13[0], typeArgs(pt)[0]);\n          return __spreadArray([annotateVar({\n            prim: \"lambda\",\n            args: [typeArgs(pt)[1], s_13[1].args[1]]\n          })], __read(stack.slice(2)));\n        }\n\n      case \"FAILWITH\":\n        {\n          var s_14 = args(0, null)[0];\n\n          if (proto === Protocol.PtEdo2Zk || proto === Protocol.PsFLorena || proto === Protocol.PtGRANADs) {\n            ensurePackableType(s_14);\n          }\n\n          return {\n            failed: s_14\n          };\n        }\n\n      case \"NEVER\":\n        args(0, [\"never\"]);\n        return {\n          failed: {\n            prim: \"never\"\n          }\n        };\n\n      case \"RENAME\":\n        return __spreadArray([annotateVar(args(0, null)[0])], __read(stack.slice(1)));\n\n      case \"CONCAT\":\n        {\n          var s0 = args(0, [\"string\", \"list\", \"bytes\"]);\n\n          if (s0[0].prim === \"list\") {\n            if (typeID(s0[0].args[0]) !== \"string\" && typeID(s0[0].args[0]) !== \"bytes\") {\n              throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": can't concatenate list of \" + typeID(s0[0].args[0]) + \"'s\");\n            }\n\n            return __spreadArray([annotateVar(s0[0].args[0])], __read(stack.slice(1)));\n          }\n\n          var s1 = args(1, [\"string\", \"bytes\"]);\n\n          if (s0[0].prim !== s1[0].prim) {\n            throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": can't concatenate \" + s0[0].prim + \" with \" + s1[0].prim);\n          }\n\n          return __spreadArray([annotateVar(s1[0])], __read(stack.slice(2)));\n        }\n\n      case \"SLICE\":\n        return __spreadArray([annotateVar({\n          prim: \"option\",\n          args: [args(0, [\"nat\"], [\"nat\"], [\"string\", \"bytes\"])[2]]\n        }, \"@slice\")], __read(stack.slice(3)));\n\n      case \"PACK\":\n        {\n          var s_15 = args(0, null)[0];\n          ensurePackableType(s_15);\n          return __spreadArray([annotateVar({\n            prim: \"bytes\"\n          }, \"@packed\")], __read(stack.slice(1)));\n        }\n\n      case \"ADD\":\n        {\n          var s_16 = args(0, [\"nat\", \"int\", \"timestamp\", \"mutez\", \"bls12_381_g1\", \"bls12_381_g2\", \"bls12_381_fr\"], [\"nat\", \"int\", \"timestamp\", \"mutez\", \"bls12_381_g1\", \"bls12_381_g2\", \"bls12_381_fr\"]);\n\n          if (s_16[0].prim === \"nat\" && s_16[1].prim === \"int\" || s_16[0].prim === \"int\" && s_16[1].prim === \"nat\") {\n            return __spreadArray([annotateVar({\n              prim: \"int\"\n            })], __read(stack.slice(2)));\n          } else if (s_16[0].prim === \"int\" && s_16[1].prim === \"timestamp\" || s_16[0].prim === \"timestamp\" && s_16[1].prim === \"int\") {\n            return __spreadArray([annotateVar({\n              prim: \"timestamp\"\n            })], __read(stack.slice(2)));\n          } else if ((s_16[0].prim === \"int\" || s_16[0].prim === \"nat\" || s_16[0].prim === \"mutez\" || s_16[0].prim === \"bls12_381_g1\" || s_16[0].prim === \"bls12_381_g2\" || s_16[0].prim === \"bls12_381_fr\") && s_16[0].prim === s_16[1].prim) {\n            return __spreadArray([annotateVar(s_16[0])], __read(stack.slice(2)));\n          }\n\n          throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": can't add \" + s_16[0].prim + \" to \" + s_16[1].prim);\n        }\n\n      case \"SUB\":\n        {\n          var s_17 = args(0, [\"nat\", \"int\", \"timestamp\", \"mutez\"], [\"nat\", \"int\", \"timestamp\", \"mutez\"]);\n\n          if ((s_17[0].prim === \"nat\" || s_17[0].prim === \"int\") && (s_17[1].prim === \"nat\" || s_17[1].prim === \"int\") || s_17[0].prim === \"timestamp\" && s_17[1].prim === \"timestamp\") {\n            return __spreadArray([annotateVar({\n              prim: \"int\"\n            })], __read(stack.slice(2)));\n          } else if (s_17[0].prim === \"timestamp\" && s_17[1].prim === \"int\") {\n            return __spreadArray([annotateVar({\n              prim: \"timestamp\"\n            })], __read(stack.slice(2)));\n          } else if (s_17[0].prim === \"mutez\" && s_17[1].prim === \"mutez\") {\n            return __spreadArray([annotateVar({\n              prim: \"mutez\"\n            })], __read(stack.slice(2)));\n          }\n\n          throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": can't subtract \" + s_17[0].prim + \" from \" + s_17[1].prim);\n        }\n\n      case \"MUL\":\n        {\n          var s_18 = args(0, [\"nat\", \"int\", \"mutez\", \"bls12_381_g1\", \"bls12_381_g2\", \"bls12_381_fr\"], [\"nat\", \"int\", \"mutez\", \"bls12_381_g1\", \"bls12_381_g2\", \"bls12_381_fr\"]);\n\n          if (s_18[0].prim === \"nat\" && s_18[1].prim === \"int\" || s_18[0].prim === \"int\" && s_18[1].prim === \"nat\") {\n            return __spreadArray([annotateVar({\n              prim: \"int\"\n            })], __read(stack.slice(2)));\n          } else if (s_18[0].prim === \"nat\" && s_18[1].prim === \"mutez\" || s_18[0].prim === \"mutez\" && s_18[1].prim === \"nat\") {\n            return __spreadArray([annotateVar({\n              prim: \"mutez\"\n            })], __read(stack.slice(2)));\n          } else if ((s_18[0].prim === \"bls12_381_g1\" || s_18[0].prim === \"bls12_381_g2\" || s_18[0].prim === \"bls12_381_fr\") && s_18[1].prim === \"bls12_381_fr\" || (s_18[0].prim === \"nat\" || s_18[0].prim === \"int\") && s_18[0].prim === s_18[1].prim) {\n            return __spreadArray([annotateVar(s_18[0])], __read(stack.slice(2)));\n          } else if ((s_18[0].prim === \"nat\" || s_18[0].prim === \"int\") && s_18[1].prim === \"bls12_381_fr\" || (s_18[1].prim === \"nat\" || s_18[1].prim === \"int\") && s_18[0].prim === \"bls12_381_fr\") {\n            return __spreadArray([annotateVar({\n              prim: \"bls12_381_fr\"\n            })], __read(stack.slice(2)));\n          }\n\n          throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": can't multiply \" + s_18[0].prim + \" by \" + s_18[1].prim);\n        }\n\n      case \"EDIV\":\n        {\n          var res = function (a, b) {\n            return {\n              prim: \"option\",\n              args: [{\n                prim: \"pair\",\n                args: [{\n                  prim: a\n                }, {\n                  prim: b\n                }]\n              }]\n            };\n          };\n\n          var s_19 = args(0, [\"nat\", \"int\", \"mutez\"], [\"nat\", \"int\", \"mutez\"]);\n\n          if (s_19[0].prim === \"nat\" && s_19[1].prim === \"nat\") {\n            return __spreadArray([annotateVar(res(\"nat\", \"nat\"))], __read(stack.slice(2)));\n          } else if ((s_19[0].prim === \"nat\" || s_19[0].prim === \"int\") && (s_19[1].prim === \"nat\" || s_19[1].prim === \"int\")) {\n            return __spreadArray([annotateVar(res(\"int\", \"nat\"))], __read(stack.slice(2)));\n          } else if (s_19[0].prim === \"mutez\" && s_19[1].prim === \"nat\") {\n            return __spreadArray([annotateVar(res(\"mutez\", \"mutez\"))], __read(stack.slice(2)));\n          } else if (s_19[0].prim === \"mutez\" && s_19[1].prim === \"mutez\") {\n            return __spreadArray([annotateVar(res(\"nat\", \"mutez\"))], __read(stack.slice(2)));\n          }\n\n          throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": can't euclideally divide \" + s_19[0].prim + \" by \" + s_19[1].prim);\n        }\n\n      case \"ABS\":\n        args(0, [\"int\"]);\n        return __spreadArray([annotateVar({\n          prim: \"nat\"\n        })], __read(stack.slice(1)));\n\n      case \"ISNAT\":\n        args(0, [\"int\"]);\n        return __spreadArray([annotateVar({\n          prim: \"option\",\n          args: [{\n            prim: \"nat\"\n          }]\n        })], __read(stack.slice(1)));\n\n      case \"INT\":\n        args(0, [\"nat\", \"bls12_381_fr\"]);\n        return __spreadArray([annotateVar({\n          prim: \"int\"\n        })], __read(stack.slice(1)));\n\n      case \"NEG\":\n        {\n          var s_20 = args(0, [\"nat\", \"int\", \"bls12_381_g1\", \"bls12_381_g2\", \"bls12_381_fr\"])[0];\n\n          if (s_20.prim === \"nat\" || s_20.prim === \"int\") {\n            return __spreadArray([annotateVar({\n              prim: \"int\"\n            })], __read(stack.slice(1)));\n          }\n\n          return __spreadArray([annotateVar(s_20)], __read(stack.slice(1)));\n        }\n\n      case \"LSL\":\n      case \"LSR\":\n        args(0, [\"nat\"], [\"nat\"]);\n        return __spreadArray([annotateVar({\n          prim: \"nat\"\n        })], __read(stack.slice(2)));\n\n      case \"OR\":\n      case \"XOR\":\n        {\n          var s_21 = args(0, [\"nat\", \"bool\"], [\"nat\", \"bool\"]);\n\n          if (s_21[0].prim !== s_21[1].prim) {\n            throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": both arguments must be of the same type: \" + s_21[0].prim + \", \" + s_21[1].prim);\n          }\n\n          return __spreadArray([annotateVar(s_21[1])], __read(stack.slice(2)));\n        }\n\n      case \"AND\":\n        {\n          var s_22 = args(0, [\"nat\", \"bool\", \"int\"], [\"nat\", \"bool\"]);\n\n          if ((s_22[0].prim !== \"int\" || s_22[1].prim !== \"nat\") && s_22[0].prim !== s_22[1].prim) {\n            throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": both arguments must be of the same type: \" + s_22[0].prim + \", \" + s_22[1].prim);\n          }\n\n          return __spreadArray([annotateVar(s_22[1])], __read(stack.slice(2)));\n        }\n\n      case \"NOT\":\n        {\n          var s_23 = args(0, [\"nat\", \"bool\", \"int\"])[0];\n\n          if (s_23.prim === \"bool\") {\n            return __spreadArray([annotateVar({\n              prim: \"bool\"\n            })], __read(stack.slice(1)));\n          }\n\n          return __spreadArray([annotateVar({\n            prim: \"int\"\n          })], __read(stack.slice(1)));\n        }\n\n      case \"COMPARE\":\n        {\n          var s_24 = args(0, null, null);\n          ensureComparableType(s_24[0]);\n          ensureComparableType(s_24[1]);\n          return __spreadArray([annotateVar({\n            prim: \"int\"\n          })], __read(stack.slice(2)));\n        }\n\n      case \"EQ\":\n      case \"NEQ\":\n      case \"LT\":\n      case \"GT\":\n      case \"LE\":\n      case \"GE\":\n        args(0, [\"int\"]);\n        return __spreadArray([annotateVar({\n          prim: \"bool\"\n        })], __read(stack.slice(1)));\n\n      case \"SELF\":\n        {\n          if ((ctx === null || ctx === void 0 ? void 0 : ctx.contract) === undefined) {\n            throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": contract required\");\n          }\n\n          var ia = instructionAnn({\n            f: 1,\n            v: 1\n          });\n          var ep = contractEntryPoint(ctx.contract, (_d = ia.f) === null || _d === void 0 ? void 0 : _d[0]);\n\n          if (ep === null) {\n            throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": contract has no entrypoint \" + ep);\n          }\n\n          return __spreadArray([annotate({\n            prim: \"contract\",\n            args: [ep]\n          }, {\n            v: ia.v ? ia.v : [\"@self\"]\n          })], __read(stack));\n        }\n\n      case \"TRANSFER_TOKENS\":\n        {\n          var s_25 = args(0, null, [\"mutez\"], [\"contract\"]);\n          ensureTypesEqual(s_25[0], s_25[2].args[0]);\n          return __spreadArray([annotateVar({\n            prim: \"operation\"\n          })], __read(stack.slice(3)));\n        }\n\n      case \"SET_DELEGATE\":\n        {\n          var s_26 = args(0, [\"option\"])[0];\n\n          if (typeID(s_26.args[0]) !== \"key_hash\") {\n            throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": key hash expected: \" + typeID(s_26.args[0]));\n          }\n\n          return __spreadArray([annotateVar({\n            prim: \"operation\"\n          })], __read(stack.slice(1)));\n        }\n\n      case \"IMPLICIT_ACCOUNT\":\n        args(0, [\"key_hash\"]);\n        return __spreadArray([annotateVar({\n          prim: \"contract\",\n          args: [{\n            prim: \"unit\"\n          }]\n        })], __read(stack.slice(1)));\n\n      case \"NOW\":\n        return __spreadArray([annotateVar({\n          prim: \"timestamp\"\n        }, \"@now\")], __read(stack));\n\n      case \"AMOUNT\":\n        return __spreadArray([annotateVar({\n          prim: \"mutez\"\n        }, \"@amount\")], __read(stack));\n\n      case \"BALANCE\":\n        return __spreadArray([annotateVar({\n          prim: \"mutez\"\n        }, \"@balance\")], __read(stack));\n\n      case \"CHECK_SIGNATURE\":\n        args(0, [\"key\"], [\"signature\"], [\"bytes\"]);\n        return __spreadArray([annotateVar({\n          prim: \"bool\"\n        })], __read(stack.slice(3)));\n\n      case \"BLAKE2B\":\n      case \"SHA256\":\n      case \"SHA512\":\n      case \"KECCAK\":\n      case \"SHA3\":\n        args(0, [\"bytes\"]);\n        return __spreadArray([annotateVar({\n          prim: \"bytes\"\n        })], __read(stack.slice(1)));\n\n      case \"HASH_KEY\":\n        args(0, [\"key\"]);\n        return __spreadArray([annotateVar({\n          prim: \"key_hash\"\n        })], __read(stack.slice(1)));\n\n      case \"SOURCE\":\n        return __spreadArray([annotateVar({\n          prim: \"address\"\n        }, \"@source\")], __read(stack));\n\n      case \"SENDER\":\n        return __spreadArray([annotateVar({\n          prim: \"address\"\n        }, \"@sender\")], __read(stack));\n\n      case \"ADDRESS\":\n        {\n          var s_27 = args(0, [\"contract\"])[0];\n          var ia = instructionAnn({\n            v: 1\n          });\n          return __spreadArray([annotate((_a = {\n            prim: \"address\"\n          }, _a[refContract] = s_27, _a), {\n            v: ia.v ? ia.v : varSuffix(argAnn(s_27), \"address\")\n          })], __read(stack.slice(1)));\n        }\n\n      case \"SELF_ADDRESS\":\n        {\n          var addr = {\n            prim: \"address\"\n          };\n\n          if ((ctx === null || ctx === void 0 ? void 0 : ctx.contract) !== undefined) {\n            addr[refContract] = {\n              prim: \"contract\",\n              args: [contractSection(ctx.contract, \"parameter\").args[0]]\n            };\n          }\n\n          return __spreadArray([annotateVar(addr, \"@address\")], __read(stack));\n        }\n\n      case \"CHAIN_ID\":\n        return __spreadArray([annotateVar({\n          prim: \"chain_id\"\n        })], __read(stack));\n\n      case \"DROP\":\n        {\n          instructionAnn({});\n          var n = instruction.args !== undefined ? parseInt(instruction.args[0].int, 10) : 1;\n          args(n - 1, null);\n          return stack.slice(n);\n        }\n\n      case \"DIG\":\n        {\n          instructionAnn({});\n          var n = parseInt(instruction.args[0].int, 10);\n          return __spreadArray(__spreadArray([args(n, null)[0]], __read(stack.slice(0, n))), __read(stack.slice(n + 1)));\n        }\n\n      case \"DUG\":\n        {\n          instructionAnn({});\n          var n = parseInt(instruction.args[0].int, 10);\n          return __spreadArray(__spreadArray(__spreadArray([], __read(stack.slice(1, n + 1))), [args(0, null)[0]]), __read(stack.slice(n + 1)));\n        }\n\n      case \"NONE\":\n        assertTypeAnnotationsValid(instruction.args[0]);\n        return __spreadArray([annotate({\n          prim: \"option\",\n          args: [instruction.args[0]]\n        }, instructionAnn({\n          t: 1,\n          v: 1\n        }))], __read(stack));\n\n      case \"LEFT\":\n      case \"RIGHT\":\n        {\n          var s_28 = args(0, null)[0];\n          var ia = instructionAnn({\n            f: 2,\n            t: 1,\n            v: 1\n          }, {\n            specialFields: true\n          });\n          var va = argAnn(s_28);\n          var children = [annotate(s_28, {\n            t: null,\n            v: null,\n            f: ia.f && ia.f.length > 0 && ia.f[0] !== \"%\" ? ia.f[0] === \"%@\" ? va.v ? [\"%\" + va.v[0].slice(1)] : undefined : ia.f : undefined\n          }), annotate(instruction.args[0], {\n            t: null,\n            f: ia.f && ia.f.length > 1 && ia.f[1] !== \"%\" ? ia.f : undefined\n          })];\n          return __spreadArray([annotate({\n            prim: \"or\",\n            args: instruction.prim === \"LEFT\" ? children : [children[1], children[0]]\n          }, {\n            t: ia.t,\n            v: ia.v\n          })], __read(stack.slice(1)));\n        }\n\n      case \"NIL\":\n        assertTypeAnnotationsValid(instruction.args[0]);\n        return __spreadArray([annotate({\n          prim: \"list\",\n          args: [instruction.args[0]]\n        }, instructionAnn({\n          t: 1,\n          v: 1\n        }))], __read(stack));\n\n      case \"UNPACK\":\n        args(0, [\"bytes\"]);\n        assertTypeAnnotationsValid(instruction.args[0]);\n        return __spreadArray([annotateVar({\n          prim: \"option\",\n          args: [instruction.args[0]]\n        }, \"@unpacked\")], __read(stack.slice(1)));\n\n      case \"CONTRACT\":\n        {\n          var s_29 = args(0, [\"address\"])[0];\n          assertTypeAnnotationsValid(instruction.args[0]);\n          var ia = instructionAnn({\n            v: 1,\n            f: 1\n          });\n          var contract = s_29[refContract];\n\n          if (contract !== undefined) {\n            var ep = contractEntryPoint(contract, (_e = ia.f) === null || _e === void 0 ? void 0 : _e[0]);\n\n            if (ep === null) {\n              throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": contract has no entrypoint \" + ep);\n            }\n\n            ensureTypesEqual(ep, instruction.args[0]);\n          }\n\n          return __spreadArray([annotate({\n            prim: \"option\",\n            args: [{\n              prim: \"contract\",\n              args: [instruction.args[0]]\n            }]\n          }, {\n            v: ia.v ? ia.v : varSuffix(argAnn(s_29), \"contract\")\n          })], __read(stack.slice(1)));\n        }\n\n      case \"CAST\":\n        instructionAnn({});\n        var s = args(0, null)[0];\n        assertTypeAnnotationsValid(instruction.args[0]);\n        ensureTypesEqual(instruction.args[0], s);\n        return __spreadArray([instruction.args[0]], __read(stack.slice(1)));\n\n      case \"IF_NONE\":\n        {\n          instructionAnn({});\n          var s_30 = args(0, [\"option\"])[0];\n          var tail = stack.slice(1);\n          var br0 = functionTypeInternal(instruction.args[0], tail, ctx);\n          var br1 = functionTypeInternal(instruction.args[1], __spreadArray([annotate(s_30.args[0], {\n            t: null,\n            v: varSuffix(argAnn(s_30), \"some\")\n          })], __read(tail)), ctx);\n          return branchType(br0, br1);\n        }\n\n      case \"IF_LEFT\":\n        {\n          instructionAnn({});\n          var s_31 = args(0, [\"or\"])[0];\n          var va = argAnn(s_31);\n          var lefta = argAnn(s_31.args[0]);\n          var righta = argAnn(s_31.args[1]);\n          var tail = stack.slice(1);\n          var br0 = functionTypeInternal(instruction.args[0], __spreadArray([annotate(s_31.args[0], {\n            t: null,\n            v: varSuffix(va, lefta.f ? lefta.f[0].slice(1) : \"left\")\n          })], __read(tail)), ctx);\n          var br1 = functionTypeInternal(instruction.args[1], __spreadArray([annotate(s_31.args[1], {\n            t: null,\n            v: varSuffix(va, righta.f ? righta.f[0].slice(1) : \"right\")\n          })], __read(tail)), ctx);\n          return branchType(br0, br1);\n        }\n\n      case \"IF_CONS\":\n        {\n          instructionAnn({});\n          var s_32 = args(0, [\"list\"])[0];\n          var va = argAnn(s_32);\n          var tail = stack.slice(1);\n          var br0 = functionTypeInternal(instruction.args[0], __spreadArray([annotate(s_32.args[0], {\n            t: null,\n            v: varSuffix(va, \"hd\")\n          }), annotate(s_32, {\n            t: null,\n            v: varSuffix(va, \"tl\")\n          })], __read(tail)), ctx);\n          var br1 = functionTypeInternal(instruction.args[1], tail, ctx);\n          return branchType(br0, br1);\n        }\n\n      case \"IF\":\n        {\n          instructionAnn({});\n          args(0, [\"bool\"]);\n          var tail = stack.slice(1);\n          var br0 = functionTypeInternal(instruction.args[0], tail, ctx);\n          var br1 = functionTypeInternal(instruction.args[1], tail, ctx);\n          return branchType(br0, br1);\n        }\n\n      case \"MAP\":\n        {\n          var s_33 = args(0, [\"list\", \"map\"])[0];\n          var tail = stack.slice(1);\n          var elt = s_33.prim === \"map\" ? {\n            prim: \"pair\",\n            args: s_33.args\n          } : s_33.args[0];\n          var body = functionTypeInternal(instruction.args[0], __spreadArray([annotate(elt, {\n            t: null,\n            v: varSuffix(argAnn(s_33), \"elt\")\n          })], __read(tail)), ctx);\n\n          if (\"failed\" in body) {\n            return body;\n          }\n\n          if (body.length < 1) {\n            throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": function must return a value\");\n          }\n\n          ensureStacksEqual(body.slice(1), tail);\n\n          if (s_33.prim === \"list\") {\n            return __spreadArray([annotateVar({\n              prim: \"list\",\n              args: [body[0]]\n            })], __read(tail));\n          }\n\n          return __spreadArray([annotateVar({\n            prim: \"map\",\n            args: [s_33.args[0], body[0]]\n          })], __read(tail));\n        }\n\n      case \"ITER\":\n        {\n          instructionAnn({});\n          var s_34 = args(0, [\"set\", \"list\", \"map\"])[0];\n          var tail = stack.slice(1);\n          var elt = s_34.prim === \"map\" ? {\n            prim: \"pair\",\n            args: s_34.args\n          } : s_34.args[0];\n          var body = functionTypeInternal(instruction.args[0], __spreadArray([annotate(elt, {\n            t: null,\n            v: varSuffix(argAnn(s_34), \"elt\")\n          })], __read(tail)), ctx);\n\n          if (\"failed\" in body) {\n            return body;\n          }\n\n          ensureStacksEqual(body, tail);\n          return tail;\n        }\n\n      case \"LOOP\":\n        {\n          instructionAnn({});\n          args(0, [\"bool\"]);\n          var tail = stack.slice(1);\n          var body = functionTypeInternal(instruction.args[0], tail, ctx);\n\n          if (\"failed\" in body) {\n            return body;\n          }\n\n          ensureStacksEqual(body, __spreadArray([{\n            prim: \"bool\"\n          }], __read(tail)));\n          return tail;\n        }\n\n      case \"LOOP_LEFT\":\n        {\n          instructionAnn({});\n          var s_35 = args(0, [\"or\"])[0];\n          var tail = stack.slice(1);\n          var body = functionTypeInternal(instruction.args[0], __spreadArray([annotate(s_35.args[0], {\n            t: null,\n            v: varSuffix(argAnn(s_35), \"left\")\n          })], __read(tail)), ctx);\n\n          if (\"failed\" in body) {\n            return body;\n          }\n\n          ensureStacksEqual(body, __spreadArray([s_35], __read(tail)));\n          return __spreadArray([annotate(s_35.args[1], {\n            t: null,\n            v: instructionAnn({\n              v: 1\n            }).v\n          })], __read(tail));\n        }\n\n      case \"DIP\":\n        {\n          instructionAnn({});\n          var n = instruction.args.length === 2 ? parseInt(instruction.args[0].int, 10) : 1;\n          args(n - 1, null);\n          var head = stack.slice(0, n);\n          var tail = stack.slice(n); // ternary operator is a type guard so use it instead of just `instruction.args.length - 1`\n\n          var body = instruction.args.length === 2 ? functionTypeInternal(instruction.args[1], tail, ctx) : functionTypeInternal(instruction.args[0], tail, ctx);\n\n          if (\"failed\" in body) {\n            return body;\n          }\n\n          return __spreadArray(__spreadArray([], __read(head)), __read(body));\n        }\n\n      case \"CREATE_CONTRACT\":\n        {\n          var ia = instructionAnn({\n            v: 2\n          });\n          var s_36 = args(0, [\"option\"], [\"mutez\"], null);\n\n          if (typeID(s_36[0].args[0]) !== \"key_hash\") {\n            throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": key hash expected: \" + typeID(s_36[0].args[0]));\n          }\n\n          if (ensureStorableType(s_36[2])) {\n            assertContractValid(instruction.args[0]);\n            assertScalarTypesEqual(contractSection(instruction.args[0], \"storage\").args[0], s_36[2]);\n          }\n\n          var va = (_f = ia.v) === null || _f === void 0 ? void 0 : _f.map(function (v) {\n            return v !== \"@\" ? [v] : undefined;\n          });\n          return __spreadArray([annotate({\n            prim: \"operation\"\n          }, {\n            v: va === null || va === void 0 ? void 0 : va[0]\n          }), annotate((_b = {\n            prim: \"address\"\n          }, _b[refContract] = {\n            prim: \"contract\",\n            args: [contractSection(instruction.args[0], \"parameter\").args[0]]\n          }, _b), {\n            v: va === null || va === void 0 ? void 0 : va[1]\n          })], __read(stack.slice(3)));\n        }\n\n      case \"PUSH\":\n        assertTypeAnnotationsValid(instruction.args[0]);\n        assertDataValidInternal(instruction.args[1], instruction.args[0], __assign(__assign({}, ctx), {\n          contract: undefined\n        }));\n        return __spreadArray([annotateVar(instruction.args[0])], __read(stack));\n\n      case \"EMPTY_SET\":\n        assertTypeAnnotationsValid(instruction.args[0]);\n        ensureComparableType(instruction.args[0]);\n        return __spreadArray([annotate({\n          prim: \"set\",\n          args: instruction.args\n        }, instructionAnn({\n          t: 1,\n          v: 1\n        }))], __read(stack));\n\n      case \"EMPTY_MAP\":\n        assertTypeAnnotationsValid(instruction.args[0]);\n        ensureComparableType(instruction.args[0]);\n        assertTypeAnnotationsValid(instruction.args[1]);\n        return __spreadArray([annotate({\n          prim: \"map\",\n          args: instruction.args\n        }, instructionAnn({\n          t: 1,\n          v: 1\n        }))], __read(stack));\n\n      case \"EMPTY_BIG_MAP\":\n        assertTypeAnnotationsValid(instruction.args[0]);\n        ensureComparableType(instruction.args[0]);\n        assertTypeAnnotationsValid(instruction.args[1]);\n        ensureBigMapStorableType(instruction.args[0]);\n        return __spreadArray([annotate({\n          prim: \"big_map\",\n          args: instruction.args\n        }, instructionAnn({\n          t: 1,\n          v: 1\n        }))], __read(stack));\n\n      case \"LAMBDA\":\n        {\n          assertTypeAnnotationsValid(instruction.args[0]);\n          assertTypeAnnotationsValid(instruction.args[1]);\n          var body = functionTypeInternal(instruction.args[2], [instruction.args[0]], __assign(__assign({}, ctx), {\n            contract: undefined\n          }));\n\n          if (\"failed\" in body) {\n            return body;\n          }\n\n          if (body.length !== 1) {\n            throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": function must return a value\");\n          }\n\n          ensureTypesEqual(instruction.args[1], body[0]);\n          return __spreadArray([annotateVar({\n            prim: \"lambda\",\n            args: [instruction.args[0], instruction.args[1]]\n          })], __read(stack));\n        }\n\n      case \"LEVEL\":\n        return __spreadArray([annotateVar({\n          prim: \"nat\"\n        }, \"@level\")], __read(stack));\n\n      case \"TOTAL_VOTING_POWER\":\n        return __spreadArray([annotateVar({\n          prim: \"nat\"\n        })], __read(stack));\n\n      case \"VOTING_POWER\":\n        args(0, [\"key_hash\"]);\n        return __spreadArray([annotateVar({\n          prim: \"nat\"\n        })], __read(stack.slice(1)));\n\n      case \"TICKET\":\n        {\n          var s_37 = args(0, null, [\"nat\"])[0];\n          ensureComparableType(s_37);\n          return __spreadArray([annotate({\n            prim: \"ticket\",\n            args: [s_37]\n          }, instructionAnn({\n            t: 1,\n            v: 1\n          }))], __read(stack.slice(2)));\n        }\n\n      case \"JOIN_TICKETS\":\n        {\n          var s_38 = unpackComb(\"pair\", args(0, [\"pair\"])[0]);\n\n          if (typeID(s_38.args[0]) !== \"ticket\") {\n            throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": ticket expected: \" + typeID(s_38.args[0]));\n          }\n\n          ensureTypesEqual(s_38.args[0], s_38.args[1]);\n          return __spreadArray([annotateVar({\n            prim: \"option\",\n            args: [annotate(s_38.args[0], {\n              t: null\n            })]\n          })], __read(stack.slice(1)));\n        }\n\n      case \"SPLIT_TICKET\":\n        {\n          var s_39 = args(0, [\"ticket\"], [\"pair\"]);\n          var p = unpackComb(\"pair\", s_39[1]);\n\n          if (typeID(p.args[0]) !== \"nat\") {\n            throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": nat expected: \" + typeID(p.args[0]));\n          }\n\n          ensureTypesEqual(p.args[0], p.args[1]);\n          return __spreadArray([annotateVar({\n            prim: \"option\",\n            args: [{\n              prim: \"pair\",\n              args: [annotate(s_39[0], {\n                t: null\n              }), annotate(s_39[0], {\n                t: null\n              })]\n            }]\n          })], __read(stack.slice(2)));\n        }\n\n      case \"READ_TICKET\":\n        {\n          var ia = instructionAnn({\n            v: 2\n          });\n          var s_40 = args(0, [\"ticket\"])[0];\n          var va = (_g = ia.v) === null || _g === void 0 ? void 0 : _g.map(function (v) {\n            return v !== \"@\" ? [v] : undefined;\n          });\n          return __spreadArray([annotate({\n            prim: \"pair\",\n            args: [{\n              prim: \"address\"\n            }, annotate(s_40.args[0], {\n              t: null\n            }), {\n              prim: \"nat\"\n            }]\n          }, {\n            v: va === null || va === void 0 ? void 0 : va[0]\n          }), annotate(s_40, {\n            v: va === null || va === void 0 ? void 0 : va[1],\n            t: null\n          })], __read(stack.slice(1)));\n        }\n\n      case \"PAIRING_CHECK\":\n        {\n          var p = args(0, [\"list\"])[0].args[0];\n\n          if (!isPairType(p)) {\n            throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": pair expected: \" + typeID(p));\n          }\n\n          var c = unpackComb(\"pair\", p);\n\n          if (typeID(c.args[0]) !== \"bls12_381_g1\") {\n            throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": bls12_381_g1 expected: \" + typeID(c.args[0]));\n          }\n\n          if (typeID(c.args[1]) !== \"bls12_381_g2\") {\n            throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": bls12_381_g2 expected: \" + typeID(c.args[1]));\n          }\n\n          return __spreadArray([annotateVar({\n            prim: \"bool\"\n          })], __read(stack.slice(1)));\n        }\n\n      case \"SAPLING_EMPTY_STATE\":\n        return __spreadArray([annotate({\n          prim: \"sapling_state\",\n          args: [instruction.args[0]]\n        }, instructionAnn({\n          v: 1,\n          t: 1\n        }))], __read(stack));\n\n      case \"SAPLING_VERIFY_UPDATE\":\n        {\n          var s_41 = args(0, [\"sapling_transaction\"], [\"sapling_state\"]);\n\n          if (parseInt(s_41[0].args[0].int, 10) !== parseInt(s_41[1].args[0].int, 10)) {\n            throw new MichelsonInstructionError(instruction, stack, instruction.prim + \": sapling memo size mismatch: \" + s_41[0].args[0].int + \" != \" + s_41[1].args[0].int);\n          }\n\n          return __spreadArray([annotateVar({\n            prim: \"option\",\n            args: [{\n              prim: \"pair\",\n              args: [{\n                prim: \"int\"\n              }, annotate(s_41[1], {\n                t: null\n              })]\n            }]\n          })], __read(stack.slice(2)));\n        }\n\n      default:\n        throw new MichelsonError(instruction, \"unexpected instruction: \" + instruction.prim);\n    }\n  }(instruction);\n\n  if ((ctx === null || ctx === void 0 ? void 0 : ctx.traceCallback) !== undefined) {\n    var trace = {\n      op: instruction,\n      in: stack,\n      out: retStack\n    };\n    ctx.traceCallback(trace);\n  }\n\n  return retStack;\n}\n\nfunction contractSection(contract, section) {\n  var e_8, _a;\n\n  try {\n    for (var contract_1 = __values(contract), contract_1_1 = contract_1.next(); !contract_1_1.done; contract_1_1 = contract_1.next()) {\n      var s = contract_1_1.value;\n\n      if (s.prim === section) {\n        return s;\n      }\n    }\n  } catch (e_8_1) {\n    e_8 = {\n      error: e_8_1\n    };\n  } finally {\n    try {\n      if (contract_1_1 && !contract_1_1.done && (_a = contract_1.return)) _a.call(contract_1);\n    } finally {\n      if (e_8) throw e_8.error;\n    }\n  }\n\n  throw new MichelsonError(contract, \"missing contract section: \" + section);\n}\n\nfunction isContract(v) {\n  var e_9, _a;\n\n  if (Array.isArray(v)) {\n    try {\n      for (var v_1 = __values(v), v_1_1 = v_1.next(); !v_1_1.done; v_1_1 = v_1.next()) {\n        var s = v_1_1.value;\n\n        if (\"prim\" in s && (s.prim === \"parameter\" || s.prim === \"storage\" || s.prim === \"code\")) {\n          return true;\n        }\n      }\n    } catch (e_9_1) {\n      e_9 = {\n        error: e_9_1\n      };\n    } finally {\n      try {\n        if (v_1_1 && !v_1_1.done && (_a = v_1.return)) _a.call(v_1);\n      } finally {\n        if (e_9) throw e_9.error;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction contractEntryPoint(src, ep) {\n  ep = ep || \"%default\";\n  var entryPoint = contractEntryPoints(src).find(function (x) {\n    return x[0] === ep;\n  });\n\n  if (entryPoint !== undefined) {\n    return entryPoint[1];\n  } else if (ep === \"%default\") {\n    return isContract(src) ? contractSection(src, \"parameter\").args[0] : src;\n  }\n\n  return null;\n}\n\nfunction isOrType(t) {\n  return Array.isArray(t) || t.prim === \"or\";\n}\n\nfunction contractEntryPoints(src) {\n  if (isContract(src)) {\n    var param = contractSection(src, \"parameter\");\n    var ch = contractEntryPoints(param.args[0]);\n    var a = unpackAnnotations(param);\n    return a.f ? __spreadArray([[a.f[0], param.args[0]]], __read(ch)) : ch;\n  }\n\n  if (isOrType(src)) {\n    var args_2 = typeArgs(src);\n\n    var getArg = function (n) {\n      var a = unpackAnnotations(args_2[n]);\n\n      if (typeID(args_2[n]) === \"or\") {\n        var ch = contractEntryPoints(args_2[n]);\n        return a.f ? __spreadArray([[a.f[0], args_2[n]]], __read(ch)) : ch;\n      }\n\n      return a.f ? [[a.f[0], args_2[n]]] : [];\n    };\n\n    return __spreadArray(__spreadArray([], __read(getArg(0))), __read(getArg(1)));\n  }\n\n  return [];\n} // Contract validation\n\n\nfunction assertContractValid(contract, ctx) {\n  var parameter = contractSection(contract, \"parameter\").args[0];\n  assertTypeAnnotationsValid(parameter, true);\n  var storage = contractSection(contract, \"storage\").args[0];\n  assertTypeAnnotationsValid(storage);\n  var arg = {\n    \"prim\": \"pair\",\n    args: [__assign(__assign({}, parameter), {\n      annots: [\"@parameter\"]\n    }), __assign(__assign({}, storage), {\n      annots: [\"@storage\"]\n    })]\n  };\n  var code = contractSection(contract, \"code\").args[0];\n  var ret = functionTypeInternal(code, [arg], __assign(__assign({}, ctx), {\n    contract: contract\n  }));\n\n  if (\"failed\" in ret) {\n    return ret;\n  }\n\n  var expected = {\n    \"prim\": \"pair\",\n    args: [{\n      \"prim\": \"list\",\n      args: [{\n        \"prim\": \"operation\"\n      }]\n    }, storage]\n  };\n\n  try {\n    assertStacksEqual(ret, [expected]);\n  } catch (err) {\n    if (err instanceof MichelsonError) {\n      throw new MichelsonInstructionError(code, ret, err.message);\n    } else {\n      throw err;\n    }\n  }\n\n  return ret;\n} // Exported wrapper functions\n\n\nfunction assertDataValid(d, t, ctx) {\n  assertTypeAnnotationsValid(t);\n  assertDataValidInternal(d, t, ctx || null);\n}\n\nfunction functionType(inst, stack, ctx) {\n  var e_10, _a, e_11, _b;\n\n  try {\n    for (var stack_1 = __values(stack), stack_1_1 = stack_1.next(); !stack_1_1.done; stack_1_1 = stack_1.next()) {\n      var t = stack_1_1.value;\n      assertTypeAnnotationsValid(t);\n    }\n  } catch (e_10_1) {\n    e_10 = {\n      error: e_10_1\n    };\n  } finally {\n    try {\n      if (stack_1_1 && !stack_1_1.done && (_a = stack_1.return)) _a.call(stack_1);\n    } finally {\n      if (e_10) throw e_10.error;\n    }\n  }\n\n  if ((ctx === null || ctx === void 0 ? void 0 : ctx.contract) !== undefined) {\n    try {\n      for (var _c = __values([\"parameter\", \"storage\"]), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var typesec = _d.value;\n        var sec = contractSection(ctx.contract, typesec).args[0];\n        assertTypeAnnotationsValid(sec);\n      }\n    } catch (e_11_1) {\n      e_11 = {\n        error: e_11_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_b = _c.return)) _b.call(_c);\n      } finally {\n        if (e_11) throw e_11.error;\n      }\n    }\n  }\n\n  return functionTypeInternal(inst, stack, ctx || null);\n}\n\nfunction assertTypesEqual(a, b, field) {\n  var e_12, _a, e_13, _b;\n\n  if (field === void 0) {\n    field = false;\n  }\n\n  if (Array.isArray(a)) {\n    try {\n      // type guards don't work for parametrized generic types\n      for (var _c = __values(a), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var v = _d.value;\n        assertTypeAnnotationsValid(v);\n      }\n    } catch (e_12_1) {\n      e_12 = {\n        error: e_12_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_12) throw e_12.error;\n      }\n    }\n\n    try {\n      for (var _e = __values(b), _f = _e.next(); !_f.done; _f = _e.next()) {\n        var v = _f.value;\n        assertTypeAnnotationsValid(v);\n      }\n    } catch (e_13_1) {\n      e_13 = {\n        error: e_13_1\n      };\n    } finally {\n      try {\n        if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n      } finally {\n        if (e_13) throw e_13.error;\n      }\n    }\n  } else {\n    assertTypeAnnotationsValid(a);\n    assertTypeAnnotationsValid(b);\n  }\n\n  assertScalarTypesEqual(a, b, field);\n}\n\nfunction isTypeAnnotationsValid(t, field) {\n  if (field === void 0) {\n    field = false;\n  }\n\n  try {\n    assertTypeAnnotationsValid(t, field);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\n\nfunction isContractValid(contract, ctx) {\n  try {\n    return assertContractValid(contract, ctx);\n  } catch (_a) {\n    return null;\n  }\n}\n\nfunction isDataValid(d, t, ctx) {\n  try {\n    assertDataValid(d, t, ctx);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\n\nfunction isTypeEqual(a, b, field) {\n  if (field === void 0) {\n    field = false;\n  }\n\n  try {\n    assertTypesEqual(a, b, field);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\n\nvar Contract =\n/** @class */\nfunction () {\n  function Contract(contract, opt) {\n    this.contract = contract;\n    this.ctx = __assign({\n      contract: contract\n    }, opt);\n    this.output = assertContractValid(contract, this.ctx);\n  }\n\n  Contract.parse = function (src, opt) {\n    var p = new Parser(opt);\n    var expr = typeof src === \"string\" ? p.parseScript(src) : p.parseJSON(src);\n\n    if (expr === null) {\n      throw new Error(\"empty contract\");\n    }\n\n    if (assertMichelsonContract(expr)) {\n      return new Contract(expr, opt);\n    }\n  };\n\n  Contract.parseTypeExpression = function (src, opt) {\n    var p = new Parser(opt);\n    var expr = typeof src === \"string\" ? p.parseScript(src) : p.parseJSON(src);\n\n    if (expr === null) {\n      throw new Error(\"empty type expression\");\n    }\n\n    if (assertMichelsonType(expr) && assertTypeAnnotationsValid(expr)) {\n      return expr;\n    }\n\n    throw undefined;\n  };\n\n  Contract.parseDataExpression = function (src, opt) {\n    var p = new Parser(opt);\n    var expr = typeof src === \"string\" ? p.parseScript(src) : p.parseJSON(src);\n\n    if (expr === null) {\n      throw new Error(\"empty data expression\");\n    }\n\n    if (assertMichelsonData(expr)) {\n      return expr;\n    }\n\n    throw undefined;\n  };\n\n  Contract.prototype.section = function (section) {\n    return contractSection(this.contract, section);\n  };\n\n  Contract.prototype.entryPoints = function () {\n    return contractEntryPoints(this.contract);\n  };\n\n  Contract.prototype.entryPoint = function (ep) {\n    return contractEntryPoint(this.contract, ep);\n  };\n\n  Contract.prototype.assertDataValid = function (d, t) {\n    assertDataValid(d, t, this.ctx);\n  };\n\n  Contract.prototype.isDataValid = function (d, t) {\n    return isDataValid(d, t, this.ctx);\n  };\n\n  Contract.prototype.assertParameterValid = function (ep, d) {\n    var t = this.entryPoint(ep || undefined);\n\n    if (t === null) {\n      throw new Error(\"contract has no entrypoint named \" + ep);\n    }\n\n    this.assertDataValid(d, t);\n  };\n\n  Contract.prototype.isParameterValid = function (ep, d) {\n    try {\n      this.assertParameterValid(ep, d);\n      return true;\n    } catch (_a) {\n      return false;\n    }\n  };\n\n  Contract.prototype.functionType = function (inst, stack) {\n    return functionType(inst, stack, this.ctx);\n  };\n\n  return Contract;\n}();\n\nvar dummyContract = new Contract([{\n  prim: \"parameter\",\n  args: [{\n    prim: \"unit\"\n  }]\n}, {\n  prim: \"storage\",\n  args: [{\n    prim: \"unit\"\n  }]\n}, {\n  prim: \"code\",\n  args: [[{\n    prim: \"CAR\"\n  }, {\n    prim: \"NIL\",\n    args: [{\n      prim: \"operation\"\n    }]\n  }, {\n    prim: \"PAIR\"\n  }]]\n}]);\n\nfunction formatStack(s) {\n  if (\"failed\" in s) {\n    return \"[FAILED: \" + emitMicheline(s.failed) + \"]\";\n  }\n\n  return s.map(function (v, i) {\n    var ann = unpackAnnotations(v);\n    return \"[\" + i + (ann.v ? \"/\" + ann.v[0] : \"\") + \"]: \" + emitMicheline(v);\n  }).join(\"\\n\");\n}\n\nfunction traceDumpFunc(blocks, cb) {\n  return function (v) {\n    var _a;\n\n    if (Array.isArray(v) && !blocks) {\n      return;\n    }\n\n    var macro = (_a = v.op[sourceReference]) === null || _a === void 0 ? void 0 : _a.macro;\n    var msg = (macro ? \"Macro\" : \"Op\") + \": \" + (macro ? emitMicheline(macro, undefined, true) + \" / \" : \"\") + emitMicheline(v.op) + \"\\nInput:\\n\" + formatStack(v.in) + \"\\nOutput:\\n\" + formatStack(v.out) + \"\\n\";\n    cb(msg);\n  };\n}\n\nfunction formatError(err) {\n  var _a;\n\n  if (err instanceof MichelsonInstructionError) {\n    var macro = (_a = err.val[sourceReference]) === null || _a === void 0 ? void 0 : _a.macro;\n    return (macro ? \"Macro\" : \"Op\") + \": \" + (macro ? emitMicheline(macro, undefined, true) + \" / \" : \"\") + emitMicheline(err.val) + \"\\nStack:\\n\" + formatStack(err.stackState) + \"\\n\";\n  } else if (err instanceof MichelsonTypeError) {\n    var type = Array.isArray(err.val) ? \"[\" + err.val.map(function (v, i) {\n      return \"[\" + i + \"]: \" + emitMicheline(v);\n    }).join(\"; \") + \"]\" : emitMicheline(err.val);\n    return \"Type: \" + type + \"\\n\" + (err.data ? \"Data: \" + emitMicheline(err.data) + \"\\n\" : \"\") + \"\\n\";\n  } else {\n    return \"Value: \" + emitMicheline(err.val);\n  }\n} // IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\n\n/* tslint:disable */\n\n\nvar VERSION = {\n  \"commitHash\": \"5711569ffaf481d88ba3251343a1788090b35dd4\",\n  \"version\": \"10.2.1\"\n};\n/* tslint:enable */\n\nexport { Contract, DefaultProtocol, JSONParseError, MacroError, MichelineParseError, MichelsonError, MichelsonInstructionError, MichelsonTypeError, MichelsonValidationError, Parser, Protocol, VERSION, assertContractValid, assertDataListIfAny, assertDataValid, assertMichelsonBigMapStorableType, assertMichelsonComparableType, assertMichelsonContract, assertMichelsonData, assertMichelsonInstruction, assertMichelsonPackableType, assertMichelsonPassableType, assertMichelsonPushableType, assertMichelsonStorableType, assertMichelsonType, assertTypeAnnotationsValid, assertTypesEqual, contractEntryPoint, contractEntryPoints, contractSection, decodeAddressBytes, decodePublicKeyBytes, decodePublicKeyHashBytes, dummyContract, emitMicheline, formatError, formatStack, functionType, instructionIDs, isContractValid, isDataValid, isInstruction, isMichelsonCode, isMichelsonData, isMichelsonError, isMichelsonScript, isMichelsonType, isTypeAnnotationsValid, isTypeEqual, packData, packDataBytes, refContract, sourceReference, traceDumpFunc, unpackData, unpackDataBytes };","map":{"version":3,"mappings":"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","names":["sourceReference","Symbol","__extends","src","idx","message","_super","_this","Object","setPrototypeOf","ScanError","prototype","Error","Literal","isSpace","RegExp","isIdentStart","isIdent","isDigit","isHex","scan","scanComments","i","length","test","s","start","t","Ident","v","slice","first","last","_a","substr","Bytes","ii","Number","esc","String","Comment","refContract","Protocol","DefaultProtocol","PsDELPH1","prim","MacroError","assertArgs","ex","n","args","undefined","_b","assertNoAnnots","annots","assertIntArg","arg","parsePairUnpairExpr","p","expr","annotations","agg","ai","ann","lexpr","c","r","an","rexpr","map","a","parseSetMapCadr","vann","term","__read","d","trimLast","l","filterAnnotations","fields","rest","a_1_1","push","mkPrim","pairRe","unpairRe","cadrRe","setCadrRe","mapCadrRe","diipRe","duupRe","expandMacros","opt","proto","protocol","mayRename","parseInt","int","rest_1","top","r_1","leaf","PtEdo2Zk","PsFLorena","PtGRANADs","PtHangzH","ch_1","token","MichelineParseError","node","JSONParseError","errEOF","isAnnotation","tok","intRe","bytesRe","Parser","ret","__assign","macro","scanner","ref","expectBracket","next","done","value","tok_1","parseExpr","expand","seq","parseArgs","itm","string","JSON","parse","_c","bytes","_d","parseSequenceExpr","parseListExpr","TypeError","parseSequence","parseList","Array","isArray","src_1_1","parseJSON","_e","_g","lev","Formatter","indent","newline","hasArgs","isMultiline","emitExpr","f","foldMacros","emitSeq","stringify","multiline","lfsp","down","lf","node_1_1","el","emitMicheline","H","K","sha256","msg","pad","buffer","fill","ror","x","h","w","offset","q","s0","s1","i_1","i_2","b0","b1","t1","t2","i_3","digest","h_1_1","v_1","base58alphabetFwd","base58alphabetBwd","byteAt","charCodeAt","decodeBase58","acc","zeros","carry","m","Math","floor","reverse","encodeBase58","fromCharCode","apply","__spreadArray","decodeBase58Check","data","sum","computed","encodeBase58Check","val","MichelsonError","isMichelsonError","err","MichelsonTypeError","neg","append","LongInteger","buf","parseBytes","isNaN","compareBytes","b","isDecimal","isNatural","sign","annRe","unpackAnnotations","field","type","vars","specialVar","specialFields","emptyFields","emptyVar","tezosPrefix","BlockHash","OperationHash","OperationListHash","OperationListListHash","ProtocolHash","ContextHash","ED25519PublicKeyHash","SECP256K1PublicKeyHash","P256PublicKeyHash","ContractHash","CryptoboxPublicKeyHash","ED25519Seed","ED25519PublicKey","SECP256K1SecretKey","P256SecretKey","ED25519EncryptedSeed","SECP256K1EncryptedSecretKey","P256EncryptedSecretKey","SECP256K1PublicKey","P256PublicKey","SECP256K1Scalar","SECP256K1Element","ED25519SecretKey","ED25519Signature","SECP256K1Signature","P256Signature","GenericSignature","ChainID","checkDecodeTezosID","id","types","types_1_1","plen","encodeTezosID","unpackComb","vv","isPairType","isPairData","rfc3339Re","parseDate","Date","valueOf","parseHex","res","ss","hexBytes","toString","join","noArgInstructionIDs","instructionIDs","assign","simpleComparableTypeIDs","typeIDs","MichelsonValidationError","isPrim","isPrimOrSeq","assertPrim","assertSeq","assertPrimOrSeq","assertNatural","assertIntLiteral","assertMichelsonInstruction","ex_1_1","hasOwnProperty","call","assertMichelsonType","assertMichelsonPackableType","assertMichelsonPassableType","assertMichelsonContract","assertMichelsonPushableType","assertMichelsonData","assertMichelsonComparableType","assertMichelsonBigMapStorableType","traverseType","assertMichelsonStorableType","cb","forEach","mapElts","ex_2_1","ent","ex_3_1","sec","isMichelsonScript","isMichelsonData","isMichelsonCode","isMichelsonType","isInstruction","assertDataListIfAny","d_1_1","primitives","primTags","Tag","Writer","writeUint8","writeUint16","writeUint32","boundsErr","cap","Reader","len","x0","x1","x2","x3","ContractID","PublicKeyHashID","readPublicKeyHash","rd","tag","readUint8","ED25519","SECP256K1","P256","hash","readBytes","readAddress","address","Implicit","Originated","dec","TextDecoder","entryPoint","decode","Uint8Array","writePublicKeyHash","writeBytes","from","writeAddress","enc","TextEncoder","encode","PublicKeyID","readPublicKey","ln","publicKey","writePublicKey","pk","writeExpr","wr","tf","e","e_4_1","Sequence","Int","BigInt","bits","byte","Prim0","Prim","_h","_k","readExpr","passThrough","readPassThrough","tr","readInt8","byte_1","length_1","readUint32","length_2","hex","length_3","savedrd","copy","it_1","reader","argn","it_2","length_4","length_5","split","isOrData","isOptionData","getWriteTransformFunc","tc","dc","dd","d_1","d_2","d_2_1","elt","iterator","sig","pkh","key","getTime","writePassThrough","isPushInstruction","packData","packDataBytes","getReadTransformFuncs","args_1","args_2","args_2_1","addr","date","toISOString","unpackData","unpackDataBytes","decodeAddressBytes","decodePublicKeyHashBytes","decodePublicKeyBytes","stackState","MichelsonInstructionError","typeID","typeArgs","assertScalarTypesEqual","aArgs","bArgs","assertStacksEqual","assertTypeAnnotationsValid","args_1_1","compareMichelsonData","tComb","aComb","bComb","cmp","localeCompare","aa","bb","isFunction","assertDataValidInternal","ctx","ep","indexOf","prev","functionTypeInternal","failed","d_3_1","instructionListType","inst","stack","inst_1_1","op","ft","traceCallback","trace","in","out","instruction","typeIds","typeIds_1_1","ids","rethrow","fn","rethrowTypeGuard","argAnn","ensureStacksEqual","ensureTypesEqual","ensureComparableType","ensurePackableType","ensureStorableType","ensurePushableType","ensureBigMapStorableType","instructionAnn","num","assertNum","annotate","tt","tx","annotateVar","def","ia","annotateField","insAnn","defField","fieldAnn","insFieldAnn","insVarAnn","varAnn","getN","right","getNth","updateNth","varSuffix","suffix","branchType","br0","br1","retStack","s_1","s_2","s_3","ia_1","trim_1","lastIndexOf","retArgs","va","s_4","ia_2","s_5","toLocaleLowerCase","s_6","s_7","s_8","s_9","s_10","s1_1","s_11","s_12","s_13","pt","s_14","s_15","s_16","s_17","s_18","s_19","s_20","s_21","s_22","s_23","s_24","contract","contractEntryPoint","s_25","s_26","s_27","contractSection","s_28","children","s_29","s_30","tail","s_31","lefta","righta","s_32","s_33","body","s_34","s_35","head","s_36","assertContractValid","_f","s_37","s_38","s_39","s_40","s_41","section","contract_1_1","isContract","v_1_1","contractEntryPoints","find","isOrType","param","ch","getArg","parameter","storage","code","expected","assertDataValid","functionType","stack_1_1","typesec","assertTypesEqual","isTypeAnnotationsValid","isContractValid","isDataValid","isTypeEqual","output","Contract","parseScript","assertParameterValid","dummyContract","formatStack","traceDumpFunc","blocks","formatError","VERSION"],"sources":["../src/micheline.ts","../src/scan.ts","../src/michelson-types.ts","../src/macros.ts","../src/micheline-parser.ts","../src/micheline-emitter.ts","../src/base58.ts","../src/utils.ts","../src/michelson-validator.ts","../src/binary.ts","../src/michelson-typecheck.ts","../src/michelson-contract.ts","../src/formatters.ts","../src/version.ts"],"sourcesContent":["// Michelson abstract syntax tree types https://tezos.gitlab.io/whitedoc/michelson.html#concrete-syntax\n\nexport type SourceReference = {\n    first: number;\n    last: number;\n    macro?: Expr;\n};\n\nexport const sourceReference: unique symbol = Symbol(\"source_reference\");\n\nexport interface Node {\n    [sourceReference]?: SourceReference;\n}\n\n/**\n * An AST node representing Michelson string literal.\n */\nexport interface StringLiteral extends Node {\n    string: string;\n}\n\n/**\n * An AST node representing Michelson int literal.\n */\nexport interface IntLiteral<T extends string = string> extends Node {\n    int: T;\n}\n\n/**\n * An AST node representing Michelson bytes literal.\n */\nexport interface BytesLiteral extends Node {\n    bytes: string;\n}\n\n/**\n * An AST node representing Michelson primitive.\n */\nexport interface Prim<PT extends string = string, AT extends Expr[] = Expr[]> extends Node {\n    prim: PT;\n    args?: AT;\n    annots?: string[];\n}\n\nexport type List<T extends Expr> = T[] & Node;\n\ninterface ExprList extends List<Expr> { }\n\n/**\n * An AST node representing valid Michelson expression. Directly corresponds to JSON-encoded Michelson node\n */\n\nexport type Expr = Prim | StringLiteral | IntLiteral | BytesLiteral | ExprList;\n","export class ScanError extends Error {\n    constructor(public src: string, public idx: number, message?: string) {\n        super(message);\n        Object.setPrototypeOf(this, ScanError.prototype);\n    }\n}\n\nexport enum Literal {\n    Comment,\n    Number,\n    String,\n    Bytes,\n    Ident,\n}\n\nexport type TokenType = \"(\" | \")\" | \"{\" | \"}\" | \";\" | Literal;\n\nconst isSpace = new RegExp(\"\\\\s\");\nconst isIdentStart = new RegExp(\"[:@%_A-Za-z]\");\nconst isIdent = new RegExp(\"[@%_\\\\.A-Za-z0-9]\");\nconst isDigit = new RegExp(\"[0-9]\");\nconst isHex = new RegExp(\"[0-9a-fA-F]\");\n\nexport interface Token {\n    t: TokenType;\n    v: string;\n    first: number;\n    last: number;\n}\n\nexport function* scan(src: string, scanComments = false): Generator<Token, void> {\n    let i = 0;\n    while (i < src.length) {\n        // Skip space\n        while (i < src.length && isSpace.test(src[i])) {\n            i++;\n        }\n        if (i === src.length) {\n            return;\n        }\n\n        const s = src[i];\n        const start = i;\n        if (isIdentStart.test(s)) {\n            // Identifier\n            i++;\n            while (i < src.length && isIdent.test(src[i])) {\n                i++;\n            }\n            yield { t: Literal.Ident, v: src.slice(start, i), first: start, last: i };\n        } else if (src.length - i > 1 && src.substr(i, 2) === \"0x\") {\n            // Bytes\n            i += 2;\n            while (i < src.length && isHex.test(src[i])) {\n                i++;\n            }\n            if (((i - start) & 1) !== 0) {\n                throw new ScanError(src, i, \"Bytes literal length is expected to be power of two\");\n            }\n            yield { t: Literal.Bytes, v: src.slice(start, i), first: start, last: i };\n        } else if (isDigit.test(s) || s === \"-\") {\n            // Number\n            if (s === \"-\") {\n                i++;\n            }\n            const ii = i;\n            while (i < src.length && isDigit.test(src[i])) {\n                i++;\n            }\n            if (ii === i) {\n                throw new ScanError(src, i, \"Number literal is too short\");\n            }\n            yield { t: Literal.Number, v: src.slice(start, i), first: start, last: i };\n        } else if (s === \"\\\"\") {\n            // String\n            i++;\n            let esc = false;\n            for (; i < src.length && (esc || src[i] !== \"\\\"\"); i++) {\n                if (!esc && src[i] === \"\\\\\") {\n                    esc = true;\n                } else {\n                    esc = false;\n                }\n            }\n            if (i === src.length) {\n                throw new ScanError(src, i, \"Unterminated string literal\");\n            }\n            i++;\n            yield { t: Literal.String, v: src.slice(start, i), first: start, last: i };\n        } else if (s === \"#\") {\n            // Comment\n            i++;\n            while (i < src.length && src[i] !== \"\\n\") {\n                i++;\n            }\n            if (scanComments) {\n                yield { t: Literal.Comment, v: src.slice(start, i), first: start, last: i };\n            }\n        } else if (src.length - i > 1 && src.substr(i, 2) === \"/*\") {\n            // C style comment\n            i += 2;\n            while (i < src.length && !(src.length - i > 1 && src.substr(i, 2) === \"*/\")) {\n                i++;\n            }\n            if (i === src.length) {\n                throw new ScanError(src, i, \"Unterminated C style comment\");\n            }\n            i += 2;\n            if (scanComments) {\n                yield { t: Literal.Comment, v: src.slice(start, i), first: start, last: i };\n            }\n        } else if (s === \"(\" || s === \")\" || s === \"{\" || s === \"}\" || s === \";\") {\n            i++;\n            yield { t: s, v: s, first: start, last: i };\n        } else {\n            throw new ScanError(src, i, `Invalid character at offset ${i}: \\`${s}'`);\n        }\n    }\n}","import { Prim, Expr, IntLiteral, StringLiteral, BytesLiteral, List, Node } from \"./micheline\";\n\ninterface Prim0<PT extends string = string> extends Prim<PT> {\n    args?: never;\n}\ninterface PrimX<PT extends string = string, AT extends Expr[] = Expr[]> extends Prim<PT, AT> {\n    args: AT;\n}\n\n// Instructions\ntype MichelsonNoArgInstructionID = \"ABS\" | \"ADD\" | \"ADDRESS\" | \"AMOUNT\" | \"AND\" | \"APPLY\" | \"BALANCE\" |\n    \"BLAKE2B\" | \"CAR\" | \"CDR\" | \"CHAIN_ID\" | \"CHECK_SIGNATURE\" | \"COMPARE\" | \"CONCAT\" | \"CONS\" | \"EDIV\" |\n    \"EQ\" | \"EXEC\" | \"FAILWITH\" | \"GE\" | \"GET_AND_UPDATE\" | \"GT\" | \"HASH_KEY\" | \"IMPLICIT_ACCOUNT\" |\n    \"INT\" | \"ISNAT\" | \"JOIN_TICKETS\" | \"KECCAK\" | \"LE\" | \"LEVEL\" | \"LSL\" | \"LSR\" | \"LT\" | \"MEM\" | \"MUL\" |\n    \"NEG\" | \"NEQ\" | \"NEVER\" | \"NOT\" | \"NOW\" | \"OR\" | \"PACK\" | \"PAIRING_CHECK\" | \"READ_TICKET\" |\n    \"SAPLING_VERIFY_UPDATE\" | \"SELF\" | \"SELF_ADDRESS\" | \"SENDER\" | \"SET_DELEGATE\" | \"SHA256\" | \"SHA3\" |\n    \"SHA512\" | \"SIZE\" | \"SLICE\" | \"SOME\" | \"SOURCE\" | \"SPLIT_TICKET\" | \"SUB\" | \"SWAP\" | \"TICKET\" |\n    \"TOTAL_VOTING_POWER\" | \"TRANSFER_TOKENS\" | \"UNIT\" | \"VOTING_POWER\" | \"XOR\" | \"RENAME\";\n\ntype MichelsonRegularInstructionID = \"CONTRACT\" | \"CREATE_CONTRACT\" | \"DIG\" | \"DIP\" | \"DROP\" |\n    \"DUG\" | \"DUP\" | \"EMPTY_BIG_MAP\" | \"EMPTY_MAP\" | \"EMPTY_SET\" | \"GET\" | \"IF\" | \"IF_CONS\" | \"IF_LEFT\" |\n    \"IF_NONE\" | \"ITER\" | \"LAMBDA\" | \"LEFT\" | \"LOOP\" | \"LOOP_LEFT\" | \"MAP\" | \"NIL\" | \"NONE\" | \"PAIR\" |\n    \"PUSH\" | \"RIGHT\" | \"SAPLING_EMPTY_STATE\" | \"UNPACK\" | \"UNPAIR\" | \"UPDATE\" | \"CAST\" |\n    // legacy\n    \"CREATE_ACCOUNT\" | \"STEPS_TO_QUOTA\";\n\nexport type MichelsonInstructionID = MichelsonNoArgInstructionID | MichelsonRegularInstructionID;\ntype InstrPrim<PT extends MichelsonInstructionID, AT extends Expr[]> = Prim<PT, AT>;\ntype Instr0<PT extends MichelsonNoArgInstructionID> = Prim0<PT>;\ntype InstrX<PT extends MichelsonRegularInstructionID, AT extends Expr[]> = PrimX<PT, AT>;\n\nexport type MichelsonCode = InstructionList | MichelsonInstruction;\nexport interface InstructionList extends List<MichelsonCode> { }\n\nexport type MichelsonNoArgInstruction = Instr0<MichelsonNoArgInstructionID>;\nexport type MichelsonInstruction =\n    MichelsonNoArgInstruction |\n    InstrX<\"DIG\" | \"DUG\" | \"SAPLING_EMPTY_STATE\", [IntLiteral]> |\n    InstrX<\"NONE\" | \"LEFT\" | \"RIGHT\" | \"NIL\" | \"CAST\", [MichelsonType]> |\n    InstrX<\"IF_NONE\" | \"IF_LEFT\" | \"IF_CONS\" | \"IF\", [InstructionList, InstructionList]> |\n    InstrX<\"MAP\" | \"ITER\" | \"LOOP\" | \"LOOP_LEFT\" | \"DIP\", [InstructionList]> |\n    InstrX<\"UNPACK\", [MichelsonType]> |\n    InstrX<\"CONTRACT\", [MichelsonType]> |\n    InstrX<\"CREATE_CONTRACT\", [MichelsonContract]> |\n    InstrX<\"PUSH\", [MichelsonType, MichelsonData]> |\n    InstrX<\"EMPTY_SET\", [MichelsonType]> |\n    InstrX<\"EMPTY_MAP\", [MichelsonType, MichelsonType]> |\n    InstrX<\"EMPTY_BIG_MAP\", [MichelsonType, MichelsonType]> |\n    InstrX<\"LAMBDA\", [MichelsonType, MichelsonType, InstructionList]> |\n    InstrX<\"DIP\", [IntLiteral, InstructionList] | [InstructionList]> |\n    InstrPrim<\"DROP\" | \"PAIR\" | \"UNPAIR\" | \"DUP\" | \"GET\" | \"UPDATE\", [IntLiteral]>;\n\n// Types\n\nexport type MichelsonSimpleComparableTypeID = \"string\" | \"nat\" | \"int\" | \"bytes\" | \"bool\" | \"mutez\" |\n    \"key_hash\" | \"address\" | \"timestamp\" | \"never\" | \"key\" | \"unit\" | \"signature\" | \"chain_id\";\n\nexport type MichelsonTypeID = MichelsonSimpleComparableTypeID |\n    \"option\" | \"list\" | \"set\" | \"contract\" | \"operation\" | \"pair\" | \"or\" | \"lambda\" | \"map\" | \"big_map\" |\n    \"sapling_transaction\" | \"sapling_state\" | \"ticket\" | \"bls12_381_g1\" | \"bls12_381_g2\" | \"bls12_381_fr\";\n\ntype Type0<PT extends MichelsonTypeID> = Prim0<PT>;\ntype TypeX<PT extends MichelsonTypeID, AT extends Expr[]> = PrimX<PT, AT>;\n\n// Michelson types\n\nexport const refContract: unique symbol = Symbol(\"ref_contract\");\nexport interface MichelsonTypeAddress extends Type0<\"address\"> {\n    [refContract]?: MichelsonTypeContract<MichelsonType>;\n}\n\nexport type MichelsonTypeInt = Type0<\"int\">;\nexport type MichelsonTypeNat = Type0<\"nat\">;\nexport type MichelsonTypeString = Type0<\"string\">;\nexport type MichelsonTypeBytes = Type0<\"bytes\">;\nexport type MichelsonTypeMutez = Type0<\"mutez\">;\nexport type MichelsonTypeBool = Type0<\"bool\">;\nexport type MichelsonTypeKeyHash = Type0<\"key_hash\">;\nexport type MichelsonTypeTimestamp = Type0<\"timestamp\">;\nexport type MichelsonTypeKey = Type0<\"key\">;\nexport type MichelsonTypeUnit = Type0<\"unit\">;\nexport type MichelsonTypeSignature = Type0<\"signature\">;\nexport type MichelsonTypeOperation = Type0<\"operation\">;\nexport type MichelsonTypeChainID = Type0<\"chain_id\">;\nexport type MichelsonTypeNever = Type0<\"never\">;\nexport type MichelsonTypeBLS12_381_G1 = Type0<\"bls12_381_g1\">;\nexport type MichelsonTypeBLS12_381_G2 = Type0<\"bls12_381_g2\">;\nexport type MichelsonTypeBLS12_381_FR = Type0<\"bls12_381_fr\">;\n\ntype TypeList<T extends MichelsonType[]> = T & Node;\nexport type MichelsonTypePair<T extends MichelsonType[]> = TypeX<\"pair\", T> | TypeList<T>;\n\nexport interface MichelsonTypeOption<T extends MichelsonType> extends TypeX<\"option\", [T]> { }\nexport interface MichelsonTypeList<T extends MichelsonType> extends TypeX<\"list\", [T]> { }\nexport interface MichelsonTypeContract<T extends MichelsonType> extends TypeX<\"contract\", [T]> { }\nexport interface MichelsonTypeOr<T extends [MichelsonType, MichelsonType]> extends TypeX<\"or\", T> { }\nexport interface MichelsonTypeLambda<Arg extends MichelsonType, Ret extends MichelsonType> extends TypeX<\"lambda\", [Arg, Ret]> { }\nexport interface MichelsonTypeSet<T extends MichelsonType> extends TypeX<\"set\", [T]> { }\nexport interface MichelsonTypeMap<K extends MichelsonType, V extends MichelsonType> extends TypeX<\"map\", [K, V]> { }\nexport interface MichelsonTypeBigMap<K extends MichelsonType, V extends MichelsonType> extends TypeX<\"big_map\", [K, V]> { }\nexport interface MichelsonTypeSaplingState<S extends string = string> extends TypeX<\"sapling_state\", [IntLiteral<S>]> { }\nexport interface MichelsonTypeSaplingTransaction<S extends string = string> extends TypeX<\"sapling_transaction\", [IntLiteral<S>]> { }\nexport interface MichelsonTypeTicket<T extends MichelsonType> extends TypeX<\"ticket\", [T]> { }\n\nexport type MichelsonType<T extends MichelsonTypeID = MichelsonTypeID> =\n    T extends \"int\" ? MichelsonTypeInt :\n    T extends \"nat\" ? MichelsonTypeNat :\n    T extends \"string\" ? MichelsonTypeString :\n    T extends \"bytes\" ? MichelsonTypeBytes :\n    T extends \"mutez\" ? MichelsonTypeMutez :\n    T extends \"bool\" ? MichelsonTypeBool :\n    T extends \"key_hash\" ? MichelsonTypeKeyHash :\n    T extends \"timestamp\" ? MichelsonTypeTimestamp :\n    T extends \"address\" ? MichelsonTypeAddress :\n    T extends \"key\" ? MichelsonTypeKey :\n    T extends \"unit\" ? MichelsonTypeUnit :\n    T extends \"signature\" ? MichelsonTypeSignature :\n    T extends \"operation\" ? MichelsonTypeOperation :\n    T extends \"chain_id\" ? MichelsonTypeChainID :\n    T extends \"option\" ? MichelsonTypeOption<MichelsonType> :\n    T extends \"list\" ? MichelsonTypeList<MichelsonType> :\n    T extends \"contract\" ? MichelsonTypeContract<MichelsonType> :\n    T extends \"ticket\" ? MichelsonTypeTicket<MichelsonType> :\n    T extends \"pair\" ? MichelsonTypePair<MichelsonType[]> :\n    T extends \"or\" ? MichelsonTypeOr<[MichelsonType, MichelsonType]> :\n    T extends \"lambda\" ? MichelsonTypeLambda<MichelsonType, MichelsonType> :\n    T extends \"set\" ? MichelsonTypeSet<MichelsonType> :\n    T extends \"map\" ? MichelsonTypeMap<MichelsonType, MichelsonType> :\n    T extends \"big_map\" ? MichelsonTypeBigMap<MichelsonType, MichelsonType> :\n    T extends \"never\" ? MichelsonTypeNever :\n    T extends \"bls12_381_g1\" ? MichelsonTypeBLS12_381_G1 :\n    T extends \"bls12_381_g2\" ? MichelsonTypeBLS12_381_G2 :\n    T extends \"bls12_381_fr\" ? MichelsonTypeBLS12_381_FR :\n    T extends \"sapling_transaction\" ? MichelsonTypeSaplingTransaction :\n    MichelsonTypeSaplingState;\n\n// Data\n\nexport type MichelsonDataID = \"Unit\" | \"True\" | \"False\" | \"None\" | \"Pair\" | \"Left\" | \"Right\" | \"Some\";\n\ntype Data0<PT extends MichelsonDataID> = Prim0<PT>;\ntype DataX<PT extends MichelsonDataID, AT extends MichelsonData[]> = PrimX<PT, AT>;\n\nexport type MichelsonDataOption = DataX<\"Some\", [MichelsonData]> | Data0<\"None\">;\nexport type MichelsonDataOr = DataX<\"Left\" | \"Right\", [MichelsonData]>;\ntype DataList<T extends MichelsonData[]> = T & Node;\nexport type MichelsonDataPair<T extends MichelsonData[]> = DataX<\"Pair\", T> | DataList<T>;\nexport type MichelsonMapElt = PrimX<\"Elt\", [MichelsonData, MichelsonData]>;\nexport type MichelsonMapEltList = List<MichelsonMapElt>;\n\nexport type MichelsonData =\n    IntLiteral |\n    StringLiteral |\n    BytesLiteral |\n    Data0<\"Unit\" | \"True\" | \"False\"> |\n    MichelsonDataOption |\n    MichelsonDataOr |\n    DataList<MichelsonData[]> |\n    MichelsonDataPair<MichelsonData[]> |\n    InstructionList |\n    MichelsonMapEltList;\n\n// Top level script sections\n\nexport type MichelsonSectionID = \"parameter\" | \"storage\" | \"code\";\ntype SectionPrim<PT extends MichelsonSectionID, AT extends Expr[]> = PrimX<PT, AT>;\n\nexport type MichelsonContractParameter = SectionPrim<\"parameter\", [MichelsonType]>;\nexport type MichelsonContractStorage = SectionPrim<\"storage\", [MichelsonType]>;\nexport type MichelsonContractCode = SectionPrim<\"code\", [InstructionList]>;\n\nexport type MichelsonContract =\n    [MichelsonContractParameter, MichelsonContractStorage, MichelsonContractCode] |\n    [MichelsonContractParameter, MichelsonContractCode, MichelsonContractStorage] |\n    [MichelsonContractStorage, MichelsonContractParameter, MichelsonContractCode] |\n    [MichelsonContractStorage, MichelsonContractCode, MichelsonContractParameter] |\n    [MichelsonContractCode, MichelsonContractStorage, MichelsonContractParameter] |\n    [MichelsonContractCode, MichelsonContractParameter, MichelsonContractStorage];\n\nexport type MichelsonContractSection<T extends MichelsonSectionID> =\n    T extends \"parameter\" ? MichelsonContractParameter :\n    T extends \"storage\" ? MichelsonContractStorage : MichelsonContractCode;\n\n// Code analysis types \nexport interface MichelsonTypeFailed {\n    failed: MichelsonType;\n}\n\nexport type MichelsonReturnType = MichelsonType[] | MichelsonTypeFailed;\n\nexport enum Protocol {\n    Pt24m4xi = \"Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd\",\n    PsBABY5H = \"PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU\",\n    PsBabyM1 = \"PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS\",\n    PsCARTHA = \"PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb\",\n    PsDELPH1 = \"PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo\",\n    PtEdo2Zk = 'PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA',\n    PsFLorena = 'PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i',\n    PtGRANADs = 'PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV',\n    PtHangzH = 'PtHangzHogokSuiMHemCuowEavgYTP8J5qQ9fQS793MHYFpCY3r'\n}\n\nexport const DefaultProtocol = Protocol.PsDELPH1;\n\nexport type ProtocolID = `${Protocol}`;\n\nexport interface ProtocolOptions {\n    protocol?: ProtocolID;\n}","import { Prim, Expr, IntLiteral } from \"./micheline\";\nimport { DefaultProtocol, Protocol, ProtocolOptions } from \"./michelson-types\";\nimport { Tuple, NoArgs, ReqArgs, NoAnnots } from \"./utils\";\n\nexport class MacroError extends Error {\n    constructor(public prim: Prim, message?: string) {\n        super(message);\n        Object.setPrototypeOf(this, MacroError.prototype);\n    }\n}\n\nfunction assertArgs<N extends number>(ex: Prim, n: N):\n    ex is N extends 0 ?\n    NoArgs<Prim<string>> :\n    ReqArgs<Prim<string, Tuple<N, Expr>>> {\n    if ((n === 0 && ex.args === undefined) || ex.args?.length === n) {\n        return true;\n    }\n    throw new MacroError(ex, `macro ${ex.prim} expects ${n} arguments, was given ${ex.args?.length}`);\n}\n\nfunction assertNoAnnots(ex: Prim): ex is NoAnnots<Prim> {\n    if (ex.annots === undefined) {\n        return true;\n    }\n    throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${ex.annots}`);\n}\n\nfunction assertIntArg(ex: Prim, arg: Expr): arg is IntLiteral {\n    if (\"int\" in arg) {\n        return true;\n    }\n    throw new MacroError(ex, `macro ${ex.prim} expects int argument`);\n}\n\ntype PT = [number, [string | null, string | null]];\n\nfunction parsePairUnpairExpr(p: Prim, expr: string, annotations: string[], agg: (l: PT[] | undefined, r: PT[] | undefined, top: PT) => PT[]): { r: PT[], n: number, an: number } {\n    let i = 0;\n    let ai = 0;\n    const ann: [string | null, string | null] = [null, null];\n\n    // Left expression\n    let lexpr: PT[] | undefined;\n    if (i === expr.length) {\n        throw new MacroError(p, `unexpected end: ${p.prim}`);\n    }\n    let c = expr[i++];\n    switch (c) {\n        case \"P\":\n            const { r, n, an } = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg);\n            lexpr = r;\n            i += n;\n            ai += an;\n            break;\n        case \"A\":\n            if (ai !== annotations.length) {\n                ann[0] = annotations[ai++];\n            }\n            break;\n        default:\n            throw new MacroError(p, `${p.prim}: unexpected character: ${c}`);\n    }\n\n    // Right expression\n    let rexpr: PT[] | undefined;\n    if (i === expr.length) {\n        throw new MacroError(p, `unexpected end: ${p.prim}`);\n    }\n    c = expr[i++];\n    switch (c) {\n        case \"P\":\n            const { r, n, an } = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg);\n            rexpr = r.map<PT>(([v, a]) => [v + 1, a]);\n            i += n;\n            ai += an;\n            break;\n        case \"I\":\n            if (ai !== annotations.length) {\n                ann[1] = annotations[ai++];\n            }\n            break;\n        default:\n            throw new MacroError(p, `${p.prim}: unexpected character: ${c}`);\n    }\n\n    return { r: agg(lexpr, rexpr, [0, ann]), n: i, an: ai };\n}\n\nfunction parseSetMapCadr(p: Prim, expr: string, vann: string[], term: { a: Expr, d: Expr }): Expr {\n    const c = expr[0];\n    switch (c) {\n        case \"A\":\n            return expr.length > 1 ?\n                [\n                    { prim: \"DUP\" },\n                    {\n                        prim: \"DIP\",\n                        args: [[\n                            { prim: \"CAR\", annots: [\"@%%\"] },\n                            parseSetMapCadr(p, expr.slice(1), [], term),\n                        ]],\n                    },\n                    { prim: \"CDR\", annots: [\"@%%\"] },\n                    { prim: \"SWAP\" },\n                    { prim: \"PAIR\", annots: [\"%@\", \"%@\", ...vann] },\n                ] : term.a;\n\n        case \"D\":\n            return expr.length > 1 ?\n                [\n                    { prim: \"DUP\" },\n                    {\n                        prim: \"DIP\",\n                        args: [[\n                            { prim: \"CDR\", annots: [\"@%%\"] },\n                            parseSetMapCadr(p, expr.slice(1), [], term),\n                        ]],\n                    },\n                    { prim: \"CAR\", annots: [\"@%%\"] },\n                    { prim: \"PAIR\", annots: [\"%@\", \"%@\", ...vann] },\n                ] : term.d;\n\n        default:\n            throw new MacroError(p, `${p.prim}: unexpected character: ${c}`);\n    }\n}\n\nfunction trimLast<T>(a: T[], v: T): T[] {\n    let l = a.length;\n    while (l > 0 && a[l - 1] === v) {\n        l--;\n    }\n    return a.slice(0, l);\n}\n\nfunction filterAnnotations(a?: string[]): {\n    fields: string[];\n    rest: string[];\n} {\n    const fields: string[] = [];\n    const rest: string[] = [];\n    if (a !== undefined) {\n        for (const v of a) {\n            (v.length !== 0 && v[0] === \"%\" ? fields : rest).push(v);\n        }\n    }\n    return { fields, rest };\n}\n\nfunction mkPrim({ prim, annots, args }: Prim): Prim {\n    return {\n        prim,\n        ...(annots && { annots }),\n        ...(args && { args }),\n    };\n}\n\nconst pairRe = /^P[PAI]{3,}R$/;\nconst unpairRe = /^UNP[PAI]{2,}R$/;\nconst cadrRe = /^C[AD]{2,}R$/;\nconst setCadrRe = /^SET_C[AD]+R$/;\nconst mapCadrRe = /^MAP_C[AD]+R$/;\nconst diipRe = /^DI{2,}P$/;\nconst duupRe = /^DU+P$/;\n\nexport function expandMacros(ex: Prim, opt?: ProtocolOptions): Expr {\n    const proto = opt?.protocol || DefaultProtocol;\n\n    function mayRename(annots?: string[]): Prim[] {\n        return annots !== undefined ? [{ prim: \"RENAME\", annots }] : [];\n    }\n\n    switch (ex.prim) {\n        // Compare\n        case \"CMPEQ\":\n        case \"CMPNEQ\":\n        case \"CMPLT\":\n        case \"CMPGT\":\n        case \"CMPLE\":\n        case \"CMPGE\":\n            if (assertArgs(ex, 0)) {\n                return [\n                    { prim: \"COMPARE\" },\n                    mkPrim({ prim: ex.prim.slice(3), annots: ex.annots }),\n                ];\n            }\n            break;\n\n        case \"IFEQ\":\n        case \"IFNEQ\":\n        case \"IFLT\":\n        case \"IFGT\":\n        case \"IFLE\":\n        case \"IFGE\":\n            if (assertArgs(ex, 2)) {\n                return [\n                    { prim: ex.prim.slice(2) },\n                    mkPrim({ prim: \"IF\", annots: ex.annots, args: ex.args }),\n                ];\n            }\n            break;\n\n        case \"IFCMPEQ\":\n        case \"IFCMPNEQ\":\n        case \"IFCMPLT\":\n        case \"IFCMPGT\":\n        case \"IFCMPLE\":\n        case \"IFCMPGE\":\n            if (assertArgs(ex, 2)) {\n                return [\n                    { prim: \"COMPARE\" },\n                    { prim: ex.prim.slice(5) },\n                    mkPrim({ prim: \"IF\", annots: ex.annots, args: ex.args }),\n                ];\n            }\n            break;\n\n        // Fail\n        case \"FAIL\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [\n                    { prim: \"UNIT\" },\n                    { prim: \"FAILWITH\" },\n                ];\n            }\n            break;\n\n        // Assertion macros\n        case \"ASSERT\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [{\n                    prim: \"IF\", args: [\n                        [],\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                    ]\n                }];\n            }\n            break;\n\n        case \"ASSERT_EQ\":\n        case \"ASSERT_NEQ\":\n        case \"ASSERT_LT\":\n        case \"ASSERT_GT\":\n        case \"ASSERT_LE\":\n        case \"ASSERT_GE\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [\n                    { prim: ex.prim.slice(7) },\n                    {\n                        prim: \"IF\", args: [\n                            [],\n                            [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                        ]\n                    },\n                ];\n            }\n            break;\n\n        case \"ASSERT_CMPEQ\":\n        case \"ASSERT_CMPNEQ\":\n        case \"ASSERT_CMPLT\":\n        case \"ASSERT_CMPGT\":\n        case \"ASSERT_CMPLE\":\n        case \"ASSERT_CMPGE\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [\n                    [\n                        { prim: \"COMPARE\" },\n                        { prim: ex.prim.slice(10) },\n                    ],\n                    {\n                        prim: \"IF\", args: [\n                            [],\n                            [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                        ]\n                    },\n                ];\n            }\n            break;\n\n        case \"ASSERT_NONE\":\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n                return [{\n                    prim: \"IF_NONE\", args: [\n                        [],\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                    ]\n                }];\n            }\n            break;\n\n        case \"ASSERT_SOME\":\n            if (assertArgs(ex, 0)) {\n                return [{\n                    prim: \"IF_NONE\", args: [\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                        mayRename(ex.annots),\n                    ]\n                }];\n            }\n            break;\n\n        case \"ASSERT_LEFT\":\n            if (assertArgs(ex, 0)) {\n                return [{\n                    prim: \"IF_LEFT\", args: [\n                        mayRename(ex.annots),\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                    ]\n                }];\n            }\n            break;\n\n        case \"ASSERT_RIGHT\":\n            if (assertArgs(ex, 0)) {\n                return [{\n                    prim: \"IF_LEFT\", args: [\n                        [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\n                        mayRename(ex.annots),\n                    ]\n                }];\n            }\n            break;\n\n        // Syntactic conveniences\n\n        case \"IF_SOME\":\n            if (assertArgs(ex, 2)) {\n                return [mkPrim({ prim: \"IF_NONE\", annots: ex.annots, args: [ex.args[1], ex.args[0]] })];\n            }\n            break;\n\n        case \"IF_RIGHT\":\n            if (assertArgs(ex, 2)) {\n                return [mkPrim({ prim: \"IF_LEFT\", annots: ex.annots, args: [ex.args[1], ex.args[0]] })];\n            }\n            break;\n\n        // CAR/CDR n\n        case \"CAR\":\n        case \"CDR\":\n            if (ex.args !== undefined) {\n                if (assertArgs(ex, 1) && assertIntArg(ex, ex.args[0])) {\n                    const n = parseInt(ex.args[0].int, 10);\n                    return mkPrim({\n                        prim: \"GET\",\n                        args: [{ int: ex.prim === \"CAR\" ? String(n * 2 + 1) : String(n * 2) }],\n                        annots: ex.annots,\n                    });\n                }\n            } else {\n                return ex;\n            }\n    }\n\n    // More syntactic conveniences\n\n    // PAPPAIIR macro\n    if (pairRe.test(ex.prim)) {\n        if (assertArgs(ex, 0)) {\n            const { fields, rest } = filterAnnotations(ex.annots);\n            const { r } = parsePairUnpairExpr(ex, ex.prim.slice(1), fields, (l, r, top) => [...(l || []), ...(r || []), top]);\n\n            return r.map(([v, a], i) => {\n                const ann = [\n                    ...trimLast(a, null).map(v => v === null ? \"%\" : v),\n                    ...((v === 0 && i === r.length - 1) ? rest : [])];\n\n                const leaf = mkPrim({ prim: \"PAIR\", annots: ann.length !== 0 ? ann : undefined, });\n\n                return v === 0 ? leaf : {\n                    prim: \"DIP\",\n                    args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]],\n                };\n            });\n        }\n    }\n\n    // UNPAPPAIIR macro\n    if (unpairRe.test(ex.prim)) {\n        if (proto === Protocol.PtEdo2Zk || proto === Protocol.PsFLorena || proto === Protocol.PtGRANADs || proto === Protocol.PtHangzH) {\n            if (ex.prim === \"UNPAIR\") {\n                return ex;\n            }\n            if (assertArgs(ex, 0)) {\n                // 008_edo: annotations are deprecated\n                const { r } = parsePairUnpairExpr(ex, ex.prim.slice(3), [], (l, r, top) => [top, ...(r || []), ...(l || [])]);\n                return r.map(([v]) => {\n                    const leaf = mkPrim({\n                        prim: \"UNPAIR\",\n                    });\n\n                    return v === 0 ? leaf : {\n                        prim: \"DIP\",\n                        args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]],\n                    };\n                });\n            }\n        } else if (assertArgs(ex, 0)) {\n            const { r } = parsePairUnpairExpr(ex, ex.prim.slice(3), ex.annots || [], (l, r, top) => [top, ...(r || []), ...(l || [])]);\n            return r.map(([v, a]) => {\n                const leaf: Prim[] = [\n                    { prim: \"DUP\" },\n                    mkPrim({ prim: \"CAR\", annots: a[0] !== null ? [a[0]] : undefined }),\n                    {\n                        prim: \"DIP\",\n                        args: [[mkPrim({ prim: \"CDR\", annots: a[1] !== null ? [a[1]] : undefined })]],\n                    }\n                ];\n\n                return v === 0 ? leaf : {\n                    prim: \"DIP\",\n                    args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]],\n                };\n            });\n        }\n    }\n\n    // C[AD]+R macro\n    if (cadrRe.test(ex.prim)) {\n        if (assertArgs(ex, 0)) {\n            const ch = [...ex.prim.slice(1, ex.prim.length - 1)];\n\n            return ch.map<Prim>((c, i) => {\n                const ann = i === ch.length - 1 ? ex.annots : undefined;\n                switch (c) {\n                    case \"A\":\n                        return mkPrim({ prim: \"CAR\", annots: ann });\n                    case \"D\":\n                        return mkPrim({ prim: \"CDR\", annots: ann });\n                    default:\n                        throw new MacroError(ex, `unexpected character: ${c}`);\n                }\n            });\n        }\n    }\n\n    // SET_C[AD]+R macro\n    if (setCadrRe.test(ex.prim)) {\n        if (assertArgs(ex, 0)) {\n            const { fields, rest } = filterAnnotations(ex.annots);\n            if (fields.length > 1) {\n                throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${fields}`);\n            }\n\n            const term = fields.length !== 0 ?\n                {\n                    a: [\n                        { prim: \"DUP\" },\n                        { prim: \"CAR\", annots: fields },\n                        { prim: \"DROP\" },\n                        { prim: \"CDR\", annots: [\"@%%\"] },\n                        { prim: \"SWAP\" },\n                        { prim: \"PAIR\", annots: [fields[0], \"%@\"] },\n                    ],\n                    d: [\n                        { prim: \"DUP\" },\n                        { prim: \"CDR\", annots: fields },\n                        { prim: \"DROP\" },\n                        { prim: \"CAR\", annots: [\"@%%\"] },\n                        { prim: \"PAIR\", annots: [\"%@\", fields[0]] },\n                    ],\n                } :\n                {\n                    a: [\n                        { prim: \"CDR\", annots: [\"@%%\"] },\n                        { prim: \"SWAP\" },\n                        { prim: \"PAIR\", annots: [\"%\", \"%@\"] },\n                    ],\n                    d: [\n                        { prim: \"CAR\", annots: [\"@%%\"] },\n                        { prim: \"PAIR\", annots: [\"%@\", \"%\"] },\n                    ],\n                };\n\n            return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), rest, term);\n        }\n    }\n\n    // MAP_C[AD]+R macro\n    if (mapCadrRe.test(ex.prim)) {\n        if (assertArgs(ex, 1)) {\n            const { fields } = filterAnnotations(ex.annots);\n            if (fields.length > 1) {\n                throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${fields}`);\n            }\n\n            const term = {\n                a: [\n                    { prim: \"DUP\" },\n                    { prim: \"CDR\", annots: [\"@%%\"] },\n                    {\n                        prim: \"DIP\", args: [[\n                            mkPrim({ prim: \"CAR\", annots: fields.length !== 0 ? [\"@\" + fields[0].slice(1)] : undefined }),\n                            ex.args[0],\n                        ]]\n                    },\n                    { prim: \"SWAP\" },\n                    { prim: \"PAIR\", annots: [fields.length !== 0 ? fields[0] : \"%\", \"%@\"] },\n                ],\n                d: [\n                    { prim: \"DUP\" },\n                    mkPrim({ prim: \"CDR\", annots: fields.length !== 0 ? [\"@\" + fields[0].slice(1)] : undefined }),\n                    ex.args[0],\n                    { prim: \"SWAP\" },\n                    { prim: \"CAR\", annots: [\"@%%\"] },\n                    { prim: \"PAIR\", annots: [\"%@\", fields.length !== 0 ? fields[0] : \"%\"] },\n                ],\n            };\n\n            return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), [], term);\n        }\n    }\n\n    // Expand deprecated DI...IP to [DIP n]\n    if (diipRe.test(ex.prim)) {\n        if (assertArgs(ex, 1)) {\n            let n = 0;\n            while (ex.prim[1 + n] === \"I\") { n++; }\n            return mkPrim({ prim: \"DIP\", args: [{ int: String(n) }, ex.args[0]] });\n        }\n    }\n\n    // Expand DU...UP and DUP n\n    if (duupRe.test(ex.prim)) {\n        let n = 0;\n        while (ex.prim[1 + n] === \"U\") { n++; }\n        if (proto === Protocol.PtEdo2Zk || proto === Protocol.PsFLorena || proto === Protocol.PtGRANADs || proto === Protocol.PtHangzH) {\n            if (n === 1) {\n                return ex;\n            }\n            if (assertArgs(ex, 0)) {\n                return mkPrim({ prim: \"DUP\", args: [{ int: String(n) }], annots: ex.annots });\n            }\n        } else {\n            if (n === 1) {\n                if (ex.args === undefined) {\n                    return ex; // skip\n                }\n                if (assertArgs(ex, 1) && assertIntArg(ex, ex.args[0])) {\n                    n = parseInt(ex.args[0].int, 10);\n                }\n            } else {\n                assertArgs(ex, 0);\n            }\n\n            if (n === 1) {\n                return [mkPrim({ prim: \"DUP\", annots: ex.annots })];\n\n            } else if (n === 2) {\n                return [\n                    {\n                        prim: \"DIP\",\n                        args: [[mkPrim({ prim: \"DUP\", annots: ex.annots })]],\n                    },\n                    { prim: \"SWAP\" },\n                ];\n\n            } else {\n                return [\n                    {\n                        prim: \"DIP\",\n                        args: [\n                            { int: String(n - 1) },\n                            [mkPrim({ prim: \"DUP\", annots: ex.annots })],\n                        ],\n                    },\n                    {\n                        prim: \"DIG\",\n                        args: [{ int: String(n) }],\n                    },\n                ];\n            }\n        }\n    }\n\n    return ex;\n}","import { scan, Token, Literal } from './scan';\nimport { Expr, Prim, StringLiteral, IntLiteral, BytesLiteral, sourceReference, List, SourceReference } from './micheline';\nimport { expandMacros } from './macros';\nimport { ProtocolOptions } from './michelson-types';\n\nexport class MichelineParseError extends Error {\n    /**\n     * @param token A token caused the error\n     * @param message An error message\n     */\n    constructor(public token: Token | null, message?: string) {\n        super(message);\n        Object.setPrototypeOf(this, MichelineParseError.prototype);\n    }\n}\n\nexport class JSONParseError extends Error {\n    /**\n     * @param node A node caused the error\n     * @param message An error message\n     */\n    constructor(public node: any, message?: string) {\n        super(message);\n        Object.setPrototypeOf(this, JSONParseError.prototype);\n    }\n}\n\nconst errEOF = new MichelineParseError(null, 'Unexpected EOF');\n\nfunction isAnnotation(tok: Token): boolean {\n    return tok.t === Literal.Ident && (tok.v[0] === '@' || tok.v[0] === '%' || tok.v[0] === ':');\n}\n\nconst intRe = new RegExp('^-?[0-9]+$');\nconst bytesRe = new RegExp('^([0-9a-fA-F]{2})*$');\n\nexport interface ParserOptions extends ProtocolOptions {\n    /**\n     * Expand [Michelson macros](https://tezos.gitlab.io/whitedoc/michelson.html#macros) during parsing.\n     */\n    expandMacros?: boolean;\n}\n\n/**\n * Converts and validates Michelson expressions between JSON-based Michelson and Micheline\n *\n * Pretty Print a Michelson Smart Contract:\n * ```\n * const contract = await Tezos.contract.at(\"KT1Vsw3kh9638gqWoHTjvHCoHLPKvCbMVbCg\");\n * const p = new Parser();\n *\n * const michelsonCode = p.parseJSON(contract.script.code);\n * const storage = p.parseJSON(contract.script.storage);\n *\n * console.log(\"Pretty print Michelson smart contract:\");\n * console.log(emitMicheline(michelsonCode, {indent:\"    \", newline: \"\\n\",}));\n *\n * console.log(\"Pretty print Storage:\");\n * console.log(emitMicheline(storage, {indent:\"    \", newline: \"\\n\",}));\n * ```\n *\n * Encode a Michelson expression for inital storage of a smart contract\n * ```\n * const src = `(Pair (Pair { Elt 1\n *                (Pair (Pair \"tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN\" \"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx\")\n *                      0x0501000000026869) }\n *          10000000)\n *    (Pair 2 333))`;\n *\n * const p = new Parser();\n *\n * const exp = p.parseMichelineExpression(src);\n * console.log(JSON.stringify(exp));\n * ```\n */\nexport class Parser {\n    constructor(private opt?: ParserOptions) {\n    }\n\n    private expand(ex: Prim): Expr {\n        if (this.opt?.expandMacros !== undefined ? this.opt?.expandMacros : true) {\n            const ret = expandMacros(ex, this.opt);\n            if (ret !== ex) {\n                ret[sourceReference] = { ...(ex[sourceReference] || { first: 0, last: 0 }), macro: ex };\n            }\n            return ret;\n        } else {\n            return ex;\n        }\n    }\n\n    private parseListExpr(scanner: Iterator<Token>, start: Token): Expr {\n        const ref: SourceReference = {\n            first: start.first,\n            last: start.last,\n        };\n\n        const expectBracket = start.t === \"(\";\n        let tok: IteratorResult<Token>;\n        if (expectBracket) {\n            tok = scanner.next();\n            if (tok.done) {\n                throw errEOF;\n            }\n            ref.last = tok.value.last;\n        } else {\n            tok = { value: start };\n        }\n\n        if (tok.value.t !== Literal.Ident) {\n            throw new MichelineParseError(tok.value, `not an identifier: ${tok.value.v}`);\n        }\n\n        const ret: Prim = {\n            prim: tok.value.v,\n            [sourceReference]: ref,\n        };\n\n        for (; ;) {\n            const tok = scanner.next();\n            if (tok.done) {\n                if (expectBracket) {\n                    throw errEOF;\n                }\n                break;\n            } else if (tok.value.t === ')') {\n                if (!expectBracket) {\n                    throw new MichelineParseError(tok.value, `unexpected closing bracket`);\n                }\n                ref.last = tok.value.last;\n                break;\n            } else if (isAnnotation(tok.value)) {\n                ret.annots = ret.annots || [];\n                ret.annots.push(tok.value.v);\n                ref.last = tok.value.last;\n            } else {\n                ret.args = ret.args || [];\n                const arg = this.parseExpr(scanner, tok.value);\n                ref.last = arg[sourceReference]?.last || ref.last;\n                ret.args.push(arg);\n            }\n        }\n        return this.expand(ret);\n    }\n\n    private parseArgs(scanner: Iterator<Token>, start: Token): [Prim, IteratorResult<Token>] {\n        // Identifier with arguments\n        const ref: SourceReference = {\n            first: start.first,\n            last: start.last,\n        };\n        const p: Prim = {\n            prim: start.v,\n            [sourceReference]: ref,\n        };\n\n        for (; ;) {\n            const t = scanner.next();\n            if (t.done || t.value.t === '}' || t.value.t === ';') {\n                return [p, t];\n            }\n\n            if (isAnnotation(t.value)) {\n                ref.last = t.value.last;\n                p.annots = p.annots || [];\n                p.annots.push(t.value.v);\n            } else {\n                const arg = this.parseExpr(scanner, t.value);\n                ref.last = arg[sourceReference]?.last || ref.last;\n                p.args = p.args || [];\n                p.args.push(arg);\n            }\n        }\n    }\n\n    private parseSequenceExpr(scanner: Iterator<Token>, start: Token): List<Expr> {\n        const ref: SourceReference = {\n            first: start.first,\n            last: start.last,\n        };\n        const seq: List<Expr> = [];\n        seq[sourceReference] = ref;\n\n        const expectBracket = start.t === \"{\";\n        let tok: IteratorResult<Token> | null = start.t === \"{\" ? null : { value: start };\n\n        for (; ;) {\n            if (tok === null) {\n                tok = scanner.next();\n                if (!tok.done) {\n                    ref.last = tok.value.last;\n                }\n            }\n            if (tok.done) {\n                if (expectBracket) {\n                    throw errEOF;\n                } else {\n                    return seq;\n                }\n            }\n\n            if (tok.value.t === \"}\") {\n                if (!expectBracket) {\n                    throw new MichelineParseError(tok.value, `unexpected closing bracket`);\n                } else {\n                    return seq;\n                }\n            } else if (tok.value.t === Literal.Ident) {\n                // Identifier with arguments\n                const [itm, n] = this.parseArgs(scanner, tok.value);\n                ref.last = itm[sourceReference]?.last || ref.last;\n                seq.push(this.expand(itm));\n                tok = n;\n            } else {\n                // Other\n                const ex = this.parseExpr(scanner, tok.value);\n                ref.last = ex[sourceReference]?.last || ref.last;\n                seq.push(ex);\n                tok = null;\n            }\n\n            if (tok === null) {\n                tok = scanner.next();\n                if (!tok.done) {\n                    ref.last = tok.value.last;\n                }\n            }\n            if (!tok.done && tok.value.t === \";\") {\n                tok = null;\n            }\n        }\n    }\n\n    private parseExpr(scanner: Iterator<Token>, tok: Token): Expr {\n        switch (tok.t) {\n            case Literal.Ident:\n                return this.expand({ prim: tok.v, [sourceReference]: { first: tok.first, last: tok.last } });\n\n            case Literal.Number:\n                return { int: tok.v, [sourceReference]: { first: tok.first, last: tok.last } };\n\n            case Literal.String:\n                return { string: JSON.parse(tok.v) as string, [sourceReference]: { first: tok.first, last: tok.last } };\n\n            case Literal.Bytes:\n                return { bytes: tok.v.slice(2), [sourceReference]: { first: tok.first, last: tok.last } };\n\n            case '{':\n                return this.parseSequenceExpr(scanner, tok);\n\n            default:\n                return this.parseListExpr(scanner, tok);\n        }\n    }\n\n    /**\n     * Parses a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.\n     * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`\n     */\n    parseSequence(src: string): Expr[] | null {\n        // tslint:disable-next-line: strict-type-predicates\n        if (typeof src !== \"string\") {\n            throw new TypeError(`string type was expected, got ${typeof src} instead`);\n        }\n\n        const scanner = scan(src);\n        const tok = scanner.next();\n        if (tok.done) {\n            return null;\n        }\n        return this.parseSequenceExpr(scanner, tok.value);\n    }\n\n    /**\n     * Parse a Micheline sequence expression. Enclosing curly brackets may be omitted.\n     * @param src A Michelson list expression such as `(Pair {Elt \"0\" 0} 0)` or `Pair {Elt \"0\" 0} 0`\n     * @returns An AST node or null for empty document.\n     */\n    parseList(src: string): Expr | null {\n        // tslint:disable-next-line: strict-type-predicates\n        if (typeof src !== \"string\") {\n            throw new TypeError(`string type was expected, got ${typeof src} instead`);\n        }\n\n        const scanner = scan(src);\n        const tok = scanner.next();\n        if (tok.done) {\n            return null;\n        }\n        return this.parseListExpr(scanner, tok.value);\n    }\n\n    /**\n     * Parse any Michelson expression\n     * @param src A Michelson expression such as `(Pair {Elt \"0\" 0} 0)` or `{parameter ...; storage int; code { DUP ; ...};}`\n     * @returns An AST node or null for empty document.\n     */\n    parseMichelineExpression(src: string): Expr | null {\n        // tslint:disable-next-line: strict-type-predicates\n        if (typeof src !== \"string\") {\n            throw new TypeError(`string type was expected, got ${typeof src} instead`);\n        }\n\n        const scanner = scan(src);\n        const tok = scanner.next();\n        if (tok.done) {\n            return null;\n        }\n        return this.parseExpr(scanner, tok.value);\n    }\n\n    /**\n     * Parse a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.\n     * An alias for `parseSequence`\n     * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`\n     */\n    parseScript(src: string): Expr[] | null {\n        return this.parseSequence(src);\n    }\n\n    /**\n     * Parse a Micheline sequence expression. Enclosing curly brackets may be omitted.\n     * An alias for `parseList`\n     * @param src A Michelson list expression such as `(Pair {Elt \"0\" 0} 0)` or `Pair {Elt \"0\" 0} 0`\n     * @returns An AST node or null for empty document.\n     */\n    parseData(src: string): Expr | null {\n        return this.parseList(src);\n    }\n\n    /**\n     * Takes a JSON-encoded Michelson, validates it, strips away unneeded properties and optionally expands macros (See {@link ParserOptions}).\n     * @param src An object containing JSON-encoded Michelson, usually returned by `JSON.parse()`\n     */\n    parseJSON(src: object): Expr {\n        // tslint:disable-next-line: strict-type-predicates\n        if (typeof src !== \"object\") {\n            throw new TypeError(`object type was expected, got ${typeof src} instead`);\n        }\n\n        if (Array.isArray(src)) {\n            const ret: Expr[] = [];\n            for (const n of src) {\n                if (n === null || typeof n !== 'object') {\n                    throw new JSONParseError(n, `unexpected sequence element: ${n}`);\n                }\n                ret.push(this.parseJSON(n));\n            }\n            return ret;\n\n        } else if ('prim' in src) {\n            const p = src as { prim: any, annots?: any[], args?: any[] };\n            if (\n                typeof p.prim === 'string' &&\n                (p.annots === undefined || Array.isArray(p.annots)) &&\n                (p.args === undefined || Array.isArray(p.args))\n            ) {\n                const ret: Prim = {\n                    prim: p.prim,\n                };\n\n                if (p.annots !== undefined) {\n                    for (const a of p.annots) {\n                        if (typeof a !== 'string') {\n                            throw new JSONParseError(a, `string expected: ${a}`);\n                        }\n                    }\n                    ret.annots = p.annots;\n                }\n\n                if (p.args !== undefined) {\n                    ret.args = [];\n                    for (const a of p.args) {\n                        if (a === null || typeof a !== 'object') {\n                            throw new JSONParseError(a, `unexpected argument: ${a}`);\n                        }\n                        ret.args.push(this.parseJSON(a));\n                    }\n                }\n\n                return this.expand(ret);\n            }\n\n            throw new JSONParseError(src, `malformed prim expression: ${src}`);\n        } else if ('string' in src) {\n            if (typeof (src as any).string === 'string') {\n                return { string: (src as StringLiteral).string };\n            }\n\n            throw new JSONParseError(src, `malformed string literal: ${src}`);\n        } else if ('int' in src) {\n            if (typeof (src as any).int === 'string' && intRe.test((src as IntLiteral).int)) {\n                return { int: (src as IntLiteral).int };\n            }\n\n            throw new JSONParseError(src, `malformed int literal: ${src}`);\n        } else if ('bytes' in src) {\n            if (\n                typeof (src as any).bytes === 'string' &&\n                bytesRe.test((src as BytesLiteral).bytes)\n            ) {\n                return { bytes: (src as BytesLiteral).bytes };\n            }\n\n            throw new JSONParseError(src, `malformed bytes literal: ${src}`);\n        } else {\n            throw new JSONParseError(src, `unexpected object: ${src}`);\n        }\n    }\n}\n","import { Expr, Prim, sourceReference } from \"./micheline\";\n\nexport interface FormatOptions {\n    /**\n     * A string used for code indentation if desired. Usually a tab character or a number of spaces.\n     */\n    indent?: string;\n    /**\n     * A string used for line separation. Usually a newline character (\"\\n\");\n     */\n    newline?: string;\n}\n\nclass Formatter {\n    constructor(private opt?: FormatOptions, private lev: number = 0) {\n    }\n\n    indent(n = 0): string {\n        let ret = \"\";\n        if (this.opt?.indent !== undefined) {\n            for (let i = this.lev + n; i > 0; i--) {\n                ret += this.opt.indent;\n            }\n        }\n        return ret;\n    }\n\n    get lf(): string {\n        return this.opt?.newline || \"\";\n    }\n\n    get lfsp(): string {\n        return this.opt?.newline || \" \";\n    }\n\n    down(n: number): Formatter {\n        return new Formatter(this.opt, this.lev + n);\n    }\n}\n\nfunction hasArgs(node: Expr): node is Prim {\n    return (\"prim\" in node) &&\n        ((node.annots !== undefined && node.annots.length !== 0) ||\n            (node.args !== undefined && node.args.length !== 0));\n}\n\nfunction isMultiline(node: Prim): boolean {\n    if (node.args !== undefined) {\n        for (const a of node.args) {\n            if (Array.isArray(a) || hasArgs(a)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nfunction emitExpr(node: Expr, f: Formatter, foldMacros: boolean): string {\n    const macro = node[sourceReference]?.macro;\n    if (foldMacros && macro) {\n        return emitExpr(macro, f, foldMacros);\n    }\n\n    if (Array.isArray(node)) {\n        return emitSeq(node, f, foldMacros);\n\n    } else if (\"string\" in node) {\n        return JSON.stringify(node.string);\n\n    } else if (\"int\" in node) {\n        return node.int;\n\n    } else if (\"bytes\" in node) {\n        return \"0x\" + node.bytes;\n\n    } else {\n        if ((node.annots === undefined || node.annots.length === 0) &&\n            (node.args === undefined || node.args.length === 0)) {\n            return node.prim;\n        }\n\n        let ret = \"(\" + node.prim;\n        if (node.annots !== undefined) {\n            for (const a of node.annots) {\n                ret += \" \" + a;\n            }\n        }\n        if (node.args !== undefined) {\n            const multiline = isMultiline(node);\n            for (const a of node.args) {\n                if (multiline) {\n                    ret += f.lfsp + f.indent(1) + emitExpr(a, f.down(1), foldMacros);\n                } else {\n                    ret += \" \" + emitExpr(a, f, foldMacros);\n                }\n            }\n        }\n        return ret + \")\";\n    }\n}\n\nfunction emitSeq(node: Expr[], f: Formatter, foldMacros: boolean): string {\n    let ret = \"{\" + f.lf;\n    let i = node.length;\n    for (const el of node) {\n        ret += f.indent(1);\n\n        if (\"prim\" in el) {\n            ret += el.prim;\n\n            if (el.annots !== undefined) {\n                for (const a of el.annots) {\n                    ret += \" \" + a;\n                }\n            }\n            if (el.args !== undefined) {\n                const multiline = isMultiline(el);\n                for (const a of el.args) {\n                    if (multiline) {\n                        ret += f.lfsp + f.indent(2) + emitExpr(a, f.down(2), foldMacros);\n                    } else {\n                        ret += \" \" + emitExpr(a, f, foldMacros);\n                    }\n                }\n            }\n        } else {\n            ret += emitExpr(el, f.down(1), foldMacros);\n        }\n\n        ret += (i > 1 ? \";\" + f.lfsp : f.lf);\n        i--;\n    }\n    return ret + f.indent() + \"}\";\n}\n\n/**\n * Formats Micheline expression\n * @param expr An AST node\n * @param opt Options\n */\nexport function emitMicheline(expr: Expr, opt?: FormatOptions, foldMacros = false): string {\n    // tslint:disable-next-line: strict-type-predicates\n    if (typeof expr !== \"object\") {\n        throw new TypeError(`object type was expected, got ${typeof expr} instead`);\n    }\n\n    return emitExpr(expr, new Formatter(opt), foldMacros);\n}","const H = [\n    0x6a09e667 | 0,\n    0xbb67ae85 | 0,\n    0x3c6ef372 | 0,\n    0xa54ff53a | 0,\n    0x510e527f | 0,\n    0x9b05688c | 0,\n    0x1f83d9ab | 0,\n    0x5be0cd19 | 0\n];\n\nconst K = [\n    0x428a2f98 | 0, 0x71374491 | 0, 0xb5c0fbcf | 0, 0xe9b5dba5 | 0, 0x3956c25b | 0, 0x59f111f1 | 0, 0x923f82a4 | 0, 0xab1c5ed5 | 0,\n    0xd807aa98 | 0, 0x12835b01 | 0, 0x243185be | 0, 0x550c7dc3 | 0, 0x72be5d74 | 0, 0x80deb1fe | 0, 0x9bdc06a7 | 0, 0xc19bf174 | 0,\n    0xe49b69c1 | 0, 0xefbe4786 | 0, 0x0fc19dc6 | 0, 0x240ca1cc | 0, 0x2de92c6f | 0, 0x4a7484aa | 0, 0x5cb0a9dc | 0, 0x76f988da | 0,\n    0x983e5152 | 0, 0xa831c66d | 0, 0xb00327c8 | 0, 0xbf597fc7 | 0, 0xc6e00bf3 | 0, 0xd5a79147 | 0, 0x06ca6351 | 0, 0x14292967 | 0,\n    0x27b70a85 | 0, 0x2e1b2138 | 0, 0x4d2c6dfc | 0, 0x53380d13 | 0, 0x650a7354 | 0, 0x766a0abb | 0, 0x81c2c92e | 0, 0x92722c85 | 0,\n    0xa2bfe8a1 | 0, 0xa81a664b | 0, 0xc24b8b70 | 0, 0xc76c51a3 | 0, 0xd192e819 | 0, 0xd6990624 | 0, 0xf40e3585 | 0, 0x106aa070 | 0,\n    0x19a4c116 | 0, 0x1e376c08 | 0, 0x2748774c | 0, 0x34b0bcb5 | 0, 0x391c0cb3 | 0, 0x4ed8aa4a | 0, 0x5b9cca4f | 0, 0x682e6ff3 | 0,\n    0x748f82ee | 0, 0x78a5636f | 0, 0x84c87814 | 0, 0x8cc70208 | 0, 0x90befffa | 0, 0xa4506ceb | 0, 0xbef9a3f7 | 0, 0xc67178f2 | 0\n];\n\n// https://tools.ietf.org/html/rfc6234\nfunction sha256(msg: number[] | Uint8Array): number[] {\n    // pad the message\n    const r = (msg.length + 9) % 64;\n    const pad = r === 0 ? 0 : 64 - r;\n\n    if (msg.length > 268435455) {\n        throw new Error(`sha256: message length is too big: ${msg.length}`);\n    }\n\n    const l = msg.length << 3;\n    const buffer = [\n        ...msg,\n        0x80,\n        ...(new Array<number>(pad).fill(0)),\n        0, 0, 0, 0, (l >> 24) & 0xff, (l >> 16) & 0xff, (l >> 8) & 0xff, l & 0xff,\n    ];\n\n    function ror(x: number, n: number): number {\n        return (x >>> n) | (x << (32 - n));\n    }\n\n    const h = [...H];\n    const w = new Array<number>(64);\n    const v = new Array<number>(8);\n\n    for (let offset = 0; offset < buffer.length; offset += 64) {\n        let q = offset;\n        let i = 0;\n        while (i < 16) {\n            w[i] = (buffer[q] << 24) | (buffer[q + 1] << 16) | (buffer[q + 2] << 8) | buffer[q + 3];\n            q += 4;\n            i++;\n        }\n        while (i < 64) {\n            const s0 = ror(w[i - 15], 7) ^ ror(w[i - 15], 18) ^ (w[i - 15] >>> 3);\n            const s1 = ror(w[i - 2], 17) ^ ror(w[i - 2], 19) ^ (w[i - 2] >>> 10);\n            w[i] = ((s1 | 0) + w[i - 7] + s0 + w[i - 16]) | 0;\n            i++;\n        }\n\n        for (let i = 0; i < 8; i++) {\n            v[i] = h[i];\n        }\n\n        for (let i = 0; i < 64; i++) {\n            const b0 = ror(v[0], 2) ^ ror(v[0], 13) ^ ror(v[0], 22);\n            const b1 = ror(v[4], 6) ^ ror(v[4], 11) ^ ror(v[4], 25);\n            const t1 = (v[7] + b1 + ((v[4] & v[5]) ^ ((~v[4]) & v[6])) + K[i] + w[i]) | 0;\n            const t2 = (b0 + (((v[0] & v[1]) ^ (v[0] & v[2]) ^ (v[1] & v[2])))) | 0;\n\n            v[7] = v[6];\n            v[6] = v[5];\n            v[5] = v[4];\n            v[4] = (v[3] + t1) | 0;\n            v[3] = v[2];\n            v[2] = v[1];\n            v[1] = v[0];\n            v[0] = (t1 + t2) | 0;\n        }\n\n        for (let i = 0; i < 8; i++) {\n            h[i] = (h[i] + v[i]) | 0;\n        }\n    }\n\n    const digest: number[] = [];\n    for (const v of h) {\n        digest.push((v >> 24) & 0xff);\n        digest.push((v >> 16) & 0xff);\n        digest.push((v >> 8) & 0xff);\n        digest.push(v & 0xff);\n    }\n\n    return digest;\n}\n\nconst base58alphabetFwd: number[] = [\n    0, 1, 2, 3, 4, 5, 6,\n    7, 8, -1, -1, -1, -1, -1, -1,\n    -1, 9, 10, 11, 12, 13, 14, 15,\n    16, -1, 17, 18, 19, 20, 21, -1,\n    22, 23, 24, 25, 26, 27, 28, 29,\n    30, 31, 32, -1, -1, -1, -1, -1,\n    -1, 33, 34, 35, 36, 37, 38, 39,\n    40, 41, 42, 43, -1, 44, 45, 46,\n    47, 48, 49, 50, 51, 52, 53, 54,\n    55, 56, 57\n];\n\nconst base58alphabetBwd: number[] = [\n    0, 1, 2, 3, 4, 5, 6, 7,\n    8, 16, 17, 18, 19, 20, 21, 22,\n    23, 25, 26, 27, 28, 29, 31, 32,\n    33, 34, 35, 36, 37, 38, 39, 40,\n    41, 48, 49, 50, 51, 52, 53, 54,\n    55, 56, 57, 58, 60, 61, 62, 63,\n    64, 65, 66, 67, 68, 69, 70, 71,\n    72, 73\n];\n\nfunction byteAt(src: string, i: number): number {\n    const c = src.charCodeAt(i) - 49;\n    if (c >= base58alphabetFwd.length || base58alphabetFwd[c] === -1) {\n        throw new Error(`Base58 decoding error: unexpected character at position ${i}: ${src[i]}`);\n    }\n    return base58alphabetFwd[c];\n}\n\nexport function decodeBase58(src: string): number[] {\n    const acc: number[] = [];\n    let i = 0;\n    // count and skip leading zeros\n    while (i < src.length && byteAt(src, i) === 0) { i++; }\n    let zeros = i;\n    while (i < src.length) {\n        let carry = byteAt(src, i++);\n        /*\n        for every symbol x\n        acc = acc * 58 + x\n        where acc is a little endian arbitrary length integer\n        */\n        let ii = 0;\n        while (carry !== 0 || ii < acc.length) {\n            const m = (acc[ii] || 0) * 58 + carry;\n            acc[ii++] = m % 256;\n            carry = Math.floor(m / 256);\n        }\n    }\n    while (zeros-- > 0) {\n        acc.push(0);\n    }\n    return acc.reverse();\n}\n\nexport function encodeBase58(src: number[] | Uint8Array): string {\n    const acc: number[] = [];\n    let i = 0;\n    // count and skip leading zeros\n    while (i < src.length && src[i] === 0) { i++; }\n    let zeros = i;\n    while (i < src.length) {\n        let carry = src[i++];\n        let ii = 0;\n        while (carry !== 0 || ii < acc.length) {\n            const m = (acc[ii] || 0) * 256 + carry;\n            acc[ii++] = m % 58;\n            carry = Math.floor(m / 58);\n        }\n    }\n    while (zeros-- > 0) {\n        acc.push(0);\n    }\n    acc.reverse();\n    return String.fromCharCode(...acc.map(v => base58alphabetBwd[v] + 49));\n}\n\nexport function decodeBase58Check(src: string): number[] {\n    const buffer = decodeBase58(src);\n    if (buffer.length < 4) {\n        throw new Error(`Base58Check decoding error: data is too short ${buffer.length}`);\n    }\n\n    const data = buffer.slice(0, buffer.length - 4);\n    const sum = buffer.slice(buffer.length - 4);\n    const computed = sha256(sha256(data));\n    if (sum[0] !== computed[0] ||\n        sum[1] !== computed[1] ||\n        sum[2] !== computed[2] ||\n        sum[3] !== computed[3]) {\n        throw new Error(\"Base58Check decoding error: invalid checksum\");\n    }\n\n    return data;\n}\n\nexport function encodeBase58Check(src: number[] | Uint8Array): string {\n    const sum = sha256(sha256(src));\n    return encodeBase58([...src, ...sum.slice(0, 4)]);\n}","import { Prim, Expr, StringLiteral, IntLiteral } from \"./micheline\";\nimport { decodeBase58Check, encodeBase58Check } from \"./base58\";\nimport { MichelsonData, MichelsonDataPair, MichelsonType, MichelsonTypePair } from \"./michelson-types\";\n\nexport type Tuple<N extends number, T> =\n    N extends 1 ? [T] :\n    N extends 2 ? [T, T] :\n    N extends 3 ? [T, T, T] :\n    N extends 4 ? [T, T, T, T] :\n    N extends 5 ? [T, T, T, T, T] :\n    N extends 6 ? [T, T, T, T, T, T] :\n    N extends 7 ? [T, T, T, T, T, T, T] :\n    N extends 8 ? [T, T, T, T, T, T, T, T] :\n    T[];\n\ntype RequiredProp<T, K extends keyof T> = Omit<T, K> & Required<Pick<T, K>>;\ntype OmitProp<T, K extends keyof T> = Omit<T, K> & { [P in K]?: undefined };\n\nexport type ReqArgs<T extends Prim> = RequiredProp<T, \"args\">;\nexport type NoArgs<T extends Prim> = OmitProp<T, \"args\">;\nexport type NoAnnots<T extends Prim> = OmitProp<T, \"annots\">;\n\nexport type Nullable<T> = { [P in keyof T]: T[P] | null };\n\nexport class MichelsonError<T extends Expr = Expr> extends Error {\n    /**\n     * @param val Value of a AST node caused the error\n     * @param path Path to a node caused the error\n     * @param message An error message\n     */\n    constructor(public val: T, message?: string) {\n        super(message);\n        Object.setPrototypeOf(this, MichelsonError.prototype);\n    }\n}\n\nexport function isMichelsonError<T extends Expr = Expr>(err: any): err is MichelsonError<T> {\n    return err instanceof MichelsonError;\n}\n\nexport class MichelsonTypeError extends MichelsonError<MichelsonType | MichelsonType[]> {\n    public data?: Expr;\n\n    /**\n     * @param val Value of a type node caused the error\n     * @param data Value of a data node caused the error\n     * @param message An error message\n     */\n    constructor(val: MichelsonType | MichelsonType[], data?: Expr, message?: string) {\n        super(val, message);\n        if (data !== undefined) {\n            this.data = data;\n        }\n        Object.setPrototypeOf(this, MichelsonTypeError.prototype);\n    }\n}\n\n// Ad hoc big integer parser\nexport class LongInteger {\n    private neg = false;\n    private buf: number[] = [];\n\n    private append(c: number) {\n        let i = 0;\n        while (c !== 0 || i < this.buf.length) {\n            const m = (this.buf[i] || 0) * 10 + c;\n            this.buf[i++] = m % 256;\n            c = Math.floor(m / 256);\n        }\n    }\n\n    constructor(arg?: string | number) {\n        if (arg === undefined) {\n            return;\n        }\n        if (typeof arg === \"string\") {\n            for (let i = 0; i < arg.length; i++) {\n                let c = arg.charCodeAt(i);\n                if (i === 0 && c === 0x2d) {\n                    this.neg = true;\n                } else {\n                    if (c < 0x30 || c > 0x39) {\n                        throw new Error(`unexpected character in integer constant: ${arg[i]}`);\n                    }\n                    this.append(c - 0x30);\n                }\n            }\n        } else if (arg < 0) {\n            this.neg = true;\n            this.append(-arg);\n        } else {\n            this.append(arg);\n        }\n    }\n\n    cmp(arg: LongInteger): number {\n        if (this.neg !== arg.neg) {\n            return (arg.neg ? 1 : 0) - (this.neg ? 1 : 0);\n        } else {\n            let ret = 0;\n            if (this.buf.length !== arg.buf.length) {\n                ret = this.buf.length < arg.buf.length ? -1 : 1;\n            } else if (this.buf.length !== 0) {\n                let i = arg.buf.length - 1;\n                while (i >= 0 && this.buf[i] === arg.buf[i]) {\n                    i--;\n                }\n                ret = i < 0 ? 0 : this.buf[i] < arg.buf[i] ? -1 : 1;\n            }\n            return !this.neg ? ret : ret === 0 ? 0 : -ret;\n        }\n    }\n\n    get sign(): number {\n        return this.buf.length === 0 ? 0 : this.neg ? -1 : 1;\n    }\n}\n\nexport function parseBytes(s: string): number[] | null {\n    const ret: number[] = [];\n    for (let i = 0; i < s.length; i += 2) {\n        const x = parseInt(s.slice(i, i + 2), 16);\n        if (Number.isNaN(x)) {\n            return null;\n        }\n        ret.push(x);\n    }\n    return ret;\n}\n\nexport function compareBytes(a: number[] | Uint8Array, b: number[] | Uint8Array): number {\n    if (a.length !== b.length) {\n        return a.length < b.length ? -1 : 1;\n    } else if (a.length !== 0) {\n        let i = 0;\n        while (i < a.length && a[i] === b[i]) {\n            i++;\n        }\n        return i === a.length ? 0 : a[i] < b[i] ? -1 : 1;\n    } else {\n        return 0;\n    }\n}\n\nexport function isDecimal(x: string): boolean {\n    try {\n        // tslint:disable-next-line: no-unused-expression\n        new LongInteger(x);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\nexport function isNatural(x: string): boolean {\n    try {\n        return new LongInteger(x).sign >= 0;\n    } catch {\n        return false;\n    }\n}\n\nexport interface UnpackedAnnotations {\n    f?: string[];\n    t?: string[];\n    v?: string[];\n}\n\nexport interface UnpackAnnotationsOptions {\n    specialVar?: boolean; // CAR, CDR\n    emptyVar?: boolean;\n    specialFields?: boolean; // PAIR, LEFT, RIGHT\n    emptyFields?: boolean;\n}\n\nconst annRe = /^(@%|@%%|%@|[@:%]([_0-9a-zA-Z][_0-9a-zA-Z\\.%@]*)?)$/;\n\nexport function unpackAnnotations(p: Prim | Expr[], opt?: UnpackAnnotationsOptions): UnpackedAnnotations {\n    if (Array.isArray(p)) {\n        return {};\n    }\n\n    let field: string[] | undefined;\n    let type: string[] | undefined;\n    let vars: string[] | undefined;\n\n    if (p.annots !== undefined) {\n        for (const v of p.annots) {\n            if (v.length !== 0) {\n                if (!annRe.test(v) ||\n                    (!opt?.specialVar && (v === \"@%\" || v === \"@%%\")) ||\n                    (!opt?.specialFields && v === \"%@\")) {\n                    throw new MichelsonError(p, `${p.prim}: unexpected annotation: ${v}`);\n                }\n\n                switch (v[0]) {\n                    case \"%\":\n                        if (opt?.emptyFields || v.length > 1) {\n                            field = field || [];\n                            field.push(v);\n                        }\n                        break;\n                    case \":\":\n                        if (v.length > 1) {\n                            type = type || [];\n                            type.push(v);\n                        }\n                        break;\n                    case \"@\":\n                        if (opt?.emptyVar || v.length > 1) {\n                            vars = vars || [];\n                            vars.push(v);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n    return { f: field, t: type, v: vars };\n}\n\nexport type TezosIDType = \"BlockHash\" | \"OperationHash\" | \"OperationListHash\" | \"OperationListListHash\" |\n    \"ProtocolHash\" | \"ContextHash\" | \"ED25519PublicKeyHash\" | \"SECP256K1PublicKeyHash\" |\n    \"P256PublicKeyHash\" | \"ContractHash\" | \"CryptoboxPublicKeyHash\" | \"ED25519Seed\" |\n    \"ED25519PublicKey\" | \"SECP256K1SecretKey\" | \"P256SecretKey\" | \"ED25519EncryptedSeed\" |\n    \"SECP256K1EncryptedSecretKey\" | \"P256EncryptedSecretKey\" | \"SECP256K1PublicKey\" |\n    \"P256PublicKey\" | \"SECP256K1Scalar\" | \"SECP256K1Element\" | \"ED25519SecretKey\" |\n    \"ED25519Signature\" | \"SECP256K1Signature\" | \"P256Signature\" | \"GenericSignature\" | \"ChainID\";\n\nexport type TezosIDPrefix = [number, number[]]; // payload length, prefix\n\nexport const tezosPrefix: Record<TezosIDType, TezosIDPrefix> = {\n    BlockHash: [32, [1, 52]], // B(51)\n    OperationHash: [32, [5, 116]], // o(51)\n    OperationListHash: [32, [133, 233]], // Lo(52)\n    OperationListListHash: [32, [29, 159, 109]], // LLo(53)\n    ProtocolHash: [32, [2, 170]], // P(51)\n    ContextHash: [32, [79, 199]], // Co(52)\n    ED25519PublicKeyHash: [20, [6, 161, 159]], // tz1(36)\n    SECP256K1PublicKeyHash: [20, [6, 161, 161]], // tz2(36)\n    P256PublicKeyHash: [20, [6, 161, 164]], // tz3(36)\n    ContractHash: [20, [2, 90, 121]], // KT1(36)\n    CryptoboxPublicKeyHash: [16, [153, 103]], // id(30)\n    ED25519Seed: [32, [13, 15, 58, 7]], // edsk(54)\n    ED25519PublicKey: [32, [13, 15, 37, 217]], // edpk(54)\n    SECP256K1SecretKey: [32, [17, 162, 224, 201]], // spsk(54)\n    P256SecretKey: [32, [16, 81, 238, 189]], // p2sk(54)\n    ED25519EncryptedSeed: [56, [7, 90, 60, 179, 41]], // edesk(88)\n    SECP256K1EncryptedSecretKey: [56, [9, 237, 241, 174, 150]], // spesk(88)\n    P256EncryptedSecretKey: [56, [9, 48, 57, 115, 171]], // p2esk(88)\n    SECP256K1PublicKey: [33, [3, 254, 226, 86]], // sppk(55)\n    P256PublicKey: [33, [3, 178, 139, 127]], // p2pk(55)\n    SECP256K1Scalar: [33, [38, 248, 136]], // SSp(53)\n    SECP256K1Element: [33, [5, 92, 0]], // GSp(54)\n    ED25519SecretKey: [64, [43, 246, 78, 7]], // edsk(98)\n    ED25519Signature: [64, [9, 245, 205, 134, 18]], // edsig(99)\n    SECP256K1Signature: [64, [13, 115, 101, 19, 63]], // spsig1(99)\n    P256Signature: [64, [54, 240, 44, 52]], // p2sig(98)\n    GenericSignature: [64, [4, 130, 43]], // sig(96)\n    ChainID: [4, [87, 82, 0]],\n};\n\nexport function checkDecodeTezosID<T extends TezosIDType[]>(id: string, ...types: T): [T[number], number[]] | null {\n    const buf = decodeBase58Check(id);\n    for (const t of types) {\n        const [plen, p] = tezosPrefix[t];\n        if (buf.length === plen + p.length) {\n            let i = 0;\n            while (i < p.length && buf[i] === p[i]) {\n                i++;\n            }\n            if (i === p.length) {\n                return [t, buf.slice(p.length)];\n            }\n        }\n    }\n    return null;\n}\n\nexport function encodeTezosID(id: TezosIDType, data: number[] | Uint8Array): string {\n    const [plen, p] = tezosPrefix[id];\n    if (data.length !== plen) {\n        throw new Error(`incorrect data length for ${id}: ${data.length}`);\n    }\n    return encodeBase58Check([...p, ...data]);\n}\n\n// reassemble comb pair for transparent comparison etc. non-recursive!\ntype PairTypeOrDataPrim<I extends \"pair\" | \"Pair\"> = I extends \"pair\" ? Extract<MichelsonTypePair<MichelsonType[]>, Prim> : Extract<MichelsonDataPair<MichelsonData[]>, Prim>;\nexport function unpackComb<I extends \"pair\" | \"Pair\">(id: I, v: I extends \"pair\" ? MichelsonTypePair<MichelsonType[]> : MichelsonDataPair<MichelsonData[]>): PairTypeOrDataPrim<I> {\n    const vv: MichelsonTypePair<MichelsonType[]> | MichelsonDataPair<MichelsonData[]> = v;\n    const args = Array.isArray(vv) ? vv : vv.args;\n    if (args.length === 2) {\n        // it's a way to make a union of two interfaces not an interface with two independent properties of union types\n        const ret = id === \"pair\" ? {\n            prim: \"pair\",\n            args,\n        } : {\n            prim: \"Pair\",\n            args,\n        };\n        return ret as PairTypeOrDataPrim<I>;\n    }\n\n    return {\n        ...(Array.isArray(vv) ? { prim: id } : vv),\n        args: [\n            args[0],\n            {\n                prim: id,\n                args: args.slice(1),\n            },\n        ],\n    } as PairTypeOrDataPrim<I>;\n}\n\nexport function isPairType(t: MichelsonType): t is MichelsonTypePair<MichelsonType[]> {\n    return Array.isArray(t) || t.prim === \"pair\";\n}\n\nexport function isPairData(d: Expr): d is MichelsonDataPair<MichelsonData[]> {\n    return Array.isArray(d) || \"prim\" in d && d.prim === \"Pair\";\n}\n\nconst rfc3339Re = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])[T ]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|[+-]([01][0-9]|2[0-3]):([0-5][0-9]))$/;\n\nexport function parseDate(a: StringLiteral | IntLiteral): Date | null {\n    if (\"string\" in a) {\n        if (isNatural(a.string)) {\n            return new Date(parseInt(a.string, 10));\n        } else if (rfc3339Re.test(a.string)) {\n            const x = new Date(a.string);\n            if (!Number.isNaN(x.valueOf)) {\n                return x;\n            }\n        }\n    } else if (isNatural(a.int)) {\n        return new Date(parseInt(a.int, 10));\n    }\n    return null;\n}\n\nexport function parseHex(s: string): number[] {\n    const res: number[] = [];\n    for (let i = 0; i < s.length; i += 2) {\n        const ss = s.slice(i, i + 2);\n        const x = parseInt(ss, 16);\n        if (Number.isNaN(x)) {\n            throw new Error(`can't parse hex byte: ${ss}`);\n        }\n        res.push(x);\n    }\n    return res;\n}\n\nexport function hexBytes(bytes: number[]): string {\n    return bytes.map(x => ((x >> 4) & 0xf).toString(16) + (x & 0xf).toString(16)).join(\"\");\n}\n","import { Prim, Expr, IntLiteral } from \"./micheline\";\nimport { Tuple, NoArgs, ReqArgs, MichelsonError } from \"./utils\";\nimport {\n   MichelsonCode, MichelsonType, MichelsonData, MichelsonContract, MichelsonNoArgInstruction,\n   MichelsonInstruction, InstructionList, MichelsonTypeID, MichelsonSimpleComparableTypeID\n} from \"./michelson-types\";\n\n// Michelson validator\n\nconst noArgInstructionIDs: Record<MichelsonNoArgInstruction[\"prim\"], true> = {\n   \"ABS\": true, \"ADD\": true, \"ADDRESS\": true, \"AMOUNT\": true, \"AND\": true, \"APPLY\": true, \"BALANCE\": true,\n   \"BLAKE2B\": true, \"CAR\": true, \"CDR\": true, \"CHAIN_ID\": true, \"CHECK_SIGNATURE\": true, \"COMPARE\": true, \"CONCAT\": true, \"CONS\": true, \"EDIV\": true,\n   \"EQ\": true, \"EXEC\": true, \"FAILWITH\": true, \"GE\": true, \"GET_AND_UPDATE\": true, \"GT\": true, \"HASH_KEY\": true, \"IMPLICIT_ACCOUNT\": true,\n   \"INT\": true, \"ISNAT\": true, \"JOIN_TICKETS\": true, \"KECCAK\": true, \"LE\": true, \"LEVEL\": true, \"LSL\": true, \"LSR\": true, \"LT\": true, \"MEM\": true, \"MUL\": true,\n   \"NEG\": true, \"NEQ\": true, \"NEVER\": true, \"NOT\": true, \"NOW\": true, \"OR\": true, \"PACK\": true, \"PAIRING_CHECK\": true, \"READ_TICKET\": true,\n   \"SAPLING_VERIFY_UPDATE\": true, \"SELF\": true, \"SELF_ADDRESS\": true, \"SENDER\": true, \"SET_DELEGATE\": true, \"SHA256\": true, \"SHA3\": true,\n   \"SHA512\": true, \"SIZE\": true, \"SLICE\": true, \"SOME\": true, \"SOURCE\": true, \"SPLIT_TICKET\": true, \"SUB\": true, \"SWAP\": true, \"TICKET\": true,\n   \"TOTAL_VOTING_POWER\": true, \"TRANSFER_TOKENS\": true, \"UNIT\": true, \"VOTING_POWER\": true, \"XOR\": true, \"RENAME\": true,\n};\n\nexport const instructionIDs: Record<MichelsonInstruction[\"prim\"], true> = Object.assign({}, noArgInstructionIDs, {\n   \"CONTRACT\": true, \"CREATE_CONTRACT\": true, \"DIG\": true, \"DIP\": true, \"DROP\": true,\n   \"DUG\": true, \"DUP\": true, \"EMPTY_BIG_MAP\": true, \"EMPTY_MAP\": true, \"EMPTY_SET\": true, \"GET\": true, \"IF\": true, \"IF_CONS\": true, \"IF_LEFT\": true,\n   \"IF_NONE\": true, \"ITER\": true, \"LAMBDA\": true, \"LEFT\": true, \"LOOP\": true, \"LOOP_LEFT\": true, \"MAP\": true, \"NIL\": true, \"NONE\": true, \"PAIR\": true,\n   \"PUSH\": true, \"RIGHT\": true, \"SAPLING_EMPTY_STATE\": true, \"UNPACK\": true, \"UNPAIR\": true, \"UPDATE\": true, \"CAST\": true,\n} as const);\n\nconst simpleComparableTypeIDs: Record<MichelsonSimpleComparableTypeID, true> = {\n   \"unit\": true, \"never\": true, \"bool\": true, \"int\": true, \"nat\": true, \"string\": true,\n   \"chain_id\": true, \"bytes\": true, \"mutez\": true, \"key_hash\": true, \"key\": true,\n   \"signature\": true, \"timestamp\": true, \"address\": true,\n};\n\nconst typeIDs: Record<MichelsonTypeID, true> = Object.assign({}, simpleComparableTypeIDs, {\n   \"or\": true, \"pair\": true, \"set\": true, \"big_map\": true, \"contract\": true, \"lambda\": true,\n   \"list\": true, \"map\": true, \"operation\": true, \"option\": true, \"bls12_381_g1\": true,\n   \"bls12_381_g2\": true, \"bls12_381_fr\": true, \"sapling_transaction\": true, \"sapling_state\": true, \"ticket\": true,\n} as const);\n\nexport class MichelsonValidationError extends MichelsonError {\n   /**\n    * @param val Value of a node caused the error\n    * @param message An error message\n    */\n   constructor(public val: Expr, message?: string) {\n      super(val, message);\n      Object.setPrototypeOf(this, MichelsonValidationError.prototype);\n   }\n}\n\nfunction isPrim(ex: Expr): ex is Prim {\n   return \"prim\" in ex;\n}\n\nfunction isPrimOrSeq(ex: Expr): ex is Prim | Expr[] {\n   return Array.isArray(ex) || \"prim\" in ex;\n}\n\nfunction assertPrim(ex: Expr): ex is Prim {\n   if (isPrim(ex)) {\n      return true;\n   }\n   throw new MichelsonValidationError(ex, \"prim expression expected\");\n}\n\nfunction assertSeq(ex: Expr): ex is Expr[] {\n   if (Array.isArray(ex)) {\n      return true;\n   }\n   throw new MichelsonValidationError(ex, \"sequence expression expected\");\n}\n\nfunction assertPrimOrSeq(ex: Expr): ex is Prim | Expr[] {\n   if (isPrimOrSeq(ex)) {\n      return true;\n   }\n   throw new MichelsonValidationError(ex, \"prim or sequence expression expected\");\n}\n\nfunction assertNatural(i: IntLiteral) {\n   if (i.int[0] === \"-\") {\n      throw new MichelsonValidationError(i, \"natural number expected\");\n   }\n}\n\nfunction assertIntLiteral(ex: Expr): ex is IntLiteral {\n   if (\"int\" in ex) {\n      return true;\n   }\n   throw new MichelsonValidationError(ex, \"int literal expected\");\n}\n\nfunction assertArgs<N extends number>(ex: Prim, n: N):\n   ex is N extends 0 ?\n   NoArgs<Prim<string>> :\n   ReqArgs<Prim<string, Tuple<N, Expr>>> {\n   if ((n === 0 && ex.args === undefined) || ex.args?.length === n) {\n      return true;\n   }\n   throw new MichelsonValidationError(ex, `${n} arguments expected`);\n}\n\n/**\n * Checks if the node is a valid Michelson code (sequence of instructions).\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport function assertMichelsonInstruction(ex: Expr): ex is MichelsonCode {\n   if (Array.isArray(ex)) {\n      for (const n of ex) {\n         if (!Array.isArray(n) && !isPrim(n)) {\n            throw new MichelsonValidationError(ex, \"sequence or prim expected\");\n         }\n         assertMichelsonInstruction(n);\n      }\n      return true;\n   }\n\n   if (assertPrim(ex)) {\n      if (Object.prototype.hasOwnProperty.call(noArgInstructionIDs, ex.prim)) {\n         assertArgs(ex, 0);\n         return true;\n      }\n\n      switch (ex.prim) {\n         case \"DROP\":\n         case \"PAIR\":\n         case \"UNPAIR\":\n         case \"DUP\":\n         case \"UPDATE\":\n         case \"GET\":\n            if (ex.args !== undefined && assertArgs(ex, 1)) {\n               /* istanbul ignore else */\n               if (assertIntLiteral(ex.args[0])) {\n                  assertNatural(ex.args[0]);\n               }\n            }\n            break;\n\n         case \"DIG\":\n         case \"DUG\":\n         case \"SAPLING_EMPTY_STATE\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1)) {\n               /* istanbul ignore else */\n               if (assertIntLiteral(ex.args[0])) {\n                  assertNatural(ex.args[0]);\n               }\n            }\n            break;\n\n         case \"NONE\":\n         case \"LEFT\":\n         case \"RIGHT\":\n         case \"NIL\":\n         case \"CAST\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1)) {\n               assertMichelsonType(ex.args[0]);\n            }\n            break;\n\n         case \"UNPACK\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1)) {\n               assertMichelsonPackableType(ex.args[0]);\n            }\n            break;\n\n         case \"CONTRACT\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1)) {\n               assertMichelsonPassableType(ex.args[0]);\n            }\n            break;\n\n         case \"IF_NONE\":\n         case \"IF_LEFT\":\n         case \"IF_CONS\":\n         case \"IF\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2)) {\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[0])) {\n                  assertMichelsonInstruction(ex.args[0]);\n               }\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[1])) {\n                  assertMichelsonInstruction(ex.args[1]);\n               }\n            }\n            break;\n\n         case \"MAP\":\n         case \"ITER\":\n         case \"LOOP\":\n         case \"LOOP_LEFT\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1)) {\n               assertMichelsonInstruction(ex.args[0]);\n            }\n            break;\n\n         case \"CREATE_CONTRACT\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1)) {\n               assertMichelsonContract(ex.args[0]);\n            }\n            break;\n\n         case \"DIP\":\n            if (ex.args?.length === 2) {\n               /* istanbul ignore else */\n               if (assertIntLiteral(ex.args[0])) {\n                  assertNatural(ex.args[0]);\n               }\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[1])) {\n                  assertMichelsonInstruction(ex.args[1]);\n               }\n            } else if (ex.args?.length === 1) {\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[0])) {\n                  assertMichelsonInstruction(ex.args[0]);\n               }\n            } else {\n               throw new MichelsonValidationError(ex, \"1 or 2 arguments expected\");\n            }\n            break;\n\n         case \"PUSH\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2)) {\n               assertMichelsonPushableType(ex.args[0]);\n               assertMichelsonData(ex.args[1]);\n            }\n            break;\n\n         case \"EMPTY_SET\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1)) {\n               assertMichelsonComparableType(ex.args[0]);\n            }\n            break;\n\n         case \"EMPTY_MAP\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2)) {\n               assertMichelsonComparableType(ex.args[0]);\n               assertMichelsonType(ex.args[1]);\n            }\n            break;\n\n         case \"EMPTY_BIG_MAP\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 2)) {\n               assertMichelsonComparableType(ex.args[0]);\n               assertMichelsonBigMapStorableType(ex.args[1]);\n            }\n            break;\n\n         case \"LAMBDA\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 3)) {\n               assertMichelsonType(ex.args[0]);\n               assertMichelsonType(ex.args[1]);\n               /* istanbul ignore else */\n               if (assertSeq(ex.args[2])) {\n                  assertMichelsonInstruction(ex.args[2]);\n               }\n            }\n            break;\n\n         default:\n            throw new MichelsonValidationError(ex, \"instruction expected\");\n      }\n   }\n   return true;\n}\n\nexport function assertMichelsonComparableType(ex: Expr): ex is MichelsonType {\n   /* istanbul ignore else */\n   if (assertPrimOrSeq(ex)) {\n      if (Array.isArray(ex) || ex.prim === \"pair\" || ex.prim === \"or\" || ex.prim === \"option\") {\n         traverseType(ex, (ex) => assertMichelsonComparableType(ex));\n      } else if (!Object.prototype.hasOwnProperty.call(simpleComparableTypeIDs, ex.prim)) {\n         throw new MichelsonValidationError(ex, `${ex.prim}: type is not comparable`);\n      }\n   }\n   return true;\n}\n\nexport function assertMichelsonPackableType(ex: Expr): ex is MichelsonType {\n   /* istanbul ignore else */\n   if (assertPrimOrSeq(ex)) {\n      if (isPrim(ex)) {\n         if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) ||\n            ex.prim === \"big_map\" ||\n            ex.prim === \"operation\" ||\n            ex.prim === \"sapling_state\" ||\n            ex.prim === \"ticket\") {\n            throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used inside PACK/UNPACK instructions`);\n         }\n         traverseType(ex, (ex) => assertMichelsonPackableType(ex));\n      }\n   }\n   return true;\n}\n\nexport function assertMichelsonPushableType(ex: Expr): ex is MichelsonType {\n   /* istanbul ignore else */\n   if (assertPrimOrSeq(ex)) {\n      if (isPrim(ex)) {\n         if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) ||\n            ex.prim === \"big_map\" ||\n            ex.prim === \"operation\" ||\n            ex.prim === \"sapling_state\" ||\n            ex.prim === \"ticket\" ||\n            ex.prim === \"contract\") {\n            throw new MichelsonValidationError(ex, `${ex.prim}: type can't be pushed`);\n         }\n         traverseType(ex, (ex) => assertMichelsonPushableType(ex));\n      }\n   }\n   return true;\n}\n\nexport function assertMichelsonStorableType(ex: Expr): ex is MichelsonType {\n   /* istanbul ignore else */\n   if (assertPrimOrSeq(ex)) {\n      if (isPrim(ex)) {\n         if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) ||\n            ex.prim === \"operation\" ||\n            ex.prim === \"contract\") {\n            throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used as part of a storage`);\n         }\n         traverseType(ex, (ex) => assertMichelsonStorableType(ex));\n      }\n   }\n   return true;\n}\n\nexport function assertMichelsonPassableType(ex: Expr): ex is MichelsonType {\n   /* istanbul ignore else */\n   if (assertPrimOrSeq(ex)) {\n      if (isPrim(ex)) {\n         if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) ||\n            ex.prim === \"operation\") {\n            throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used as part of a parameter`);\n         }\n         traverseType(ex, (ex) => assertMichelsonPassableType(ex));\n      }\n   }\n   return true;\n}\n\nexport function assertMichelsonBigMapStorableType(ex: Expr): ex is MichelsonType {\n   /* istanbul ignore else */\n   if (assertPrimOrSeq(ex)) {\n      if (isPrim(ex)) {\n         if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) ||\n            ex.prim === \"big_map\" ||\n            ex.prim === \"operation\" ||\n            ex.prim === \"sapling_state\") {\n            throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used inside a big_map`);\n         }\n         traverseType(ex, (ex) => assertMichelsonBigMapStorableType(ex));\n      }\n   }\n   return true;\n}\n\n/**\n * Checks if the node is a valid Michelson type expression.\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport function assertMichelsonType(ex: Expr): ex is MichelsonType {\n   /* istanbul ignore else */\n   if (assertPrimOrSeq(ex)) {\n      if (isPrim(ex)) {\n         if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim)) {\n            throw new MichelsonValidationError(ex, \"type expected\");\n         }\n         traverseType(ex, (ex) => assertMichelsonType(ex));\n      }\n   }\n   return true;\n}\n\nfunction traverseType(ex: Prim | Expr[], cb: (ex: Prim | Expr[]) => void): ex is MichelsonType {\n   if (Array.isArray(ex) || ex.prim === \"pair\") {\n      const args = Array.isArray(ex) ? ex : ex.args;\n      if (args === undefined || args.length < 2) {\n         throw new MichelsonValidationError(ex, \"at least 2 arguments expected\");\n      }\n      args.forEach(a => {\n         if (assertPrimOrSeq(a)) {\n            cb(a);\n         }\n      });\n      return true;\n   }\n\n   switch (ex.prim) {\n      case \"option\":\n      case \"list\":\n         /* istanbul ignore else */\n         if (assertArgs(ex, 1) && assertPrimOrSeq(ex.args[0])) {\n            cb(ex.args[0]);\n         }\n         break;\n\n      case \"contract\":\n         /* istanbul ignore else */\n         if (assertArgs(ex, 1)) {\n            assertMichelsonPassableType(ex.args[0]);\n         }\n         break;\n\n      case \"or\":\n         /* istanbul ignore else */\n         if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {\n            cb(ex.args[0]);\n            cb(ex.args[1]);\n         }\n         break;\n\n      case \"lambda\":\n         /* istanbul ignore else */\n         if (assertArgs(ex, 2)) {\n            assertMichelsonType(ex.args[0]);\n            assertMichelsonType(ex.args[1]);\n         }\n         break;\n\n      case \"set\":\n         /* istanbul ignore else */\n         if (assertArgs(ex, 1)) {\n            assertMichelsonComparableType(ex.args[0]);\n         }\n         break;\n\n      case \"map\":\n         /* istanbul ignore else */\n         if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {\n            assertMichelsonComparableType(ex.args[0]);\n            cb(ex.args[1]);\n         }\n         break;\n\n      case \"big_map\":\n         /* istanbul ignore else */\n         if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {\n            assertMichelsonComparableType(ex.args[0]);\n            assertMichelsonBigMapStorableType(ex.args[1]);\n            cb(ex.args[1]);\n         }\n         break;\n\n      case \"ticket\":\n         /* istanbul ignore else */\n         if (assertArgs(ex, 1) && assertPrimOrSeq(ex.args[0])) {\n            assertMichelsonComparableType(ex.args[0]);\n         }\n         break;\n\n      case \"sapling_state\":\n      case \"sapling_transaction\":\n         if (assertArgs(ex, 1)) {\n            assertIntLiteral(ex.args[0]);\n         }\n         break;\n\n      default:\n         assertArgs(ex, 0);\n   }\n\n   return true;\n}\n/**\n * Checks if the node is a valid Michelson data literal such as `(Pair {Elt \"0\" 0} 0)`.\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport function assertMichelsonData(ex: Expr): ex is MichelsonData {\n   if ((\"int\" in ex) || (\"string\" in ex) || (\"bytes\" in ex)) {\n      return true;\n   }\n\n   if (Array.isArray(ex)) {\n      let mapElts = 0;\n      for (const n of ex) {\n         if (isPrim(n) && n.prim === \"Elt\") {\n            /* istanbul ignore else */\n            if (assertArgs(n, 2)) {\n               assertMichelsonData(n.args[0]);\n               assertMichelsonData(n.args[1]);\n            }\n            mapElts++;\n         } else {\n            assertMichelsonData(n);\n         }\n      }\n\n      if (mapElts !== 0 && mapElts !== ex.length) {\n         throw new MichelsonValidationError(ex, \"data entries and map elements can't be intermixed\");\n      }\n      return true;\n   }\n\n   if (isPrim(ex)) {\n      switch (ex.prim) {\n         case \"Unit\":\n         case \"True\":\n         case \"False\":\n         case \"None\":\n            assertArgs(ex, 0);\n            break;\n\n         case \"Pair\":\n            /* istanbul ignore else */\n            if (ex.args === undefined || ex.args.length < 2) {\n               throw new MichelsonValidationError(ex, \"at least 2 arguments expected\");\n            }\n            for (const a of ex.args) {\n               assertMichelsonData(a);\n            }\n            break;\n\n         case \"Left\":\n         case \"Right\":\n         case \"Some\":\n            /* istanbul ignore else */\n            if (assertArgs(ex, 1)) {\n               assertMichelsonData(ex.args[0]);\n            }\n            break;\n\n         default:\n            if (Object.prototype.hasOwnProperty.call(instructionIDs, ex.prim)) {\n               assertMichelsonInstruction(ex);\n            } else {\n               throw new MichelsonValidationError(ex, \"data entry or instruction expected\");\n            }\n      }\n   } else {\n      throw new MichelsonValidationError(ex, \"data entry expected\");\n   }\n\n   return true;\n}\n\n/**\n * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */\nexport function assertMichelsonContract(ex: Expr): ex is MichelsonContract {\n   /* istanbul ignore else */\n   if (assertSeq(ex)) {\n      const ent: { [sec: string]: boolean } = {};\n      for (const sec of ex) {\n         if (assertPrim(sec)) {\n            if (sec.prim !== \"code\" && sec.prim !== \"parameter\" && sec.prim !== \"storage\") {\n               throw new MichelsonValidationError(ex, `unexpected contract section: ${sec.prim}`);\n            }\n            if (sec.prim in ent) {\n               throw new MichelsonValidationError(ex, `duplicate contract section: ${sec.prim}`);\n            }\n            ent[sec.prim] = true;\n\n            /* istanbul ignore else */\n            if (assertArgs(sec, 1)) {\n               switch (sec.prim) {\n                  case \"code\":\n                     /* istanbul ignore else */\n                     if (assertSeq(sec.args[0])) {\n                        assertMichelsonInstruction(sec.args[0]);\n                     }\n                     break;\n\n                  case \"parameter\":\n                     assertMichelsonPassableType(sec.args[0]);\n                     break;\n\n                  case \"storage\":\n                     assertMichelsonStorableType(sec.args[0]);\n               }\n            }\n         }\n      }\n   }\n   return true;\n}\n\n/**\n * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.\n * @param ex An AST node\n */\nexport function isMichelsonScript(ex: Expr): ex is MichelsonContract {\n   try {\n      assertMichelsonContract(ex);\n      return true;\n   } catch {\n      return false;\n   }\n}\n\n/**\n * Checks if the node is a valid Michelson data literal such as `(Pair {Elt \"0\" 0} 0)`.\n * @param ex An AST node\n */\nexport function isMichelsonData(ex: Expr): ex is MichelsonData {\n   try {\n      assertMichelsonData(ex);\n      return true;\n   } catch {\n      return false;\n   }\n}\n\n/**\n * Checks if the node is a valid Michelson code (sequence of instructions).\n * @param ex An AST node\n */\nexport function isMichelsonCode(ex: Expr): ex is InstructionList {\n   try {\n      assertMichelsonInstruction(ex);\n      return true;\n   } catch {\n      return false;\n   }\n}\n\n/**\n * Checks if the node is a valid Michelson type expression.\n * @param ex An AST node\n */\nexport function isMichelsonType(ex: Expr): ex is MichelsonType {\n   try {\n      assertMichelsonType(ex);\n      return true;\n   } catch {\n      return false;\n   }\n}\n\nexport function isInstruction(p: Prim): p is MichelsonInstruction {\n   return Object.prototype.hasOwnProperty.call(instructionIDs, p.prim);\n}\n\nexport function assertDataListIfAny(d: MichelsonData): d is MichelsonData[] {\n   if (!Array.isArray(d)) {\n      return false;\n   }\n   for (const v of d) {\n      if (\"prim\" in v) {\n         if (isInstruction(v)) {\n            throw new MichelsonError(d, `Instruction outside of a lambda: ${JSON.stringify(d)}`);\n         } else if (v.prim === \"Elt\") {\n            throw new MichelsonError(d, `Elt item outside of a map literal: ${JSON.stringify(d)}`);\n         }\n      }\n   }\n   return true;\n}","import { BytesLiteral, Expr, IntLiteral, Prim } from \"./micheline\";\nimport {\n    MichelsonTypeID, MichelsonDataID,\n    MichelsonSectionID, MichelsonInstructionID,\n    MichelsonData, MichelsonType, MichelsonDataOr,\n    MichelsonDataOption, MichelsonInstruction\n} from \"./michelson-types\";\nimport { assertDataListIfAny, assertMichelsonData, assertMichelsonInstruction } from \"./michelson-validator\";\nimport {\n    checkDecodeTezosID, encodeTezosID, hexBytes,\n    isPairData, isPairType, MichelsonTypeError,\n    parseBytes, parseDate, parseHex, unpackComb\n} from \"./utils\";\n\ntype PrimID = MichelsonTypeID |\n    MichelsonDataID |\n    MichelsonSectionID |\n    MichelsonInstructionID |\n    \"Elt\";\n\nconst primitives: PrimID[] = [\"parameter\", \"storage\", \"code\", \"False\", \"Elt\", \"Left\", \"None\", \"Pair\",\n    \"Right\", \"Some\", \"True\", \"Unit\", \"PACK\", \"UNPACK\", \"BLAKE2B\", \"SHA256\", \"SHA512\", \"ABS\", \"ADD\",\n    \"AMOUNT\", \"AND\", \"BALANCE\", \"CAR\", \"CDR\", \"CHECK_SIGNATURE\", \"COMPARE\", \"CONCAT\", \"CONS\",\n    \"CREATE_ACCOUNT\", \"CREATE_CONTRACT\", \"IMPLICIT_ACCOUNT\", \"DIP\", \"DROP\", \"DUP\", \"EDIV\", \"EMPTY_MAP\",\n    \"EMPTY_SET\", \"EQ\", \"EXEC\", \"FAILWITH\", \"GE\", \"GET\", \"GT\", \"HASH_KEY\", \"IF\", \"IF_CONS\", \"IF_LEFT\",\n    \"IF_NONE\", \"INT\", \"LAMBDA\", \"LE\", \"LEFT\", \"LOOP\", \"LSL\", \"LSR\", \"LT\", \"MAP\", \"MEM\", \"MUL\", \"NEG\",\n    \"NEQ\", \"NIL\", \"NONE\", \"NOT\", \"NOW\", \"OR\", \"PAIR\", \"PUSH\", \"RIGHT\", \"SIZE\", \"SOME\", \"SOURCE\",\n    \"SENDER\", \"SELF\", \"STEPS_TO_QUOTA\", \"SUB\", \"SWAP\", \"TRANSFER_TOKENS\", \"SET_DELEGATE\", \"UNIT\",\n    \"UPDATE\", \"XOR\", \"ITER\", \"LOOP_LEFT\", \"ADDRESS\", \"CONTRACT\", \"ISNAT\", \"CAST\", \"RENAME\", \"bool\",\n    \"contract\", \"int\", \"key\", \"key_hash\", \"lambda\", \"list\", \"map\", \"big_map\", \"nat\", \"option\", \"or\",\n    \"pair\", \"set\", \"signature\", \"string\", \"bytes\", \"mutez\", \"timestamp\", \"unit\", \"operation\",\n    \"address\", \"SLICE\", \"DIG\", \"DUG\", \"EMPTY_BIG_MAP\", \"APPLY\", \"chain_id\", \"CHAIN_ID\", \"LEVEL\",\n    \"SELF_ADDRESS\", \"never\", \"NEVER\", \"UNPAIR\", \"VOTING_POWER\", \"TOTAL_VOTING_POWER\", \"KECCAK\",\n    \"SHA3\", \"PAIRING_CHECK\", \"bls12_381_g1\", \"bls12_381_g2\", \"bls12_381_fr\", \"sapling_state\",\n    \"sapling_transaction\", \"SAPLING_EMPTY_STATE\", \"SAPLING_VERIFY_UPDATE\", \"ticket\", \"TICKET\",\n    \"READ_TICKET\", \"SPLIT_TICKET\", \"JOIN_TICKETS\", \"GET_AND_UPDATE\"];\n\nconst primTags: { [key in PrimID]?: number } & { [key: string]: number | undefined; } = Object.assign({}, ...primitives.map((v, i) => ({ [v]: i })));\n\nenum Tag {\n    Int = 0,\n    String = 1,\n    Sequence = 2,\n    Prim0 = 3,\n    Prim0Annot = 4,\n    Prim1 = 5,\n    Prim1Annot = 6,\n    Prim2 = 7,\n    Prim2Annot = 8,\n    Prim = 9,\n    Bytes = 10,\n}\nclass Writer {\n    public buffer: number[] = [];\n\n    get length(): number {\n        return this.buffer.length;\n    }\n\n    writeBytes(val: number[]) {\n        this.buffer.push(...val.map(v => v & 0xff));\n    }\n\n    writeUint8(val: number) {\n        const v = val | 0;\n        this.buffer.push(v & 0xff);\n    }\n\n    writeUint16(val: number) {\n        const v = val | 0;\n        this.buffer.push((v >> 8) & 0xff);\n        this.buffer.push(v & 0xff);\n    }\n\n    writeUint32(val: number) {\n        const v = val | 0;\n        this.buffer.push((v >> 24) & 0xff);\n        this.buffer.push((v >> 16) & 0xff);\n        this.buffer.push((v >> 8) & 0xff);\n        this.buffer.push(v & 0xff);\n    }\n\n    writeInt8(val: number) {\n        this.writeUint8(val);\n    }\n\n    writeInt16(val: number) {\n        this.writeUint16(val);\n    }\n\n    writeInt32(val: number) {\n        this.writeUint32(val);\n    }\n}\n\nconst boundsErr = new Error(\"bounds out of range\");\nclass Reader {\n    constructor(private buffer: number[] | Uint8Array, private idx: number = 0, private cap: number = buffer.length) {\n    }\n\n    /** Remaining length */\n    get length(): number {\n        return this.cap - this.idx;\n    }\n\n    readBytes(len: number): number[] | Uint8Array {\n        if (this.cap - this.idx < len) {\n            throw boundsErr;\n        }\n        const ret = this.buffer.slice(this.idx, this.idx + len);\n        this.idx += len;\n        return ret;\n    }\n\n    reader(len: number): Reader {\n        if (this.cap - this.idx < len) {\n            throw boundsErr;\n        }\n        const ret = new Reader(this.buffer, this.idx, this.idx + len);\n        this.idx += len;\n        return ret;\n    }\n\n    copy(): Reader {\n        return new Reader(this.buffer, this.idx, this.cap);\n    }\n\n    readUint8(): number {\n        if (this.cap - this.idx < 1) {\n            throw boundsErr;\n        }\n        return this.buffer[this.idx++] >>> 0;\n    }\n\n    readUint16(): number {\n        if (this.cap - this.idx < 2) {\n            throw boundsErr;\n        }\n        const x0 = this.buffer[this.idx++];\n        const x1 = this.buffer[this.idx++];\n        return ((x0 << 8) | x1) >>> 0;\n    }\n\n    readUint32(): number {\n        if (this.cap - this.idx < 4) {\n            throw boundsErr;\n        }\n        const x0 = this.buffer[this.idx++];\n        const x1 = this.buffer[this.idx++];\n        const x2 = this.buffer[this.idx++];\n        const x3 = this.buffer[this.idx++];\n        return ((x0 << 24) | (x1 << 16) | (x2 << 8) | x3) >>> 0;\n    }\n\n    readInt8(): number {\n        if (this.cap - this.idx < 1) {\n            throw boundsErr;\n        }\n        const x = this.buffer[this.idx++];\n        return (x << 24) >> 24;\n    }\n\n    readInt16(): number {\n        if (this.cap - this.idx < 2) {\n            throw boundsErr;\n        }\n        const x0 = this.buffer[this.idx++];\n        const x1 = this.buffer[this.idx++];\n        return (((x0 << 8) | x1) << 16) >> 16;\n    }\n\n    readInt32(): number {\n        if (this.cap - this.idx < 4) {\n            throw boundsErr;\n        }\n        const x0 = this.buffer[this.idx++];\n        const x1 = this.buffer[this.idx++];\n        const x2 = this.buffer[this.idx++];\n        const x3 = this.buffer[this.idx++];\n        return (x0 << 24) | (x1 << 16) | (x2 << 8) | x3;\n    }\n}\n\nenum ContractID {\n    Implicit = 0,\n    Originated = 1,\n}\n\nenum PublicKeyHashID {\n    ED25519 = 0,\n    SECP256K1 = 1,\n    P256 = 2,\n}\n\ntype AddressType = \"ED25519PublicKeyHash\" | \"SECP256K1PublicKeyHash\" | \"P256PublicKeyHash\" | \"ContractHash\";\n\nexport interface Address {\n    type: AddressType;\n    hash: number[] | Uint8Array;\n    entryPoint?: string;\n}\n\nfunction readPublicKeyHash(rd: Reader): Address {\n    let type: AddressType;\n    const tag = rd.readUint8();\n    switch (tag) {\n        case PublicKeyHashID.ED25519:\n            type = \"ED25519PublicKeyHash\";\n            break;\n        case PublicKeyHashID.SECP256K1:\n            type = \"SECP256K1PublicKeyHash\";\n            break;\n        case PublicKeyHashID.P256:\n            type = \"P256PublicKeyHash\";\n            break;\n        default:\n            throw new Error(`unknown public key hash tag: ${tag}`);\n    }\n    return { type, hash: rd.readBytes(20) };\n}\n\nfunction readAddress(rd: Reader): Address {\n    let address: Address;\n    const tag = rd.readUint8();\n    switch (tag) {\n        case ContractID.Implicit:\n            address = readPublicKeyHash(rd);\n            break;\n\n        case ContractID.Originated:\n            address = {\n                type: \"ContractHash\",\n                hash: rd.readBytes(20),\n            };\n            rd.readBytes(1);\n            break;\n\n        default:\n            throw new Error(`unknown address tag: ${tag}`);\n    }\n\n    if (rd.length !== 0) {\n        // entry point\n        const dec = new TextDecoder();\n        address.entryPoint = dec.decode(new Uint8Array(rd.readBytes(rd.length)));\n    }\n    return address;\n}\n\nfunction writePublicKeyHash(a: Address, w: Writer): void {\n    let tag: PublicKeyHashID;\n    switch (a.type) {\n        case \"ED25519PublicKeyHash\":\n            tag = PublicKeyHashID.ED25519;\n            break;\n        case \"SECP256K1PublicKeyHash\":\n            tag = PublicKeyHashID.SECP256K1;\n            break;\n        case \"P256PublicKeyHash\":\n            tag = PublicKeyHashID.P256;\n            break;\n        default:\n            throw new Error(`unexpected address type: ${a.type}`);\n    }\n    w.writeUint8(tag);\n    w.writeBytes(Array.from(a.hash));\n}\n\nfunction writeAddress(a: Address, w: Writer): void {\n    if (a.type === \"ContractHash\") {\n        w.writeUint8(ContractID.Originated);\n        w.writeBytes(Array.from(a.hash));\n        w.writeUint8(0);\n    } else {\n        w.writeUint8(ContractID.Implicit);\n        writePublicKeyHash(a, w);\n    }\n\n    if (a.entryPoint !== undefined && a.entryPoint !== \"\" && a.entryPoint !== \"default\") {\n        const enc = new TextEncoder();\n        const bytes = enc.encode(a.entryPoint);\n        w.writeBytes(Array.from(bytes));\n    }\n}\n\nenum PublicKeyID {\n    ED25519 = 0,\n    SECP256K1 = 1,\n    P256 = 2,\n}\n\nexport type PublicKeyType = \"ED25519PublicKey\" | \"SECP256K1PublicKey\" | \"P256PublicKey\";\nexport interface PublicKey {\n    type: PublicKeyType;\n    publicKey: number[] | Uint8Array;\n}\n\nfunction readPublicKey(rd: Reader): PublicKey {\n    let ln: number;\n    let type: PublicKeyType;\n    const tag = rd.readUint8();\n    switch (tag) {\n        case PublicKeyID.ED25519:\n            type = \"ED25519PublicKey\";\n            ln = 32;\n            break;\n        case PublicKeyID.SECP256K1:\n            type = \"SECP256K1PublicKey\";\n            ln = 33;\n            break;\n        case PublicKeyID.P256:\n            type = \"P256PublicKey\";\n            ln = 33;\n            break;\n        default:\n            throw new Error(`unknown public key tag: ${tag}`);\n    }\n    return { type, publicKey: rd.readBytes(ln) };\n}\n\nfunction writePublicKey(pk: PublicKey, w: Writer): void {\n    let tag: PublicKeyID;\n    switch (pk.type) {\n        case \"ED25519PublicKey\":\n            tag = PublicKeyID.ED25519;\n            break;\n        case \"SECP256K1PublicKey\":\n            tag = PublicKeyID.SECP256K1;\n            break;\n        case \"P256PublicKey\":\n            tag = PublicKeyID.P256;\n            break;\n        default:\n            throw new Error(`unexpected public key type: ${pk.type}`);\n    }\n    w.writeUint8(tag);\n    w.writeBytes(Array.from(pk.publicKey));\n}\n\ntype WriteTransformFunc = (e: Expr) => [Expr, IterableIterator<WriteTransformFunc>];\n\nfunction writeExpr(expr: Expr, wr: Writer, tf: WriteTransformFunc): void {\n    const [e, args] = tf(expr);\n\n    if (Array.isArray(e)) {\n        const w = new Writer();\n        for (const v of e) {\n            const a = args.next();\n            if (a.done) {\n                throw new Error(\"REPORT ME: iterator is done\");\n            }\n            writeExpr(v, w, a.value);\n        }\n        wr.writeUint8(Tag.Sequence);\n        wr.writeUint32(w.length);\n        wr.writeBytes(w.buffer);\n        return;\n    }\n\n    if (\"string\" in e) {\n        const enc = new TextEncoder();\n        const bytes = enc.encode(e.string);\n        wr.writeUint8(Tag.String);\n        wr.writeUint32(bytes.length);\n        wr.writeBytes(Array.from(bytes));\n        return;\n    }\n\n    if (\"int\" in e) {\n        wr.writeUint8(Tag.Int);\n        let val = BigInt(e.int);\n        const sign = val < 0;\n        if (sign) {\n            val = -val;\n        }\n        let i = 0;\n        do {\n            const bits = (i === 0) ? BigInt(6) : BigInt(7);\n            let byte = val & ((BigInt(1) << bits) - BigInt(1));\n            val >>= bits;\n            if (val) {\n                byte |= BigInt(0x80);\n            }\n            if (i === 0 && sign) {\n                byte |= BigInt(0x40);\n            }\n            wr.writeUint8(Number(byte));\n            i++;\n        } while (val);\n        return;\n    }\n\n    if (\"bytes\" in e) {\n        const bytes = parseHex(e.bytes);\n        wr.writeUint8(Tag.Bytes);\n        wr.writeUint32(bytes.length);\n        wr.writeBytes(bytes);\n        return;\n    }\n\n    const prim = primTags[e.prim];\n    if (prim === undefined) {\n        throw new TypeError(`Can't encode primary: ${e.prim}`);\n    }\n\n    const tag = (e.args?.length || 0) < 3 ?\n        Tag.Prim0 + (e.args?.length || 0) * 2 + (e.annots === undefined || e.annots.length === 0 ? 0 : 1) :\n        Tag.Prim;\n\n    wr.writeUint8(tag);\n    wr.writeUint8(prim);\n\n    if (e.args !== undefined) {\n        if (e.args.length < 3) {\n            for (const v of e.args) {\n                const a = args.next();\n                if (a.done) {\n                    throw new Error(\"REPORT ME: iterator is done\");\n                }\n                writeExpr(v, wr, a.value);\n            }\n        } else {\n            const w = new Writer();\n            for (const v of e.args) {\n                const a = args.next();\n                if (a.done) {\n                    throw new Error(\"REPORT ME: iterator is done\");\n                }\n                writeExpr(v, w, a.value);\n            }\n            wr.writeUint32(w.length);\n            wr.writeBytes(w.buffer);\n        }\n    }\n\n    if (e.annots !== undefined && e.annots.length !== 0) {\n        const enc = new TextEncoder();\n        const bytes = enc.encode(e.annots.join(\" \"));\n        wr.writeUint32(bytes.length);\n        wr.writeBytes(Array.from(bytes));\n    } else if (e.args !== undefined && e.args.length >= 3) {\n        wr.writeUint32(0);\n    }\n}\n\ntype ReadTransformFuncs = [(e: Expr) => IterableIterator<ReadTransformFuncs>, (e: Expr) => Expr];\n\nfunction readExpr(rd: Reader, tf: ReadTransformFuncs): Expr {\n    function* passThrough() {\n        while (true) {\n            yield readPassThrough;\n        }\n    }\n    const [args, tr] = tf;\n    const tag = rd.readUint8();\n    switch (tag) {\n        case Tag.Int:\n            {\n                const buf: number[] = [];\n                let byte: number;\n                do {\n                    byte = rd.readInt8();\n                    buf.push(byte);\n                } while ((byte & 0x80) !== 0);\n                let val = BigInt(0);\n                let sign = false;\n                for (let i = buf.length - 1; i >= 0; i--) {\n                    const bits = (i === 0) ? BigInt(6) : BigInt(7);\n                    const byte = BigInt(buf[i]);\n                    val <<= bits;\n                    val |= byte & ((BigInt(1) << bits) - BigInt(1));\n                    if (i === 0) {\n                        sign = !!(byte & BigInt(0x40));\n                    }\n                }\n                if (sign) {\n                    val = -val;\n                }\n                return tr({ int: String(val) });\n            }\n\n        case Tag.String:\n            {\n                const length = rd.readUint32();\n                const bytes = rd.readBytes(length);\n                const dec = new TextDecoder();\n                return tr({ string: dec.decode(new Uint8Array(bytes)) });\n            }\n\n        case Tag.Bytes:\n            {\n                const length = rd.readUint32();\n                const bytes = rd.readBytes(length);\n                const hex = hexBytes(Array.from(bytes));\n                return tr({ bytes: hex });\n            }\n\n        case Tag.Sequence:\n            {\n                const length = rd.readUint32();\n                let res: Expr[] = [];\n                let savedrd = rd.copy();\n                // make two passes\n                let it: IterableIterator<ReadTransformFuncs> = passThrough();\n                for (let n = 0; n < 2; n++) {\n                    const r = savedrd.reader(length);\n                    res = [];\n                    while (r.length > 0) {\n                        const a = it.next();\n                        if (a.done) {\n                            throw new Error(\"REPORT ME: iterator is done\");\n                        }\n                        res.push(readExpr(r, a.value));\n                    }\n                    // make a second pass with injected side effects\n                    it = args(res);\n                    savedrd = rd;\n                }\n                return tr(res);\n            }\n\n        default:\n            {\n                if (tag > 9) {\n                    throw new Error(`Unknown tag: ${tag}`);\n                }\n                const p = rd.readUint8();\n                if (p >= primitives.length) {\n                    throw new Error(`Unknown primitive tag: ${p}`);\n                }\n                const prim = primitives[p];\n                const argn = (tag - 3) >> 1;\n                let res: Prim = { prim };\n                // make two passes\n                let it: IterableIterator<ReadTransformFuncs> = passThrough();\n                let savedrd = rd.copy();\n                for (let n = 0; n < 2; n++) {\n                    res = { prim };\n                    if (argn < 3) {\n                        for (let i = 0; i < argn; i++) {\n                            const a = it.next();\n                            if (a.done) {\n                                throw new Error(\"REPORT ME: iterator is done\");\n                            }\n                            res.args = res.args || [];\n                            res.args.push(readExpr(savedrd, a.value));\n                        }\n                    } else {\n                        res.args = res.args || [];\n                        const length = savedrd.readUint32();\n                        const r = savedrd.reader(length);\n                        while (r.length > 0) {\n                            const a = it.next();\n                            if (a.done) {\n                                throw new Error(\"REPORT ME: iterator is done\");\n                            }\n                            res.args.push(readExpr(r, a.value));\n                        }\n                    }\n                    // make a second pass with injected side effects\n                    it = args(res);\n                    savedrd = rd;\n                }\n\n                if (((tag - 3) & 1) === 1 || argn === 3) {\n                    // read annotations\n                    const length = rd.readUint32();\n                    if (length !== 0) {\n                        const bytes = rd.readBytes(length);\n                        const dec = new TextDecoder();\n                        res.annots = dec.decode(new Uint8Array(bytes)).split(\" \");\n                    }\n                }\n                return tr(res);\n            }\n    }\n}\n\nconst isOrData = (e: Expr): e is MichelsonDataOr => \"prim\" in e && (e.prim === \"Left\" || e.prim === \"Right\");\nconst isOptionData = (e: Expr): e is MichelsonDataOption => \"prim\" in e && (e.prim === \"Some\" || e.prim === \"None\");\n\nconst getWriteTransformFunc = (t: MichelsonType): WriteTransformFunc => {\n    if (isPairType(t)) {\n        return (d: Expr) => {\n            if (!isPairData(d)) {\n                throw new MichelsonTypeError(t, d, `pair expected: ${JSON.stringify(d)}`);\n            }\n            assertDataListIfAny(d);\n            // combs aren't used in pack format\n            const tc = unpackComb(\"pair\", t);\n            const dc = unpackComb(\"Pair\", d);\n            return [dc, (function* () {\n                for (const a of tc.args) {\n                    yield getWriteTransformFunc(a);\n                }\n            })()];\n        };\n    }\n\n    switch (t.prim) {\n        case \"or\":\n            return (d: Expr) => {\n                if (!isOrData(d)) {\n                    throw new MichelsonTypeError(t, d, `or expected: ${JSON.stringify(d)}`);\n                }\n                return [d, (function* () {\n                    yield getWriteTransformFunc(t.args[d.prim === \"Left\" ? 0 : 1]);\n                })()];\n            };\n\n        case \"option\":\n            return (d: Expr) => {\n                if (!isOptionData(d)) {\n                    throw new MichelsonTypeError(t, d, `option expected: ${JSON.stringify(d)}`);\n                }\n                return [d, (function* () {\n                    const dd = d;\n                    if (dd.prim === \"Some\") {\n                        yield getWriteTransformFunc(t.args[0]);\n                    }\n                })()];\n            };\n\n        case \"list\":\n        case \"set\":\n            return (d: Expr) => {\n                if (!Array.isArray(d)) {\n                    throw new MichelsonTypeError(t, d, `${t.prim} expected: ${JSON.stringify(d)}`);\n                }\n                return [d, (function* () {\n                    for (const _v of d) {\n                        yield getWriteTransformFunc(t.args[0]);\n                    }\n                })()];\n            };\n\n        case \"map\":\n            return (d: Expr) => {\n                if (!Array.isArray(d)) {\n                    throw new MichelsonTypeError(t, d, `map expected: ${JSON.stringify(d)}`);\n                }\n                return [d, (function* (): Generator<WriteTransformFunc> {\n                    for (const _elt of d) {\n                        yield (elt: Expr) => {\n                            if (!(\"prim\" in elt) || elt.prim !== \"Elt\") {\n                                throw new MichelsonTypeError(t, elt, `map element expected: ${JSON.stringify(elt)}`);\n                            }\n                            return [elt, (function* () {\n                                for (const a of t.args) {\n                                    yield getWriteTransformFunc(a);\n                                }\n                            })()];\n                        };\n                    }\n                })()];\n            };\n\n        case \"chain_id\":\n            return (d: Expr) => {\n                if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                    throw new MichelsonTypeError(t, d, `chain id expected: ${JSON.stringify(d)}`);\n                }\n                let bytes: BytesLiteral;\n                if (\"string\" in d) {\n                    const id = checkDecodeTezosID(d.string, \"ChainID\");\n                    if (id === null) {\n                        throw new MichelsonTypeError(t, d, `chain id base58 expected: ${d.string}`);\n                    }\n                    bytes = { bytes: hexBytes(id[1]) };\n                } else {\n                    bytes = d;\n                }\n                return [bytes, [][Symbol.iterator]()];\n            };\n\n        case \"signature\":\n            return (d: Expr) => {\n                if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                    throw new MichelsonTypeError(t, d, `signature expected: ${JSON.stringify(d)}`);\n                }\n                let bytes: BytesLiteral;\n                if (\"string\" in d) {\n                    const sig = checkDecodeTezosID(d.string, \"ED25519Signature\", \"SECP256K1Signature\", \"P256Signature\", \"GenericSignature\");\n                    if (sig === null) {\n                        throw new MichelsonTypeError(t, d, `signature base58 expected: ${d.string}`);\n                    }\n                    bytes = { bytes: hexBytes(sig[1]) };\n                } else {\n                    bytes = d;\n                }\n                return [bytes, [][Symbol.iterator]()];\n            };\n\n        case \"key_hash\":\n            return (d: Expr) => {\n                if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                    throw new MichelsonTypeError(t, d, `key hash expected: ${JSON.stringify(d)}`);\n                }\n                let bytes: BytesLiteral;\n                if (\"string\" in d) {\n                    const pkh = checkDecodeTezosID(d.string, \"ED25519PublicKeyHash\", \"SECP256K1PublicKeyHash\", \"P256PublicKeyHash\");\n                    if (pkh === null) {\n                        throw new MichelsonTypeError(t, d, `key hash base58 expected: ${d.string}`);\n                    }\n                    const w = new Writer();\n                    writePublicKeyHash({ type: pkh[0], hash: pkh[1] }, w);\n                    bytes = { bytes: hexBytes(w.buffer) };\n                } else {\n                    bytes = d;\n                }\n                return [bytes, [][Symbol.iterator]()];\n            };\n\n        case \"key\":\n            return (d: Expr) => {\n                if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                    throw new MichelsonTypeError(t, d, `public key expected: ${JSON.stringify(d)}`);\n                }\n                let bytes: BytesLiteral;\n                if (\"string\" in d) {\n                    const key = checkDecodeTezosID(d.string, \"ED25519PublicKey\", \"SECP256K1PublicKey\", \"P256PublicKey\");\n                    if (key === null) {\n                        throw new MichelsonTypeError(t, d, `public key base58 expected: ${d.string}`);\n                    }\n                    const w = new Writer();\n                    writePublicKey({ type: key[0], publicKey: key[1] }, w);\n                    bytes = { bytes: hexBytes(w.buffer) };\n                } else {\n                    bytes = d;\n                }\n                return [bytes, [][Symbol.iterator]()];\n            };\n\n        case \"address\":\n            return (d: Expr) => {\n                if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                    throw new MichelsonTypeError(t, d, `address expected: ${JSON.stringify(d)}`);\n                }\n                let bytes: BytesLiteral;\n                if (\"string\" in d) {\n                    const s = d.string.split(\"%\");\n                    const address = checkDecodeTezosID(s[0], \"ED25519PublicKeyHash\", \"SECP256K1PublicKeyHash\", \"P256PublicKeyHash\", \"ContractHash\");\n                    if (address === null) {\n                        throw new MichelsonTypeError(t, d, `address base58 expected: ${d.string}`);\n                    }\n                    const w = new Writer();\n                    writeAddress({ type: address[0], hash: address[1], entryPoint: s.length > 1 ? s[1] : undefined }, w);\n                    bytes = { bytes: hexBytes(w.buffer) };\n                } else {\n                    bytes = d;\n                }\n                return [bytes, [][Symbol.iterator]()];\n            };\n\n        case \"timestamp\":\n            return (d: Expr) => {\n                if (!(\"string\" in d) && !(\"int\" in d)) {\n                    throw new MichelsonTypeError(t, d, `timestamp expected: ${JSON.stringify(d)}`);\n                }\n                let int: IntLiteral;\n                if (\"string\" in d) {\n                    const p = parseDate(d);\n                    if (p === null) {\n                        throw new MichelsonTypeError(t, d, `can't parse date: ${d.string}`);\n                    }\n                    int = { int: String(Math.floor(p.getTime() / 1000)) };\n                } else {\n                    int = d;\n                }\n                return [int, [][Symbol.iterator]()];\n            };\n\n        default:\n            return writePassThrough;\n    }\n};\n\ntype PushInstruction = MichelsonInstruction & Prim<\"PUSH\">;\nconst isPushInstruction = (e: Expr): e is PushInstruction => \"prim\" in e && e.prim === \"PUSH\";\n\nconst writePassThrough: WriteTransformFunc = (e: Expr) => {\n    if (isPushInstruction(e)) {\n        assertMichelsonInstruction(e);\n        // capture inlined type definition\n        return [e, (function* () {\n            yield writePassThrough;\n            yield getWriteTransformFunc(e.args[0]);\n        })()];\n    }\n\n    return [e, (function* () {\n        while (true) {\n            yield writePassThrough;\n        }\n    })()];\n};\n\n/**\n * Serializes any value of packable type to its optimized binary representation \n * identical to the one used by PACK and UNPACK Michelson instructions.\n * Without a type definition (not recommended) the data will be encoded as a binary form of a generic Michelson expression.\n * Type definition allows some types like `timestamp` and `address` and other base58 representable types to be encoded to\n * corresponding optimized binary forms borrowed from the Tezos protocol\n * \n * ```typescript\n * const data: MichelsonData = {\n *     string: \"KT1RvkwF4F7pz1gCoxkyZrG1RkrxQy3gmFTv%foo\"\n * };\n * \n * const typ: MichelsonType = {\n *     prim: \"address\"\n * };\n * \n * const packed = packData(data, typ);\n * \n * // 050a0000001901be41ee922ddd2cf33201e49d32da0afec571dce300666f6f\n * ```\n * \n * Without a type definition the base58 encoded address will be treated as a string\n * ```typescript\n * const data: MichelsonData = {\n *     string: \"KT1RvkwF4F7pz1gCoxkyZrG1RkrxQy3gmFTv%foo\"\n * };\n * \n * const packed = packData(data);\n * \n * // 0501000000284b543152766b7746344637707a3167436f786b795a724731526b7278517933676d46547625666f6f\n * ```\n * @param d Data object\n * @param t Optional type definition\n * @returns Binary representation as numeric array\n */\nexport function packData(d: MichelsonData, t?: MichelsonType): number[] {\n    const w = new Writer();\n    w.writeUint8(5);\n    writeExpr(d, w, t !== undefined ? getWriteTransformFunc(t) : writePassThrough);\n    return w.buffer;\n}\n\n/**\n * Serializes any value of packable type to its optimized binary representation \n * identical to the one used by PACK and UNPACK Michelson instructions.\n * Same as {@link packData} but returns a `bytes` Michelson data literal instead of an array\n * \n * ```typescript\n * const data: MichelsonData = {\n *     string: \"2019-09-26T10:59:51Z\"\n * };\n * \n * const typ: MichelsonType = {\n *     prim: \"timestamp\"\n * };\n * \n * const packed = packDataBytes(data, typ);\n * \n * // { bytes: \"0500a7e8e4d80b\" }\n * ```\n * @param d Data object\n * @param t Optional type definition\n * @returns Binary representation as a bytes literal\n */\nexport function packDataBytes(d: MichelsonData, t?: MichelsonType): BytesLiteral {\n    return { bytes: hexBytes(packData(d, t)) };\n}\n\nconst getReadTransformFuncs = (t: MichelsonType): ReadTransformFuncs => {\n    if (isPairType(t)) {\n        const args = Array.isArray(t) ? t : t.args;\n        return [\n            (d: Expr) => {\n                if (!isPairData(d)) {\n                    throw new MichelsonTypeError(t, d, `pair expected: ${JSON.stringify(d)}`);\n                }\n                return (function* () {\n                    for (const a of args) {\n                        yield getReadTransformFuncs(a);\n                    }\n                })();\n            },\n            (d: Expr) => d\n        ];\n    }\n\n    switch (t.prim) {\n        case \"or\":\n            return [\n                (d: Expr) => {\n                    if (!isOrData(d)) {\n                        throw new MichelsonTypeError(t, d, `or expected: ${JSON.stringify(d)}`);\n                    }\n                    return (function* () {\n                        yield getReadTransformFuncs(t.args[d.prim === \"Left\" ? 0 : 1]);\n                    })();\n                },\n                (d: Expr) => d\n            ];\n\n        case \"option\":\n            return [\n                (d: Expr) => {\n                    if (!isOptionData(d)) {\n                        throw new MichelsonTypeError(t, d, `option expected: ${JSON.stringify(d)}`);\n                    }\n                    return (function* () {\n                        if (d.prim === \"Some\") {\n                            yield getReadTransformFuncs(t.args[0]);\n                        }\n                    })();\n                },\n                (d: Expr) => d\n            ];\n\n        case \"list\":\n        case \"set\":\n            return [\n                (d: Expr) => {\n                    if (!Array.isArray(d)) {\n                        throw new MichelsonTypeError(t, d, `${t.prim} expected: ${JSON.stringify(d)}`);\n                    }\n                    return (function* () {\n                        while (true) {\n                            yield getReadTransformFuncs(t.args[0]);\n                        }\n                    })();\n                },\n                (d: Expr) => d\n            ];\n\n        case \"map\":\n            return [\n                (d: Expr): IterableIterator<ReadTransformFuncs> => {\n                    if (!Array.isArray(d)) {\n                        throw new MichelsonTypeError(t, d, `map expected: ${JSON.stringify(d)}`);\n                    }\n                    return (function* (): Generator<ReadTransformFuncs> {\n                        while (true) {\n                            yield [\n                                (elt: Expr) => {\n                                    if (!(\"prim\" in elt) || elt.prim !== \"Elt\") {\n                                        throw new MichelsonTypeError(t, elt, `map element expected: ${JSON.stringify(elt)}`);\n                                    }\n                                    return (function* () {\n                                        for (const a of t.args) {\n                                            yield getReadTransformFuncs(a);\n                                        }\n                                    })();\n                                },\n                                (elt: Expr) => elt\n                            ];\n                        }\n                    })();\n                },\n                (d: Expr) => d\n            ];\n\n        case \"chain_id\":\n            return [\n                () => [][Symbol.iterator](),\n                (d: Expr) => {\n                    if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                        throw new MichelsonTypeError(t, d, `chain id expected: ${JSON.stringify(d)}`);\n                    }\n                    if (\"string\" in d) {\n                        return d;\n                    }\n                    const bytes = parseBytes(d.bytes);\n                    if (bytes === null) {\n                        throw new MichelsonTypeError(t, d, `can't parse bytes: ${d.bytes}`);\n                    }\n                    return { string: encodeTezosID(\"ChainID\", bytes) };\n                }\n            ];\n\n        case \"signature\":\n            return [\n                () => [][Symbol.iterator](),\n                (d: Expr) => {\n                    if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                        throw new MichelsonTypeError(t, d, `signature expected: ${JSON.stringify(d)}`);\n                    }\n                    if (\"string\" in d) {\n                        return d;\n                    }\n                    const bytes = parseBytes(d.bytes);\n                    if (bytes === null) {\n                        throw new MichelsonTypeError(t, d, `can't parse bytes: ${d.bytes}`);\n                    }\n                    return { string: encodeTezosID(\"GenericSignature\", bytes) };\n                }\n            ];\n\n        case \"key_hash\":\n            return [\n                () => [][Symbol.iterator](),\n                (d: Expr) => {\n                    if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                        throw new MichelsonTypeError(t, d, `key hash expected: ${JSON.stringify(d)}`);\n                    }\n                    if (\"string\" in d) {\n                        return d;\n                    }\n                    const bytes = parseBytes(d.bytes);\n                    if (bytes === null) {\n                        throw new MichelsonTypeError(t, d, `can't parse bytes: ${d.bytes}`);\n                    }\n                    const rd = new Reader(new Uint8Array(bytes));\n                    const addr = readPublicKeyHash(rd);\n                    return { string: encodeTezosID(addr.type, addr.hash) + (addr.entryPoint ? \"%\" + addr.entryPoint : \"\") };\n                }\n            ];\n\n        case \"key\":\n            return [\n                () => [][Symbol.iterator](),\n                (d: Expr) => {\n                    if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                        throw new MichelsonTypeError(t, d, `public key expected: ${JSON.stringify(d)}`);\n                    }\n                    if (\"string\" in d) {\n                        return d;\n                    }\n                    const bytes = parseBytes(d.bytes);\n                    if (bytes === null) {\n                        throw new MichelsonTypeError(t, d, `can't parse bytes: ${d.bytes}`);\n                    }\n                    const rd = new Reader(new Uint8Array(bytes));\n                    const pk = readPublicKey(rd);\n                    return { string: encodeTezosID(pk.type, pk.publicKey) };\n                }\n            ];\n\n        case \"address\":\n            return [\n                () => [][Symbol.iterator](),\n                (d: Expr) => {\n                    if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                        throw new MichelsonTypeError(t, d, `address expected: ${JSON.stringify(d)}`);\n                    }\n                    if (\"string\" in d) {\n                        return d;\n                    }\n                    const bytes = parseBytes(d.bytes);\n                    if (bytes === null) {\n                        throw new MichelsonTypeError(t, d, `can't parse bytes: ${d.bytes}`);\n                    }\n                    const rd = new Reader(new Uint8Array(bytes));\n                    const addr = readAddress(rd);\n                    return { string: encodeTezosID(addr.type, addr.hash) + (addr.entryPoint ? \"%\" + addr.entryPoint : \"\") };\n                }\n            ];\n\n        case \"timestamp\":\n            return [\n                () => [][Symbol.iterator](),\n                (d: Expr) => {\n                    if (!(\"int\" in d) && !(\"string\" in d)) {\n                        throw new MichelsonTypeError(t, d, `address expected: ${JSON.stringify(d)}`);\n                    }\n                    if (\"string\" in d) {\n                        return d;\n                    }\n                    const date = new Date(parseInt(d.int, 10) * 1000);\n                    return { string: date.toISOString().slice(0, 19) + \"Z\" };\n                }\n            ];\n\n        default:\n            return readPassThrough;\n    }\n};\n\nconst readPassThrough: ReadTransformFuncs = [\n    (e: Expr) => {\n        if (isPushInstruction(e)) {\n            assertMichelsonInstruction(e);\n            // capture inlined type definition\n            return (function* () {\n                yield readPassThrough;\n                yield getReadTransformFuncs(e.args[0]);\n            })();\n        }\n\n        return (function* () {\n            while (true) {\n                yield readPassThrough;\n            }\n        })();\n    },\n    (e: Expr) => e\n];\n\n/**\n * Deserialize a byte array into the corresponding Michelson value.\n * Without a type definition (not recommended) the binary data will be treated as a binary form of a generic Michelson expression and returned as is.\n * Type definition allows some types like `timestamp` and `address` and other types usually encoded in optimized binary forms to be transformed \n * back to their string representations like base58 and ISO timestamps.\n * \n * ```typescript\n * const src = [0x05, 0x00, 0xa7, 0xe8, 0xe4, 0xd8, 0x0b];\n * \n * const typ: MichelsonType = {\n *     prim: \"timestamp\"\n * };\n * \n * const data = unpackData(src, typ);\n * \n * // { string: \"2019-09-26T10:59:51Z\" }\n * ```\n * \n * Same binary data without a type definition\n * ```typescript\n * const src = [0x05, 0x00, 0xa7, 0xe8, 0xe4, 0xd8, 0x0b];\n * \n * const data = unpackData(src);\n * \n * // { int: \"1569495591\" }\n * ```\n * @param src Byte array\n * @param t Optional type definition\n * @returns Deserialized data\n */\nexport function unpackData(src: number[] | Uint8Array, t?: MichelsonType): MichelsonData {\n    const r = new Reader(src);\n    if (r.readUint8() !== 5) {\n        throw new Error(\"incorrect packed data magic number\");\n    }\n    const ex = readExpr(r, t !== undefined ? getReadTransformFuncs(t) : readPassThrough);\n    if (assertMichelsonData(ex)) {\n        return ex;\n    }\n    throw new Error(); // never\n}\n\n/**\n * Deserialize a byte array into the corresponding Michelson value.\n * Same as {@link unpackData} but takes a `bytes` Michelson data literal instead of an array\n * \n * ```typescript\n * const src = { bytes: \"0500a7e8e4d80b\" };\n * \n * const typ: MichelsonType = {\n *     prim: \"timestamp\"\n * };\n * \n * const data = unpackDataBytes(src, typ);\n * \n * // { string: \"2019-09-26T10:59:51Z\" }\n * ```\n * @param src Bytes object\n * @param t Optional type definition\n * @returns Deserialized data\n */\nexport function unpackDataBytes(src: BytesLiteral, t?: MichelsonType): MichelsonData {\n    const bytes = parseBytes(src.bytes);\n    if (bytes === null) {\n        throw new Error(`can't parse bytes: \"${src.bytes}\"`);\n    }\n    return unpackData(bytes, t);\n}\n\n// helper functions also used by validator\n\nexport function decodeAddressBytes(b: BytesLiteral): Address {\n    const bytes = parseBytes(b.bytes);\n    if (bytes === null) {\n        throw new Error(`can't parse bytes: \"${b.bytes}\"`);\n    }\n    const rd = new Reader(new Uint8Array(bytes));\n    return readAddress(rd);\n}\n\nexport function decodePublicKeyHashBytes(b: BytesLiteral): Address {\n    const bytes = parseBytes(b.bytes);\n    if (bytes === null) {\n        throw new Error(`can't parse bytes: \"${b.bytes}\"`);\n    }\n    const rd = new Reader(new Uint8Array(bytes));\n    return readPublicKeyHash(rd);\n}\n\nexport function decodePublicKeyBytes(b: BytesLiteral): PublicKey {\n    const bytes = parseBytes(b.bytes);\n    if (bytes === null) {\n        throw new Error(`can't parse bytes: \"${b.bytes}\"`);\n    }\n    const rd = new Reader(new Uint8Array(bytes));\n    return readPublicKey(rd);\n}","import { Prim, Expr } from \"./micheline\";\nimport {\n    MichelsonType, MichelsonData, MichelsonMapElt, MichelsonCode, MichelsonTypeOption,\n    MichelsonContract, MichelsonContractSection, MichelsonReturnType, MichelsonTypePair,\n    MichelsonInstruction, InstructionList, MichelsonTypeID, MichelsonTypeOr,\n    DefaultProtocol,\n    Protocol,\n    refContract,\n    MichelsonTypeAddress\n} from \"./michelson-types\";\nimport {\n    unpackAnnotations, MichelsonError, isNatural,\n    LongInteger, parseBytes, compareBytes, isDecimal,\n    checkDecodeTezosID, UnpackedAnnotations, Nullable,\n    UnpackAnnotationsOptions, unpackComb, MichelsonTypeError, isPairType, isPairData, parseDate,\n} from \"./utils\";\nimport { decodeBase58Check } from \"./base58\";\nimport { decodeAddressBytes, decodePublicKeyBytes, decodePublicKeyHashBytes } from \"./binary\";\nimport {\n    assertMichelsonComparableType,\n    assertMichelsonPackableType, assertMichelsonStorableType,\n    assertMichelsonBigMapStorableType, assertMichelsonPushableType, isInstruction, assertDataListIfAny\n} from \"./michelson-validator\";\nimport { ParserOptions } from \"./micheline-parser\";\n\nexport interface Context extends ParserOptions {\n    contract?: MichelsonContract;\n    traceCallback?: (t: InstructionTrace) => void;\n}\n\nexport class MichelsonInstructionError extends MichelsonError<MichelsonCode> {\n    /**\n     * @param val Value of a type node caused the error\n     * @param stackState Current stack state\n     * @param message An error message\n     */\n    constructor(val: MichelsonCode, public stackState: MichelsonReturnType, message?: string) {\n        super(val, message);\n        Object.setPrototypeOf(this, MichelsonInstructionError.prototype);\n    }\n}\n\n// 'sequence as a pair' edo syntax helpers\nfunction typeID(t: MichelsonType): MichelsonTypeID {\n    return Array.isArray(t) ? \"pair\" : t.prim;\n}\n\ntype TypeArgs<T extends MichelsonType> = T extends Prim ? T[\"args\"] : T;\nfunction typeArgs<T extends MichelsonType>(t: T): TypeArgs<T> {\n    return (\"prim\" in t ? (t as Extract<MichelsonType, Prim>).args : t) as TypeArgs<T>;\n}\n\nfunction assertScalarTypesEqual(a: MichelsonType, b: MichelsonType, field: boolean = false): void {\n    if (typeID(a) !== typeID(b)) {\n        throw new MichelsonTypeError(a, undefined, `types mismatch: ${typeID(a)} != ${typeID(b)}`);\n    }\n\n    const ann = [unpackAnnotations(a), unpackAnnotations(b)];\n    if (ann[0].t && ann[1].t && ann[0].t[0] !== ann[1].t[0]) {\n        throw new MichelsonTypeError(a, undefined, `${typeID(a)}: type names mismatch: ${ann[0].t[0]} != ${ann[1].t[0]}`);\n    }\n    if (field &&\n        (ann[0].f && ann[1].f && ann[0].f[0] !== ann[1].f[0])) {\n        throw new MichelsonTypeError(a, undefined, `${typeID(a)}: field names mismatch: ${ann[0].f[0]} != ${ann[1].f}`);\n    }\n\n    if (isPairType(a)) {\n        const aArgs = unpackComb(\"pair\", a);\n        const bArgs = unpackComb(\"pair\", b as typeof a);\n        assertScalarTypesEqual(aArgs.args[0], bArgs.args[0], true);\n        assertScalarTypesEqual(aArgs.args[1], bArgs.args[1], true);\n        return;\n    }\n\n    switch (a.prim) {\n        case \"option\":\n        case \"list\":\n        case \"contract\":\n        case \"set\":\n        case \"ticket\":\n            assertScalarTypesEqual(a.args[0], (b as typeof a).args[0]);\n            break;\n\n        case \"or\":\n            assertScalarTypesEqual(a.args[0], (b as typeof a).args[0], true);\n            assertScalarTypesEqual(a.args[1], (b as typeof a).args[1], true);\n            break;\n\n        case \"lambda\":\n        case \"map\":\n        case \"big_map\":\n            assertScalarTypesEqual(a.args[0], (b as typeof a).args[0]);\n            assertScalarTypesEqual(a.args[1], (b as typeof a).args[1]);\n            break;\n\n        case \"sapling_state\":\n        case \"sapling_transaction\":\n            if (parseInt(a.args[0].int, 10) !== parseInt((b as typeof a).args[0].int, 10)) {\n                throw new MichelsonTypeError(a, undefined, `${typeID(a)}: type argument mismatch: ${a.args[0].int} != ${(b as typeof a).args[0].int}`);\n            }\n    }\n}\n\nfunction assertStacksEqual<T1 extends MichelsonType[], T2 extends T1>(a: T1, b: T2): void {\n    if (a.length !== b.length) {\n        throw new MichelsonTypeError(a, undefined, `stack length mismatch: ${a.length} != ${b.length}`);\n    }\n    for (let i = 0; i < a.length; i++) {\n        assertScalarTypesEqual(a[i], b[i]);\n    }\n}\n\nexport function assertTypeAnnotationsValid(t: MichelsonType, field: boolean = false): void {\n    if (!Array.isArray(t)) {\n        const ann = unpackAnnotations(t);\n        if ((ann.t?.length || 0) > 1) {\n            throw new MichelsonTypeError(t, undefined, `${t.prim}: at most one type annotation allowed: ${t.annots}`);\n        }\n\n        if (field) {\n            if ((ann.f?.length || 0) > 1) {\n                throw new MichelsonTypeError(t, undefined, `${t.prim}: at most one field annotation allowed: ${t.annots}`);\n            }\n        } else {\n            if ((ann.f?.length || 0) > 0) {\n                throw new MichelsonTypeError(t, undefined, `${t.prim}: field annotations aren't allowed: ${t.annots}`);\n            }\n        }\n    }\n\n    if (isPairType(t)) {\n        const args = typeArgs(t);\n        for (const a of args) {\n            assertTypeAnnotationsValid(a, true);\n        }\n        return;\n    }\n\n    switch (t.prim) {\n        case \"option\":\n        case \"list\":\n        case \"contract\":\n        case \"set\":\n            assertTypeAnnotationsValid(t.args[0]);\n            break;\n\n        case \"or\":\n            for (const a of t.args) {\n                assertTypeAnnotationsValid(a, true);\n            }\n            break;\n\n        case \"lambda\":\n        case \"map\":\n        case \"big_map\":\n            assertTypeAnnotationsValid(t.args[0]);\n            assertTypeAnnotationsValid(t.args[1]);\n    }\n}\n\n// Data integrity check\n\nfunction compareMichelsonData(t: MichelsonType, a: MichelsonData, b: MichelsonData): number {\n    if (isPairType(t)) {\n        if (isPairData(a) && isPairData(b)) {\n            assertDataListIfAny(a);\n            assertDataListIfAny(b);\n            const tComb = unpackComb(\"pair\", t);\n            const aComb = unpackComb(\"Pair\", a);\n            const bComb = unpackComb(\"Pair\", b);\n            const x = compareMichelsonData(tComb.args[0], aComb.args[0], bComb.args[0]);\n            if (x !== 0) {\n                return x;\n            }\n            return compareMichelsonData(tComb.args[0], aComb.args[1], bComb.args[1]);\n        }\n    } else {\n        switch (t.prim) {\n            case \"int\":\n            case \"nat\":\n            case \"mutez\":\n                if ((\"int\" in a) && (\"int\" in b)) {\n                    return new LongInteger(a.int).cmp(new LongInteger(b.int));\n                }\n                break;\n\n            case \"string\":\n                if ((\"string\" in a) && (\"string\" in b)) {\n                    const x = a.string.localeCompare(b.string);\n                    return x < 0 ? -1 : x > 0 ? 1 : 0;\n                }\n                break;\n\n            case \"bytes\":\n                if ((\"bytes\" in a) && (\"bytes\" in b)) {\n                    const aa = parseBytes(a.bytes);\n                    const bb = parseBytes(b.bytes);\n                    if (aa !== null && bb !== null) {\n                        return compareBytes(aa, bb);\n                    }\n                }\n                break;\n\n            case \"bool\":\n                if ((\"prim\" in a) && (\"prim\" in b) && (a.prim === \"True\" || a.prim === \"False\") && (b.prim === \"True\" || b.prim === \"False\")) {\n                    return a.prim === b.prim ? 0 : a.prim === \"False\" ? -1 : 1;\n                }\n                break;\n\n            case \"key\":\n            case \"key_hash\":\n            case \"address\":\n            case \"signature\":\n            case \"chain_id\":\n                if ((\"string\" in a || \"bytes\" in a) && (\"string\" in b || \"bytes\" in b)) {\n                    return compareBytes(\"string\" in a ? decodeBase58Check(a.string) : parseBytes(a.bytes) || [], \"string\" in b ? decodeBase58Check(b.string) : parseBytes(b.bytes) || []);\n                }\n                break;\n\n            case \"timestamp\":\n                if (((\"string\" in a) || (\"int\" in a)) && ((\"string\" in b) || (\"int\" in b))) {\n                    const aa = parseDate(a);\n                    const bb = parseDate(b);\n                    if (aa !== null && bb !== null) {\n                        const x = aa.valueOf() - bb.valueOf();\n                        return x < 0 ? -1 : x > 0 ? 1 : 0;\n                    }\n                }\n                break;\n\n            case \"unit\":\n                if ((\"prim\" in a) && (\"prim\" in b) && a.prim === \"Unit\" && b.prim === \"Unit\") {\n                    return 0;\n                }\n        }\n    }\n\n    // Unlikely, types are expected to be verified before the function call\n    throw new MichelsonTypeError(t, undefined, `${typeID(t)}: not comparable values: ${JSON.stringify(a)}, ${JSON.stringify(b)}`);\n}\n\n// Simplified version of assertMichelsonInstruction() for previously validated data\nfunction isFunction(d: MichelsonData): d is InstructionList {\n    if (!Array.isArray(d)) {\n        return false;\n    }\n    for (const v of d) {\n        if (!(Array.isArray(v) && isFunction(v) ||\n            (\"prim\" in v) && isInstruction(v))) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction assertDataValidInternal(d: MichelsonData, t: MichelsonType, ctx: Context | null): void {\n    if (isPairType(t)) {\n        if (isPairData(d)) {\n            assertDataListIfAny(d);\n            const dc = unpackComb(\"Pair\", d);\n            const tc = unpackComb(\"pair\", t);\n            assertDataValidInternal(dc.args[0], tc.args[0], ctx);\n            assertDataValidInternal(dc.args[1], tc.args[1], ctx);\n            return;\n        }\n        throw new MichelsonTypeError(t, d, `pair expected: ${JSON.stringify(d)}`);\n    }\n\n    switch (t.prim) {\n        // Atomic literals\n        case \"int\":\n            if ((\"int\" in d) && isDecimal(d.int)) {\n                return;\n            }\n            throw new MichelsonTypeError(t, d, `integer value expected: ${JSON.stringify(d)}`);\n\n        case \"nat\":\n        case \"mutez\":\n            if ((\"int\" in d) && isNatural(d.int)) {\n                return;\n            }\n            throw new MichelsonTypeError(t, d, `natural value expected: ${JSON.stringify(d)}`);\n\n        case \"string\":\n            if (\"string\" in d) {\n                return;\n            }\n            throw new MichelsonTypeError(t, d, `string value expected: ${JSON.stringify(d)}`);\n\n        case \"bytes\":\n        case \"bls12_381_g1\":\n        case \"bls12_381_g2\":\n            if (\"bytes\" in d && parseBytes(d.bytes) !== null) {\n                return;\n            }\n            throw new MichelsonTypeError(t, d, `bytes value expected: ${JSON.stringify(d)}`);\n\n        case \"bool\":\n            if ((\"prim\" in d) && (d.prim === \"True\" || d.prim === \"False\")) {\n                return;\n            }\n            throw new MichelsonTypeError(t, d, `boolean value expected: ${JSON.stringify(d)}`);\n\n        case \"key_hash\":\n            if ((\"string\" in d) &&\n                checkDecodeTezosID(d.string,\n                    \"ED25519PublicKeyHash\",\n                    \"SECP256K1PublicKeyHash\",\n                    \"P256PublicKeyHash\") !== null) {\n                return;\n            } else if (\"bytes\" in d) {\n                try {\n                    decodePublicKeyHashBytes(d);\n                    return;\n                } catch (err) {\n                    // ignore message\n                }\n            }\n            throw new MichelsonTypeError(t, d, `key hash expected: ${JSON.stringify(d)}`);\n\n        case \"timestamp\":\n            if (((\"string\" in d) || (\"int\" in d)) && parseDate(d) !== null) {\n                return;\n            }\n            throw new MichelsonTypeError(t, d, `timestamp expected: ${JSON.stringify(d)}`);\n\n        case \"address\":\n            if (\"string\" in d) {\n                let address = d.string;\n                const ep = d.string.indexOf(\"%\");\n                if (ep >= 0) {\n                    // trim entry point\n                    address = d.string.slice(0, ep);\n                }\n                if (checkDecodeTezosID(address,\n                    \"ED25519PublicKeyHash\",\n                    \"SECP256K1PublicKeyHash\",\n                    \"P256PublicKeyHash\",\n                    \"ContractHash\") !== null) {\n                    return;\n                }\n            } else if (\"bytes\" in d) {\n                try {\n                    decodeAddressBytes(d);\n                    return;\n                } catch (err) {\n                    // ignore message\n                }\n            }\n            throw new MichelsonTypeError(t, d, `address expected: ${JSON.stringify(d)}`);\n\n        case \"key\":\n            if ((\"string\" in d) &&\n                checkDecodeTezosID(d.string,\n                    \"ED25519PublicKey\",\n                    \"SECP256K1PublicKey\",\n                    \"P256PublicKey\") !== null) {\n                return;\n            } else if (\"bytes\" in d) {\n                try {\n                    decodePublicKeyBytes(d);\n                    return;\n                } catch (err) {\n                    // ignore message\n                }\n            }\n            throw new MichelsonTypeError(t, d, `public key expected: ${JSON.stringify(d)}`);\n\n        case \"unit\":\n            if ((\"prim\" in d) && d.prim === \"Unit\") {\n                return;\n            }\n            throw new MichelsonTypeError(t, d, `unit value expected: ${JSON.stringify(d)}`);\n\n        case \"signature\":\n            if ((\"bytes\" in d) || (\"string\" in d) &&\n                checkDecodeTezosID(d.string,\n                    \"ED25519Signature\",\n                    \"SECP256K1Signature\",\n                    \"P256Signature\",\n                    \"GenericSignature\") !== null) {\n                return;\n            }\n            throw new MichelsonTypeError(t, d, `signature expected: ${JSON.stringify(d)}`);\n\n        case \"chain_id\":\n            if (\"bytes\" in d || \"string\" in d) {\n                const x = \"string\" in d ? decodeBase58Check(d.string) : parseBytes(d.bytes);\n                if (x !== null) {\n                    return;\n                }\n            }\n            throw new MichelsonTypeError(t, d, `chain id expected: ${JSON.stringify(d)}`);\n\n        case \"operation\":\n            throw new MichelsonTypeError(t, d, \"operation type can't be represented as a literal value\");\n\n        case \"contract\":\n            throw new MichelsonTypeError(t, d, \"contract type can't be represented as a literal value\");\n\n        // Complex types\n        case \"option\":\n            if (\"prim\" in d) {\n                if (d.prim === \"None\") {\n                    return;\n                } else if (d.prim === \"Some\") {\n                    assertDataValidInternal(d.args[0], t.args[0], ctx);\n                    return;\n                }\n            }\n            throw new MichelsonTypeError(t, d, `option expected: ${JSON.stringify(d)}`);\n\n        case \"list\":\n        case \"set\":\n            if (assertDataListIfAny(d)) {\n                let prev: MichelsonData | undefined;\n                for (const v of d) {\n                    assertDataValidInternal(v, t.args[0], ctx);\n                    if (t.prim === \"set\") {\n                        if (prev === undefined) {\n                            prev = v;\n                        } else if (compareMichelsonData(t.args[0], prev, v) > 0) {\n                            throw new MichelsonTypeError(t, d, `set elements must be ordered: ${JSON.stringify(d)}`);\n                        }\n                    }\n                }\n                return;\n            }\n            throw new MichelsonTypeError(t, d, `${t.prim} expected: ${JSON.stringify(d)}`);\n\n        case \"or\":\n            if (\"prim\" in d) {\n                if (d.prim === \"Left\") {\n                    assertDataValidInternal(d.args[0], t.args[0], ctx);\n                    return;\n                } else if (d.prim === \"Right\") {\n                    assertDataValidInternal(d.args[0], t.args[1], ctx);\n                    return;\n                }\n            }\n            throw new MichelsonTypeError(t, d, `union (or) expected: ${JSON.stringify(d)}`);\n\n        case \"lambda\":\n            if (isFunction(d)) {\n                const ret = functionTypeInternal(d, [t.args[0]], ctx);\n                if (\"failed\" in ret) {\n                    throw new MichelsonTypeError(t, d, `function is failed with error type: ${ret.failed}`);\n                }\n                if (ret.length !== 1) {\n                    throw new MichelsonTypeError(t, d, `function must return a value`);\n                }\n                assertScalarTypesEqual(t.args[1], ret[0]);\n                return;\n            }\n            throw new MichelsonTypeError(t, d, `function expected: ${JSON.stringify(d)}`);\n\n        case \"map\":\n        case \"big_map\":\n            if (Array.isArray(d)) {\n                let prev: MichelsonMapElt | undefined;\n                for (const v of d) {\n                    if (!(\"prim\" in v) || v.prim !== \"Elt\") {\n                        throw new MichelsonTypeError(t, d, `map elements expected: ${JSON.stringify(d)}`);\n                    }\n                    assertDataValidInternal(v.args[0], t.args[0], ctx);\n                    assertDataValidInternal(v.args[1], t.args[1], ctx);\n                    if (prev === undefined) {\n                        prev = v;\n                    } else if (compareMichelsonData(t.args[0], prev.args[0], v.args[0]) > 0) {\n                        throw new MichelsonTypeError(t, d, `map elements must be ordered: ${JSON.stringify(d)}`);\n                    }\n                }\n                return;\n            }\n            throw new MichelsonTypeError(t, d, `${t.prim} expected: ${JSON.stringify(d)}`);\n\n        case \"bls12_381_fr\":\n            if (\"int\" in d && isDecimal(d.int) || \"bytes\" in d && parseBytes(d.bytes) !== null) {\n                return;\n            }\n            throw new MichelsonTypeError(t, d, `BLS12-381 element expected: ${JSON.stringify(d)}`);\n\n        case \"sapling_state\":\n            if (Array.isArray(d)) {\n                return;\n            }\n            throw new MichelsonTypeError(t, d, `sapling state expected: ${JSON.stringify(d)}`);\n\n        case \"ticket\":\n            assertDataValidInternal(d, {\n                prim: \"pair\", args: [\n                    { prim: \"address\" },\n                    t.args[0],\n                    { prim: \"nat\" },\n                ]\n            }, ctx);\n            return;\n\n        default:\n            throw new MichelsonTypeError(t, d, `unexpected type: ${typeID(t)}`);\n    }\n}\n\n// Code validation\n\ntype StackType<T extends (MichelsonTypeID[] | null)[]> = {\n    [N in keyof T]: T[N] extends MichelsonTypeID[] ? MichelsonType<T[N][number]> : MichelsonType;\n};\n\nexport interface InstructionTrace {\n    op: MichelsonCode;\n    in: MichelsonType[];\n    out: MichelsonReturnType;\n}\n\nfunction instructionListType(inst: InstructionList, stack: MichelsonType[], ctx: Context | null): MichelsonReturnType {\n    let ret: MichelsonReturnType = stack;\n    let s = stack;\n    let i = 0;\n    for (const op of inst) {\n        const ft = functionTypeInternal(op, s, ctx);\n        ret = ft;\n        if (\"failed\" in ft) {\n            break;\n        }\n        s = ft;\n        i++;\n    }\n\n    if ((\"failed\" in ret) && i !== inst.length - 1) {\n        throw new MichelsonInstructionError(inst, ret, \"FAIL must appear in a tail position\");\n    }\n\n    if (ctx?.traceCallback !== undefined) {\n        const trace: InstructionTrace = {\n            op: inst,\n            in: stack,\n            out: ret,\n        };\n        ctx.traceCallback(trace);\n    }\n    return ret;\n}\n\nfunction functionTypeInternal(inst: MichelsonCode, stack: MichelsonType[], ctx: Context | null): MichelsonReturnType {\n    const proto = ctx?.protocol || DefaultProtocol;\n\n    if (Array.isArray(inst)) {\n        return instructionListType(inst, stack, ctx);\n    }\n    const instruction = inst; // Make it const for type guarding\n\n    // make sure the stack has enough number of arguments of specific types\n    function args<T extends (MichelsonTypeID[] | null)[]>(n: number, ...typeIds: T): StackType<T> {\n        if (stack.length < typeIds.length + n) {\n            throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: stack must have at least ${typeIds.length} element(s)`);\n        }\n\n        let i = n;\n        for (const ids of typeIds) {\n            if (ids !== null && ids.length !== 0) {\n                let ii = 0;\n                while (ii < ids.length && ids[ii] !== typeID(stack[i])) {\n                    ii++;\n                }\n                if (ii === ids.length) {\n                    throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: stack type mismatch: [${i}] expected to be ${ids}, got ${typeID(stack[i])} instead`);\n                }\n            }\n            i++;\n        }\n        return stack.slice(n, typeIds.length + n) as StackType<T>;\n    }\n\n    function rethrow<T extends unknown[], U>(fn: (...args: T) => U) {\n        return (...args: T): U => {\n            try {\n                return fn(...args);\n            } catch (err) {\n                if (err instanceof MichelsonError) {\n                    throw new MichelsonInstructionError(instruction, stack, err.message);\n                } else {\n                    throw err;\n                }\n            }\n        };\n    }\n\n    function rethrowTypeGuard<T extends Expr, U extends MichelsonType & T>(fn: (arg: T) => arg is U) {\n        return (arg: T): arg is U => {\n            try {\n                return fn(arg);\n            } catch (err) {\n                if (err instanceof MichelsonError) {\n                    throw new MichelsonInstructionError(instruction, stack, err.message);\n                } else {\n                    throw err;\n                }\n            }\n        };\n    }\n\n    const argAnn = rethrow(unpackAnnotations);\n    const ensureStacksEqual = rethrow(assertStacksEqual);\n    const ensureTypesEqual = rethrow(assertScalarTypesEqual);\n    const ensureComparableType = rethrowTypeGuard(assertMichelsonComparableType);\n    const ensurePackableType = rethrowTypeGuard(assertMichelsonPackableType);\n    const ensureStorableType = rethrowTypeGuard(assertMichelsonStorableType);\n    const ensurePushableType = rethrowTypeGuard(assertMichelsonPushableType);\n    const ensureBigMapStorableType = rethrowTypeGuard(assertMichelsonBigMapStorableType);\n\n    // unpack instruction annotations and assert their maximum number\n    function instructionAnn(num: { f?: number; t?: number; v?: number }, opt?: UnpackAnnotationsOptions) {\n        const a = argAnn(instruction, {\n            ...opt,\n            emptyFields: num.f !== undefined && num.f > 1,\n            emptyVar: num.v !== undefined && num.v > 1,\n        });\n        const assertNum = (a: string[] | undefined, n: number | undefined, type: string) => {\n            if (a && a.length > (n || 0)) {\n                throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at most ${n || 0} ${type} annotations allowed`);\n            }\n        };\n        assertNum(a.f, num.f, \"field\");\n        assertNum(a.t, num.t, \"type\");\n        assertNum(a.v, num.v, \"variable\");\n        return a;\n    }\n\n    // also keeps annotation class if null is provided\n    function annotate<T extends MichelsonType>(tt: T, a: Nullable<UnpackedAnnotations>): T {\n        const tx: MichelsonType = tt;\n        const t: Extract<MichelsonType, Prim> = Array.isArray(tx) ? { prim: \"pair\", args: tx } : tx;\n        const src = argAnn(t);\n        const ann = (a.v !== undefined || a.t !== undefined || a.f !== undefined) ?\n            [\n                ...((a.v === null ? src.v : a.v) || []),\n                ...((a.t === null ? src.t : a.t) || []),\n                ...((a.f === null ? src.f : a.f) || [])\n            ] : undefined;\n\n        const { annots, ...rest } = t;\n        return { ...(rest as T), ...(ann && ann.length !== 0 && { annots: ann }) };\n    }\n\n    // shortcut to copy at most one variable annotation from the instruction to the type\n    function annotateVar<T extends MichelsonType>(t: T, def?: string) {\n        const ia = instructionAnn({ v: 1 });\n        return annotate(t, { v: ia.v !== undefined ? ia.v : def !== undefined ? [def] : null, t: null });\n    }\n\n    // annotate CAR/CDR/UNPAIR/GET\n    function annotateField(arg: MichelsonTypePair<MichelsonType[]>, field: MichelsonType, insAnn: UnpackedAnnotations, n: number, defField: string): MichelsonType {\n        const fieldAnn = argAnn(field).f?.[0]; // field's field annotation\n        const insFieldAnn = insAnn.f?.[n];\n        if (insFieldAnn !== undefined && insFieldAnn !== \"%\" && fieldAnn !== undefined && insFieldAnn !== fieldAnn) {\n            throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: field names doesn't match: ${insFieldAnn} !== ${fieldAnn}`);\n        }\n        const insVarAnn = insAnn.v?.[n]; // nth instruction's variable annotation\n        const varAnn = argAnn(arg).v?.[0]; // instruction argument's variable annotation\n        return annotate(field, {\n            t: null,\n            v: insVarAnn ?\n                insVarAnn === \"@%\" ?\n                    fieldAnn ? [\"@\" + fieldAnn.slice(1)] : undefined :\n                    insVarAnn === \"@%%\" ?\n                        varAnn ?\n                            [\"@\" + varAnn.slice(1) + \".\" + (fieldAnn ? fieldAnn.slice(1) : defField)] :\n                            fieldAnn ? [\"@\" + fieldAnn.slice(1)] : undefined :\n                        [insVarAnn] :\n                null,\n        });\n    }\n\n    // comb helper functions\n    function getN(src: MichelsonTypePair<MichelsonType[]>, n: number, i: number = n): MichelsonType[] {\n        const p = unpackComb(\"pair\", src);\n        if (i === 1) {\n            return [p.args[0]];\n        } else if (i === 2) {\n            return p.args;\n        }\n        const right = p.args[1];\n        if (isPairType(right)) {\n            return [p.args[0], ...getN(right, n, i - 1)];\n        } else {\n            throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at least ${n} fields are expected`);\n        }\n    }\n\n    function getNth(src: MichelsonTypePair<MichelsonType[]>, n: number, i: number = n): MichelsonType {\n        if (i === 0) {\n            return src;\n        }\n        const p = unpackComb(\"pair\", src);\n        if (i === 1) {\n            return p.args[0];\n        }\n        const right = p.args[1];\n        if (isPairType(right)) {\n            return getNth(right, n, i - 2);\n        } else if (i === 2) {\n            return right;\n        }\n        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at least ${n + 1} fields are expected`);\n    }\n\n    function updateNth(src: MichelsonTypePair<MichelsonType[]>, x: MichelsonType, n: number, i: number = n): MichelsonType {\n        if (i === 0) {\n            return x;\n        }\n        const p = unpackComb(\"pair\", src);\n        if (i === 1) {\n            return {\n                ...p,\n                args: [x, p.args[1]],\n            };\n        }\n        const right = p.args[1];\n        if (isPairType(right)) {\n            return {\n                ...p,\n                args: [p.args[0], updateNth(right, x, n, i - 2)],\n            };\n        } else if (i === 2) {\n            return {\n                ...p,\n                args: [p.args[0], x],\n            };\n        }\n        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at least ${n + 1} fields are expected`);\n    }\n\n    const varSuffix = (a: UnpackedAnnotations, suffix: string) => [\"@\" + (a.v ? a.v[0].slice(1) + \".\" : \"\") + suffix];\n\n    function branchType(br0: MichelsonReturnType, br1: MichelsonReturnType): MichelsonReturnType {\n        if ((\"failed\" in br0) || (\"failed\" in br1)) {\n            // Might be useful for debugging\n            if ((\"failed\" in br0) && (\"failed\" in br1)) {\n                try {\n                    assertScalarTypesEqual(br0.failed, br1.failed);\n                    return br0;\n                } catch {\n                    return { failed: { prim: \"or\", args: [br0.failed, br1.failed] } };\n                }\n            } else {\n                return (\"failed\" in br0) ? br1 : br0;\n            }\n        } else {\n            ensureStacksEqual(br0, br1);\n            return br0;\n        }\n    }\n\n    const retStack = ((instruction: MichelsonInstruction): MichelsonReturnType => {\n        switch (instruction.prim) {\n            case \"DUP\":\n                {\n                    const n = instruction.args ? parseInt(instruction.args[0].int, 10) : 1;\n                    if (n === 0) {\n                        throw new MichelsonInstructionError(instruction, stack, \"DUP 0 is forbidden\");\n                    }\n                    const s = args(n - 1, null)[0];\n                    if (typeID(s) === \"ticket\") {\n                        throw new MichelsonInstructionError(instruction, stack, \"ticket can't be DUPed\");\n                    }\n                    return [s, ...stack];\n                }\n\n            case \"SWAP\":\n                {\n                    const s = args(0, null, null);\n                    instructionAnn({});\n                    return [s[1], s[0], ...stack.slice(2)];\n                }\n\n            case \"SOME\":\n                return [annotate({ prim: \"option\", args: [args(0, null)[0]] }, instructionAnn({ t: 1, v: 1 })), ...stack.slice(1)];\n\n            case \"UNIT\":\n                return [annotate({ prim: \"unit\" }, instructionAnn({ v: 1, t: 1 })), ...stack];\n\n            case \"PAIR\":\n                {\n                    const n = instruction.args ? parseInt(instruction.args[0].int, 10) : 2;\n                    if (n < 2) {\n                        throw new MichelsonInstructionError(instruction, stack, `PAIR ${n} is forbidden`);\n                    }\n                    const s = args(0, ...new Array<null>(n).fill(null));\n                    const ia = instructionAnn({ f: n, t: 1, v: 1 }, { specialFields: true });\n                    const trim = (s: string) => {\n                        const i = s.lastIndexOf(\".\");\n                        return s.slice(i > 0 ? i + 1 : 1);\n                    };\n                    const retArgs = s.map((v, i) => {\n                        const va = argAnn(v);\n                        const f = ia.f && ia.f.length > i && ia.f[i] !== \"%\" ?\n                            ia.f[i] === \"%@\" ?\n                                va.v ? [\"%\" + trim(va.v?.[0] || \"\")] : undefined :\n                                [ia.f[i]] :\n                            undefined;\n                        return annotate(v, { v: null, t: null, f });\n                    });\n                    return [\n                        annotate({\n                            prim: \"pair\",\n                            args: retArgs,\n                        }, { t: ia.t, v: ia.v }),\n                        ...stack.slice(n)\n                    ];\n                }\n\n            case \"UNPAIR\":\n                {\n                    const n = instruction.args ? parseInt(instruction.args[0].int, 10) : 2;\n                    if (n < 2) {\n                        throw new MichelsonInstructionError(instruction, stack, `UNPAIR ${n} is forbidden`);\n                    }\n                    const s = args(0, [\"pair\"])[0];\n                    const ia = instructionAnn({ f: 2, v: 2 }, { specialVar: true });\n                    const fields = getN(s, n);\n                    return [...fields.map((field, i) => annotateField(s, field, ia, i, i === 0 ? \"car\" : \"cdr\")), ...stack.slice(1)];\n                }\n\n            case \"CAR\":\n            case \"CDR\":\n                {\n                    const s = unpackComb(\"pair\", args(0, [\"pair\"])[0]);\n                    const field = s.args[instruction.prim === \"CAR\" ? 0 : 1];\n                    const ia = instructionAnn({ f: 1, v: 1 }, { specialVar: true });\n                    return [annotateField(s, field, ia, 0, instruction.prim.toLocaleLowerCase()), ...stack.slice(1)];\n                }\n\n            case \"CONS\":\n                {\n                    const s = args(0, null, [\"list\"]);\n                    ensureTypesEqual(s[0], s[1].args[0]);\n                    return [annotateVar({ prim: \"list\", args: [s[1].args[0]] }), ...stack.slice(2)];\n                }\n\n            case \"SIZE\":\n                args(0, [\"string\", \"list\", \"set\", \"map\", \"bytes\"]);\n                return [annotateVar({ prim: \"nat\" }), ...stack.slice(1)];\n\n            case \"MEM\":\n                {\n                    const s = args(0, null, [\"set\", \"map\", \"big_map\"]);\n                    ensureComparableType(s[0]);\n                    ensureTypesEqual(s[0], s[1].args[0]);\n                    return [annotateVar({ prim: \"bool\" }), ...stack.slice(2)];\n                }\n\n            case \"GET\":\n                if (instruction.args) {\n                    // comb operation\n                    const n = parseInt(instruction.args[0].int, 10);\n                    const s = args(0, [\"pair\"])[0];\n                    return [annotateVar(getNth(s, n)), ...stack.slice(1)];\n                } else {\n                    // map operation\n                    const s = args(0, null, [\"map\", \"big_map\"]);\n                    ensureComparableType(s[0]);\n                    ensureTypesEqual(s[0], s[1].args[0]);\n                    return [annotateVar({ prim: \"option\", args: [s[1].args[1]] }), ...stack.slice(2)];\n                }\n\n            case \"UPDATE\":\n                if (instruction.args) {\n                    // comb operation\n                    const n = parseInt(instruction.args[0].int, 10);\n                    const s = args(0, null, [\"pair\"]);\n                    return [annotateVar(updateNth(s[1], s[0], n)), ...stack.slice(2)];\n\n                } else {\n                    // map operation\n                    const s0 = args(0, null, [\"bool\", \"option\"]);\n                    ensureComparableType(s0[0]);\n                    if (s0[1].prim === \"bool\") {\n                        const s1 = args(2, [\"set\"]);\n                        ensureTypesEqual(s0[0], s1[0].args[0]);\n                        return [annotateVar({\n                            prim: \"set\",\n                            args: [annotate(s0[0], { t: null })],\n                        }), ...stack.slice(3)];\n                    }\n\n                    const s1 = args(2, [\"map\", \"big_map\"]);\n                    ensureTypesEqual(s0[0], s1[0].args[0]);\n                    if (s1[0].prim === \"map\") {\n                        return [annotateVar({\n                            prim: \"map\",\n                            args: [\n                                annotate(s0[0], { t: null }),\n                                annotate(s0[1].args[0], { t: null }),\n                            ],\n                        }), ...stack.slice(3)];\n                    }\n                    ensureBigMapStorableType(s0[1].args[0]);\n                    return [annotateVar({\n                        prim: \"big_map\",\n                        args: [\n                            annotate(s0[0], { t: null }),\n                            annotate(s0[1].args[0], { t: null }),\n                        ],\n                    }), ...stack.slice(3)];\n                }\n\n            case \"GET_AND_UPDATE\":\n                {\n                    const ia = instructionAnn({ v: 2 });\n                    const s = args(0, null, [\"option\"], [\"map\", \"big_map\"]);\n                    ensureComparableType(s[0]);\n                    ensureTypesEqual(s[0], s[2].args[0]);\n                    ensureTypesEqual(s[1].args[0], s[2].args[1]);\n                    const va = ia.v?.map(v => v !== \"@\" ? [v] : undefined);\n                    if (s[2].prim === \"map\") {\n                        return [\n                            annotate({ prim: \"option\", args: [s[2].args[1]] }, { v: va?.[0] }),\n                            annotate({\n                                prim: \"map\",\n                                args: [\n                                    annotate(s[0], { t: null }),\n                                    annotate(s[1].args[0], { t: null }),\n                                ],\n                            }, { v: va?.[1] }),\n                            ...stack.slice(3),\n                        ];\n                    }\n                    ensureBigMapStorableType(s[1].args[0]);\n                    return [\n                        annotate({ prim: \"option\", args: [s[2].args[1]] }, { v: va?.[0] }),\n                        annotate({\n                            prim: \"big_map\",\n                            args: [\n                                annotate(s[0], { t: null }),\n                                annotate(s[1].args[0], { t: null }),\n                            ],\n                        }, { v: va?.[1] }),\n                        ...stack.slice(3),\n                    ];\n                }\n\n            case \"EXEC\":\n                {\n                    const s = args(0, null, [\"lambda\"]);\n                    ensureTypesEqual(s[0], s[1].args[0]);\n                    return [annotateVar(s[1].args[1]), ...stack.slice(2)];\n                }\n\n            case \"APPLY\":\n                {\n                    const s = args(0, null, [\"lambda\"]);\n                    ensureStorableType(s[0]);\n                    ensurePushableType(s[0]);\n                    if (!isPairType(s[1].args[0])) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: function's argument must be a pair: ${typeID(s[1].args[0])}`);\n                    }\n                    const pt = s[1].args[0];\n                    ensureTypesEqual(s[0], typeArgs(pt)[0]);\n                    return [annotateVar({ prim: \"lambda\", args: [typeArgs(pt)[1], s[1].args[1]] }), ...stack.slice(2)];\n                }\n\n            case \"FAILWITH\":\n                {\n                    const s = args(0, null)[0];\n                    if (proto === Protocol.PtEdo2Zk || proto === Protocol.PsFLorena || proto === Protocol.PtGRANADs) {\n                        ensurePackableType(s);\n                    }\n                    return { failed: s };\n                }\n\n            case \"NEVER\":\n                args(0, [\"never\"]);\n                return { failed: { prim: \"never\" } };\n\n\n            case \"RENAME\":\n                return [annotateVar(args(0, null)[0]), ...stack.slice(1)];\n\n            case \"CONCAT\":\n                {\n                    const s0 = args(0, [\"string\", \"list\", \"bytes\"]);\n                    if (s0[0].prim === \"list\") {\n                        if (typeID(s0[0].args[0]) !== \"string\" && typeID(s0[0].args[0]) !== \"bytes\") {\n                            throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: can't concatenate list of ${typeID(s0[0].args[0])}'s`);\n                        }\n                        return [annotateVar(s0[0].args[0]), ...stack.slice(1)];\n                    }\n                    const s1 = args(1, [\"string\", \"bytes\"]);\n                    if (s0[0].prim !== s1[0].prim) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: can't concatenate ${s0[0].prim} with ${s1[0].prim}`);\n                    }\n                    return [annotateVar(s1[0]), ...stack.slice(2)];\n                }\n\n            case \"SLICE\":\n                return [annotateVar({ prim: \"option\", args: [args(0, [\"nat\"], [\"nat\"], [\"string\", \"bytes\"])[2]] }, \"@slice\"), ...stack.slice(3)];\n\n            case \"PACK\":\n                {\n                    const s = args(0, null)[0];\n                    ensurePackableType(s);\n                    return [annotateVar({ prim: \"bytes\" }, \"@packed\"), ...stack.slice(1)];\n                }\n\n            case \"ADD\":\n                {\n                    const s = args(0,\n                        [\"nat\", \"int\", \"timestamp\", \"mutez\", \"bls12_381_g1\", \"bls12_381_g2\", \"bls12_381_fr\"],\n                        [\"nat\", \"int\", \"timestamp\", \"mutez\", \"bls12_381_g1\", \"bls12_381_g2\", \"bls12_381_fr\"]\n                    );\n                    if (s[0].prim === \"nat\" && s[1].prim === \"int\" || s[0].prim === \"int\" && s[1].prim === \"nat\") {\n                        return [annotateVar({ prim: \"int\" }), ...stack.slice(2)];\n                    } else if (s[0].prim === \"int\" && s[1].prim === \"timestamp\" || s[0].prim === \"timestamp\" && s[1].prim === \"int\") {\n                        return [annotateVar({ prim: \"timestamp\" }), ...stack.slice(2)];\n                    } else if ((s[0].prim === \"int\" || s[0].prim === \"nat\" || s[0].prim === \"mutez\" || s[0].prim === \"bls12_381_g1\" || s[0].prim === \"bls12_381_g2\" || s[0].prim === \"bls12_381_fr\") && s[0].prim === s[1].prim) {\n                        return [annotateVar(s[0]), ...stack.slice(2)];\n                    }\n                    throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: can't add ${s[0].prim} to ${s[1].prim}`);\n                }\n\n            case \"SUB\":\n                {\n                    const s = args(0, [\"nat\", \"int\", \"timestamp\", \"mutez\"], [\"nat\", \"int\", \"timestamp\", \"mutez\"]);\n                    if (((s[0].prim === \"nat\" || s[0].prim === \"int\") && (s[1].prim === \"nat\" || s[1].prim === \"int\")) ||\n                        s[0].prim === \"timestamp\" && s[1].prim === \"timestamp\") {\n                        return [annotateVar({ prim: \"int\" }), ...stack.slice(2)];\n                    } else if (s[0].prim === \"timestamp\" && s[1].prim === \"int\") {\n                        return [annotateVar({ prim: \"timestamp\" }), ...stack.slice(2)];\n                    } else if (s[0].prim === \"mutez\" && s[1].prim === \"mutez\") {\n                        return [annotateVar({ prim: \"mutez\" }), ...stack.slice(2)];\n                    }\n                    throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: can't subtract ${s[0].prim} from ${s[1].prim}`);\n                }\n\n            case \"MUL\":\n                {\n                    const s = args(0,\n                        [\"nat\", \"int\", \"mutez\", \"bls12_381_g1\", \"bls12_381_g2\", \"bls12_381_fr\"],\n                        [\"nat\", \"int\", \"mutez\", \"bls12_381_g1\", \"bls12_381_g2\", \"bls12_381_fr\"]\n                    );\n                    if (s[0].prim === \"nat\" && s[1].prim === \"int\" || s[0].prim === \"int\" && s[1].prim === \"nat\") {\n                        return [annotateVar({ prim: \"int\" }), ...stack.slice(2)];\n                    } else if (s[0].prim === \"nat\" && s[1].prim === \"mutez\" || s[0].prim === \"mutez\" && s[1].prim === \"nat\") {\n                        return [annotateVar({ prim: \"mutez\" }), ...stack.slice(2)];\n                    } else if ((s[0].prim === \"bls12_381_g1\" || s[0].prim === \"bls12_381_g2\" || s[0].prim === \"bls12_381_fr\") && s[1].prim === \"bls12_381_fr\" ||\n                        (s[0].prim === \"nat\" || s[0].prim === \"int\") && s[0].prim === s[1].prim) {\n                        return [annotateVar(s[0]), ...stack.slice(2)];\n                    } else if ((s[0].prim === \"nat\" || s[0].prim === \"int\") && s[1].prim === \"bls12_381_fr\" ||\n                        (s[1].prim === \"nat\" || s[1].prim === \"int\") && s[0].prim === \"bls12_381_fr\") {\n                        return [annotateVar({ prim: \"bls12_381_fr\" }), ...stack.slice(2)];\n                    }\n                    throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: can't multiply ${s[0].prim} by ${s[1].prim}`);\n                }\n\n            case \"EDIV\":\n                {\n                    const res = (a: \"nat\" | \"int\" | \"mutez\", b: \"nat\" | \"int\" | \"mutez\"): MichelsonTypeOption<MichelsonType> => ({ prim: \"option\", args: [{ prim: \"pair\", args: [{ prim: a }, { prim: b }] }] });\n                    const s = args(0, [\"nat\", \"int\", \"mutez\"], [\"nat\", \"int\", \"mutez\"]);\n                    if (s[0].prim === \"nat\" && s[1].prim === \"nat\") {\n                        return [annotateVar(res(\"nat\", \"nat\")), ...stack.slice(2)];\n                    } else if ((s[0].prim === \"nat\" || s[0].prim === \"int\") && (s[1].prim === \"nat\" || s[1].prim === \"int\")) {\n                        return [annotateVar(res(\"int\", \"nat\")), ...stack.slice(2)];\n                    } else if (s[0].prim === \"mutez\" && s[1].prim === \"nat\") {\n                        return [annotateVar(res(\"mutez\", \"mutez\")), ...stack.slice(2)];\n                    } else if (s[0].prim === \"mutez\" && s[1].prim === \"mutez\") {\n                        return [annotateVar(res(\"nat\", \"mutez\")), ...stack.slice(2)];\n                    }\n                    throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: can't euclideally divide ${s[0].prim} by ${s[1].prim}`);\n                }\n\n            case \"ABS\":\n                args(0, [\"int\"]);\n                return [annotateVar({ prim: \"nat\" }), ...stack.slice(1)];\n\n            case \"ISNAT\":\n                args(0, [\"int\"]);\n                return [annotateVar({ prim: \"option\", args: [{ prim: \"nat\" }] }), ...stack.slice(1)];\n\n            case \"INT\":\n                args(0, [\"nat\", \"bls12_381_fr\"]);\n                return [annotateVar({ prim: \"int\" }), ...stack.slice(1)];\n\n            case \"NEG\":\n                {\n                    const s = args(0, [\"nat\", \"int\", \"bls12_381_g1\", \"bls12_381_g2\", \"bls12_381_fr\"])[0];\n                    if (s.prim === \"nat\" || s.prim === \"int\") {\n                        return [annotateVar({ prim: \"int\" }), ...stack.slice(1)];\n                    }\n                    return [annotateVar(s), ...stack.slice(1)];\n                }\n\n            case \"LSL\":\n            case \"LSR\":\n                args(0, [\"nat\"], [\"nat\"]);\n                return [annotateVar({ prim: \"nat\" }), ...stack.slice(2)];\n\n            case \"OR\":\n            case \"XOR\":\n                {\n                    const s = args(0, [\"nat\", \"bool\"], [\"nat\", \"bool\"]);\n                    if (s[0].prim !== s[1].prim) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: both arguments must be of the same type: ${s[0].prim}, ${s[1].prim}`);\n                    }\n                    return [annotateVar(s[1]), ...stack.slice(2)];\n                }\n\n            case \"AND\":\n                {\n                    const s = args(0, [\"nat\", \"bool\", \"int\"], [\"nat\", \"bool\"]);\n                    if ((s[0].prim !== \"int\" || s[1].prim !== \"nat\") && s[0].prim !== s[1].prim) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: both arguments must be of the same type: ${s[0].prim}, ${s[1].prim}`);\n                    }\n                    return [annotateVar(s[1]), ...stack.slice(2)];\n                }\n\n            case \"NOT\":\n                {\n                    const s = args(0, [\"nat\", \"bool\", \"int\"])[0];\n                    if (s.prim === \"bool\") {\n                        return [annotateVar({ prim: \"bool\" }), ...stack.slice(1)];\n                    }\n                    return [annotateVar({ prim: \"int\" }), ...stack.slice(1)];\n                }\n\n            case \"COMPARE\":\n                {\n                    const s = args(0, null, null);\n                    ensureComparableType(s[0]);\n                    ensureComparableType(s[1]);\n                    return [annotateVar({ prim: \"int\" }), ...stack.slice(2)];\n                }\n\n            case \"EQ\":\n            case \"NEQ\":\n            case \"LT\":\n            case \"GT\":\n            case \"LE\":\n            case \"GE\":\n                args(0, [\"int\"]);\n                return [annotateVar({ prim: \"bool\" }), ...stack.slice(1)];\n\n            case \"SELF\":\n                {\n                    if (ctx?.contract === undefined) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: contract required`);\n                    }\n                    const ia = instructionAnn({ f: 1, v: 1 });\n                    const ep = contractEntryPoint(ctx.contract, ia.f?.[0]);\n                    if (ep === null) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: contract has no entrypoint ${ep}`);\n                    }\n                    return [annotate({ prim: \"contract\", args: [ep] }, { v: ia.v ? ia.v : [\"@self\"] }), ...stack];\n                }\n\n            case \"TRANSFER_TOKENS\":\n                {\n                    const s = args(0, null, [\"mutez\"], [\"contract\"]);\n                    ensureTypesEqual(s[0], s[2].args[0]);\n                    return [annotateVar({ prim: \"operation\" }), ...stack.slice(3)];\n                }\n\n            case \"SET_DELEGATE\":\n                {\n                    const s = args(0, [\"option\"])[0];\n                    if (typeID(s.args[0]) !== \"key_hash\") {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: key hash expected: ${typeID(s.args[0])}`);\n                    }\n                    return [annotateVar({ prim: \"operation\" }), ...stack.slice(1)];\n                }\n\n            case \"IMPLICIT_ACCOUNT\":\n                args(0, [\"key_hash\"]);\n                return [annotateVar({ prim: \"contract\", args: [{ prim: \"unit\" }] }), ...stack.slice(1)];\n\n            case \"NOW\":\n                return [annotateVar({ prim: \"timestamp\" }, \"@now\"), ...stack];\n\n            case \"AMOUNT\":\n                return [annotateVar({ prim: \"mutez\" }, \"@amount\"), ...stack];\n\n            case \"BALANCE\":\n                return [annotateVar({ prim: \"mutez\" }, \"@balance\"), ...stack];\n\n            case \"CHECK_SIGNATURE\":\n                args(0, [\"key\"], [\"signature\"], [\"bytes\"]);\n                return [annotateVar({ prim: \"bool\" }), ...stack.slice(3)];\n\n            case \"BLAKE2B\":\n            case \"SHA256\":\n            case \"SHA512\":\n            case \"KECCAK\":\n            case \"SHA3\":\n                args(0, [\"bytes\"]);\n                return [annotateVar({ prim: \"bytes\" }), ...stack.slice(1)];\n\n            case \"HASH_KEY\":\n                args(0, [\"key\"]);\n                return [annotateVar({ prim: \"key_hash\" }), ...stack.slice(1)];\n\n            case \"SOURCE\":\n                return [annotateVar({ prim: \"address\" }, \"@source\"), ...stack];\n\n            case \"SENDER\":\n                return [annotateVar({ prim: \"address\" }, \"@sender\"), ...stack];\n\n            case \"ADDRESS\":\n                {\n                    const s = args(0, [\"contract\"])[0];\n                    const ia = instructionAnn({ v: 1 });\n                    return [\n                        annotate({ prim: \"address\", [refContract]: s }, { v: ia.v ? ia.v : varSuffix(argAnn(s), \"address\") }),\n                        ...stack.slice(1)];\n                }\n\n            case \"SELF_ADDRESS\":\n                {\n                    const addr: MichelsonTypeAddress = { prim: \"address\" };\n                    if (ctx?.contract !== undefined) {\n                        addr[refContract] = { prim: \"contract\", args: [contractSection(ctx.contract, \"parameter\").args[0]] };\n                    }\n                    return [annotateVar(addr, \"@address\"), ...stack];\n                }\n\n            case \"CHAIN_ID\":\n                return [annotateVar({ prim: \"chain_id\" }), ...stack];\n\n            case \"DROP\":\n                {\n                    instructionAnn({});\n                    const n = instruction.args !== undefined ? parseInt(instruction.args[0].int, 10) : 1;\n                    args(n - 1, null);\n                    return stack.slice(n);\n                }\n\n            case \"DIG\":\n                {\n                    instructionAnn({});\n                    const n = parseInt(instruction.args[0].int, 10);\n                    return [args(n, null)[0], ...stack.slice(0, n), ...stack.slice(n + 1)];\n                }\n\n            case \"DUG\":\n                {\n                    instructionAnn({});\n                    const n = parseInt(instruction.args[0].int, 10);\n                    return [...stack.slice(1, n + 1), args(0, null)[0], ...stack.slice(n + 1)];\n                }\n\n            case \"NONE\":\n                assertTypeAnnotationsValid(instruction.args[0]);\n                return [annotate({ prim: \"option\", args: [instruction.args[0]] }, instructionAnn({ t: 1, v: 1 })), ...stack];\n\n            case \"LEFT\":\n            case \"RIGHT\":\n                {\n                    const s = args(0, null)[0];\n                    const ia = instructionAnn({ f: 2, t: 1, v: 1 }, { specialFields: true });\n                    const va = argAnn(s);\n\n                    const children: [MichelsonType, MichelsonType] = [\n                        annotate(s, {\n                            t: null,\n                            v: null,\n                            f: ia.f && ia.f.length > 0 && ia.f[0] !== \"%\" ?\n                                ia.f[0] === \"%@\" ?\n                                    va.v ? [\"%\" + va.v[0].slice(1)] : undefined :\n                                    ia.f :\n                                undefined,\n                        }),\n                        annotate(instruction.args[0], {\n                            t: null,\n                            f: ia.f && ia.f.length > 1 && ia.f[1] !== \"%\" ? ia.f : undefined,\n                        }),\n                    ];\n\n                    return [annotate({\n                        prim: \"or\", args: instruction.prim === \"LEFT\" ? children : [children[1], children[0]]\n                    }, { t: ia.t, v: ia.v }), ...stack.slice(1)];\n                }\n\n            case \"NIL\":\n                assertTypeAnnotationsValid(instruction.args[0]);\n                return [annotate({ prim: \"list\", args: [instruction.args[0]] }, instructionAnn({ t: 1, v: 1 })), ...stack];\n\n            case \"UNPACK\":\n                args(0, [\"bytes\"]);\n                assertTypeAnnotationsValid(instruction.args[0]);\n                return [annotateVar({ prim: \"option\", args: [instruction.args[0]] }, \"@unpacked\"), ...stack.slice(1)];\n\n            case \"CONTRACT\":\n                {\n                    const s = args(0, [\"address\"])[0];\n                    assertTypeAnnotationsValid(instruction.args[0]);\n                    const ia = instructionAnn({ v: 1, f: 1 });\n                    const contract = s[refContract];\n                    if (contract !== undefined) {\n                        const ep = contractEntryPoint(contract, ia.f?.[0]);\n                        if (ep === null) {\n                            throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: contract has no entrypoint ${ep}`);\n                        }\n                        ensureTypesEqual(ep, instruction.args[0]);\n                    }\n                    return [\n                        annotate({ prim: \"option\", args: [{ prim: \"contract\", args: [instruction.args[0]] }] }, { v: ia.v ? ia.v : varSuffix(argAnn(s), \"contract\") }),\n                        ...stack.slice(1)];\n                }\n\n            case \"CAST\":\n                instructionAnn({});\n                const s = args(0, null)[0];\n                assertTypeAnnotationsValid(instruction.args[0]);\n                ensureTypesEqual(instruction.args[0], s);\n                return [instruction.args[0], ...stack.slice(1)];\n\n            case \"IF_NONE\":\n                {\n                    instructionAnn({});\n                    const s = args(0, [\"option\"])[0];\n                    const tail = stack.slice(1);\n                    const br0 = functionTypeInternal(instruction.args[0], tail, ctx);\n                    const br1 = functionTypeInternal(instruction.args[1], [annotate(s.args[0], { t: null, v: varSuffix(argAnn(s), \"some\") }), ...tail], ctx);\n                    return branchType(br0, br1);\n                }\n\n            case \"IF_LEFT\":\n                {\n                    instructionAnn({});\n                    const s = args(0, [\"or\"])[0];\n                    const va = argAnn(s);\n                    const lefta = argAnn(s.args[0]);\n                    const righta = argAnn(s.args[1]);\n                    const tail = stack.slice(1);\n                    const br0 = functionTypeInternal(instruction.args[0],\n                        [\n                            annotate(s.args[0], { t: null, v: varSuffix(va, lefta.f ? lefta.f[0].slice(1) : \"left\") }),\n                            ...tail\n                        ],\n                        ctx);\n                    const br1 = functionTypeInternal(instruction.args[1],\n                        [\n                            annotate(s.args[1], { t: null, v: varSuffix(va, righta.f ? righta.f[0].slice(1) : \"right\") }),\n                            ...tail\n                        ],\n                        ctx);\n                    return branchType(br0, br1);\n                }\n\n            case \"IF_CONS\":\n                {\n                    instructionAnn({});\n                    const s = args(0, [\"list\"])[0];\n                    const va = argAnn(s);\n                    const tail = stack.slice(1);\n                    const br0 = functionTypeInternal(instruction.args[0],\n                        [\n                            annotate(s.args[0], { t: null, v: varSuffix(va, \"hd\") }),\n                            annotate(s, { t: null, v: varSuffix(va, \"tl\") }),\n                            ...tail\n                        ],\n                        ctx);\n                    const br1 = functionTypeInternal(instruction.args[1], tail, ctx);\n                    return branchType(br0, br1);\n                }\n\n            case \"IF\":\n                {\n                    instructionAnn({});\n                    args(0, [\"bool\"]);\n                    const tail = stack.slice(1);\n                    const br0 = functionTypeInternal(instruction.args[0], tail, ctx);\n                    const br1 = functionTypeInternal(instruction.args[1], tail, ctx);\n                    return branchType(br0, br1);\n                }\n\n            case \"MAP\":\n                {\n                    const s = args(0, [\"list\", \"map\"])[0];\n                    const tail = stack.slice(1);\n                    const elt = s.prim === \"map\" ? { prim: \"pair\" as const, args: s.args } : s.args[0];\n                    const body = functionTypeInternal(instruction.args[0],\n                        [annotate(elt, { t: null, v: varSuffix(argAnn(s), \"elt\") }), ...tail],\n                        ctx);\n                    if (\"failed\" in body) {\n                        return body;\n                    }\n                    if (body.length < 1) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: function must return a value`);\n                    }\n                    ensureStacksEqual(body.slice(1), tail);\n                    if (s.prim === \"list\") {\n                        return [annotateVar({ prim: \"list\", args: [body[0]] }), ...tail];\n                    }\n                    return [annotateVar({ prim: \"map\", args: [s.args[0], body[0]] }), ...tail];\n                }\n\n            case \"ITER\":\n                {\n                    instructionAnn({});\n                    const s = args(0, [\"set\", \"list\", \"map\"])[0];\n                    const tail = stack.slice(1);\n                    const elt = s.prim === \"map\" ? { prim: \"pair\" as const, args: s.args } : s.args[0];\n                    const body = functionTypeInternal(instruction.args[0],\n                        [annotate(elt, { t: null, v: varSuffix(argAnn(s), \"elt\") }), ...tail],\n                        ctx);\n                    if (\"failed\" in body) {\n                        return body;\n                    }\n                    ensureStacksEqual(body, tail);\n                    return tail;\n                }\n\n            case \"LOOP\":\n                {\n                    instructionAnn({});\n                    args(0, [\"bool\"]);\n                    const tail = stack.slice(1);\n                    const body = functionTypeInternal(instruction.args[0], tail, ctx);\n                    if (\"failed\" in body) {\n                        return body;\n                    }\n                    ensureStacksEqual(body, [{ prim: \"bool\" }, ...tail]);\n                    return tail;\n                }\n\n            case \"LOOP_LEFT\":\n                {\n                    instructionAnn({});\n                    const s = args(0, [\"or\"])[0];\n                    const tail = stack.slice(1);\n                    const body = functionTypeInternal(instruction.args[0],\n                        [annotate(s.args[0], { t: null, v: varSuffix(argAnn(s), \"left\") }), ...tail],\n                        ctx);\n                    if (\"failed\" in body) {\n                        return body;\n                    }\n                    ensureStacksEqual(body, [s, ...tail]);\n                    return [annotate(s.args[1], { t: null, v: instructionAnn({ v: 1 }).v }), ...tail];\n                }\n\n            case \"DIP\":\n                {\n                    instructionAnn({});\n                    const n = instruction.args.length === 2 ? parseInt(instruction.args[0].int, 10) : 1;\n                    args(n - 1, null);\n                    const head = stack.slice(0, n);\n                    const tail = stack.slice(n);\n                    // ternary operator is a type guard so use it instead of just `instruction.args.length - 1`\n                    const body = instruction.args.length === 2 ?\n                        functionTypeInternal(instruction.args[1], tail, ctx) :\n                        functionTypeInternal(instruction.args[0], tail, ctx);\n                    if (\"failed\" in body) {\n                        return body;\n                    }\n                    return [...head, ...body];\n                }\n\n            case \"CREATE_CONTRACT\":\n                {\n                    const ia = instructionAnn({ v: 2 });\n                    const s = args(0, [\"option\"], [\"mutez\"], null);\n                    if (typeID(s[0].args[0]) !== \"key_hash\") {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: key hash expected: ${typeID(s[0].args[0])}`);\n                    }\n                    if (ensureStorableType(s[2])) {\n                        assertContractValid(instruction.args[0]);\n                        assertScalarTypesEqual(contractSection(instruction.args[0], \"storage\").args[0], s[2]);\n                    }\n\n                    const va = ia.v?.map(v => v !== \"@\" ? [v] : undefined);\n                    return [\n                        annotate({ prim: \"operation\" }, { v: va?.[0] }),\n                        annotate({\n                            prim: \"address\",\n                            [refContract]: { prim: \"contract\", args: [contractSection(instruction.args[0], \"parameter\").args[0]] },\n                        }, { v: va?.[1] }),\n                        ...stack.slice(3)\n                    ];\n                }\n\n            case \"PUSH\":\n                assertTypeAnnotationsValid(instruction.args[0]);\n                assertDataValidInternal(instruction.args[1], instruction.args[0], { ...ctx, contract: undefined });\n                return [annotateVar(instruction.args[0]), ...stack];\n\n            case \"EMPTY_SET\":\n                assertTypeAnnotationsValid(instruction.args[0]);\n                ensureComparableType(instruction.args[0]);\n                return [annotate({ prim: \"set\", args: instruction.args }, instructionAnn({ t: 1, v: 1 })), ...stack];\n\n            case \"EMPTY_MAP\":\n                assertTypeAnnotationsValid(instruction.args[0]);\n                ensureComparableType(instruction.args[0]);\n                assertTypeAnnotationsValid(instruction.args[1]);\n                return [annotate({ prim: \"map\", args: instruction.args }, instructionAnn({ t: 1, v: 1 })), ...stack];\n\n            case \"EMPTY_BIG_MAP\":\n                assertTypeAnnotationsValid(instruction.args[0]);\n                ensureComparableType(instruction.args[0]);\n                assertTypeAnnotationsValid(instruction.args[1]);\n                ensureBigMapStorableType(instruction.args[0]);\n                return [annotate({ prim: \"big_map\", args: instruction.args }, instructionAnn({ t: 1, v: 1 })), ...stack];\n\n            case \"LAMBDA\":\n                {\n                    assertTypeAnnotationsValid(instruction.args[0]);\n                    assertTypeAnnotationsValid(instruction.args[1]);\n                    const body = functionTypeInternal(instruction.args[2], [instruction.args[0]], { ...ctx, contract: undefined });\n                    if (\"failed\" in body) {\n                        return body;\n                    }\n                    if (body.length !== 1) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: function must return a value`);\n                    }\n                    ensureTypesEqual(instruction.args[1], body[0]);\n                    return [annotateVar({ prim: \"lambda\", args: [instruction.args[0], instruction.args[1]] }), ...stack];\n                }\n\n            case \"LEVEL\":\n                return [annotateVar({ prim: \"nat\" }, \"@level\"), ...stack];\n\n            case \"TOTAL_VOTING_POWER\":\n                return [annotateVar({ prim: \"nat\" }), ...stack];\n\n            case \"VOTING_POWER\":\n                args(0, [\"key_hash\"]);\n                return [annotateVar({ prim: \"nat\" }), ...stack.slice(1)];\n\n            case \"TICKET\":\n                {\n                    const s = args(0, null, [\"nat\"])[0];\n                    ensureComparableType(s);\n                    return [annotate({ prim: \"ticket\", args: [s] }, instructionAnn({ t: 1, v: 1 })), ...stack.slice(2)];\n                }\n\n            case \"JOIN_TICKETS\":\n                {\n                    const s = unpackComb(\"pair\", args(0, [\"pair\"])[0]);\n                    if (typeID(s.args[0]) !== \"ticket\") {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: ticket expected: ${typeID(s.args[0])}`);\n                    }\n                    ensureTypesEqual(s.args[0], s.args[1]);\n                    return [annotateVar({\n                        prim: \"option\",\n                        args: [annotate(s.args[0], { t: null })],\n                    }), ...stack.slice(1)];\n                }\n\n            case \"SPLIT_TICKET\":\n                {\n                    const s = args(0, [\"ticket\"], [\"pair\"]);\n                    const p = unpackComb(\"pair\", s[1]);\n                    if (typeID(p.args[0]) !== \"nat\") {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: nat expected: ${typeID(p.args[0])}`);\n                    }\n                    ensureTypesEqual(p.args[0], p.args[1]);\n                    return [annotateVar({\n                        prim: \"option\",\n                        args: [{\n                            prim: \"pair\",\n                            args: [\n                                annotate(s[0], { t: null }),\n                                annotate(s[0], { t: null }),\n                            ],\n                        }],\n                    }), ...stack.slice(2)];\n                }\n\n            case \"READ_TICKET\":\n                {\n                    const ia = instructionAnn({ v: 2 });\n                    const s = args(0, [\"ticket\"])[0];\n                    const va = ia.v?.map(v => v !== \"@\" ? [v] : undefined);\n                    return [\n                        annotate({\n                            prim: \"pair\",\n                            args: [\n                                { prim: \"address\" },\n                                annotate(s.args[0], { t: null }),\n                                { prim: \"nat\" },\n                            ]\n                        }, { v: va?.[0] }),\n                        annotate(s, { v: va?.[1], t: null }),\n                        ...stack.slice(1),\n                    ];\n                }\n\n            case \"PAIRING_CHECK\":\n                {\n                    const p = args(0, [\"list\"])[0].args[0];\n                    if (!isPairType(p)) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: pair expected: ${typeID(p)}`);\n                    }\n                    const c = unpackComb(\"pair\", p);\n                    if (typeID(c.args[0]) !== \"bls12_381_g1\") {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: bls12_381_g1 expected: ${typeID(c.args[0])}`);\n                    }\n                    if (typeID(c.args[1]) !== \"bls12_381_g2\") {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: bls12_381_g2 expected: ${typeID(c.args[1])}`);\n                    }\n                    return [annotateVar({ prim: \"bool\" }), ...stack.slice(1)];\n                }\n\n            case \"SAPLING_EMPTY_STATE\":\n                return [annotate({ prim: \"sapling_state\", args: [instruction.args[0]] }, instructionAnn({ v: 1, t: 1 })), ...stack];\n\n            case \"SAPLING_VERIFY_UPDATE\":\n                {\n                    const s = args(0, [\"sapling_transaction\"], [\"sapling_state\"]);\n                    if (parseInt(s[0].args[0].int, 10) !== parseInt(s[1].args[0].int, 10)) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: sapling memo size mismatch: ${s[0].args[0].int} != ${s[1].args[0].int}`);\n                    }\n                    return [annotateVar({\n                        prim: \"option\",\n                        args: [{\n                            prim: \"pair\",\n                            args: [\n                                { prim: \"int\" },\n                                annotate(s[1], { t: null }),\n                            ],\n                        }],\n                    }), ...stack.slice(2)];\n                }\n\n            default:\n                throw new MichelsonError((instruction as MichelsonCode), `unexpected instruction: ${(instruction as Prim).prim}`);\n        }\n    })(instruction);\n\n    if (ctx?.traceCallback !== undefined) {\n        const trace: InstructionTrace = {\n            op: instruction,\n            in: stack,\n            out: retStack,\n        };\n        ctx.traceCallback(trace);\n    }\n\n    return retStack;\n}\n\nexport function contractSection<T extends \"parameter\" | \"storage\" | \"code\">(contract: MichelsonContract, section: T): MichelsonContractSection<T> {\n    for (const s of contract) {\n        if (s.prim === section) {\n            return s as MichelsonContractSection<T>;\n        }\n    }\n    throw new MichelsonError(contract, `missing contract section: ${section}`);\n}\n\nfunction isContract(v: Expr): v is MichelsonContract {\n    if (Array.isArray(v)) {\n        for (const s of v) {\n            if (\"prim\" in s && (s.prim === \"parameter\" || s.prim === \"storage\" || s.prim === \"code\")) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\nexport function contractEntryPoint(src: MichelsonContract | MichelsonType, ep?: string): MichelsonType | null {\n    ep = ep || \"%default\";\n    const entryPoint = contractEntryPoints(src).find(x => x[0] === ep);\n\n    if (entryPoint !== undefined) {\n        return entryPoint[1];\n    } else if (ep === \"%default\") {\n        return isContract(src) ? contractSection(src, \"parameter\").args[0] : src;\n    }\n    return null;\n}\n\nfunction isOrType(t: MichelsonType): t is MichelsonTypeOr<[MichelsonType, MichelsonType]> {\n    return Array.isArray(t) || t.prim === \"or\";\n}\n\nexport function contractEntryPoints(src: MichelsonContract | MichelsonType): [string, MichelsonType][] {\n    if (isContract(src)) {\n        const param = contractSection(src, \"parameter\");\n        const ch = contractEntryPoints(param.args[0]);\n        const a = unpackAnnotations(param);\n        return a.f ? [[a.f[0], param.args[0]], ...ch] : ch;\n    }\n\n    if (isOrType(src)) {\n        const args = typeArgs(src);\n        const getArg = (n: 0 | 1): [string, MichelsonType][] => {\n            const a = unpackAnnotations(args[n]);\n            if (typeID(args[n]) === \"or\") {\n                const ch = contractEntryPoints(args[n]);\n                return a.f ? [[a.f[0], args[n]], ...ch] : ch;\n            }\n            return a.f ? [[a.f[0], args[n]]] : [];\n        };\n        return [...getArg(0), ...getArg(1)];\n    }\n    return [];\n}\n\n// Contract validation\n\nexport function assertContractValid(contract: MichelsonContract, ctx?: Context): MichelsonReturnType {\n    const parameter = contractSection(contract, \"parameter\").args[0];\n    assertTypeAnnotationsValid(parameter, true);\n\n    const storage = contractSection(contract, \"storage\").args[0];\n    assertTypeAnnotationsValid(storage);\n\n    const arg: MichelsonType = {\n        \"prim\": \"pair\",\n        args: [\n            { ...parameter, ...{ annots: [\"@parameter\"] } },\n            { ...storage, ...{ annots: [\"@storage\"] } },\n        ]\n    };\n\n    const code = contractSection(contract, \"code\").args[0];\n    const ret = functionTypeInternal(code, [arg], { ...ctx, ...{ contract } });\n\n    if (\"failed\" in ret) {\n        return ret;\n    }\n\n    const expected: MichelsonType = {\n        \"prim\": \"pair\",\n        args: [\n            { \"prim\": \"list\", args: [{ \"prim\": \"operation\" }] },\n            storage,\n        ]\n    };\n\n    try {\n        assertStacksEqual(ret, [expected]);\n    } catch (err) {\n        if (err instanceof MichelsonError) {\n            throw new MichelsonInstructionError(code, ret, err.message);\n        } else {\n            throw err;\n        }\n    }\n\n    return ret;\n}\n\n// Exported wrapper functions\n\nexport function assertDataValid(d: MichelsonData, t: MichelsonType, ctx?: Context): void {\n    assertTypeAnnotationsValid(t);\n    assertDataValidInternal(d, t, ctx || null);\n}\n\nexport function functionType(inst: MichelsonCode, stack: MichelsonType[], ctx?: Context): MichelsonReturnType {\n    for (const t of stack) {\n        assertTypeAnnotationsValid(t);\n    }\n\n    if (ctx?.contract !== undefined) {\n        for (const typesec of [\"parameter\", \"storage\"] as const) {\n            const sec = contractSection(ctx.contract, typesec).args[0];\n            assertTypeAnnotationsValid(sec);\n        }\n    }\n\n    return functionTypeInternal(inst, stack, ctx || null);\n}\n\nexport function assertTypesEqual<T1 extends MichelsonType | MichelsonType[], T2 extends T1>(a: T1, b: T2, field: boolean = false): void {\n    if (Array.isArray(a)) {\n        // type guards don't work for parametrized generic types\n        for (const v of a as MichelsonType[]) {\n            assertTypeAnnotationsValid(v);\n        }\n        for (const v of b as MichelsonType[]) {\n            assertTypeAnnotationsValid(v);\n        }\n    } else {\n        assertTypeAnnotationsValid(a as MichelsonType);\n        assertTypeAnnotationsValid(b as MichelsonType);\n    }\n    assertScalarTypesEqual(a, b, field);\n}\n\nexport function isTypeAnnotationsValid(t: MichelsonType, field: boolean = false): boolean {\n    try {\n        assertTypeAnnotationsValid(t, field);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\nexport function isContractValid(contract: MichelsonContract, ctx?: Context): MichelsonReturnType | null {\n    try {\n        return assertContractValid(contract, ctx);\n    } catch {\n        return null;\n    }\n}\n\nexport function isDataValid(d: MichelsonData, t: MichelsonType, ctx?: Context): boolean {\n    try {\n        assertDataValid(d, t, ctx);\n        return true;\n    } catch {\n        return false;\n    }\n}\n\nexport function isTypeEqual<T1 extends MichelsonType | MichelsonType[], T2 extends T1>(a: T1, b: T2, field: boolean = false): boolean {\n    try {\n        assertTypesEqual(a, b, field);\n        return true;\n    } catch {\n        return false;\n    }\n}","import {\n    MichelsonContract, MichelsonContractSection, MichelsonType,\n    MichelsonData, MichelsonCode, MichelsonReturnType\n} from \"./michelson-types\";\nimport {\n    assertContractValid, contractSection,\n    contractEntryPoint, assertDataValid,\n    assertTypeAnnotationsValid,\n    InstructionTrace, Context, functionType,\n    isDataValid, contractEntryPoints\n} from \"./michelson-typecheck\";\nimport { Parser, ParserOptions } from \"./micheline-parser\";\nimport { assertMichelsonContract, assertMichelsonType, assertMichelsonData } from \"./michelson-validator\";\n\nexport interface ContractOptions extends ParserOptions {\n    traceCallback?: (t: InstructionTrace) => void;\n}\n\nexport class Contract {\n    private ctx: Context;\n    public readonly output: MichelsonReturnType;\n\n    constructor(public readonly contract: MichelsonContract, opt?: ContractOptions) {\n        this.ctx = { contract, ...opt };\n        this.output = assertContractValid(contract, this.ctx);\n    }\n\n    static parse(src: string | object, opt?: ContractOptions): Contract {\n        const p = new Parser(opt);\n        const expr = typeof src === \"string\" ? p.parseScript(src) : p.parseJSON(src);\n        if (expr === null) {\n            throw new Error(\"empty contract\");\n        }\n        if (assertMichelsonContract(expr)) {\n            return new Contract(expr, opt);\n        }\n        throw undefined;\n    }\n\n    static parseTypeExpression(src: string | object, opt?: ParserOptions): MichelsonType {\n        const p = new Parser(opt);\n        const expr = typeof src === \"string\" ? p.parseScript(src) : p.parseJSON(src);\n        if (expr === null) {\n            throw new Error(\"empty type expression\");\n        }\n        if (assertMichelsonType(expr) && assertTypeAnnotationsValid(expr)) {\n            return expr;\n        }\n        throw undefined;\n    }\n\n    static parseDataExpression(src: string | object, opt?: ParserOptions): MichelsonData {\n        const p = new Parser(opt);\n        const expr: any = typeof src === \"string\" ? p.parseScript(src) : p.parseJSON(src);\n        if (expr === null) {\n            throw new Error(\"empty data expression\");\n        }\n        if (assertMichelsonData(expr)) {\n            return expr;\n        }\n        throw undefined;\n    }\n\n    section<T extends \"parameter\" | \"storage\" | \"code\">(section: T): MichelsonContractSection<T> {\n        return contractSection(this.contract, section);\n    }\n\n    entryPoints(): [string, MichelsonType][] {\n        return contractEntryPoints(this.contract);\n    }\n\n    entryPoint(ep?: string): MichelsonType | null {\n        return contractEntryPoint(this.contract, ep);\n    }\n\n    assertDataValid(d: MichelsonData, t: MichelsonType): void {\n        assertDataValid(d, t, this.ctx);\n    }\n\n    isDataValid(d: MichelsonData, t: MichelsonType): boolean {\n        return isDataValid(d, t, this.ctx);\n    }\n\n    assertParameterValid(ep: string | null, d: MichelsonData): void {\n        const t = this.entryPoint(ep || undefined);\n        if (t === null) {\n            throw new Error(`contract has no entrypoint named ${ep}`);\n        }\n        this.assertDataValid(d, t);\n    }\n\n    isParameterValid(ep: string | null, d: MichelsonData): boolean {\n        try {\n            this.assertParameterValid(ep, d);\n            return true;\n        } catch {\n            return false;\n        }\n    }\n\n    functionType(inst: MichelsonCode, stack: MichelsonType[]): MichelsonReturnType {\n        return functionType(inst, stack, this.ctx);\n    }\n}\n\nexport const dummyContract = new Contract([\n    { prim: \"parameter\", args: [{ prim: \"unit\" }] },\n    { prim: \"storage\", args: [{ prim: \"unit\" }] },\n    {\n        prim: \"code\", args: [\n            [\n                { prim: \"CAR\" },\n                { prim: \"NIL\", args: [{ prim: \"operation\" }] },\n                { prim: \"PAIR\" },\n            ]\n        ]\n    },\n]);","import { sourceReference, Expr } from \"./micheline\";\nimport { InstructionTrace, MichelsonInstructionError } from \"./michelson-typecheck\";\nimport { emitMicheline } from \"./micheline-emitter\";\nimport { unpackAnnotations, MichelsonError, MichelsonTypeError } from \"./utils\";\nimport { MichelsonReturnType } from \"./michelson-types\";\n\nexport function formatStack(s: MichelsonReturnType): string {\n    if (\"failed\" in s) {\n        return `[FAILED: ${emitMicheline(s.failed)}]`;\n    }\n\n    return s.map((v, i) => {\n        const ann = unpackAnnotations(v);\n        return `[${i}${ann.v ? \"/\" + ann.v[0] : \"\"}]: ${emitMicheline(v)}`;\n    }).join(\"\\n\");\n}\n\nexport function traceDumpFunc(blocks: boolean, cb: (s: string) => void): (v: InstructionTrace) => void {\n    return (v: InstructionTrace) => {\n        if (Array.isArray(v) && !blocks) {\n            return;\n        }\n        const macro = v.op[sourceReference]?.macro;\n\n        const msg = `${macro ? \"Macro\" : \"Op\"}: ${macro ? emitMicheline(macro, undefined, true) + \" / \" : \"\"}${emitMicheline(v.op)}\nInput:\n${formatStack(v.in)}\nOutput:\n${formatStack(v.out)}\n`;\n        cb(msg);\n    };\n}\n\nexport function formatError(err: MichelsonError): string {\n    if (err instanceof MichelsonInstructionError) {\n        const macro = err.val[sourceReference]?.macro;\n        return `${macro ? \"Macro\" : \"Op\"}: ${macro ? emitMicheline(macro, undefined, true) + \" / \" : \"\"}${emitMicheline(err.val)}\nStack:\n${formatStack(err.stackState)}\n`;\n    } else if (err instanceof MichelsonTypeError) {\n        const type = Array.isArray(err.val) ?\n            \"[\" + (err.val as Expr[]).map((v, i) => `[${i}]: ${emitMicheline(v)}`).join(\"; \") + \"]\" :\n            emitMicheline(err.val);\n\n        return `Type: ${type}\n${err.data ? `Data: ${emitMicheline(err.data)}\n` : \"\"}\n`;\n    } else {\n        return `Value: ${emitMicheline(err.val)}`;\n    }\n}","\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\n/* tslint:disable */\nexport const VERSION = {\n    \"commitHash\": \"5711569ffaf481d88ba3251343a1788090b35dd4\",\n    \"version\": \"10.2.1\"\n};\n/* tslint:enable */\n"]},"metadata":{},"sourceType":"module"}