{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ready, crypto_secretbox_NONCEBYTES, crypto_secretbox_MACBYTES } from 'libsodium-wrappers';\nimport { BEACON_VERSION } from '../../constants';\nimport { decryptCryptoboxPayload, encryptCryptoboxPayload, generateGUID } from '@airgap/beacon-utils';\nimport { CommunicationClient } from './CommunicationClient';\n/**\n * @internalapi\n *\n *\n */\n\nexport class MessageBasedClient extends CommunicationClient {\n  constructor(name, keyPair) {\n    super(keyPair);\n    this.name = name;\n    this.init().catch(console.error);\n  }\n  /**\n   * start the client and make sure all dependencies are ready\n   */\n\n\n  start() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield ready;\n    });\n  }\n  /**\n   * Get the pairing request information. This will be shared with the peer during the connection setup\n   */\n\n\n  getPairingRequestInfo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        id: yield generateGUID(),\n        type: 'postmessage-pairing-request',\n        name: this.name,\n        version: BEACON_VERSION,\n        publicKey: yield this.getPublicKey()\n      };\n    });\n  }\n  /**\n   * Get the pairing response information. This will be shared with the peer during the connection setup\n   */\n\n\n  getPairingResponseInfo(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        id: request.id,\n        type: 'postmessage-pairing-response',\n        name: this.name,\n        version: BEACON_VERSION,\n        publicKey: yield this.getPublicKey()\n      };\n    });\n  }\n  /**\n   * Unsubscribe from encrypted messages from a specific peer\n   *\n   * @param senderPublicKey\n   */\n\n\n  unsubscribeFromEncryptedMessage(senderPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const listener = this.activeListeners.get(senderPublicKey);\n\n      if (!listener) {\n        return;\n      }\n\n      this.activeListeners.delete(senderPublicKey);\n    });\n  }\n  /**\n   * Unsubscribe from all encrypted messages\n   */\n\n\n  unsubscribeFromEncryptedMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.activeListeners.clear();\n    });\n  }\n  /**\n   * Decrypt a message from a specific peer\n   *\n   * @param senderPublicKey\n   * @param payload\n   */\n\n\n  decryptMessage(senderPublicKey, payload) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        sharedRx\n      } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n      const hexPayload = Buffer.from(payload, 'hex');\n\n      if (hexPayload.length >= crypto_secretbox_NONCEBYTES + crypto_secretbox_MACBYTES) {\n        try {\n          return yield decryptCryptoboxPayload(hexPayload, sharedRx);\n        } catch (decryptionError) {\n          /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n        }\n      }\n\n      throw new Error('Could not decrypt message');\n    });\n  }\n  /**\n   * Encrypt a message for a specific publicKey (receiver)\n   *\n   * @param recipientPublicKey\n   * @param message\n   */\n\n\n  encryptMessage(recipientPublicKey, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        sharedTx\n      } = yield this.createCryptoBoxClient(recipientPublicKey, this.keyPair.privateKey);\n      return encryptCryptoboxPayload(message, sharedTx);\n    });\n  }\n\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SACEA,KADF,EAGEC,2BAHF,EAIEC,yBAJF,QAKO,oBALP;AAMA,SAASC,cAAT,QAA+B,iBAA/B;AACA,SACEC,uBADF,EAEEC,uBAFF,EAGEC,YAHF,QAIO,sBAJP;AAKA,SAASC,mBAAT,QAAoC,uBAApC;AAGA;;;;;;AAKA,OAAM,MAAgBC,kBAAhB,SAA2CD,mBAA3C,CAA8D;EAMlEE,YAA+BC,IAA/B,EAA6CC,OAA7C,EAA6D;IAC3D,MAAMA,OAAN;IAD6B;IAE7B,KAAKC,IAAL,GAAYC,KAAZ,CAAkBC,OAAO,CAACC,KAA1B;EACD;EAED;;;;;EAGaC,KAAK;;MAChB,MAAMhB,KAAN;IACD;EAAA;EAED;;;;;EAGaiB,qBAAqB;;MAChC,OAAO;QACLC,EAAE,EAAE,MAAMZ,YAAY,EADjB;QAELa,IAAI,EAAE,6BAFD;QAGLT,IAAI,EAAE,KAAKA,IAHN;QAILU,OAAO,EAAEjB,cAJJ;QAKLkB,SAAS,EAAE,MAAM,KAAKC,YAAL;MALZ,CAAP;IAOD;EAAA;EAED;;;;;EAGaC,sBAAsB,CACjCC,OADiC,EACC;;MAElC,OAAO;QACLN,EAAE,EAAEM,OAAO,CAACN,EADP;QAELC,IAAI,EAAE,8BAFD;QAGLT,IAAI,EAAE,KAAKA,IAHN;QAILU,OAAO,EAAEjB,cAJJ;QAKLkB,SAAS,EAAE,MAAM,KAAKC,YAAL;MALZ,CAAP;IAOD;EAAA;EAED;;;;;;;EAKaG,+BAA+B,CAACC,eAAD,EAAwB;;MAClE,MAAMC,QAAQ,GAAG,KAAKC,eAAL,CAAqBC,GAArB,CAAyBH,eAAzB,CAAjB;;MACA,IAAI,CAACC,QAAL,EAAe;QACb;MACD;;MAED,KAAKC,eAAL,CAAqBE,MAArB,CAA4BJ,eAA5B;IACD;EAAA;EAED;;;;;EAGaK,gCAAgC;;MAC3C,KAAKH,eAAL,CAAqBI,KAArB;IACD;EAAA;EAED;;;;;;;;EAMgBC,cAAc,CAACP,eAAD,EAA0BQ,OAA1B,EAAyC;;MACrE,MAAM;QAAEC;MAAF,IAAe,MAAM,KAAKC,qBAAL,CAA2BV,eAA3B,EAA4C,KAAKf,OAAL,CAAa0B,UAAzD,CAA3B;MAEA,MAAMC,UAAU,GAAGC,MAAM,CAACC,IAAP,CAAYN,OAAZ,EAAqB,KAArB,CAAnB;;MAEA,IAAII,UAAU,CAACG,MAAX,IAAqBxC,2BAA2B,GAAGC,yBAAvD,EAAkF;QAChF,IAAI;UACF,OAAO,MAAME,uBAAuB,CAACkC,UAAD,EAAaH,QAAb,CAApC;QACD,CAFD,CAEE,OAAOO,eAAP,EAAwB;UACxB;QACD;MACF;;MAED,MAAM,IAAIC,KAAJ,CAAU,2BAAV,CAAN;IACD;EAAA;EAED;;;;;;;;EAMgBC,cAAc,CAACC,kBAAD,EAA6BC,OAA7B,EAA4C;;MACxE,MAAM;QAAEC;MAAF,IAAe,MAAM,KAAKC,qBAAL,CACzBH,kBADyB,EAEzB,KAAKlC,OAAL,CAAa0B,UAFY,CAA3B;MAKA,OAAOhC,uBAAuB,CAACyC,OAAD,EAAUC,QAAV,CAA9B;IACD;EAAA;;AAtGiE","names":["ready","crypto_secretbox_NONCEBYTES","crypto_secretbox_MACBYTES","BEACON_VERSION","decryptCryptoboxPayload","encryptCryptoboxPayload","generateGUID","CommunicationClient","MessageBasedClient","constructor","name","keyPair","init","catch","console","error","start","getPairingRequestInfo","id","type","version","publicKey","getPublicKey","getPairingResponseInfo","request","unsubscribeFromEncryptedMessage","senderPublicKey","listener","activeListeners","get","delete","unsubscribeFromEncryptedMessages","clear","decryptMessage","payload","sharedRx","createCryptoBoxServer","privateKey","hexPayload","Buffer","from","length","decryptionError","Error","encryptMessage","recipientPublicKey","message","sharedTx","createCryptoBoxClient"],"sourceRoot":"","sources":["../../../../src/transports/clients/MessageBasedClient.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}