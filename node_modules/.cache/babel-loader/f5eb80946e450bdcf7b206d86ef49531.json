{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/**\n * A service to help with matrix event management\n */\n\n\nexport class MatrixEventService {\n  constructor(httpClient) {\n    this.httpClient = httpClient;\n    this.cachedPromises = new Map();\n  }\n  /**\n   * Get the latest state from the matrix node\n   *\n   * @param accessToken\n   * @param options\n   */\n\n\n  sync(accessToken, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.withCache('sync', () => this.httpClient.get('/sync', {\n        timeout: options ? options.pollingTimeout : undefined,\n        since: options ? options.syncToken : undefined\n      }, {\n        accessToken\n      }));\n    });\n  }\n  /**\n   * Send a message to a room\n   *\n   * @param accessToken\n   * @param room\n   * @param content\n   * @param txnId\n   */\n\n\n  sendMessage(accessToken, roomId, content, txnId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return new Promise((resolve, reject) => this.scheduleEvent({\n        accessToken,\n        roomId,\n        type: 'm.room.message',\n        content,\n        txnId,\n        onSuccess: resolve,\n        onError: reject\n      }));\n    });\n  }\n  /**\n   * Schedules an event to be sent to the node\n   *\n   * @param event\n   */\n\n\n  scheduleEvent(event) {\n    // TODO: actual scheduling\n    this.sendEvent(event);\n  }\n  /**\n   * Send an event to the matrix node\n   *\n   * @param scheduledEvent\n   */\n\n\n  sendEvent(scheduledEvent) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        roomId,\n        type,\n        txnId,\n        content,\n        accessToken\n      } = scheduledEvent;\n\n      try {\n        const response = yield this.httpClient.put(`/rooms/${encodeURIComponent(roomId)}/send/${type}/${encodeURIComponent(txnId)}`, content, {\n          accessToken\n        });\n        scheduledEvent.onSuccess(response);\n      } catch (error) {\n        scheduledEvent.onError(error);\n      }\n    });\n  }\n  /**\n   * Check the cache when interacting with the Matrix node, if there is an already ongoing call for the specified key, return its promise instead of duplicating the call.\n   *\n   * @param key\n   * @param promiseProvider\n   */\n\n\n  withCache(key, promiseProvider) {\n    let promise = this.cachedPromises.get(key);\n\n    if (!promise) {\n      promise = promiseProvider().finally(() => {\n        this.cachedPromises.delete(key);\n      });\n      this.cachedPromises.set(key, promise);\n    }\n\n    return promise;\n  }\n\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;;;;AAGA,OAAM,MAAOA,kBAAP,CAAyB;EAG7BC,YAA6BC,UAA7B,EAAyD;IAA5B;IAFZ,sBAA+C,IAAIC,GAAJ,EAA/C;EAE4C;EAE7D;;;;;;;;EAMaC,IAAI,CAACC,WAAD,EAAsBC,OAAtB,EAAiD;;MAChE,OAAO,KAAKC,SAAL,CAAe,MAAf,EAAuB,MAC5B,KAAKL,UAAL,CAAgBM,GAAhB,CACE,OADF,EAEE;QACEC,OAAO,EAAEH,OAAO,GAAGA,OAAO,CAACI,cAAX,GAA4BC,SAD9C;QAEEC,KAAK,EAAEN,OAAO,GAAGA,OAAO,CAACO,SAAX,GAAuBF;MAFvC,CAFF,EAME;QAAEN;MAAF,CANF,CADK,CAAP;IAUD;EAAA;EAED;;;;;;;;;;EAQaS,WAAW,CACtBT,WADsB,EAEtBU,MAFsB,EAGtBC,OAHsB,EAItBC,KAJsB,EAIT;;MAEb,OAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KACjB,KAAKC,aAAL,CAAmB;QACjBhB,WADiB;QAEjBU,MAFiB;QAGjBO,IAAI,EAAE,gBAHW;QAIjBN,OAJiB;QAKjBC,KALiB;QAMjBM,SAAS,EAAEJ,OANM;QAOjBK,OAAO,EAAEJ;MAPQ,CAAnB,CADK,CAAP;IAWD;EAAA;EAED;;;;;;;EAKOC,aAAa,CAACI,KAAD,EAAiC;IACnD;IACA,KAAKC,SAAL,CAAeD,KAAf;EACD;EAED;;;;;;;EAKaC,SAAS,CAACC,cAAD,EAA0C;;MAC9D,MAAM;QAAEZ,MAAF;QAAUO,IAAV;QAAgBL,KAAhB;QAAuBD,OAAvB;QAAgCX;MAAhC,IAAgDsB,cAAtD;;MAEA,IAAI;QACF,MAAMC,QAAQ,GAAG,MAAM,KAAK1B,UAAL,CAAgB2B,GAAhB,CACrB,UAAUC,kBAAkB,CAACf,MAAD,CAAQ,SAASO,IAAI,IAAIQ,kBAAkB,CAACb,KAAD,CAAO,EADzD,EAErBD,OAFqB,EAGrB;UAAEX;QAAF,CAHqB,CAAvB;QAKAsB,cAAc,CAACJ,SAAf,CAAyBK,QAAzB;MACD,CAPD,CAOE,OAAOG,KAAP,EAAc;QACdJ,cAAc,CAACH,OAAf,CAAuBO,KAAvB;MACD;IACF;EAAA;EAED;;;;;;;;EAMQxB,SAAS,CAAIyB,GAAJ,EAAoBC,eAApB,EAAqD;IACpE,IAAIC,OAAO,GAAG,KAAKC,cAAL,CAAoB3B,GAApB,CAAwBwB,GAAxB,CAAd;;IAEA,IAAI,CAACE,OAAL,EAAc;MACZA,OAAO,GAAGD,eAAe,GAAGG,OAAlB,CAA0B,MAAK;QACvC,KAAKD,cAAL,CAAoBE,MAApB,CAA2BL,GAA3B;MACD,CAFS,CAAV;MAGA,KAAKG,cAAL,CAAoBG,GAApB,CAAwBN,GAAxB,EAA6BE,OAA7B;IACD;;IAED,OAAOA,OAAP;EACD;;AAlG4B","names":["MatrixEventService","constructor","httpClient","Map","sync","accessToken","options","withCache","get","timeout","pollingTimeout","undefined","since","syncToken","sendMessage","roomId","content","txnId","Promise","resolve","reject","scheduleEvent","type","onSuccess","onError","event","sendEvent","scheduledEvent","response","put","encodeURIComponent","error","key","promiseProvider","promise","cachedPromises","finally","delete","set"],"sourceRoot":"","sources":["../../../../src/matrix-client/services/MatrixEventService.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}