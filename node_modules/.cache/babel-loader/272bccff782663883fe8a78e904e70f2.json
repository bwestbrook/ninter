{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Logger, Transport, PeerManager } from '@airgap/beacon-core';\nimport { TransportStatus, TransportType, Origin } from '@airgap/beacon-types';\nimport { P2PCommunicationClient } from '@airgap/beacon-transport-matrix';\nconst logger = new Logger('P2PTransport');\n/**\n * @internalapi\n *\n *\n */\n\nexport class P2PTransport extends Transport {\n  constructor(name, keyPair, storage, matrixNodes, storageKey, iconUrl, appUrl) {\n    super(name, new P2PCommunicationClient(name, keyPair, 1, storage, matrixNodes, iconUrl, appUrl), new PeerManager(storage, storageKey));\n    this.type = TransportType.P2P;\n  }\n\n  static isAvailable() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return Promise.resolve(true);\n    });\n  }\n\n  connect() {\n    const _super = Object.create(null, {\n      connect: {\n        get: () => super.connect\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._isConnected !== TransportStatus.NOT_CONNECTED) {\n        return;\n      }\n\n      logger.log('connect');\n      this._isConnected = TransportStatus.CONNECTING;\n      yield this.client.start();\n      const knownPeers = yield this.getPeers();\n\n      if (knownPeers.length > 0) {\n        logger.log('connect', `connecting to ${knownPeers.length} peers`);\n        const connectionPromises = knownPeers.map(peer => __awaiter(this, void 0, void 0, function* () {\n          return this.listen(peer.publicKey);\n        }));\n        Promise.all(connectionPromises).catch(error => logger.error('connect', error));\n      }\n\n      yield this.startOpenChannelListener();\n      return _super.connect.call(this);\n    });\n  }\n\n  disconnect() {\n    const _super = Object.create(null, {\n      disconnect: {\n        get: () => super.disconnect\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.client.stop();\n      return _super.disconnect.call(this);\n    });\n  }\n\n  startOpenChannelListener() {\n    return __awaiter(this, void 0, void 0, function* () {//\n    });\n  }\n\n  getPairingRequestInfo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.client.getPairingRequestInfo();\n    });\n  }\n\n  listen(publicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.client.listenForEncryptedMessage(publicKey, message => {\n        const connectionContext = {\n          origin: Origin.P2P,\n          id: publicKey\n        };\n        this.notifyListeners(message, connectionContext).catch(error => {\n          throw error;\n        });\n      }).catch(error => {\n        throw error;\n      });\n    });\n  }\n\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,SAASA,MAAT,EAAiBC,SAAjB,EAA4BC,WAA5B,QAA+C,qBAA/C;AACA,SAKEC,eALF,EAMEC,aANF,EAOEC,MAPF,QASO,sBATP;AAUA,SAASC,sBAAT,QAAuC,iCAAvC;AAEA,MAAMC,MAAM,GAAG,IAAIP,MAAJ,CAAW,cAAX,CAAf;AAEA;;;;;;AAKA,OAAM,MAAOQ,YAAP,SAGIP,SAHJ,CAG2C;EAG/CQ,YACEC,IADF,EAEEC,OAFF,EAGEC,OAHF,EAIEC,WAJF,EAKEC,UALF,EAMEC,OANF,EAOEC,MAPF,EAOiB;IAEf,MACEN,IADF,EAEE,IAAIJ,sBAAJ,CAA2BI,IAA3B,EAAiCC,OAAjC,EAA0C,CAA1C,EAA6CC,OAA7C,EAAsDC,WAAtD,EAAmEE,OAAnE,EAA4EC,MAA5E,CAFF,EAGE,IAAId,WAAJ,CAAmBU,OAAnB,EAA4BE,UAA5B,CAHF;IAXc,YAAsBV,aAAa,CAACa,GAApC;EAgBf;;EAE8B,OAAXC,WAAW;;MAC7B,OAAOC,OAAO,CAACC,OAAR,CAAgB,IAAhB,CAAP;IACD;EAAA;;EAEYC,OAAO;;;;;;;;MAClB,IAAI,KAAKC,YAAL,KAAsBnB,eAAe,CAACoB,aAA1C,EAAyD;QACvD;MACD;;MAEDhB,MAAM,CAACiB,GAAP,CAAW,SAAX;MACA,KAAKF,YAAL,GAAoBnB,eAAe,CAACsB,UAApC;MAEA,MAAM,KAAKC,MAAL,CAAYC,KAAZ,EAAN;MAEA,MAAMC,UAAU,GAAG,MAAM,KAAKC,QAAL,EAAzB;;MAEA,IAAID,UAAU,CAACE,MAAX,GAAoB,CAAxB,EAA2B;QACzBvB,MAAM,CAACiB,GAAP,CAAW,SAAX,EAAsB,iBAAiBI,UAAU,CAACE,MAAM,QAAxD;QACA,MAAMC,kBAAkB,GAAGH,UAAU,CAACI,GAAX,CAAsBC,IAAP,IAAeC;UAAC,YAAKC,MAAL,CAAYF,IAAI,CAACG,SAAjB;QAA2B,CAA5B,CAA9B,CAA3B;QACAjB,OAAO,CAACkB,GAAR,CAAYN,kBAAZ,EAAgCO,KAAhC,CAAuCC,KAAD,IAAWhC,MAAM,CAACgC,KAAP,CAAa,SAAb,EAAwBA,KAAxB,CAAjD;MACD;;MAED,MAAM,KAAKC,wBAAL,EAAN;MAEA,OAAOC,OAAMpB,OAAN,CAAaqB,IAAb,CAAa,IAAb,CAAP;IACD;EAAA;;EAEYC,UAAU;;;;;;;;MACrB,MAAM,KAAKjB,MAAL,CAAYkB,IAAZ,EAAN;MAEA,OAAOH,OAAME,UAAN,CAAgBD,IAAhB,CAAgB,IAAhB,CAAP;IACD;EAAA;;EAEYF,wBAAwB;yDACnC;IACD;EAAA;;EAEYK,qBAAqB;;MAChC,OAAO,KAAKnB,MAAL,CAAYmB,qBAAZ,EAAP;IACD;EAAA;;EAEYV,MAAM,CAACC,SAAD,EAAkB;;MACnC,MAAM,KAAKV,MAAL,CACHoB,yBADG,CACuBV,SADvB,EACmCW,OAAD,IAAY;QAChD,MAAMC,iBAAiB,GAAsB;UAC3CC,MAAM,EAAE5C,MAAM,CAACY,GAD4B;UAE3CiC,EAAE,EAAEd;QAFuC,CAA7C;QAKA,KAAKe,eAAL,CAAqBJ,OAArB,EAA8BC,iBAA9B,EAAiDV,KAAjD,CAAwDC,KAAD,IAAU;UAC/D,MAAMA,KAAN;QACD,CAFD;MAGD,CAVG,EAWHD,KAXG,CAWIC,KAAD,IAAU;QACf,MAAMA,KAAN;MACD,CAbG,CAAN;IAcD;EAAA;;AA3E8C","names":["Logger","Transport","PeerManager","TransportStatus","TransportType","Origin","P2PCommunicationClient","logger","P2PTransport","constructor","name","keyPair","storage","matrixNodes","storageKey","iconUrl","appUrl","P2P","isAvailable","Promise","resolve","connect","_isConnected","NOT_CONNECTED","log","CONNECTING","client","start","knownPeers","getPeers","length","connectionPromises","map","peer","__awaiter","listen","publicKey","all","catch","error","startOpenChannelListener","_super","call","disconnect","stop","getPairingRequestInfo","listenForEncryptedMessage","message","connectionContext","origin","id","notifyListeners"],"sourceRoot":"","sources":["../../src/P2PTransport.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}