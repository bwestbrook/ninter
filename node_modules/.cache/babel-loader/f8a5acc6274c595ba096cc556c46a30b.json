{"ast":null,"code":"import \"core-js/modules/es.error.cause.js\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ready, crypto_generichash, from_string, crypto_sign_detached, crypto_secretbox_NONCEBYTES, crypto_secretbox_MACBYTES } from 'libsodium-wrappers';\nimport axios from 'axios';\nimport { getHexHash, toHex, recipientString, openCryptobox, encryptCryptoboxPayload, decryptCryptoboxPayload } from '@airgap/beacon-utils';\nimport { MatrixClient } from '../matrix-client/MatrixClient';\nimport { MatrixClientEventType } from '../matrix-client/models/MatrixClientEvent';\nimport { MatrixMessageType } from '../matrix-client/models/MatrixMessage';\nimport { StorageKey } from '@airgap/beacon-types';\nimport { PeerManager, BEACON_VERSION, getSenderId, Logger, CommunicationClient } from '@airgap/beacon-core';\nimport { ExposedPromise, generateGUID } from '@airgap/beacon-utils';\nconst logger = new Logger('P2PCommunicationClient');\nexport const KNOWN_RELAY_SERVERS = ['beacon-node-1.diamond.papers.tech', 'beacon-node-1.sky.papers.tech', 'beacon-node-2.sky.papers.tech', 'beacon-node-1.hope.papers.tech', 'beacon-node-1.hope-2.papers.tech', 'beacon-node-1.hope-3.papers.tech', 'beacon-node-1.hope-4.papers.tech', 'beacon-node-1.hope-5.papers.tech'];\n/**\n * @internalapi\n */\n\nexport class P2PCommunicationClient extends CommunicationClient {\n  constructor(name, keyPair, replicationCount, storage, matrixNodes, iconUrl, appUrl) {\n    super(keyPair);\n    this.name = name;\n    this.replicationCount = replicationCount;\n    this.storage = storage;\n    this.iconUrl = iconUrl;\n    this.appUrl = appUrl;\n    this.client = new ExposedPromise();\n    this.activeListeners = new Map();\n    this.ignoredRooms = [];\n    this.loginCounter = 0;\n    logger.log('constructor', 'P2PCommunicationClient created');\n    const nodes = matrixNodes.length > 0 ? matrixNodes : KNOWN_RELAY_SERVERS;\n    this.ENABLED_RELAY_SERVERS = nodes;\n  }\n\n  getPairingRequestInfo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const info = {\n        id: yield generateGUID(),\n        type: 'p2p-pairing-request',\n        name: this.name,\n        version: BEACON_VERSION,\n        publicKey: yield this.getPublicKey(),\n        relayServer: yield this.getRelayServer()\n      };\n\n      if (this.iconUrl) {\n        info.icon = this.iconUrl;\n      }\n\n      if (this.appUrl) {\n        info.appUrl = this.appUrl;\n      }\n\n      return info;\n    });\n  }\n\n  getPairingResponseInfo(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const info = {\n        id: request.id,\n        type: 'p2p-pairing-response',\n        name: this.name,\n        version: BEACON_VERSION,\n        publicKey: yield this.getPublicKey(),\n        relayServer: yield this.getRelayServer()\n      };\n\n      if (this.iconUrl) {\n        info.icon = this.iconUrl;\n      }\n\n      if (this.appUrl) {\n        info.appUrl = this.appUrl;\n      }\n\n      return info;\n    });\n  }\n\n  getRelayServer() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.relayServer) {\n        return this.relayServer.promise;\n      } else {\n        this.relayServer = new ExposedPromise();\n      }\n\n      const node = yield this.storage.get(StorageKey.MATRIX_SELECTED_NODE);\n\n      if (node && node.length > 0) {\n        this.relayServer.resolve(node);\n        return node;\n      }\n\n      const nodes = [...this.ENABLED_RELAY_SERVERS];\n\n      while (nodes.length > 0) {\n        const index = Math.floor(Math.random() * nodes.length);\n        const server = nodes[index];\n\n        try {\n          yield axios.get(`https://${server}/_matrix/client/versions`);\n          this.storage.set(StorageKey.MATRIX_SELECTED_NODE, server).catch(error => logger.log(error));\n          this.relayServer.resolve(server);\n          return server;\n        } catch (relayError) {\n          logger.log(`Ignoring server \"${server}\", trying another one...`);\n          nodes.splice(index, 1);\n        }\n      }\n\n      this.relayServer.reject(`No matrix server reachable!`);\n      throw new Error(`No matrix server reachable!`);\n    });\n  }\n\n  tryJoinRooms(roomId, retry = 1) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield (yield this.client.promise).joinRooms(roomId);\n      } catch (error) {\n        if (retry <= 10 && error.errcode === 'M_FORBIDDEN') {\n          // If we join the room too fast after receiving the invite, the server can accidentally reject our join. This seems to be a problem only when using a federated multi-node setup. Usually waiting for a couple milliseconds solves the issue, but to handle lag, we will keep retrying for 2 seconds.\n          logger.log(`Retrying to join...`, error);\n          setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n            yield this.tryJoinRooms(roomId, retry + 1);\n          }), 200);\n        } else {\n          logger.log(`Failed to join after ${retry} tries.`, error);\n        }\n      }\n    });\n  }\n\n  start() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('start', 'starting client');\n      yield ready;\n      const loginRawDigest = crypto_generichash(32, from_string(`login:${Math.floor(Date.now() / 1000 / (5 * 60))}`));\n      const rawSignature = crypto_sign_detached(loginRawDigest, this.keyPair.privateKey);\n      logger.log('start', `connecting to server`);\n      const relayServer = yield this.getRelayServer();\n      const client = MatrixClient.create({\n        baseUrl: `https://${relayServer}`,\n        storage: this.storage\n      });\n\n      this.initialListener = event => __awaiter(this, void 0, void 0, function* () {\n        if (this.initialEvent && this.initialEvent.timestamp && event && event.timestamp) {\n          if (this.initialEvent.timestamp < event.timestamp) {\n            this.initialEvent = event;\n          }\n        } else {\n          this.initialEvent = event;\n        }\n      });\n\n      client.subscribe(MatrixClientEventType.MESSAGE, this.initialListener);\n      client.subscribe(MatrixClientEventType.INVITE, event => __awaiter(this, void 0, void 0, function* () {\n        let member;\n\n        if (event.content.members.length === 1) {\n          // If there is only one member we know it's a new room\n          // TODO: Use the \"sender\" of the event instead\n          member = event.content.members[0];\n        }\n\n        yield this.tryJoinRooms(event.content.roomId);\n\n        if (member) {\n          yield this.updateRelayServer(member);\n          yield this.updatePeerRoom(member, event.content.roomId);\n        }\n      }));\n      logger.log('start', 'login', yield this.getPublicKeyHash(), 'on', relayServer);\n\n      try {\n        yield client.start({\n          id: yield this.getPublicKeyHash(),\n          password: `ed:${toHex(rawSignature)}:${yield this.getPublicKey()}`,\n          deviceId: toHex(this.keyPair.publicKey)\n        });\n      } catch (error) {\n        console.log('ERROR, RETRYING');\n        yield this.reset(); // If we can't log in, let's reset\n\n        console.log('TRYING AGAIN');\n\n        if (this.loginCounter <= this.ENABLED_RELAY_SERVERS.length) {\n          this.loginCounter++;\n          this.start();\n          return;\n        } else {\n          throw new Error('Too many login attempts. Try again later.');\n        }\n      }\n\n      console.log('client is ready');\n      this.client.resolve(client);\n    });\n  }\n\n  stop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.client.isResolved()) {\n        yield (yield this.client.promise).stop().catch(error => logger.error(error));\n      }\n\n      yield this.reset();\n    });\n  }\n\n  reset() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.storage.delete(StorageKey.MATRIX_PEER_ROOM_IDS).catch(error => logger.log(error));\n      yield this.storage.delete(StorageKey.MATRIX_PRESERVED_STATE).catch(error => logger.log(error));\n      yield this.storage.delete(StorageKey.MATRIX_SELECTED_NODE).catch(error => logger.log(error)); // Instead of resetting everything, maybe we should make sure a new instance is created?\n\n      this.relayServer = undefined;\n      this.client = new ExposedPromise();\n      this.initialEvent = undefined;\n      this.initialListener = undefined;\n    });\n  }\n\n  listenForEncryptedMessage(senderPublicKey, messageCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.activeListeners.has(senderPublicKey)) {\n        return;\n      }\n\n      const {\n        sharedRx\n      } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n\n      const callbackFunction = event => __awaiter(this, void 0, void 0, function* () {\n        if (this.isTextMessage(event.content) && (yield this.isSender(event, senderPublicKey))) {\n          let payload;\n          yield this.updateRelayServer(event.content.message.sender);\n          yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n\n          try {\n            payload = Buffer.from(event.content.message.content, 'hex'); // content can be non-hex if it's a connection open request\n          } catch (_a) {\n            /* */\n          }\n\n          if (payload && payload.length >= crypto_secretbox_NONCEBYTES + crypto_secretbox_MACBYTES) {\n            try {\n              const decryptedMessage = yield decryptCryptoboxPayload(payload, sharedRx); // logger.log(\n              //   'listenForEncryptedMessage',\n              //   'encrypted message received',\n              //   decryptedMessage,\n              //   await new Serializer().deserialize(decryptedMessage)\n              // )\n              // console.log('calculated sender ID', await getSenderId(senderPublicKey))\n              // TODO: Add check for correct decryption key / sender ID\n\n              messageCallback(decryptedMessage);\n            } catch (decryptionError) {\n              /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n            }\n          }\n        }\n      });\n\n      this.activeListeners.set(senderPublicKey, callbackFunction);\n      (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, callbackFunction);\n      const lastEvent = this.initialEvent;\n\n      if (lastEvent && lastEvent.timestamp && new Date().getTime() - lastEvent.timestamp < 5 * 60 * 1000) {\n        logger.log('listenForEncryptedMessage', 'Handling previous event');\n        yield callbackFunction(lastEvent);\n      } else {\n        logger.log('listenForEncryptedMessage', 'No previous event found');\n      }\n\n      const initialListener = this.initialListener;\n\n      if (initialListener) {\n        ;\n        (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, initialListener);\n      }\n\n      this.initialListener = undefined;\n      this.initialEvent = undefined;\n    });\n  }\n\n  unsubscribeFromEncryptedMessage(senderPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const listener = this.activeListeners.get(senderPublicKey);\n\n      if (!listener) {\n        return;\n      }\n\n      ;\n      (yield this.client.promise).unsubscribe(MatrixClientEventType.MESSAGE, listener);\n      this.activeListeners.delete(senderPublicKey);\n    });\n  }\n\n  unsubscribeFromEncryptedMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      ;\n      (yield this.client.promise).unsubscribeAll(MatrixClientEventType.MESSAGE);\n      this.activeListeners.clear();\n    });\n  }\n\n  sendMessage(message, peer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        sharedTx\n      } = yield this.createCryptoBoxClient(peer.publicKey, this.keyPair.privateKey);\n      const recipientHash = yield getHexHash(Buffer.from(peer.publicKey, 'hex'));\n      const recipient = recipientString(recipientHash, peer.relayServer);\n      const roomId = yield this.getRelevantRoom(recipient); // Before we send the message, we have to wait for the join to be accepted.\n\n      yield this.waitForJoin(roomId); // TODO: This can probably be removed because we are now waiting inside the get room method\n\n      const encryptedMessage = yield encryptCryptoboxPayload(message, sharedTx);\n      (yield this.client.promise).sendTextMessage(roomId, encryptedMessage).catch(error => __awaiter(this, void 0, void 0, function* () {\n        if (error.errcode === 'M_FORBIDDEN') {\n          // Room doesn't exist\n          logger.log(`sendMessage`, `M_FORBIDDEN`, error);\n          yield this.deleteRoomIdFromRooms(roomId);\n          const newRoomId = yield this.getRelevantRoom(recipient);\n          (yield this.client.promise).sendTextMessage(newRoomId, encryptedMessage).catch(error2 => __awaiter(this, void 0, void 0, function* () {\n            logger.log(`sendMessage`, `inner error`, error2);\n          }));\n        } else {\n          logger.log(`sendMessage`, `not forbidden`, error);\n        }\n      }));\n    });\n  }\n\n  updatePeerRoom(sender, roomId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n      const split = sender.split(':');\n\n      if (split.length < 2 || !split[0].startsWith('@')) {\n        throw new Error('Invalid sender');\n      }\n\n      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n      const room = roomIds[sender];\n\n      if (room && room[1]) {\n        // If we have a room already, let's ignore it. We need to do this, otherwise it will be loaded from the matrix cache.\n        this.ignoredRooms.push(room[1]);\n      }\n\n      roomIds[sender] = roomId;\n      yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds); // TODO: We also need to delete the room from the sync state\n      // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n    });\n  }\n\n  deleteRoomIdFromRooms(roomId) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n      const newRoomIds = Object.entries(roomIds).filter(entry => entry[1] !== roomId).reduce((pv, cv) => Object.assign(Object.assign({}, pv), {\n        [cv[0]]: cv[1]\n      }), {});\n      yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, newRoomIds); // TODO: We also need to delete the room from the sync state\n      // If we need to delete a room, we can assume the local state is not up to date anymore, so we can reset the state\n\n      this.ignoredRooms.push(roomId);\n    });\n  }\n\n  listenForChannelOpening(messageCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      ;\n      (yield this.client.promise).subscribe(MatrixClientEventType.MESSAGE, event => __awaiter(this, void 0, void 0, function* () {\n        if (this.isTextMessage(event.content) && (yield this.isChannelOpenMessage(event.content))) {\n          logger.log(`listenForChannelOpening`, `channel opening`, JSON.stringify(event));\n          yield this.updateRelayServer(event.content.message.sender);\n          yield this.updatePeerRoom(event.content.message.sender, event.content.roomId);\n          const splits = event.content.message.content.split(':');\n          const payload = Buffer.from(splits[splits.length - 1], 'hex');\n\n          if (payload.length >= crypto_secretbox_NONCEBYTES + crypto_secretbox_MACBYTES) {\n            try {\n              const pairingResponse = JSON.parse(yield openCryptobox(payload, this.keyPair.publicKey, this.keyPair.privateKey));\n              messageCallback(Object.assign(Object.assign({}, pairingResponse), {\n                senderId: yield getSenderId(pairingResponse.publicKey)\n              }));\n            } catch (decryptionError) {\n              /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n            }\n          }\n        }\n      }));\n    });\n  }\n\n  waitForJoin(roomId, retry = 0) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Rooms are updated as new events come in. `client.getRoomById` only accesses memory, it does not do any network requests.\n      // TODO: Improve to listen to \"JOIN\" event\n      const room = yield (yield this.client.promise).getRoomById(roomId);\n      logger.log(`waitForJoin`, `Currently ${room.members.length} members, we need at least 2`);\n\n      if (room.members.length >= 2 || room.members.length === 0) {\n        // 0 means it's an unknown room, we don't need to wait\n        return;\n      } else {\n        if (retry <= 200) {\n          // On mobile, due to app switching, we potentially have to wait for a long time\n          logger.log(`Waiting for join... Try: ${retry}`);\n          return new Promise(resolve => {\n            setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n              resolve(this.waitForJoin(roomId, retry + 1));\n            }), 100 * (retry > 50 ? 10 : 1)); // After the initial 5 seconds, retry only once per second\n          });\n        } else {\n          throw new Error(`No one joined after ${retry} tries.`);\n        }\n      }\n    });\n  }\n\n  sendPairingResponse(pairingRequest) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log(`sendPairingResponse`);\n      const recipientHash = yield getHexHash(Buffer.from(pairingRequest.publicKey, 'hex'));\n      const recipient = recipientString(recipientHash, pairingRequest.relayServer); // We force room creation here because if we \"re-pair\", we need to make sure that we don't send it to an old room.\n\n      const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);\n      yield this.updatePeerRoom(recipient, roomId); // Before we send the message, we have to wait for the join to be accepted.\n\n      yield this.waitForJoin(roomId); // TODO: This can probably be removed because we are now waiting inside the get room method\n      // TODO: remove v1 backwards-compatibility\n\n      const message = typeof pairingRequest.version === 'undefined' ? yield this.getPublicKey() // v1\n      : JSON.stringify(yield this.getPairingResponseInfo(pairingRequest)); // v2\n\n      const encryptedMessage = yield this.encryptMessageAsymmetric(pairingRequest.publicKey, message);\n      const msg = ['@channel-open', recipient, encryptedMessage].join(':');\n      (yield this.client.promise).sendTextMessage(roomId, msg).catch(error => __awaiter(this, void 0, void 0, function* () {\n        if (error.errcode === 'M_FORBIDDEN') {\n          // Room doesn't exist\n          logger.log(`sendMessage`, `M_FORBIDDEN`, error);\n          yield this.deleteRoomIdFromRooms(roomId);\n          const newRoomId = yield this.getRelevantRoom(recipient);\n          (yield this.client.promise).sendTextMessage(newRoomId, msg).catch(error2 => __awaiter(this, void 0, void 0, function* () {\n            logger.log(`sendMessage`, `inner error`, error2);\n          }));\n        } else {\n          logger.log(`sendMessage`, `not forbidden`, error);\n        }\n      }));\n    });\n  }\n\n  isTextMessage(content) {\n    return content.message.type === MatrixMessageType.TEXT;\n  }\n\n  updateRelayServer(sender) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Sender is in the format \"@pubkeyhash:relayserver.tld\"\n      const split = sender.split(':');\n\n      if (split.length < 2 || !split[0].startsWith('@')) {\n        throw new Error('Invalid sender');\n      }\n\n      const senderHash = split.shift();\n      const relayServer = split.join(':');\n      const manager = localStorage.getItem('beacon:communication-peers-dapp') ? new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_DAPP) : new PeerManager(this.storage, StorageKey.TRANSPORT_P2P_PEERS_WALLET);\n      const peers = yield manager.getPeers();\n      const promiseArray = peers.map(peer => __awaiter(this, void 0, void 0, function* () {\n        const hash = `@${yield getHexHash(Buffer.from(peer.publicKey, 'hex'))}`;\n\n        if (hash === senderHash) {\n          if (peer.relayServer !== relayServer) {\n            peer.relayServer = relayServer;\n            yield manager.addPeer(peer);\n          }\n        }\n      }));\n      yield Promise.all(promiseArray);\n    });\n  }\n\n  isChannelOpenMessage(content) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return content.message.content.startsWith(`@channel-open:@${yield getHexHash(Buffer.from(yield this.getPublicKey(), 'hex'))}`);\n    });\n  }\n\n  isSender(event, senderPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return event.content.message.sender.startsWith(`@${yield getHexHash(Buffer.from(senderPublicKey, 'hex'))}`);\n    });\n  }\n\n  getRelevantRoom(recipient) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const roomIds = yield this.storage.get(StorageKey.MATRIX_PEER_ROOM_IDS);\n      let roomId = roomIds[recipient];\n\n      if (!roomId) {\n        logger.log(`getRelevantRoom`, `No room found for peer ${recipient}, checking joined ones.`);\n        const room = yield this.getRelevantJoinedRoom(recipient);\n        roomId = room.id;\n        roomIds[recipient] = room.id;\n        yield this.storage.set(StorageKey.MATRIX_PEER_ROOM_IDS, roomIds);\n      }\n\n      logger.log(`getRelevantRoom`, `Using room ${roomId}`);\n      return roomId;\n    });\n  }\n\n  getRelevantJoinedRoom(recipient) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const joinedRooms = yield (yield this.client.promise).joinedRooms;\n      logger.log('checking joined rooms', joinedRooms, recipient);\n      const relevantRooms = joinedRooms.filter(roomElement => !this.ignoredRooms.some(id => roomElement.id === id)).filter(roomElement => roomElement.members.some(member => member === recipient));\n      let room; // We always create a new room if one has been ignored. This is because if we ignore one, we know the server state changed.\n      // So we cannot trust the current sync state. This can be removed once we have a method to properly clear and refresh the sync state.\n\n      if (relevantRooms.length === 0 || this.ignoredRooms.length > 0) {\n        logger.log(`getRelevantJoinedRoom`, `no relevant rooms found, creating new one`);\n        const roomId = yield (yield this.client.promise).createTrustedPrivateRoom(recipient);\n        room = yield (yield this.client.promise).getRoomById(roomId);\n        logger.log(`getRelevantJoinedRoom`, `waiting for other party to join room: ${room.id}`);\n        yield this.waitForJoin(roomId);\n        logger.log(`getRelevantJoinedRoom`, `new room created and peer invited: ${room.id}`);\n      } else {\n        room = relevantRooms[0];\n        logger.log(`getRelevantJoinedRoom`, `channel already open, reusing room ${room.id}`);\n      }\n\n      return room;\n    });\n  }\n\n}","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAEEA,KAFF,EAGEC,kBAHF,EAIEC,WAJF,EAKEC,oBALF,EAMEC,2BANF,EAOEC,yBAPF,QAQO,oBARP;AASA,OAAOC,KAAP,MAAkB,OAAlB;AACA,SACEC,UADF,EAEEC,KAFF,EAGEC,eAHF,EAIEC,aAJF,EAKEC,uBALF,EAMEC,uBANF,QAOO,sBAPP;AAQA,SAASC,YAAT,QAA6B,+BAA7B;AACA,SAEEC,qBAFF,QAIO,2CAJP;AAKA,SAASC,iBAAT,QAAkC,uCAAlC;AAEA,SAGEC,UAHF,QAMO,sBANP;AAOA,SACEC,WADF,EAEEC,cAFF,EAGEC,WAHF,EAIEC,MAJF,EAKEC,mBALF,QAMO,qBANP;AAOA,SAASC,cAAT,EAAyBC,YAAzB,QAA6C,sBAA7C;AAEA,MAAMC,MAAM,GAAG,IAAIJ,MAAJ,CAAW,wBAAX,CAAf;AAEA,OAAO,MAAMK,mBAAmB,GAAG,CACjC,mCADiC,EAEjC,+BAFiC,EAGjC,+BAHiC,EAIjC,gCAJiC,EAKjC,kCALiC,EAMjC,kCANiC,EAOjC,kCAPiC,EAQjC,kCARiC,CAA5B;AAWP;;;;AAGA,OAAM,MAAOC,sBAAP,SAAsCL,mBAAtC,CAAyD;EAgB7DM,YACmBC,IADnB,EAEEC,OAFF,EAGkBC,gBAHlB,EAImBC,OAJnB,EAKEC,WALF,EAMmBC,OANnB,EAOmBC,MAPnB,EAOkC;IAEhC,MAAML,OAAN;IARiB;IAED;IACC;IAEA;IACA;IAtBX,cAAuC,IAAIP,cAAJ,EAAvC;IAUS,uBAAwE,IAAIa,GAAJ,EAAxE;IAEA,oBAAyB,EAAzB;IACT,oBAAuB,CAAvB;IAaNX,MAAM,CAACY,GAAP,CAAW,aAAX,EAA0B,gCAA1B;IACA,MAAMC,KAAK,GAAGL,WAAW,CAACM,MAAZ,GAAqB,CAArB,GAAyBN,WAAzB,GAAuCP,mBAArD;IACA,KAAKc,qBAAL,GAA6BF,KAA7B;EACD;;EAEYG,qBAAqB;;MAChC,MAAMC,IAAI,GAAsB;QAC9BC,EAAE,EAAE,MAAMnB,YAAY,EADQ;QAE9BoB,IAAI,EAAE,qBAFwB;QAG9Bf,IAAI,EAAE,KAAKA,IAHmB;QAI9BgB,OAAO,EAAE1B,cAJqB;QAK9B2B,SAAS,EAAE,MAAM,KAAKC,YAAL,EALa;QAM9BC,WAAW,EAAE,MAAM,KAAKC,cAAL;MANW,CAAhC;;MASA,IAAI,KAAKf,OAAT,EAAkB;QAChBQ,IAAI,CAACQ,IAAL,GAAY,KAAKhB,OAAjB;MACD;;MACD,IAAI,KAAKC,MAAT,EAAiB;QACfO,IAAI,CAACP,MAAL,GAAc,KAAKA,MAAnB;MACD;;MAED,OAAOO,IAAP;IACD;EAAA;;EAEYS,sBAAsB,CAACC,OAAD,EAA2B;;MAC5D,MAAMV,IAAI,GAAuB;QAC/BC,EAAE,EAAES,OAAO,CAACT,EADmB;QAE/BC,IAAI,EAAE,sBAFyB;QAG/Bf,IAAI,EAAE,KAAKA,IAHoB;QAI/BgB,OAAO,EAAE1B,cAJsB;QAK/B2B,SAAS,EAAE,MAAM,KAAKC,YAAL,EALc;QAM/BC,WAAW,EAAE,MAAM,KAAKC,cAAL;MANY,CAAjC;;MASA,IAAI,KAAKf,OAAT,EAAkB;QAChBQ,IAAI,CAACQ,IAAL,GAAY,KAAKhB,OAAjB;MACD;;MACD,IAAI,KAAKC,MAAT,EAAiB;QACfO,IAAI,CAACP,MAAL,GAAc,KAAKA,MAAnB;MACD;;MAED,OAAOO,IAAP;IACD;EAAA;;EAEYO,cAAc;;MACzB,IAAI,KAAKD,WAAT,EAAsB;QACpB,OAAO,KAAKA,WAAL,CAAiBK,OAAxB;MACD,CAFD,MAEO;QACL,KAAKL,WAAL,GAAmB,IAAIzB,cAAJ,EAAnB;MACD;;MAED,MAAM+B,IAAI,GAAG,MAAM,KAAKtB,OAAL,CAAauB,GAAb,CAAiBtC,UAAU,CAACuC,oBAA5B,CAAnB;;MACA,IAAIF,IAAI,IAAIA,IAAI,CAACf,MAAL,GAAc,CAA1B,EAA6B;QAC3B,KAAKS,WAAL,CAAiBS,OAAjB,CAAyBH,IAAzB;QACA,OAAOA,IAAP;MACD;;MAED,MAAMhB,KAAK,GAAG,CAAC,GAAG,KAAKE,qBAAT,CAAd;;MAEA,OAAOF,KAAK,CAACC,MAAN,GAAe,CAAtB,EAAyB;QACvB,MAAMmB,KAAK,GAAGC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgBvB,KAAK,CAACC,MAAjC,CAAd;QACA,MAAMuB,MAAM,GAAGxB,KAAK,CAACoB,KAAD,CAApB;;QAEA,IAAI;UACF,MAAMnD,KAAK,CAACgD,GAAN,CAAU,WAAWO,MAAM,0BAA3B,CAAN;UACA,KAAK9B,OAAL,CACG+B,GADH,CACO9C,UAAU,CAACuC,oBADlB,EACwCM,MADxC,EAEGE,KAFH,CAEUC,KAAD,IAAWxC,MAAM,CAACY,GAAP,CAAW4B,KAAX,CAFpB;UAIA,KAAKjB,WAAL,CAAiBS,OAAjB,CAAyBK,MAAzB;UACA,OAAOA,MAAP;QACD,CARD,CAQE,OAAOI,UAAP,EAAmB;UACnBzC,MAAM,CAACY,GAAP,CAAW,oBAAoByB,MAAM,0BAArC;UACAxB,KAAK,CAAC6B,MAAN,CAAaT,KAAb,EAAoB,CAApB;QACD;MACF;;MAED,KAAKV,WAAL,CAAiBoB,MAAjB,CAAwB,6BAAxB;MACA,MAAM,IAAIC,KAAJ,CAAU,6BAAV,CAAN;IACD;EAAA;;EAEYC,YAAY,CAACC,MAAD,EAAiBC,QAAgB,CAAjC,EAAkC;;MACzD,IAAI;QACF,MAAM,CAAC,MAAM,KAAKC,MAAL,CAAYpB,OAAnB,EAA4BqB,SAA5B,CAAsCH,MAAtC,CAAN;MACD,CAFD,CAEE,OAAON,KAAP,EAAc;QACd,IAAIO,KAAK,IAAI,EAAT,IAAgBP,KAAa,CAACU,OAAd,KAA0B,aAA9C,EAA6D;UAC3D;UACAlD,MAAM,CAACY,GAAP,CAAW,qBAAX,EAAkC4B,KAAlC;UACAW,UAAU,CAAC,MAAWC;YACpB,MAAM,KAAKP,YAAL,CAAkBC,MAAlB,EAA0BC,KAAK,GAAG,CAAlC,CAAN;UACD,CAFqB,CAAZ,EAEP,GAFO,CAAV;QAGD,CAND,MAMO;UACL/C,MAAM,CAACY,GAAP,CAAW,wBAAwBmC,KAAK,SAAxC,EAAmDP,KAAnD;QACD;MACF;IACF;EAAA;;EAEYa,KAAK;;MAChBrD,MAAM,CAACY,GAAP,CAAW,OAAX,EAAoB,iBAApB;MAEA,MAAMpC,KAAN;MAEA,MAAM8E,cAAc,GAAG7E,kBAAkB,CACvC,EADuC,EAEvCC,WAAW,CAAC,SAASwD,IAAI,CAACC,KAAL,CAAWoB,IAAI,CAACC,GAAL,KAAa,IAAb,IAAqB,IAAI,EAAzB,CAAX,CAAwC,EAAlD,CAF4B,CAAzC;MAIA,MAAMC,YAAY,GAAG9E,oBAAoB,CAAC2E,cAAD,EAAiB,KAAKjD,OAAL,CAAaqD,UAA9B,CAAzC;MAEA1D,MAAM,CAACY,GAAP,CAAW,OAAX,EAAoB,sBAApB;MAEA,MAAMW,WAAW,GAAG,MAAM,KAAKC,cAAL,EAA1B;MAEA,MAAMwB,MAAM,GAAG3D,YAAY,CAACsE,MAAb,CAAoB;QACjCC,OAAO,EAAE,WAAWrC,WAAW,EADE;QAEjChB,OAAO,EAAE,KAAKA;MAFmB,CAApB,CAAf;;MAKA,KAAKsD,eAAL,GACEC,KADqB,IAEJV;QACjB,IAAI,KAAKW,YAAL,IAAqB,KAAKA,YAAL,CAAkBC,SAAvC,IAAoDF,KAApD,IAA6DA,KAAK,CAACE,SAAvE,EAAkF;UAChF,IAAI,KAAKD,YAAL,CAAkBC,SAAlB,GAA8BF,KAAK,CAACE,SAAxC,EAAmD;YACjD,KAAKD,YAAL,GAAoBD,KAApB;UACD;QACF,CAJD,MAIO;UACL,KAAKC,YAAL,GAAoBD,KAApB;QACD;MACF,CARkB,CAFnB;;MAWAd,MAAM,CAACiB,SAAP,CAAiB3E,qBAAqB,CAAC4E,OAAvC,EAAgD,KAAKL,eAArD;MAEAb,MAAM,CAACiB,SAAP,CAAiB3E,qBAAqB,CAAC6E,MAAvC,EAAsDL,KAAP,IAAgBV;QAC7D,IAAIgB,MAAJ;;QACA,IAAIN,KAAK,CAACO,OAAN,CAAcC,OAAd,CAAsBxD,MAAtB,KAAiC,CAArC,EAAwC;UACtC;UACA;UACAsD,MAAM,GAAGN,KAAK,CAACO,OAAN,CAAcC,OAAd,CAAsB,CAAtB,CAAT;QACD;;QAED,MAAM,KAAKzB,YAAL,CAAkBiB,KAAK,CAACO,OAAN,CAAcvB,MAAhC,CAAN;;QAEA,IAAIsB,MAAJ,EAAY;UACV,MAAM,KAAKG,iBAAL,CAAuBH,MAAvB,CAAN;UACA,MAAM,KAAKI,cAAL,CAAoBJ,MAApB,EAA4BN,KAAK,CAACO,OAAN,CAAcvB,MAA1C,CAAN;QACD;MACF,CAd8D,CAA/D;MAgBA9C,MAAM,CAACY,GAAP,CAAW,OAAX,EAAoB,OAApB,EAA6B,MAAM,KAAK6D,gBAAL,EAAnC,EAA4D,IAA5D,EAAkElD,WAAlE;;MAEA,IAAI;QACF,MAAMyB,MAAM,CAACK,KAAP,CAAa;UACjBnC,EAAE,EAAE,MAAM,KAAKuD,gBAAL,EADO;UAEjBC,QAAQ,EAAE,MAAM1F,KAAK,CAACyE,YAAD,CAAc,IAAI,MAAM,KAAKnC,YAAL,EAAmB,EAF/C;UAGjBqD,QAAQ,EAAE3F,KAAK,CAAC,KAAKqB,OAAL,CAAagB,SAAd;QAHE,CAAb,CAAN;MAKD,CAND,CAME,OAAOmB,KAAP,EAAc;QACdoC,OAAO,CAAChE,GAAR,CAAY,iBAAZ;QACA,MAAM,KAAKiE,KAAL,EAAN,CAFc,CAEK;;QACnBD,OAAO,CAAChE,GAAR,CAAY,cAAZ;;QACA,IAAI,KAAKkE,YAAL,IAAqB,KAAK/D,qBAAL,CAA2BD,MAApD,EAA4D;UAC1D,KAAKgE,YAAL;UACA,KAAKzB,KAAL;UACA;QACD,CAJD,MAIO;UACL,MAAM,IAAIT,KAAJ,CAAU,2CAAV,CAAN;QACD;MACF;;MAEDgC,OAAO,CAAChE,GAAR,CAAY,iBAAZ;MACA,KAAKoC,MAAL,CAAYhB,OAAZ,CAAoBgB,MAApB;IACD;EAAA;;EAEY+B,IAAI;;MACf,IAAI,KAAK/B,MAAL,CAAYgC,UAAZ,EAAJ,EAA8B;QAC5B,MAAM,CAAC,MAAM,KAAKhC,MAAL,CAAYpB,OAAnB,EAA4BmD,IAA5B,GAAmCxC,KAAnC,CAA0CC,KAAD,IAAWxC,MAAM,CAACwC,KAAP,CAAaA,KAAb,CAApD,CAAN;MACD;;MACD,MAAM,KAAKqC,KAAL,EAAN;IACD;EAAA;;EAEYA,KAAK;;MAChB,MAAM,KAAKtE,OAAL,CAAa0E,MAAb,CAAoBzF,UAAU,CAAC0F,oBAA/B,EAAqD3C,KAArD,CAA4DC,KAAD,IAAWxC,MAAM,CAACY,GAAP,CAAW4B,KAAX,CAAtE,CAAN;MACA,MAAM,KAAKjC,OAAL,CAAa0E,MAAb,CAAoBzF,UAAU,CAAC2F,sBAA/B,EAAuD5C,KAAvD,CAA8DC,KAAD,IAAWxC,MAAM,CAACY,GAAP,CAAW4B,KAAX,CAAxE,CAAN;MACA,MAAM,KAAKjC,OAAL,CAAa0E,MAAb,CAAoBzF,UAAU,CAACuC,oBAA/B,EAAqDQ,KAArD,CAA4DC,KAAD,IAAWxC,MAAM,CAACY,GAAP,CAAW4B,KAAX,CAAtE,CAAN,EACA;;MACA,KAAKjB,WAAL,GAAmB6D,SAAnB;MACA,KAAKpC,MAAL,GAAc,IAAIlD,cAAJ,EAAd;MACA,KAAKiE,YAAL,GAAoBqB,SAApB;MACA,KAAKvB,eAAL,GAAuBuB,SAAvB;IACD;EAAA;;EAEYC,yBAAyB,CACpCC,eADoC,EAEpCC,eAFoC,EAEM;;MAE1C,IAAI,KAAKC,eAAL,CAAqBC,GAArB,CAAyBH,eAAzB,CAAJ,EAA+C;QAC7C;MACD;;MAED,MAAM;QAAEI;MAAF,IAAe,MAAM,KAAKC,qBAAL,CAA2BL,eAA3B,EAA4C,KAAKjF,OAAL,CAAaqD,UAAzD,CAA3B;;MAEA,MAAMkC,gBAAgB,GACpB9B,KADuB,IAENV;QACjB,IAAI,KAAKyC,aAAL,CAAmB/B,KAAK,CAACO,OAAzB,MAAsC,MAAM,KAAKyB,QAAL,CAAchC,KAAd,EAAqBwB,eAArB,CAA5C,CAAJ,EAAwF;UACtF,IAAIS,OAAJ;UAEA,MAAM,KAAKxB,iBAAL,CAAuBT,KAAK,CAACO,OAAN,CAAc2B,OAAd,CAAsBC,MAA7C,CAAN;UACA,MAAM,KAAKzB,cAAL,CAAoBV,KAAK,CAACO,OAAN,CAAc2B,OAAd,CAAsBC,MAA1C,EAAkDnC,KAAK,CAACO,OAAN,CAAcvB,MAAhE,CAAN;;UAEA,IAAI;YACFiD,OAAO,GAAGG,MAAM,CAACC,IAAP,CAAYrC,KAAK,CAACO,OAAN,CAAc2B,OAAd,CAAsB3B,OAAlC,EAA2C,KAA3C,CAAV,CADE,CAEF;UACD,CAHD,CAGE,WAAM;YACN;UACD;;UACD,IAAI0B,OAAO,IAAIA,OAAO,CAACjF,MAAR,IAAkBlC,2BAA2B,GAAGC,yBAA/D,EAA0F;YACxF,IAAI;cACF,MAAMuH,gBAAgB,GAAG,MAAMhH,uBAAuB,CAAC2G,OAAD,EAAUL,QAAV,CAAtD,CADE,CAGF;cACA;cACA;cACA;cACA;cACA;cACA;cACA;;cAEAH,eAAe,CAACa,gBAAD,CAAf;YACD,CAbD,CAaE,OAAOC,eAAP,EAAwB;cACxB;YACD;UACF;QACF;MACF,CAhCkB,CAFnB;;MAoCA,KAAKb,eAAL,CAAqBlD,GAArB,CAAyBgD,eAAzB,EAA0CM,gBAA1C;MACC,CAAC,MAAM,KAAK5C,MAAL,CAAYpB,OAAnB,EAA4BqC,SAA5B,CAAsC3E,qBAAqB,CAAC4E,OAA5D,EAAqE0B,gBAArE;MAED,MAAMU,SAAS,GAAG,KAAKvC,YAAvB;;MACA,IACEuC,SAAS,IACTA,SAAS,CAACtC,SADV,IAEA,IAAIT,IAAJ,GAAWgD,OAAX,KAAuBD,SAAS,CAACtC,SAAjC,GAA6C,IAAI,EAAJ,GAAS,IAHxD,EAIE;QACAhE,MAAM,CAACY,GAAP,CAAW,2BAAX,EAAwC,yBAAxC;QACA,MAAMgF,gBAAgB,CAACU,SAAD,CAAtB;MACD,CAPD,MAOO;QACLtG,MAAM,CAACY,GAAP,CAAW,2BAAX,EAAwC,yBAAxC;MACD;;MAED,MAAMiD,eAAe,GAAG,KAAKA,eAA7B;;MACA,IAAIA,eAAJ,EAAqB;QACnB;QAAC,CAAC,MAAM,KAAKb,MAAL,CAAYpB,OAAnB,EAA4B4E,WAA5B,CAAwClH,qBAAqB,CAAC4E,OAA9D,EAAuEL,eAAvE;MACF;;MACD,KAAKA,eAAL,GAAuBuB,SAAvB;MACA,KAAKrB,YAAL,GAAoBqB,SAApB;IACD;EAAA;;EAEYqB,+BAA+B,CAACnB,eAAD,EAAwB;;MAClE,MAAMoB,QAAQ,GAAG,KAAKlB,eAAL,CAAqB1D,GAArB,CAAyBwD,eAAzB,CAAjB;;MACA,IAAI,CAACoB,QAAL,EAAe;QACb;MACD;;MAED;MAAC,CAAC,MAAM,KAAK1D,MAAL,CAAYpB,OAAnB,EAA4B4E,WAA5B,CAAwClH,qBAAqB,CAAC4E,OAA9D,EAAuEwC,QAAvE;MAED,KAAKlB,eAAL,CAAqBP,MAArB,CAA4BK,eAA5B;IACD;EAAA;;EAEYqB,gCAAgC;;MAC3C;MAAC,CAAC,MAAM,KAAK3D,MAAL,CAAYpB,OAAnB,EAA4BgF,cAA5B,CAA2CtH,qBAAqB,CAAC4E,OAAjE;MAED,KAAKsB,eAAL,CAAqBqB,KAArB;IACD;EAAA;;EAEYC,WAAW,CACtBd,OADsB,EAEtBe,IAFsB,EAE8B;;MAEpD,MAAM;QAAEC;MAAF,IAAe,MAAM,KAAKC,qBAAL,CAA2BF,IAAI,CAAC1F,SAAhC,EAA2C,KAAKhB,OAAL,CAAaqD,UAAxD,CAA3B;MAEA,MAAMwD,aAAa,GAAW,MAAMnI,UAAU,CAACmH,MAAM,CAACC,IAAP,CAAYY,IAAI,CAAC1F,SAAjB,EAA4B,KAA5B,CAAD,CAA9C;MACA,MAAM8F,SAAS,GAAGlI,eAAe,CAACiI,aAAD,EAAgBH,IAAI,CAACxF,WAArB,CAAjC;MAEA,MAAMuB,MAAM,GAAG,MAAM,KAAKsE,eAAL,CAAqBD,SAArB,CAArB,EAEA;;MACA,MAAM,KAAKE,WAAL,CAAiBvE,MAAjB,CAAN,EAA+B;;MAE/B,MAAMwE,gBAAgB,GAAG,MAAMnI,uBAAuB,CAAC6G,OAAD,EAAUgB,QAAV,CAAtD;MAWC,CAAC,MAAM,KAAKhE,MAAL,CAAYpB,OAAnB,EAA4B2F,eAA5B,CAA4CzE,MAA5C,EAAoDwE,gBAApD,EAAsE/E,KAAtE,CAAmFC,KAAP,IAAgBY;QAC3F,IAAIZ,KAAK,CAACU,OAAN,KAAkB,aAAtB,EAAqC;UACnC;UACAlD,MAAM,CAACY,GAAP,CAAW,aAAX,EAA0B,aAA1B,EAAyC4B,KAAzC;UACA,MAAM,KAAKgF,qBAAL,CAA2B1E,MAA3B,CAAN;UACA,MAAM2E,SAAS,GAAG,MAAM,KAAKL,eAAL,CAAqBD,SAArB,CAAxB;UAEC,CAAC,MAAM,KAAKnE,MAAL,CAAYpB,OAAnB,EACE2F,eADF,CACkBE,SADlB,EAC6BH,gBAD7B,EAEE/E,KAFF,CAEemF,MAAP,IAAiBtE;YACtBpD,MAAM,CAACY,GAAP,CAAW,aAAX,EAA0B,aAA1B,EAAyC8G,MAAzC;UACD,CAFuB,CAFzB;QAKF,CAXD,MAWO;UACL1H,MAAM,CAACY,GAAP,CAAW,aAAX,EAA0B,eAA1B,EAA2C4B,KAA3C;QACD;MACF,CAf4F,CAA5F;IAgBF;EAAA;;EAEYgC,cAAc,CAACyB,MAAD,EAAiBnD,MAAjB,EAA+B;;MACxD;MACA,MAAM6E,KAAK,GAAG1B,MAAM,CAAC0B,KAAP,CAAa,GAAb,CAAd;;MACA,IAAIA,KAAK,CAAC7G,MAAN,GAAe,CAAf,IAAoB,CAAC6G,KAAK,CAAC,CAAD,CAAL,CAASC,UAAT,CAAoB,GAApB,CAAzB,EAAmD;QACjD,MAAM,IAAIhF,KAAJ,CAAU,gBAAV,CAAN;MACD;;MAED,MAAMiF,OAAO,GAAG,MAAM,KAAKtH,OAAL,CAAauB,GAAb,CAAiBtC,UAAU,CAAC0F,oBAA5B,CAAtB;MAEA,MAAM4C,IAAI,GAAGD,OAAO,CAAC5B,MAAD,CAApB;;MAEA,IAAI6B,IAAI,IAAIA,IAAI,CAAC,CAAD,CAAhB,EAAqB;QACnB;QACA,KAAKC,YAAL,CAAkBC,IAAlB,CAAuBF,IAAI,CAAC,CAAD,CAA3B;MACD;;MAEDD,OAAO,CAAC5B,MAAD,CAAP,GAAkBnD,MAAlB;MAEA,MAAM,KAAKvC,OAAL,CAAa+B,GAAb,CAAiB9C,UAAU,CAAC0F,oBAA5B,EAAkD2C,OAAlD,CAAN,EAEA;MACA;IACD;EAAA;;EAEYL,qBAAqB,CAAC1E,MAAD,EAAe;;MAC/C,MAAM+E,OAAO,GAAG,MAAM,KAAKtH,OAAL,CAAauB,GAAb,CAAiBtC,UAAU,CAAC0F,oBAA5B,CAAtB;MACA,MAAM+C,UAAU,GAAGC,MAAM,CAACC,OAAP,CAAeN,OAAf,EAChBO,MADgB,CACRC,KAAD,IAAWA,KAAK,CAAC,CAAD,CAAL,KAAavF,MADf,EAEhBwF,MAFgB,CAGf,CAACC,EAAD,EAAKC,EAAL,KAAYN,gCAAMK,EAAN,GAAQ;QAAE,CAACC,EAAE,CAAC,CAAD,CAAH,GAASA,EAAE,CAAC,CAAD;MAAb,CAAR,CAHG,EAIf,EAJe,CAAnB;MAQA,MAAM,KAAKjI,OAAL,CAAa+B,GAAb,CAAiB9C,UAAU,CAAC0F,oBAA5B,EAAkD+C,UAAlD,CAAN,EAEA;MACA;;MAEA,KAAKF,YAAL,CAAkBC,IAAlB,CAAuBlF,MAAvB;IACD;EAAA;;EAEY2F,uBAAuB,CAClClD,eADkC,EACoC;;MAEtE;MAAC,CAAC,MAAM,KAAKvC,MAAL,CAAYpB,OAAnB,EAA4BqC,SAA5B,CAAsC3E,qBAAqB,CAAC4E,OAA5D,EAA4EJ,KAAP,IAAgBV;QACpF,IAAI,KAAKyC,aAAL,CAAmB/B,KAAK,CAACO,OAAzB,MAAsC,MAAM,KAAKqE,oBAAL,CAA0B5E,KAAK,CAACO,OAAhC,CAA5C,CAAJ,EAA2F;UACzFrE,MAAM,CAACY,GAAP,CAAW,yBAAX,EAAsC,iBAAtC,EAAyD+H,IAAI,CAACC,SAAL,CAAe9E,KAAf,CAAzD;UAEA,MAAM,KAAKS,iBAAL,CAAuBT,KAAK,CAACO,OAAN,CAAc2B,OAAd,CAAsBC,MAA7C,CAAN;UACA,MAAM,KAAKzB,cAAL,CAAoBV,KAAK,CAACO,OAAN,CAAc2B,OAAd,CAAsBC,MAA1C,EAAkDnC,KAAK,CAACO,OAAN,CAAcvB,MAAhE,CAAN;UAEA,MAAM+F,MAAM,GAAG/E,KAAK,CAACO,OAAN,CAAc2B,OAAd,CAAsB3B,OAAtB,CAA8BsD,KAA9B,CAAoC,GAApC,CAAf;UACA,MAAM5B,OAAO,GAAGG,MAAM,CAACC,IAAP,CAAY0C,MAAM,CAACA,MAAM,CAAC/H,MAAP,GAAgB,CAAjB,CAAlB,EAAuC,KAAvC,CAAhB;;UAEA,IAAIiF,OAAO,CAACjF,MAAR,IAAkBlC,2BAA2B,GAAGC,yBAApD,EAA+E;YAC7E,IAAI;cACF,MAAMiK,eAAe,GAAuBH,IAAI,CAACI,KAAL,CAC1C,MAAM7J,aAAa,CAAC6G,OAAD,EAAU,KAAK1F,OAAL,CAAagB,SAAvB,EAAkC,KAAKhB,OAAL,CAAaqD,UAA/C,CADuB,CAA5C;cAIA6B,eAAe,iCACVuD,eADU,GACK;gBAClBE,QAAQ,EAAE,MAAMrJ,WAAW,CAACmJ,eAAe,CAACzH,SAAjB;cADT,CADL,EAAf;YAID,CATD,CASE,OAAOgF,eAAP,EAAwB;cACxB;YACD;UACF;QACF;MACF,CAzBqF,CAArF;IA0BF;EAAA;;EAEYgB,WAAW,CAACvE,MAAD,EAAiBC,QAAgB,CAAjC,EAAkC;;MACxD;MACA;MACA,MAAM+E,IAAI,GAAG,MAAM,CAAC,MAAM,KAAK9E,MAAL,CAAYpB,OAAnB,EAA4BqH,WAA5B,CAAwCnG,MAAxC,CAAnB;MACA9C,MAAM,CAACY,GAAP,CAAW,aAAX,EAA0B,aAAakH,IAAI,CAACxD,OAAL,CAAaxD,MAAM,8BAA1D;;MACA,IAAIgH,IAAI,CAACxD,OAAL,CAAaxD,MAAb,IAAuB,CAAvB,IAA4BgH,IAAI,CAACxD,OAAL,CAAaxD,MAAb,KAAwB,CAAxD,EAA2D;QACzD;QACA;MACD,CAHD,MAGO;QACL,IAAIiC,KAAK,IAAI,GAAb,EAAkB;UAChB;UACA/C,MAAM,CAACY,GAAP,CAAW,4BAA4BmC,KAAK,EAA5C;UAEA,OAAO,IAAImG,OAAJ,CAAalH,OAAD,IAAY;YAC7BmB,UAAU,CAAC,MAAWC;cACpBpB,OAAO,CAAC,KAAKqF,WAAL,CAAiBvE,MAAjB,EAAyBC,KAAK,GAAG,CAAjC,CAAD,CAAP;YACD,CAFqB,CAAZ,EAEP,OAAOA,KAAK,GAAG,EAAR,GAAa,EAAb,GAAkB,CAAzB,CAFO,CAAV,CAD6B,CAGG;UACjC,CAJM,CAAP;QAKD,CATD,MASO;UACL,MAAM,IAAIH,KAAJ,CAAU,uBAAuBG,KAAK,SAAtC,CAAN;QACD;MACF;IACF;EAAA;;EAEYoG,mBAAmB,CAACC,cAAD,EAAkC;;MAChEpJ,MAAM,CAACY,GAAP,CAAW,qBAAX;MACA,MAAMsG,aAAa,GAAG,MAAMnI,UAAU,CAACmH,MAAM,CAACC,IAAP,CAAYiD,cAAc,CAAC/H,SAA3B,EAAsC,KAAtC,CAAD,CAAtC;MACA,MAAM8F,SAAS,GAAGlI,eAAe,CAACiI,aAAD,EAAgBkC,cAAc,CAAC7H,WAA/B,CAAjC,EAEA;;MACA,MAAMuB,MAAM,GAAG,MAAM,CAAC,MAAM,KAAKE,MAAL,CAAYpB,OAAnB,EAA4ByH,wBAA5B,CAAqDlC,SAArD,CAArB;MAEA,MAAM,KAAK3C,cAAL,CAAoB2C,SAApB,EAA+BrE,MAA/B,CAAN,EAEA;;MACA,MAAM,KAAKuE,WAAL,CAAiBvE,MAAjB,CAAN,EAA+B;MAE/B;;MACA,MAAMkD,OAAO,GACX,OAAOoD,cAAc,CAAChI,OAAtB,KAAkC,WAAlC,GACI,MAAM,KAAKE,YAAL,EADV,CAC8B;MAD9B,EAEIqH,IAAI,CAACC,SAAL,CAAe,MAAM,KAAKlH,sBAAL,CAA4B0H,cAA5B,CAArB,CAHN,EAGwE;;MAExE,MAAM9B,gBAAgB,GAAW,MAAM,KAAKgC,wBAAL,CACrCF,cAAc,CAAC/H,SADsB,EAErC2E,OAFqC,CAAvC;MAKA,MAAMuD,GAAG,GAAG,CAAC,eAAD,EAAkBpC,SAAlB,EAA6BG,gBAA7B,EAA+CkC,IAA/C,CAAoD,GAApD,CAAZ;MACC,CAAC,MAAM,KAAKxG,MAAL,CAAYpB,OAAnB,EAA4B2F,eAA5B,CAA4CzE,MAA5C,EAAoDyG,GAApD,EAAyDhH,KAAzD,CAAsEC,KAAP,IAAgBY;QAC9E,IAAIZ,KAAK,CAACU,OAAN,KAAkB,aAAtB,EAAqC;UACnC;UACAlD,MAAM,CAACY,GAAP,CAAW,aAAX,EAA0B,aAA1B,EAAyC4B,KAAzC;UACA,MAAM,KAAKgF,qBAAL,CAA2B1E,MAA3B,CAAN;UACA,MAAM2E,SAAS,GAAG,MAAM,KAAKL,eAAL,CAAqBD,SAArB,CAAxB;UAEC,CAAC,MAAM,KAAKnE,MAAL,CAAYpB,OAAnB,EAA4B2F,eAA5B,CAA4CE,SAA5C,EAAuD8B,GAAvD,EAA4DhH,KAA5D,CAAyEmF,MAAP,IAAiBtE;YAClFpD,MAAM,CAACY,GAAP,CAAW,aAAX,EAA0B,aAA1B,EAAyC8G,MAAzC;UACD,CAFmF,CAAnF;QAGF,CATD,MASO;UACL1H,MAAM,CAACY,GAAP,CAAW,aAAX,EAA0B,eAA1B,EAA2C4B,KAA3C;QACD;MACF,CAb+E,CAA/E;IAcF;EAAA;;EAEMqD,aAAa,CAClBxB,OADkB,EAC2B;IAE7C,OAAOA,OAAO,CAAC2B,OAAR,CAAgB7E,IAAhB,KAAyB5B,iBAAiB,CAACkK,IAAlD;EACD;;EAEYlF,iBAAiB,CAAC0B,MAAD,EAAe;;MAC3C;MACA,MAAM0B,KAAK,GAAG1B,MAAM,CAAC0B,KAAP,CAAa,GAAb,CAAd;;MACA,IAAIA,KAAK,CAAC7G,MAAN,GAAe,CAAf,IAAoB,CAAC6G,KAAK,CAAC,CAAD,CAAL,CAASC,UAAT,CAAoB,GAApB,CAAzB,EAAmD;QACjD,MAAM,IAAIhF,KAAJ,CAAU,gBAAV,CAAN;MACD;;MACD,MAAM8G,UAAU,GAAG/B,KAAK,CAACgC,KAAN,EAAnB;MACA,MAAMpI,WAAW,GAAGoG,KAAK,CAAC6B,IAAN,CAAW,GAAX,CAApB;MACA,MAAMI,OAAO,GAAGC,YAAY,CAACC,OAAb,CAAqB,iCAArB,IACZ,IAAIrK,WAAJ,CAAgB,KAAKc,OAArB,EAA8Bf,UAAU,CAACuK,wBAAzC,CADY,GAEZ,IAAItK,WAAJ,CAAgB,KAAKc,OAArB,EAA8Bf,UAAU,CAACwK,0BAAzC,CAFJ;MAGA,MAAMC,KAAK,GAAG,MAAML,OAAO,CAACM,QAAR,EAApB;MACA,MAAMC,YAAY,GAAIF,KAAa,CAACG,GAAd,CACbrD,IAAP,IAA+D3D;QAC7D,MAAMiH,IAAI,GAAG,IAAI,MAAMtL,UAAU,CAACmH,MAAM,CAACC,IAAP,CAAYY,IAAI,CAAC1F,SAAjB,EAA4B,KAA5B,CAAD,CAAoC,EAArE;;QACA,IAAIgJ,IAAI,KAAKX,UAAb,EAAyB;UACvB,IAAI3C,IAAI,CAACxF,WAAL,KAAqBA,WAAzB,EAAsC;YACpCwF,IAAI,CAACxF,WAAL,GAAmBA,WAAnB;YACA,MAAMqI,OAAO,CAACU,OAAR,CAAgBvD,IAAhB,CAAN;UACD;QACF;MACF,CAR8D,CAD3C,CAAtB;MAWA,MAAMmC,OAAO,CAACqB,GAAR,CAAYJ,YAAZ,CAAN;IACD;EAAA;;EAEYzB,oBAAoB,CAC/BrE,OAD+B,EACiB;;MAEhD,OAAOA,OAAO,CAAC2B,OAAR,CAAgB3B,OAAhB,CAAwBuD,UAAxB,CACL,kBAAkB,MAAM7I,UAAU,CAACmH,MAAM,CAACC,IAAP,CAAY,MAAM,KAAK7E,YAAL,EAAlB,EAAuC,KAAvC,CAAD,CAA+C,EAD5E,CAAP;IAGD;EAAA;;EAEYwE,QAAQ,CACnBhC,KADmB,EAEnBwB,eAFmB,EAEI;;MAEvB,OAAOxB,KAAK,CAACO,OAAN,CAAc2B,OAAd,CAAsBC,MAAtB,CAA6B2B,UAA7B,CACL,IAAI,MAAM7I,UAAU,CAACmH,MAAM,CAACC,IAAP,CAAYb,eAAZ,EAA6B,KAA7B,CAAD,CAAqC,EADpD,CAAP;IAGD;EAAA;;EAEa8B,eAAe,CAACD,SAAD,EAAkB;;MAC7C,MAAMU,OAAO,GAAG,MAAM,KAAKtH,OAAL,CAAauB,GAAb,CAAiBtC,UAAU,CAAC0F,oBAA5B,CAAtB;MACA,IAAIpC,MAAM,GAAG+E,OAAO,CAACV,SAAD,CAApB;;MAEA,IAAI,CAACrE,MAAL,EAAa;QACX9C,MAAM,CAACY,GAAP,CAAW,iBAAX,EAA8B,0BAA0BuG,SAAS,yBAAjE;QACA,MAAMW,IAAI,GAAG,MAAM,KAAK0C,qBAAL,CAA2BrD,SAA3B,CAAnB;QACArE,MAAM,GAAGgF,IAAI,CAAC5G,EAAd;QACA2G,OAAO,CAACV,SAAD,CAAP,GAAqBW,IAAI,CAAC5G,EAA1B;QACA,MAAM,KAAKX,OAAL,CAAa+B,GAAb,CAAiB9C,UAAU,CAAC0F,oBAA5B,EAAkD2C,OAAlD,CAAN;MACD;;MAED7H,MAAM,CAACY,GAAP,CAAW,iBAAX,EAA8B,cAAckC,MAAM,EAAlD;MAEA,OAAOA,MAAP;IACD;EAAA;;EAEa0H,qBAAqB,CAACrD,SAAD,EAAkB;;MACnD,MAAMsD,WAAW,GAAG,MAAM,CAAC,MAAM,KAAKzH,MAAL,CAAYpB,OAAnB,EAA4B6I,WAAtD;MACAzK,MAAM,CAACY,GAAP,CAAW,uBAAX,EAAoC6J,WAApC,EAAiDtD,SAAjD;MACA,MAAMuD,aAAa,GAAGD,WAAW,CAC9BrC,MADmB,CACXuC,WAAD,IAA6B,CAAC,KAAK5C,YAAL,CAAkB6C,IAAlB,CAAwB1J,EAAD,IAAQyJ,WAAW,CAACzJ,EAAZ,KAAmBA,EAAlD,CADlB,EAEnBkH,MAFmB,CAEXuC,WAAD,IACNA,WAAW,CAACrG,OAAZ,CAAoBsG,IAApB,CAA0BxG,MAAD,IAAoBA,MAAM,KAAK+C,SAAxD,CAHkB,CAAtB;MAMA,IAAIW,IAAJ,EACA;MACA;;MACA,IAAI4C,aAAa,CAAC5J,MAAd,KAAyB,CAAzB,IAA8B,KAAKiH,YAAL,CAAkBjH,MAAlB,GAA2B,CAA7D,EAAgE;QAC9Dd,MAAM,CAACY,GAAP,CAAW,uBAAX,EAAoC,2CAApC;QAEA,MAAMkC,MAAM,GAAG,MAAM,CAAC,MAAM,KAAKE,MAAL,CAAYpB,OAAnB,EAA4ByH,wBAA5B,CAAqDlC,SAArD,CAArB;QACAW,IAAI,GAAG,MAAM,CAAC,MAAM,KAAK9E,MAAL,CAAYpB,OAAnB,EAA4BqH,WAA5B,CAAwCnG,MAAxC,CAAb;QACA9C,MAAM,CAACY,GAAP,CAAW,uBAAX,EAAoC,yCAAyCkH,IAAI,CAAC5G,EAAE,EAApF;QACA,MAAM,KAAKmG,WAAL,CAAiBvE,MAAjB,CAAN;QACA9C,MAAM,CAACY,GAAP,CAAW,uBAAX,EAAoC,sCAAsCkH,IAAI,CAAC5G,EAAE,EAAjF;MACD,CARD,MAQO;QACL4G,IAAI,GAAG4C,aAAa,CAAC,CAAD,CAApB;QACA1K,MAAM,CAACY,GAAP,CAAW,uBAAX,EAAoC,sCAAsCkH,IAAI,CAAC5G,EAAE,EAAjF;MACD;;MAED,OAAO4G,IAAP;IACD;EAAA;;AAhkB4D","names":["ready","crypto_generichash","from_string","crypto_sign_detached","crypto_secretbox_NONCEBYTES","crypto_secretbox_MACBYTES","axios","getHexHash","toHex","recipientString","openCryptobox","encryptCryptoboxPayload","decryptCryptoboxPayload","MatrixClient","MatrixClientEventType","MatrixMessageType","StorageKey","PeerManager","BEACON_VERSION","getSenderId","Logger","CommunicationClient","ExposedPromise","generateGUID","logger","KNOWN_RELAY_SERVERS","P2PCommunicationClient","constructor","name","keyPair","replicationCount","storage","matrixNodes","iconUrl","appUrl","Map","log","nodes","length","ENABLED_RELAY_SERVERS","getPairingRequestInfo","info","id","type","version","publicKey","getPublicKey","relayServer","getRelayServer","icon","getPairingResponseInfo","request","promise","node","get","MATRIX_SELECTED_NODE","resolve","index","Math","floor","random","server","set","catch","error","relayError","splice","reject","Error","tryJoinRooms","roomId","retry","client","joinRooms","errcode","setTimeout","__awaiter","start","loginRawDigest","Date","now","rawSignature","privateKey","create","baseUrl","initialListener","event","initialEvent","timestamp","subscribe","MESSAGE","INVITE","member","content","members","updateRelayServer","updatePeerRoom","getPublicKeyHash","password","deviceId","console","reset","loginCounter","stop","isResolved","delete","MATRIX_PEER_ROOM_IDS","MATRIX_PRESERVED_STATE","undefined","listenForEncryptedMessage","senderPublicKey","messageCallback","activeListeners","has","sharedRx","createCryptoBoxServer","callbackFunction","isTextMessage","isSender","payload","message","sender","Buffer","from","decryptedMessage","decryptionError","lastEvent","getTime","unsubscribe","unsubscribeFromEncryptedMessage","listener","unsubscribeFromEncryptedMessages","unsubscribeAll","clear","sendMessage","peer","sharedTx","createCryptoBoxClient","recipientHash","recipient","getRelevantRoom","waitForJoin","encryptedMessage","sendTextMessage","deleteRoomIdFromRooms","newRoomId","error2","split","startsWith","roomIds","room","ignoredRooms","push","newRoomIds","Object","entries","filter","entry","reduce","pv","cv","listenForChannelOpening","isChannelOpenMessage","JSON","stringify","splits","pairingResponse","parse","senderId","getRoomById","Promise","sendPairingResponse","pairingRequest","createTrustedPrivateRoom","encryptMessageAsymmetric","msg","join","TEXT","senderHash","shift","manager","localStorage","getItem","TRANSPORT_P2P_PEERS_DAPP","TRANSPORT_P2P_PEERS_WALLET","peers","getPeers","promiseArray","map","hash","addPeer","all","getRelevantJoinedRoom","joinedRooms","relevantRooms","roomElement","some"],"sourceRoot":"","sources":["../../../src/communication-client/P2PCommunicationClient.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"module"}