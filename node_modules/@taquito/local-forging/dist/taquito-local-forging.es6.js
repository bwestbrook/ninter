import { Prefix, prefixLength, b58cencode, prefix, buf2hex, b58cdecode, InvalidKeyHashError, InvalidPublicKeyError, InvalidAddressError, InvalidOperationKindError, validateBlock, ValidationResult } from '@taquito/utils';
import BigNumber$1, { BigNumber } from 'bignumber.js';

const toHexString = (bytes) => bytes.reduce((str, byte) => str + byte.toString(16).padStart(2, '0'), '');
const pad = (num, paddingLen = 8) => {
    return num.toString(16).padStart(paddingLen, '0');
};

/*
 * Some code in this file is originally from sotez
 * Copyright (c) 2018 Andrew Kishino
 */
// See: https://tezos.gitlab.io/protocols/005_babylon.html#transactions-now-have-an-entrypoint
const ENTRYPOINT_MAX_LENGTH = 31;
var CODEC;
(function (CODEC) {
    CODEC["SECRET"] = "secret";
    CODEC["RAW"] = "raw";
    CODEC["TZ1"] = "tz1";
    CODEC["BRANCH"] = "branch";
    CODEC["ZARITH"] = "zarith";
    CODEC["PUBLIC_KEY"] = "public_key";
    CODEC["PKH"] = "pkh";
    CODEC["DELEGATE"] = "delegate";
    CODEC["SCRIPT"] = "script";
    CODEC["BALLOT_STATEMENT"] = "ballotStmt";
    CODEC["PROPOSAL"] = "proposal";
    CODEC["PROPOSAL_ARR"] = "proposalArr";
    CODEC["INT32"] = "int32";
    CODEC["INT16"] = "int16";
    CODEC["PARAMETERS"] = "parameters";
    CODEC["ADDRESS"] = "address";
    CODEC["OPERATION"] = "operation";
    CODEC["OP_ACTIVATE_ACCOUNT"] = "activate_account";
    CODEC["OP_DELEGATION"] = "delegation";
    CODEC["OP_TRANSACTION"] = "transaction";
    CODEC["OP_ORIGINATION"] = "origination";
    CODEC["OP_BALLOT"] = "ballot";
    CODEC["OP_ENDORSEMENT"] = "endorsement";
    CODEC["OP_SEED_NONCE_REVELATION"] = "seed_nonce_revelation";
    CODEC["OP_REVEAL"] = "reveal";
    CODEC["OP_PROPOSALS"] = "proposals";
    CODEC["OP_REGISTER_GLOBAL_CONSTANT"] = "register_global_constant";
    CODEC["VALUE"] = "value";
    CODEC["MANAGER"] = "manager";
    CODEC["BLOCK_PAYLOAD_HASH"] = "blockPayloadHash";
})(CODEC || (CODEC = {}));
// See https://tezos.gitlab.io/whitedoc/michelson.html#full-grammar
const opMapping = {
    '00': 'parameter',
    '01': 'storage',
    '02': 'code',
    '03': 'False',
    '04': 'Elt',
    '05': 'Left',
    '06': 'None',
    '07': 'Pair',
    '08': 'Right',
    '09': 'Some',
    '0a': 'True',
    '0b': 'Unit',
    '0c': 'PACK',
    '0d': 'UNPACK',
    '0e': 'BLAKE2B',
    '0f': 'SHA256',
    '10': 'SHA512',
    '11': 'ABS',
    '12': 'ADD',
    '13': 'AMOUNT',
    '14': 'AND',
    '15': 'BALANCE',
    '16': 'CAR',
    '17': 'CDR',
    '18': 'CHECK_SIGNATURE',
    '19': 'COMPARE',
    '1a': 'CONCAT',
    '1b': 'CONS',
    '1c': 'CREATE_ACCOUNT',
    '1d': 'CREATE_CONTRACT',
    '1e': 'IMPLICIT_ACCOUNT',
    '1f': 'DIP',
    '20': 'DROP',
    '21': 'DUP',
    '22': 'EDIV',
    '23': 'EMPTY_MAP',
    '24': 'EMPTY_SET',
    '25': 'EQ',
    '26': 'EXEC',
    '27': 'FAILWITH',
    '28': 'GE',
    '29': 'GET',
    '2a': 'GT',
    '2b': 'HASH_KEY',
    '2c': 'IF',
    '2d': 'IF_CONS',
    '2e': 'IF_LEFT',
    '2f': 'IF_NONE',
    '30': 'INT',
    '31': 'LAMBDA',
    '32': 'LE',
    '33': 'LEFT',
    '34': 'LOOP',
    '35': 'LSL',
    '36': 'LSR',
    '37': 'LT',
    '38': 'MAP',
    '39': 'MEM',
    '3a': 'MUL',
    '3b': 'NEG',
    '3c': 'NEQ',
    '3d': 'NIL',
    '3e': 'NONE',
    '3f': 'NOT',
    '40': 'NOW',
    '41': 'OR',
    '42': 'PAIR',
    '43': 'PUSH',
    '44': 'RIGHT',
    '45': 'SIZE',
    '46': 'SOME',
    '47': 'SOURCE',
    '48': 'SENDER',
    '49': 'SELF',
    '4a': 'STEPS_TO_QUOTA',
    '4b': 'SUB',
    '4c': 'SWAP',
    '4d': 'TRANSFER_TOKENS',
    '4e': 'SET_DELEGATE',
    '4f': 'UNIT',
    '50': 'UPDATE',
    '51': 'XOR',
    '52': 'ITER',
    '53': 'LOOP_LEFT',
    '54': 'ADDRESS',
    '55': 'CONTRACT',
    '56': 'ISNAT',
    '57': 'CAST',
    '58': 'RENAME',
    '59': 'bool',
    '5a': 'contract',
    '5b': 'int',
    '5c': 'key',
    '5d': 'key_hash',
    '5e': 'lambda',
    '5f': 'list',
    '60': 'map',
    '61': 'big_map',
    '62': 'nat',
    '63': 'option',
    '64': 'or',
    '65': 'pair',
    '66': 'set',
    '67': 'signature',
    '68': 'string',
    '69': 'bytes',
    '6a': 'mutez',
    '6b': 'timestamp',
    '6c': 'unit',
    '6d': 'operation',
    '6e': 'address',
    '6f': 'SLICE',
    '70': 'DIG',
    '71': 'DUG',
    '72': 'EMPTY_BIG_MAP',
    '73': 'APPLY',
    '74': 'chain_id',
    '75': 'CHAIN_ID',
    '76': 'LEVEL',
    '77': 'SELF_ADDRESS',
    '78': 'never',
    '79': 'NEVER',
    '7a': 'UNPAIR',
    '7b': 'VOTING_POWER',
    '7c': 'TOTAL_VOTING_POWER',
    '7d': 'KECCAK',
    '7e': 'SHA3',
    '7f': 'PAIRING_CHECK',
    '80': 'bls12_381_g1',
    '81': 'bls12_381_g2',
    '82': 'bls12_381_fr',
    '83': 'sapling_state',
    '84': 'sapling_transaction',
    '85': 'SAPLING_EMPTY_STATE',
    '86': 'SAPLING_VERIFY_UPDATE',
    '87': 'ticket',
    '88': 'TICKET',
    '89': 'READ_TICKET',
    '8a': 'SPLIT_TICKET',
    '8b': 'JOIN_TICKETS',
    '8c': 'GET_AND_UPDATE',
    '8d': 'chest',
    '8e': 'chest_key',
    '8f': 'OPEN_CHEST',
    '90': 'VIEW',
    '91': 'view',
    '92': 'constant',
    '93': 'SUB_MUTEZ',
};
const opMappingReverse = (() => {
    const result = {};
    Object.keys(opMapping).forEach((key) => {
        result[opMapping[key]] = key;
    });
    return result;
})();
// See https://tezos.gitlab.io/api/p2p.html
const kindMapping = {
    0x04: 'activate_account',
    0x6b: 'reveal',
    0x6e: 'delegation',
    0x6c: 'transaction',
    0x6d: 'origination',
    0x06: 'ballot',
    0x00: 'endorsement',
    0x01: 'seed_nonce_revelation',
    0x05: 'proposals',
    0x6f: 'register_global_constant',
};
const kindMappingReverse = (() => {
    const result = {};
    Object.keys(kindMapping).forEach((key) => {
        const keyNum = typeof key === 'string' ? parseInt(key, 10) : key;
        result[kindMapping[keyNum]] = pad(keyNum, 2);
    });
    return result;
})();
// See https://tezos.gitlab.io/protocols/005_babylon.html#transactions-now-have-an-entrypoint
const entrypointMapping = {
    '00': 'default',
    '01': 'root',
    '02': 'do',
    '03': 'set_delegate',
    '04': 'remove_delegate',
};
const entrypointMappingReverse = (() => {
    const result = {};
    Object.keys(entrypointMapping).forEach((key) => {
        result[entrypointMapping[key]] = key;
    });
    return result;
})();

/**
 *  @category Error
 *  @description Error that indicates an invalid block hash being passed or used
 */
class InvalidBlockHashError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
        this.name = 'InvalidBlockHashError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates an invalid operation schema being passed or used
 */ class InvalidOperationSchemaError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
        this.name = 'InvalidOperationSchemaError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates an entrypoint exceeding maximum size
 */
class OversizedEntryPointError extends Error {
    constructor(entrypoint) {
        super(`Oversized entrypoint: ${entrypoint}. The maximum length of entrypoint is ${ENTRYPOINT_MAX_LENGTH}`);
        this.entrypoint = entrypoint;
        this.name = 'OversizedEntryPointError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates an invalid ballot value
 */
class InvalidBallotValueError extends Error {
    constructor(ballotValue) {
        super(`The ballot value '${ballotValue}' is invalid`);
        this.ballotValue = ballotValue;
        this.name = 'InvalidBallotValueError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates a failure when trying to decode ballot value
 */
class DecodeBallotValueError extends Error {
    constructor(ballotValue) {
        super(`Failed to decode ballot value ${ballotValue}`);
        this.ballotValue = ballotValue;
        this.name = 'DecodeBallotValueError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates an invalid hex string have been passed or used
 */
class InvalidHexStringError extends Error {
    constructor(hexString) {
        super(`The hex string '${hexString}' is invalid`);
        this.hexString = hexString;
        this.name = 'InvalidHexStringError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates unexpected Michelson Value being passed or used
 */
class UnexpectedMichelsonValueError extends Error {
    constructor(value) {
        super(`Failed to encode michelson value '${value}'`);
        this.value = value;
        this.name = 'UnexpectedMichelsonValueError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates a failure when trying to decode an operation
 */
class OperationDecodingError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
        this.name = 'OperationDecodingError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates a failure when trying to encode an operation
 */
class OperationEncodingError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
        this.name = 'OperationEncodingError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates an unsupported operation being passed or used
 */
class UnsupportedOperationError extends Error {
    constructor(op) {
        super(`The operation '${op}' is unsupported`);
        this.op = op;
        this.name = 'UnsupportedOperationError';
    }
}

class Uint8ArrayConsumer {
    constructor(arr, offset = 0) {
        this.arr = arr;
        this.offset = offset;
    }
    static fromHexString(hex) {
        const lowHex = hex.toLowerCase();
        if (/^(([a-f]|\d){2})*$/.test(lowHex)) {
            const arr = new Uint8Array((lowHex.match(/([a-z]|\d){2}/g) || []).map((byte) => parseInt(byte, 16)));
            return new Uint8ArrayConsumer(arr);
        }
        else {
            throw new InvalidHexStringError(lowHex);
        }
    }
    consume(count) {
        const subArr = this.arr.subarray(this.offset, this.offset + count);
        this.offset += count;
        return subArr;
    }
    get(idx) {
        return this.arr[this.offset + idx];
    }
    length() {
        return this.arr.length - this.offset;
    }
}

const isPrim = (value) => {
    return 'prim' in value;
};
const isBytes = (value) => {
    return 'bytes' in value && typeof value.bytes === 'string';
};
const isString = (value) => {
    return 'string' in value && typeof value.string === 'string';
};
const isInt = (value) => {
    return 'int' in value && typeof value.int === 'string';
};
const scriptEncoder = (script) => {
    const code = valueEncoder(script.code);
    const storage = valueEncoder(script.storage);
    return `${pad(code.length / 2, 8)}${code}${pad(storage.length / 2, 8)}${storage}`;
};
const scriptDecoder = (value) => {
    const code = extractRequiredLen(value);
    const storage = extractRequiredLen(value);
    return {
        code: valueDecoder(new Uint8ArrayConsumer(code)),
        storage: valueDecoder(new Uint8ArrayConsumer(storage)),
    };
};
const valueEncoder = (value) => {
    if (Array.isArray(value)) {
        const encoded = value.map((x) => valueEncoder(x)).join('');
        const len = encoded.length / 2;
        return `02${pad(len)}${encoded}`;
    }
    else if (isPrim(value)) {
        return primEncoder(value);
    }
    else if (isBytes(value)) {
        return bytesEncoder(value);
    }
    else if (isString(value)) {
        return stringEncoder(value);
    }
    else if (isInt(value)) {
        return intEncoder(value);
    }
    throw new UnexpectedMichelsonValueError(value);
};
const valueDecoder = (value) => {
    const preamble = value.consume(1);
    switch (preamble[0]) {
        case 0x0a:
            return bytesDecoder(value);
        case 0x01:
            return stringDecoder(value);
        case 0x00:
            return intDecoder(value);
        case 0x02: {
            const val = new Uint8ArrayConsumer(extractRequiredLen(value));
            const results = [];
            while (val.length() > 0) {
                results.push(valueDecoder(val));
            }
            return results;
        }
        default:
            return primDecoder(value, preamble);
    }
};
const extractRequiredLen = (value, bytesLength = 4) => {
    const len = value.consume(bytesLength);
    const valueLen = parseInt(Buffer.from(len).toString('hex'), 16);
    return value.consume(valueLen);
};
const bytesEncoder = (value) => {
    if (!/^([A-Fa-f0-9]{2})*$/.test(value.bytes)) {
        throw new InvalidHexStringError(value.bytes);
    }
    const len = value.bytes.length / 2;
    return `0a${pad(len)}${value.bytes}`;
};
const bytesDecoder = (value) => {
    const bytes = extractRequiredLen(value);
    return {
        bytes: Buffer.from(bytes).toString('hex'),
    };
};
const stringEncoder = (value) => {
    const str = Buffer.from(value.string, 'utf8').toString('hex');
    const hexLength = str.length / 2;
    return `01${pad(hexLength)}${str}`;
};
const stringDecoder = (value) => {
    const str = extractRequiredLen(value);
    return {
        string: Buffer.from(str).toString('utf8'),
    };
};
const intEncoder = ({ int }) => {
    const num = new BigNumber(int, 10);
    const positiveMark = num.toString(2)[0] === '-' ? '1' : '0';
    const binary = num.toString(2).replace(/-/g, '');
    const pad = binary.length <= 6
        ? 6
        : (binary.length - 6) % 7
            ? binary.length + 7 - ((binary.length - 6) % 7)
            : binary.length;
    const splitted = binary.padStart(pad, '0').match(/\d{6,7}/g);
    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
    const reversed = splitted.reverse();
    reversed[0] = positiveMark + reversed[0];
    const numHex = reversed.map((x, i) => 
    // Add one to the last chunk
    parseInt((i === reversed.length - 1 ? '0' : '1') + x, 2)
        .toString(16)
        .padStart(2, '0'));
    return `00${numHex.join('')}`;
};
const intDecoder = (value) => {
    let c = value.consume(1)[0];
    const hexNumber = [];
    const isNotLastChunkMask = 1 << 7;
    while (c & isNotLastChunkMask) {
        hexNumber.push(c);
        c = value.consume(1)[0];
    }
    hexNumber.push(c);
    const isNegative = !!((1 << 6) & hexNumber[0]);
    hexNumber[0] = hexNumber[0] & 0b1111111;
    const numBin = hexNumber
        .map((x, i) => x
        .toString(2)
        .slice(i === 0 ? -6 : -7)
        .padStart(i === 0 ? 6 : 7, '0'))
        .reverse();
    let num = new BigNumber(numBin.join(''), 2);
    if (isNegative) {
        num = num.times(-1);
    }
    return {
        int: num.toFixed(),
    };
};
const primEncoder = (value) => {
    const hasAnnot = +Array.isArray(value.annots);
    const argsCount = Array.isArray(value.args) ? value.args.length : 0;
    // Specify the number of args max is 3 without annotation
    const preamble = pad(Math.min(2 * argsCount + hasAnnot + 0x03, 9), 2);
    const op = opMappingReverse[value.prim];
    let encodedArgs = (value.args || []).map((arg) => valueEncoder(arg)).join('');
    const encodedAnnots = Array.isArray(value.annots) ? encodeAnnots(value.annots) : '';
    if (value.prim === 'LAMBDA' && argsCount) {
        encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
    }
    if ((value.prim === 'pair' || value.prim === 'Pair') && argsCount > 2) {
        encodedArgs =
            encodedAnnots === ''
                ? pad(encodedArgs.length / 2) + encodedArgs + pad(0)
                : pad(encodedArgs.length / 2) + encodedArgs;
    }
    if (value.prim === 'view' && value.args) {
        encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
    }
    return `${preamble}${op}${encodedArgs}${encodedAnnots}`;
};
const primDecoder = (value, preamble) => {
    const hasAnnot = (preamble[0] - 0x03) % 2 === 1;
    let argsCount = Math.floor((preamble[0] - 0x03) / 2);
    const op = value.consume(1)[0].toString(16).padStart(2, '0');
    const result = {
        prim: opMapping[op],
    };
    if (opMapping[op] === 'LAMBDA') {
        value.consume(4);
    }
    if (opMapping[op] === 'view') {
        if (argsCount != 0) {
            return primViewDecoder(value, result);
        }
        else {
            return result;
        }
    }
    let combPairArgs;
    let combPairAnnots;
    if ((opMapping[op] === 'pair' || opMapping[op] === 'Pair') && argsCount > 2) {
        combPairArgs = decodeCombPair$1(value);
        argsCount = 0;
        combPairAnnots = decodeAnnots(value);
    }
    const args = new Array(argsCount).fill(0).map(() => valueDecoder(value));
    if (opMapping[op] === 'LAMBDA') {
        value.consume(4);
    }
    if (combPairArgs) {
        result['args'] = combPairArgs;
    }
    else if (args.length) {
        result['args'] = args;
    }
    if (combPairAnnots && combPairAnnots[0] !== '') {
        result['annots'] = combPairAnnots;
    }
    else if (hasAnnot) {
        result['annots'] = decodeAnnots(value);
    }
    return result;
};
const primViewDecoder = (value, result) => {
    value.consume(4);
    result['args'] = new Array(4).fill(0).map(() => valueDecoder(value));
    value.consume(4);
    return result;
};
const decodeCombPair$1 = (val) => {
    const array = new Uint8ArrayConsumer(extractRequiredLen(val));
    const args = [];
    while (array.length() > 0) {
        args.push(valueDecoder(array));
    }
    return args;
};
const encodeAnnots = (value) => {
    const mergedAnnot = value
        .map((x) => {
        return Buffer.from(x, 'utf8').toString('hex');
    })
        .join('20');
    const len = mergedAnnot.length / 2;
    return `${pad(len)}${mergedAnnot}`;
};
const decodeAnnots = (val) => {
    const len = val.consume(4);
    const annotLen = parseInt(Buffer.from(len).toString('hex'), 16);
    const restOfAnnot = val.consume(annotLen);
    const restOfAnnotHex = Buffer.from(restOfAnnot).toString('hex');
    return restOfAnnotHex.split('20').map((x) => Buffer.from(x, 'hex').toString('utf8'));
};

const prefixEncoder = (prefix$1) => (str) => {
    return buf2hex(Buffer.from(b58cdecode(str, prefix[prefix$1])));
};
const prefixDecoder = (pre) => (str) => {
    const val = str.consume(prefixLength[pre]);
    return b58cencode(val, prefix[pre]);
};
const tz1Decoder = prefixDecoder(Prefix.TZ1);
const branchDecoder = prefixDecoder(Prefix.B);
const pkhDecoder = (val) => {
    const prefix = val.consume(1);
    if (prefix[0] === 0x00) {
        return prefixDecoder(Prefix.TZ1)(val);
    }
    else if (prefix[0] === 0x01) {
        return prefixDecoder(Prefix.TZ2)(val);
    }
    else if (prefix[0] === 0x02) {
        return prefixDecoder(Prefix.TZ3)(val);
    }
};
const branchEncoder = prefixEncoder(Prefix.B);
const tz1Encoder = prefixEncoder(Prefix.TZ1);
const boolEncoder = (bool) => (bool ? 'ff' : '00');
const proposalEncoder = (proposal) => {
    return prefixEncoder(Prefix.P)(proposal);
};
const proposalDecoder = (proposal) => {
    return prefixDecoder(Prefix.P)(proposal);
};
const proposalsDecoder = (proposal) => {
    const proposals = [];
    proposal.consume(4);
    while (proposal.length() > 0) {
        proposals.push(proposalDecoder(proposal));
    }
    return proposals;
};
const proposalsEncoder = (proposals) => {
    return pad(32 * proposals.length) + proposals.map((x) => proposalEncoder(x)).join('');
};
const ballotEncoder = (ballot) => {
    switch (ballot) {
        case 'yay':
            return '00';
        case 'nay':
            return '01';
        case 'pass':
            return '02';
        default:
            throw new InvalidBallotValueError(ballot);
    }
};
const ballotDecoder = (ballot) => {
    const value = ballot.consume(1);
    switch (value[0]) {
        case 0x00:
            return 'yay';
        case 0x01:
            return 'nay';
        case 0x02:
            return 'pass';
        default:
            throw new DecodeBallotValueError(value[0].toString());
    }
};
const delegateEncoder = (val) => {
    if (val) {
        return boolEncoder(true) + pkhEncoder(val);
    }
    else {
        return boolEncoder(false);
    }
};
const int32Encoder = (val) => {
    const num = parseInt(String(val), 10);
    const byte = [];
    for (let i = 0; i < 4; i++) {
        const shiftBy = (4 - (i + 1)) * 8;
        byte.push((num & (0xff << shiftBy)) >> shiftBy);
    }
    return Buffer.from(byte).toString('hex');
};
const int32Decoder = (val) => {
    const num = val.consume(4);
    let finalNum = 0;
    for (let i = 0; i < num.length; i++) {
        finalNum = finalNum | (num[i] << ((num.length - (i + 1)) * 8));
    }
    return finalNum;
};
const int16Encoder = (val) => {
    const num = parseInt(String(val), 10);
    const byte = [];
    for (let i = 0; i < 2; i++) {
        const shiftBy = (2 - (i + 1)) * 8;
        byte.push((num & (0xff << shiftBy)) >> shiftBy);
    }
    return Buffer.from(byte).toString('hex');
};
const int16Decoder = (val) => {
    const num = val.consume(2);
    let finalNum = 0;
    for (let i = 0; i < num.length; i++) {
        finalNum = finalNum | (num[i] << ((num.length - (i + 1)) * 8));
    }
    return finalNum;
};
const boolDecoder = (val) => {
    const bool = val.consume(1);
    return bool[0] === 0xff;
};
const delegateDecoder = (val) => {
    const hasDelegate = boolDecoder(val);
    if (hasDelegate) {
        return pkhDecoder(val);
    }
};
const pkhEncoder = (val) => {
    const pubkeyPrefix = val.substr(0, 3);
    switch (pubkeyPrefix) {
        case Prefix.TZ1:
            return '00' + prefixEncoder(Prefix.TZ1)(val);
        case Prefix.TZ2:
            return '01' + prefixEncoder(Prefix.TZ2)(val);
        case Prefix.TZ3:
            return '02' + prefixEncoder(Prefix.TZ3)(val);
        default:
            throw new InvalidKeyHashError(val);
    }
};
const publicKeyEncoder = (val) => {
    const pubkeyPrefix = val.substr(0, 4);
    switch (pubkeyPrefix) {
        case Prefix.EDPK:
            return '00' + prefixEncoder(Prefix.EDPK)(val);
        case Prefix.SPPK:
            return '01' + prefixEncoder(Prefix.SPPK)(val);
        case Prefix.P2PK:
            return '02' + prefixEncoder(Prefix.P2PK)(val);
        default:
            throw new InvalidPublicKeyError(val);
    }
};
const addressEncoder = (val) => {
    const pubkeyPrefix = val.substr(0, 3);
    switch (pubkeyPrefix) {
        case Prefix.TZ1:
        case Prefix.TZ2:
        case Prefix.TZ3:
            return '00' + pkhEncoder(val);
        case Prefix.KT1:
            return '01' + prefixEncoder(Prefix.KT1)(val) + '00';
        default:
            throw new InvalidAddressError(val);
    }
};
const publicKeyDecoder = (val) => {
    const preamble = val.consume(1);
    switch (preamble[0]) {
        case 0x00:
            return prefixDecoder(Prefix.EDPK)(val);
        case 0x01:
            return prefixDecoder(Prefix.SPPK)(val);
        case 0x02:
            return prefixDecoder(Prefix.P2PK)(val);
        default:
            throw new InvalidPublicKeyError(val.toString());
    }
};
const addressDecoder = (val) => {
    const preamble = val.consume(1);
    switch (preamble[0]) {
        case 0x00:
            return pkhDecoder(val);
        case 0x01: {
            const address = prefixDecoder(Prefix.KT1)(val);
            val.consume(1);
            return address;
        }
        default:
            throw new InvalidAddressError(val.toString());
    }
};
const zarithEncoder = (n) => {
    const fn = [];
    let nn = new BigNumber$1(n, 10);
    if (nn.isNaN()) {
        throw new TypeError(`Invalid zarith number ${n}`);
    }
    // eslint-disable-next-line no-constant-condition
    while (true) {
        if (nn.lt(128)) {
            if (nn.lt(16))
                fn.push('0');
            fn.push(nn.toString(16));
            break;
        }
        else {
            let b = nn.mod(128);
            nn = nn.minus(b);
            nn = nn.dividedBy(128);
            b = b.plus(128);
            fn.push(b.toString(16));
        }
    }
    return fn.join('');
};
const zarithDecoder = (n) => {
    let mostSignificantByte = 0;
    while (mostSignificantByte < n.length() && (n.get(mostSignificantByte) & 128) !== 0) {
        mostSignificantByte += 1;
    }
    let num = new BigNumber$1(0);
    for (let i = mostSignificantByte; i >= 0; i -= 1) {
        const tmp = n.get(i) & 0x7f;
        num = num.multipliedBy(128);
        num = num.plus(tmp);
    }
    n.consume(mostSignificantByte + 1);
    return new BigNumber$1(num).toString();
};
const entrypointDecoder = (value) => {
    const preamble = pad(value.consume(1)[0], 2);
    if (preamble in entrypointMapping) {
        return entrypointMapping[preamble];
    }
    else {
        const entry = extractRequiredLen(value, 1);
        const entrypoint = Buffer.from(entry).toString('utf8');
        if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {
            throw new OversizedEntryPointError(entrypoint);
        }
        return entrypoint;
    }
};
const parametersDecoder = (val) => {
    const preamble = val.consume(1);
    if (preamble[0] === 0x00) {
        return;
    }
    else {
        const encodedEntrypoint = entrypointDecoder(val);
        const params = extractRequiredLen(val);
        const parameters = valueDecoder(new Uint8ArrayConsumer(params));
        return {
            entrypoint: encodedEntrypoint,
            value: parameters,
        };
    }
};
const entrypointEncoder = (entrypoint) => {
    if (entrypoint in entrypointMappingReverse) {
        return `${entrypointMappingReverse[entrypoint]}`;
    }
    else {
        if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {
            throw new OversizedEntryPointError(entrypoint);
        }
        const value = { string: entrypoint };
        return `ff${valueEncoder(value).slice(8)}`;
    }
};
const parametersEncoder = (val) => {
    if (!val || (val.entrypoint === 'default' && 'prim' in val.value && val.value.prim === 'Unit')) {
        return '00';
    }
    const encodedEntrypoint = entrypointEncoder(val.entrypoint);
    const parameters = valueEncoder(val.value);
    const length = (parameters.length / 2).toString(16).padStart(8, '0');
    return `ff${encodedEntrypoint}${length}${parameters}`;
};
const valueParameterEncoder = (value) => {
    const valueEncoded = valueEncoder(value);
    return `${pad(valueEncoded.length / 2)}${valueEncoded}`;
};
const valueParameterDecoder = (val) => {
    const value = extractRequiredLen(val);
    return valueDecoder(new Uint8ArrayConsumer(value));
};

const ManagerOperationSchema = {
    branch: 'branch',
    contents: ['operation'],
};
const ActivationSchema = {
    pkh: 'tz1',
    secret: 'secret',
};
const RevealSchema = {
    source: 'pkh',
    fee: 'zarith',
    counter: 'zarith',
    gas_limit: 'zarith',
    storage_limit: 'zarith',
    public_key: 'public_key',
};
const DelegationSchema = {
    source: 'pkh',
    fee: 'zarith',
    counter: 'zarith',
    gas_limit: 'zarith',
    storage_limit: 'zarith',
    delegate: 'delegate',
};
const TransactionSchema = {
    source: 'pkh',
    fee: 'zarith',
    counter: 'zarith',
    gas_limit: 'zarith',
    storage_limit: 'zarith',
    amount: 'zarith',
    destination: 'address',
    parameters: 'parameters',
};
const OriginationSchema = {
    source: 'pkh',
    fee: 'zarith',
    counter: 'zarith',
    gas_limit: 'zarith',
    storage_limit: 'zarith',
    balance: 'zarith',
    delegate: 'delegate',
    script: 'script',
};
const BallotSchema = {
    source: 'pkh',
    period: 'int32',
    proposal: 'proposal',
    ballot: 'ballotStmt',
};
const EndorsementSchema = {
    level: 'int32',
};
const SeedNonceRevelationSchema = {
    level: 'int32',
    nonce: 'raw',
};
const ProposalsSchema = {
    source: 'pkh',
    period: 'int32',
    proposals: 'proposalArr',
};
const RegisterGlobalConstantSchema = {
    source: 'pkh',
    fee: 'zarith',
    counter: 'zarith',
    gas_limit: 'zarith',
    storage_limit: 'zarith',
    value: 'value',
};
const operationEncoder = (encoders) => (operation) => {
    if (!(operation.kind in encoders) || !(operation.kind in kindMappingReverse)) {
        throw new InvalidOperationKindError(operation.kind);
    }
    return kindMappingReverse[operation.kind] + encoders[operation.kind](operation);
};
const operationDecoder = (decoders) => (value) => {
    const op = value.consume(1);
    const operationName = kindMapping[op[0]];
    if (operationName === undefined) {
        throw new UnsupportedOperationError(op[0].toString());
    }
    const decodedObj = decoders[operationName](value);
    if (typeof decodedObj !== 'object') {
        throw new OperationDecodingError('Decoded invalid operation');
    }
    return Object.assign({ kind: operationName }, decodedObj);
};
const schemaEncoder = (encoders) => (schema) => (value) => {
    const keys = Object.keys(schema);
    return keys.reduce((prev, key) => {
        const valueToEncode = schema[key];
        if (Array.isArray(valueToEncode)) {
            const encoder = encoders[valueToEncode[0]];
            const values = value[key];
            if (!Array.isArray(values)) {
                throw new OperationEncodingError(`Expected value to be Array ${JSON.stringify(values)}`);
            }
            return prev + values.reduce((prevBytes, current) => prevBytes + encoder(current), '');
        }
        else {
            const encoder = encoders[valueToEncode];
            return prev + encoder(value[key]);
        }
    }, '');
};
const schemaDecoder = (decoders) => (schema) => (value) => {
    const keys = Object.keys(schema);
    return keys.reduce((prev, key) => {
        const valueToEncode = schema[key];
        if (Array.isArray(valueToEncode)) {
            const decoder = decoders[valueToEncode[0]];
            const decoded = [];
            const lastLength = value.length();
            while (value.length() > 0) {
                decoded.push(decoder(value));
                if (lastLength === value.length()) {
                    throw new OperationDecodingError('Unable to decode value');
                }
            }
            return Object.assign(Object.assign({}, prev), { [key]: decoded });
        }
        else {
            const decoder = decoders[valueToEncode];
            const result = decoder(value);
            if (typeof result !== 'undefined') {
                return Object.assign(Object.assign({}, prev), { [key]: result });
            }
            else {
                return Object.assign({}, prev);
            }
        }
    }, {});
};

const decoders = {
    [CODEC.SECRET]: (val) => toHexString(val.consume(20)),
    [CODEC.RAW]: (val) => toHexString(val.consume(32)),
    [CODEC.TZ1]: tz1Decoder,
    [CODEC.BRANCH]: branchDecoder,
    [CODEC.ZARITH]: zarithDecoder,
    [CODEC.PUBLIC_KEY]: publicKeyDecoder,
    [CODEC.PKH]: pkhDecoder,
    [CODEC.DELEGATE]: delegateDecoder,
    [CODEC.INT32]: int32Decoder,
    [CODEC.SCRIPT]: scriptDecoder,
    [CODEC.BALLOT_STATEMENT]: ballotDecoder,
    [CODEC.PROPOSAL]: proposalDecoder,
    [CODEC.PROPOSAL_ARR]: proposalsDecoder,
    [CODEC.PARAMETERS]: parametersDecoder,
    [CODEC.ADDRESS]: addressDecoder,
    [CODEC.VALUE]: valueParameterDecoder,
};
decoders[CODEC.OPERATION] = operationDecoder(decoders);
decoders[CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaDecoder(decoders)(ActivationSchema)(val);
decoders[CODEC.OP_DELEGATION] = (val) => schemaDecoder(decoders)(DelegationSchema)(val);
decoders[CODEC.OP_TRANSACTION] = (val) => schemaDecoder(decoders)(TransactionSchema)(val);
decoders[CODEC.OP_ORIGINATION] = (val) => schemaDecoder(decoders)(OriginationSchema)(val);
decoders[CODEC.OP_BALLOT] = (val) => schemaDecoder(decoders)(BallotSchema)(val);
decoders[CODEC.OP_ENDORSEMENT] = (val) => schemaDecoder(decoders)(EndorsementSchema)(val);
decoders[CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaDecoder(decoders)(SeedNonceRevelationSchema)(val);
decoders[CODEC.OP_PROPOSALS] = (val) => schemaDecoder(decoders)(ProposalsSchema)(val);
decoders[CODEC.OP_REVEAL] = (val) => schemaDecoder(decoders)(RevealSchema)(val);
decoders[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaDecoder(decoders)(RegisterGlobalConstantSchema)(val);
decoders[CODEC.MANAGER] = schemaDecoder(decoders)(ManagerOperationSchema);

const encoders = {
    [CODEC.SECRET]: (val) => val,
    [CODEC.RAW]: (val) => val,
    [CODEC.TZ1]: tz1Encoder,
    [CODEC.BRANCH]: branchEncoder,
    [CODEC.ZARITH]: zarithEncoder,
    [CODEC.PUBLIC_KEY]: publicKeyEncoder,
    [CODEC.PKH]: pkhEncoder,
    [CODEC.DELEGATE]: delegateEncoder,
    [CODEC.SCRIPT]: scriptEncoder,
    [CODEC.BALLOT_STATEMENT]: ballotEncoder,
    [CODEC.PROPOSAL]: proposalEncoder,
    [CODEC.PROPOSAL_ARR]: proposalsEncoder,
    [CODEC.INT32]: int32Encoder,
    [CODEC.PARAMETERS]: parametersEncoder,
    [CODEC.ADDRESS]: addressEncoder,
    [CODEC.VALUE]: valueParameterEncoder
};
encoders[CODEC.OPERATION] = operationEncoder(encoders);
encoders[CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaEncoder(encoders)(ActivationSchema)(val);
encoders[CODEC.OP_DELEGATION] = (val) => schemaEncoder(encoders)(DelegationSchema)(val);
encoders[CODEC.OP_TRANSACTION] = (val) => schemaEncoder(encoders)(TransactionSchema)(val);
encoders[CODEC.OP_ORIGINATION] = (val) => schemaEncoder(encoders)(OriginationSchema)(val);
encoders[CODEC.OP_BALLOT] = (val) => schemaEncoder(encoders)(BallotSchema)(val);
encoders[CODEC.OP_ENDORSEMENT] = (val) => schemaEncoder(encoders)(EndorsementSchema)(val);
encoders[CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaEncoder(encoders)(SeedNonceRevelationSchema)(val);
encoders[CODEC.OP_PROPOSALS] = (val) => schemaEncoder(encoders)(ProposalsSchema)(val);
encoders[CODEC.OP_REVEAL] = (val) => schemaEncoder(encoders)(RevealSchema)(val);
encoders[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaEncoder(encoders)(RegisterGlobalConstantSchema)(val);
encoders[CODEC.MANAGER] = schemaEncoder(encoders)(ManagerOperationSchema);

const blockPayloadHashEncoder = prefixEncoder(Prefix.VH);
const blockPayloadHashDecoder = prefixDecoder(Prefix.VH);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

const kindMappingNoEndorsement = __rest(kindMapping, ["0"]);
const kindMappingProto12 = Object.assign(Object.assign({}, kindMappingNoEndorsement), { 0x15: 'endorsement' });
const kindMappingReverseProto12 = (() => {
    const result = {};
    Object.keys(kindMappingProto12).forEach((key) => {
        const keyNum = typeof key === 'string' ? parseInt(key, 10) : key;
        result[kindMappingProto12[keyNum]] = pad(keyNum, 2);
    });
    return result;
})();

const EndorsementSchemaProto12 = {
    slot: 'int16',
    level: 'int32',
    round: 'int32',
    block_payload_hash: 'blockPayloadHash',
};
const operationEncoderProto12 = (encoders) => (operation) => {
    if (!(operation.kind in encoders) || !(operation.kind in kindMappingReverseProto12)) {
        throw new InvalidOperationKindError(operation.kind);
    }
    return kindMappingReverseProto12[operation.kind] + encoders[operation.kind](operation);
};
const operationDecoderProto12 = (decoders) => (value) => {
    const op = value.consume(1);
    const operationName = kindMappingProto12[op[0]];
    if (operationName === undefined) {
        throw new UnsupportedOperationError(op[0].toString());
    }
    const decodedObj = decoders[operationName](value);
    if (typeof decodedObj !== 'object') {
        throw new OperationDecodingError('Decoded invalid operation');
    }
    return Object.assign({ kind: operationName }, decodedObj);
};

const decodersProto12 = Object.assign(Object.assign({}, decoders), { [CODEC.INT16]: int16Decoder, [CODEC.BLOCK_PAYLOAD_HASH]: blockPayloadHashDecoder });
decodersProto12[CODEC.OPERATION] = operationDecoderProto12(decodersProto12);
decodersProto12[CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaDecoder(decodersProto12)(ActivationSchema)(val);
decodersProto12[CODEC.OP_DELEGATION] = (val) => schemaDecoder(decodersProto12)(DelegationSchema)(val);
decodersProto12[CODEC.OP_TRANSACTION] = (val) => schemaDecoder(decodersProto12)(TransactionSchema)(val);
decodersProto12[CODEC.OP_ORIGINATION] = (val) => schemaDecoder(decodersProto12)(OriginationSchema)(val);
decodersProto12[CODEC.OP_BALLOT] = (val) => schemaDecoder(decodersProto12)(BallotSchema)(val);
decodersProto12[CODEC.OP_ENDORSEMENT] = (val) => schemaDecoder(decodersProto12)(EndorsementSchemaProto12)(val);
decodersProto12[CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaDecoder(decodersProto12)(SeedNonceRevelationSchema)(val);
decodersProto12[CODEC.OP_PROPOSALS] = (val) => schemaDecoder(decodersProto12)(ProposalsSchema)(val);
decodersProto12[CODEC.OP_REVEAL] = (val) => schemaDecoder(decodersProto12)(RevealSchema)(val);
decodersProto12[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaDecoder(decodersProto12)(RegisterGlobalConstantSchema)(val);
decodersProto12[CODEC.MANAGER] = schemaDecoder(decodersProto12)(ManagerOperationSchema);

const encodersProto12 = Object.assign(Object.assign({}, encoders), { [CODEC.INT16]: int16Encoder, [CODEC.BLOCK_PAYLOAD_HASH]: blockPayloadHashEncoder });
encodersProto12[CODEC.OPERATION] = operationEncoderProto12(encodersProto12);
encodersProto12[CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaEncoder(encodersProto12)(ActivationSchema)(val);
encodersProto12[CODEC.OP_DELEGATION] = (val) => schemaEncoder(encodersProto12)(DelegationSchema)(val);
encodersProto12[CODEC.OP_TRANSACTION] = (val) => schemaEncoder(encodersProto12)(TransactionSchema)(val);
encodersProto12[CODEC.OP_ORIGINATION] = (val) => schemaEncoder(encodersProto12)(OriginationSchema)(val);
encodersProto12[CODEC.OP_BALLOT] = (val) => schemaEncoder(encodersProto12)(BallotSchema)(val);
encodersProto12[CODEC.OP_ENDORSEMENT] = (val) => schemaEncoder(encodersProto12)(EndorsementSchemaProto12)(val);
encodersProto12[CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaEncoder(encodersProto12)(SeedNonceRevelationSchema)(val);
encodersProto12[CODEC.OP_PROPOSALS] = (val) => schemaEncoder(encodersProto12)(ProposalsSchema)(val);
encodersProto12[CODEC.OP_REVEAL] = (val) => schemaEncoder(encodersProto12)(RevealSchema)(val);
encodersProto12[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaEncoder(encodersProto12)(RegisterGlobalConstantSchema)(val);
encodersProto12[CODEC.MANAGER] = schemaEncoder(encodersProto12)(ManagerOperationSchema);

const OperationKindMapping = {
    activate_account: ActivationSchema,
    reveal: RevealSchema,
    delegation: DelegationSchema,
    transaction: TransactionSchema,
    origination: OriginationSchema,
    ballot: BallotSchema,
    endorsement: EndorsementSchema,
    seed_nonce_revelation: SeedNonceRevelationSchema,
    proposals: ProposalsSchema,
    register_global_constant: RegisterGlobalConstantSchema,
};
// Asymmetric difference: only account for things in arr2 that are not present in arr1, not vice versa
const getArrayDifference = (arr1, arr2) => {
    return arr2.filter((x) => !arr1.includes(x));
};
const deleteArrayElementByValue = (array, item) => {
    return array.filter((e) => e !== item);
};
/**
 * @returns A boolean value to indicate whether the operation kind is valid or not
 */
const validateOperationKind = (opKind) => {
    const opKindList = Object.keys(OperationKindMapping);
    return opKindList.includes(opKind);
};
/**
 *  returns 0 when the two array of properties are identical or the passed property
 *  does not have any missing parameters from the corresponding schema
 *
 *  @returns array element differences if there are missing required property keys
 */
const validateMissingProperty = (operationContent) => {
    const kind = operationContent.kind;
    const keys = Object.keys(operationContent);
    const cleanKeys = deleteArrayElementByValue(keys, 'kind');
    const schemaKeys = Object.keys(OperationKindMapping[kind]);
    return getArrayDifference(cleanKeys, schemaKeys);
};

var ProtocolsHash;
(function (ProtocolsHash) {
    ProtocolsHash["Pt24m4xi"] = "Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd";
    ProtocolsHash["PsBABY5H"] = "PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU";
    ProtocolsHash["PsBabyM1"] = "PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS";
    ProtocolsHash["PsCARTHA"] = "PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb";
    ProtocolsHash["PsDELPH1"] = "PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo";
    ProtocolsHash["PtEdo2Zk"] = "PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA";
    ProtocolsHash["PsFLorena"] = "PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i";
    ProtocolsHash["PtGRANADs"] = "PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV";
    ProtocolsHash["PtHangz2"] = "PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx";
    ProtocolsHash["Psithaca2"] = "Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A";
    ProtocolsHash["ProtoALpha"] = "ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK";
})(ProtocolsHash || (ProtocolsHash = {}));
const protoLevel = {
    Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd: 4,
    PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU: 5,
    PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS: 5,
    PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb: 6,
    PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo: 7,
    PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA: 8,
    PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i: 9,
    PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV: 10,
    PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx: 11,
    Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A: 12,
    ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK: 13,
};
function ProtoInferiorTo(a, b) {
    return protoLevel[a] < protoLevel[b];
}

const opMappingProto13 = Object.assign(Object.assign({}, opMapping), { '84': 'sapling_transaction_deprecated', '94': 'tx_rollup_l2_address', '95': 'MIN_BLOCK_TIME', '96': 'sapling_transaction' });
const opMappingReverseProto13 = (() => {
    const result = {};
    Object.keys(opMappingProto13).forEach((key) => {
        result[opMappingProto13[key]] = key;
    });
    return result;
})();

const scriptEncoderProto13 = (script) => {
    const code = valueEncoderProto13(script.code);
    const storage = valueEncoderProto13(script.storage);
    return `${pad(code.length / 2, 8)}${code}${pad(storage.length / 2, 8)}${storage}`;
};
const scriptDecoderProto13 = (value) => {
    const code = extractRequiredLen(value);
    const storage = extractRequiredLen(value);
    return {
        code: valueDecoderProto13(new Uint8ArrayConsumer(code)),
        storage: valueDecoderProto13(new Uint8ArrayConsumer(storage)),
    };
};
const valueEncoderProto13 = (value) => {
    if (Array.isArray(value)) {
        const encoded = value.map((x) => valueEncoderProto13(x)).join('');
        const len = encoded.length / 2;
        return `02${pad(len)}${encoded}`;
    }
    else if (isPrim(value)) {
        return primEncoderProto13(value);
    }
    else if (isBytes(value)) {
        return bytesEncoder(value);
    }
    else if (isString(value)) {
        return stringEncoder(value);
    }
    else if (isInt(value)) {
        return intEncoder(value);
    }
    throw new UnexpectedMichelsonValueError('Unexpected value');
};
const valueDecoderProto13 = (value) => {
    const preamble = value.consume(1);
    switch (preamble[0]) {
        case 0x0a:
            return bytesDecoder(value);
        case 0x01:
            return stringDecoder(value);
        case 0x00:
            return intDecoder(value);
        case 0x02: {
            const val = new Uint8ArrayConsumer(extractRequiredLen(value));
            const results = [];
            while (val.length() > 0) {
                results.push(valueDecoderProto13(val));
            }
            return results;
        }
        default:
            return primDecoderProto13(value, preamble);
    }
};
const primEncoderProto13 = (value) => {
    const hasAnnot = +Array.isArray(value.annots);
    const argsCount = Array.isArray(value.args) ? value.args.length : 0;
    // Specify the number of args max is 3 without annotation
    const preamble = pad(Math.min(2 * argsCount + hasAnnot + 0x03, 9), 2);
    const op = opMappingReverseProto13[value.prim];
    let encodedArgs = (value.args || []).map((arg) => valueEncoderProto13(arg)).join('');
    const encodedAnnots = Array.isArray(value.annots) ? encodeAnnots(value.annots) : '';
    if (value.prim === 'LAMBDA' && argsCount) {
        encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
    }
    if ((value.prim === 'pair' || value.prim === 'Pair') && argsCount > 2) {
        encodedArgs =
            encodedAnnots === ''
                ? pad(encodedArgs.length / 2) + encodedArgs + pad(0)
                : pad(encodedArgs.length / 2) + encodedArgs;
    }
    if (value.prim === 'view' && value.args) {
        encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);
    }
    return `${preamble}${op}${encodedArgs}${encodedAnnots}`;
};
const primDecoderProto13 = (value, preamble) => {
    const hasAnnot = (preamble[0] - 0x03) % 2 === 1;
    let argsCount = Math.floor((preamble[0] - 0x03) / 2);
    const op = value.consume(1)[0].toString(16).padStart(2, '0');
    const result = {
        prim: opMappingProto13[op],
    };
    if (opMappingProto13[op] === 'LAMBDA') {
        value.consume(4);
    }
    if (opMappingProto13[op] === 'view') {
        if (argsCount != 0) {
            return primViewDecoderProto13(value, result);
        }
        else {
            return result;
        }
    }
    let combPairArgs;
    let combPairAnnots;
    if ((opMappingProto13[op] === 'pair' || opMappingProto13[op] === 'Pair') && argsCount > 2) {
        combPairArgs = decodeCombPair(value);
        argsCount = 0;
        combPairAnnots = decodeAnnots(value);
    }
    const args = new Array(argsCount).fill(0).map(() => valueDecoderProto13(value));
    if (opMappingProto13[op] === 'LAMBDA') {
        value.consume(4);
    }
    if (combPairArgs) {
        result['args'] = combPairArgs;
    }
    else if (args.length) {
        result['args'] = args;
    }
    if (combPairAnnots && combPairAnnots[0] !== '') {
        result['annots'] = combPairAnnots;
    }
    else if (hasAnnot) {
        result['annots'] = decodeAnnots(value);
    }
    return result;
};
const primViewDecoderProto13 = (value, result) => {
    value.consume(4);
    result['args'] = new Array(4).fill(0).map(() => valueDecoderProto13(value));
    value.consume(4);
    return result;
};
const decodeCombPair = (val) => {
    const array = new Uint8ArrayConsumer(extractRequiredLen(val));
    const args = [];
    while (array.length() > 0) {
        args.push(valueDecoderProto13(array));
    }
    return args;
};

const parametersDecoderProto13 = (val) => {
    const preamble = val.consume(1);
    if (preamble[0] === 0x00) {
        return;
    }
    else {
        const encodedEntrypoint = entrypointDecoder(val);
        const params = extractRequiredLen(val);
        const parameters = valueDecoderProto13(new Uint8ArrayConsumer(params));
        return {
            entrypoint: encodedEntrypoint,
            value: parameters,
        };
    }
};
const valueParameterDecoderProto13 = (val) => {
    const value = extractRequiredLen(val);
    return valueDecoderProto13(new Uint8ArrayConsumer(value));
};
const entrypointEncoderProto13 = (entrypoint) => {
    if (entrypoint in entrypointMappingReverse) {
        return `${entrypointMappingReverse[entrypoint]}`;
    }
    else {
        if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {
            throw new OversizedEntryPointError(entrypoint);
        }
        const value = { string: entrypoint };
        return `ff${valueEncoderProto13(value).slice(8)}`;
    }
};
const parametersEncoderProto13 = (val) => {
    if (!val || (val.entrypoint === 'default' && 'prim' in val.value && val.value.prim === 'Unit')) {
        return '00';
    }
    const encodedEntrypoint = entrypointEncoderProto13(val.entrypoint);
    const parameters = valueEncoderProto13(val.value);
    const length = (parameters.length / 2).toString(16).padStart(8, '0');
    return `ff${encodedEntrypoint}${length}${parameters}`;
};
const valueParameterEncoderProto13 = (value) => {
    const valueEncoded = valueEncoderProto13(value);
    return `${pad(valueEncoded.length / 2)}${valueEncoded}`;
};

const encodersProto13 = Object.assign(Object.assign({}, encodersProto12), { [CODEC.SCRIPT]: scriptEncoderProto13, [CODEC.PARAMETERS]: parametersEncoderProto13, [CODEC.VALUE]: valueParameterEncoderProto13 });
encodersProto13[CODEC.OPERATION] = operationEncoderProto12(encodersProto13);
encodersProto13[CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaEncoder(encodersProto13)(ActivationSchema)(val);
encodersProto13[CODEC.OP_DELEGATION] = (val) => schemaEncoder(encodersProto13)(DelegationSchema)(val);
encodersProto13[CODEC.OP_TRANSACTION] = (val) => schemaEncoder(encodersProto13)(TransactionSchema)(val);
encodersProto13[CODEC.OP_ORIGINATION] = (val) => schemaEncoder(encodersProto13)(OriginationSchema)(val);
encodersProto13[CODEC.OP_BALLOT] = (val) => schemaEncoder(encodersProto13)(BallotSchema)(val);
encodersProto13[CODEC.OP_ENDORSEMENT] = (val) => schemaEncoder(encodersProto13)(EndorsementSchemaProto12)(val);
encodersProto13[CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaEncoder(encodersProto13)(SeedNonceRevelationSchema)(val);
encodersProto13[CODEC.OP_PROPOSALS] = (val) => schemaEncoder(encodersProto13)(ProposalsSchema)(val);
encodersProto13[CODEC.OP_REVEAL] = (val) => schemaEncoder(encodersProto13)(RevealSchema)(val);
encodersProto13[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaEncoder(encodersProto13)(RegisterGlobalConstantSchema)(val);
encodersProto13[CODEC.MANAGER] = schemaEncoder(encodersProto13)(ManagerOperationSchema);

const decodersProto13 = Object.assign(Object.assign({}, decodersProto12), { [CODEC.SCRIPT]: scriptDecoderProto13, [CODEC.PARAMETERS]: parametersDecoderProto13, [CODEC.VALUE]: valueParameterDecoderProto13 });
decodersProto13[CODEC.OPERATION] = operationDecoderProto12(decodersProto13);
decodersProto13[CODEC.OP_ACTIVATE_ACCOUNT] = (val) => schemaDecoder(decodersProto13)(ActivationSchema)(val);
decodersProto13[CODEC.OP_DELEGATION] = (val) => schemaDecoder(decodersProto13)(DelegationSchema)(val);
decodersProto13[CODEC.OP_TRANSACTION] = (val) => schemaDecoder(decodersProto13)(TransactionSchema)(val);
decodersProto13[CODEC.OP_ORIGINATION] = (val) => schemaDecoder(decodersProto13)(OriginationSchema)(val);
decodersProto13[CODEC.OP_BALLOT] = (val) => schemaDecoder(decodersProto13)(BallotSchema)(val);
decodersProto13[CODEC.OP_ENDORSEMENT] = (val) => schemaDecoder(decodersProto13)(EndorsementSchemaProto12)(val);
decodersProto13[CODEC.OP_SEED_NONCE_REVELATION] = (val) => schemaDecoder(decodersProto13)(SeedNonceRevelationSchema)(val);
decodersProto13[CODEC.OP_PROPOSALS] = (val) => schemaDecoder(decodersProto13)(ProposalsSchema)(val);
decodersProto13[CODEC.OP_REVEAL] = (val) => schemaDecoder(decodersProto13)(RevealSchema)(val);
decodersProto13[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val) => schemaDecoder(decodersProto13)(RegisterGlobalConstantSchema)(val);
decodersProto13[CODEC.MANAGER] = schemaDecoder(decodersProto13)(ManagerOperationSchema);

// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
const VERSION = {
    "commitHash": "cbdd0af87e400489076259d065e2d328feb8e1b4",
    "version": "12.1.0"
};

/**
 * @packageDocumentation
 * @module @taquito/local-forging
 */
const PROTOCOL_CURRENT = ProtocolsHash.Psithaca2;
function getCodec(codec, proto) {
    if (proto === ProtocolsHash.Psithaca2) {
        return {
            encoder: encodersProto12[codec],
            decoder: (hex) => {
                const consumer = Uint8ArrayConsumer.fromHexString(hex);
                return decodersProto12[codec](consumer);
            },
        };
    }
    else if (ProtoInferiorTo(proto, ProtocolsHash.Psithaca2)) {
        return {
            encoder: encoders[codec],
            decoder: (hex) => {
                const consumer = Uint8ArrayConsumer.fromHexString(hex);
                return decoders[codec](consumer);
            },
        };
    }
    else {
        return {
            encoder: encodersProto13[codec],
            decoder: (hex) => {
                const consumer = Uint8ArrayConsumer.fromHexString(hex);
                return decodersProto13[codec](consumer);
            },
        };
    }
}
class LocalForger {
    constructor(protocolHash = PROTOCOL_CURRENT) {
        this.protocolHash = protocolHash;
        this.codec = getCodec(CODEC.MANAGER, this.protocolHash);
    }
    forge(params) {
        if (validateBlock(params.branch) !== ValidationResult.VALID) {
            throw new InvalidBlockHashError(`The block hash ${params.branch} is invalid`);
        }
        for (const content of params.contents) {
            if (!validateOperationKind(content.kind)) {
                throw new InvalidOperationKindError(content.kind);
            }
            const diff = validateMissingProperty(content);
            if (diff.length === 1) {
                if (content.kind === 'delegation' && diff[0] === 'delegate') {
                    continue;
                }
                else if (content.kind === 'origination' && diff[0] === 'delegate') {
                    continue;
                }
                else if (content.kind === 'transaction' && diff[0] === 'parameters') {
                    continue;
                }
                else {
                    throw new InvalidOperationSchemaError(`Missing properties: ${diff.join(', ').toString()}`);
                }
            }
            else if (diff.length > 1) {
                throw new InvalidOperationSchemaError(`Missing properties: ${diff.join(', ').toString()}`);
            }
        }
        return Promise.resolve(this.codec.encoder(params));
    }
    parse(hex) {
        return Promise.resolve(this.codec.decoder(hex));
    }
}
const localForger = new LocalForger();

export { CODEC, LocalForger, ProtocolsHash, Uint8ArrayConsumer, VERSION, decoders, encoders, getCodec, localForger };
//# sourceMappingURL=taquito-local-forging.es6.js.map
